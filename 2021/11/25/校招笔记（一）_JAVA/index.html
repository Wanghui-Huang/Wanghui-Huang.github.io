<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（一）_JAVA | royhuang's blog</title><meta name="keywords" content="JAVA,校招"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、JAVA1.1  JAVA入门1.1.1 JAVA基本1. 介绍一下JVM&amp;JRE&amp;JDK？ JAVA语言有什么特点？ JVM&amp;JRE&amp;JDK  JVM:  即java虚拟机，针对不同操作系统，JVM把Java代码翻译成对应操作系统可以识别的内容，实现跨平台 ； JRE : JVM + 核心类库 &#x3D; JRE ， 即Java运行时环境。只有JVM不能运行，它还需要">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（一）_JAVA">
<meta property="og:url" content="http://example.com/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="一、JAVA1.1  JAVA入门1.1.1 JAVA基本1. 介绍一下JVM&amp;JRE&amp;JDK？ JAVA语言有什么特点？ JVM&amp;JRE&amp;JDK  JVM:  即java虚拟机，针对不同操作系统，JVM把Java代码翻译成对应操作系统可以识别的内容，实现跨平台 ； JRE : JVM + 核心类库 &#x3D; JRE ， 即Java运行时环境。只有JVM不能运行，它还需要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/about-bg.jpg">
<meta property="article:published_time" content="2021-11-25T08:16:17.565Z">
<meta property="article:modified_time" content="2021-11-25T13:01:25.412Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="校招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/about-bg.jpg"><link rel="shortcut icon" href="/img/cat.jpg"><link rel="canonical" href="http://example.com/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（一）_JAVA',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-25 21:01:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/about-bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">校招笔记（一）_JAVA</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T08:16:17.565Z" title="发表于 2021-11-25 16:16:17">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-25T13:01:25.412Z" title="更新于 2021-11-25 21:01:25">2021-11-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">69.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>240分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（一）_JAVA"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、JAVA"><a href="#一、JAVA" class="headerlink" title="一、JAVA"></a><strong>一、JAVA</strong></h1><h2 id="1-1-JAVA入门"><a href="#1-1-JAVA入门" class="headerlink" title="1.1  JAVA入门"></a>1.1  JAVA入门</h2><h3 id="1-1-1-JAVA基本"><a href="#1-1-1-JAVA基本" class="headerlink" title="1.1.1 JAVA基本"></a>1.1.1 JAVA基本</h3><h4 id="1-介绍一下JVM-amp-JRE-amp-JDK？-JAVA语言有什么特点？"><a href="#1-介绍一下JVM-amp-JRE-amp-JDK？-JAVA语言有什么特点？" class="headerlink" title="1. 介绍一下JVM&amp;JRE&amp;JDK？ JAVA语言有什么特点？"></a>1. <strong>介绍一下JVM&amp;JRE&amp;JDK？</strong> JAVA语言有什么特点？</h4><ul>
<li><p><strong>JVM&amp;JRE&amp;JDK</strong></p>
<ul>
<li><strong>JVM:</strong>  即java虚拟机，针对不同操作系统，JVM把Java代码翻译成<u>对应操作系统可以识别的内容，实现跨平台</u> ；</li>
<li><strong>JRE</strong> : <u>JVM + 核心类库 = JRE</u> ， 即Java运行时环境。只有JVM不能运行，它还<strong>需要核心类库，才能保证Java运行</strong> ； </li>
<li><strong>JDK:</strong> <u>JRE + <strong>java开发工具</strong>（编译器等) = JDK</u> ，Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具。</li>
</ul>
</li>
<li><p><strong>Java语言特点</strong></p>
<ol>
<li><p>简单易学；</p>
</li>
<li><p>面向对象（封装，继承，多态）；</p>
</li>
<li><p><strong>平台无关性</strong>（ Java 虚拟机实现平台无关性）；</p>
</li>
<li><p>可靠性；</p>
</li>
<li><p>安全性；</p>
</li>
<li><p><strong>支持多线程</strong>（ <u>C++ 语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计</u>，而 Java 语⾔却提供了多线程支持）；</p>
<h4 id="2-什么是Java虚拟机？为什么Java被称为平台无关的编程语言？"><a href="#2-什么是Java虚拟机？为什么Java被称为平台无关的编程语言？" class="headerlink" title="2. 什么是Java虚拟机？为什么Java被称为平台无关的编程语言？"></a>2. <strong>什么是Java虚拟机？为什么Java被称为平台无关的编程语言？</strong></h4></li>
</ol>
</li>
</ul>
<p><img src="https://i.loli.net/2021/05/12/b4HUYmVo6P5uFCi.png" alt="image-20210512104311616"></p>
<ul>
<li><p>java虚拟机，是<strong>执行字节码文件（.class）</strong>的<u>虚拟机进程</u>；</p>
<blockquote>
<p>在 Java 中，<strong>JVM 可以理解的代码就叫做 字节码</strong> （即扩展名为 .class 的⽂件），它不面向任 何特定的处理器，<strong>只面向虚拟机</strong>。</p>
</blockquote>
</li>
<li><p>java源程序（.java）被编译器编译成字节码文件（.class）。然后字节码文件，将由<u>java虚拟机，解释成机器码（<strong>不同平台的机器码不同</strong>）</u>。</p>
</li>
</ul>
<h4 id="3-请你谈谈Java中是如何支持正则表达式操作的？（补充实例）"><a href="#3-请你谈谈Java中是如何支持正则表达式操作的？（补充实例）" class="headerlink" title="3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例）"></a>3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例）</h4><p>Java中的String类提供了支持正则表达式操作的方法，包括：</p>
<ul>
<li><code>matches()、replaceAll()、replaceFirst()、split()</code></li>
</ul>
<p>此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;成都市(成华区)(武侯区)(高新区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实例示范（PCG问过）"><a href="#实例示范（PCG问过）" class="headerlink" title="实例示范（PCG问过）"></a>实例示范（PCG问过）</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p>
</blockquote>
<ul>
<li><p><strong>特殊字符</strong></p>
<img src="https://i.loli.net/2021/05/12/9IBVheAOz5aGnxC.png" alt="image-20210512110705420" style="zoom:80%;" /></li>
<li><p><strong>普通字符</strong></p>
<p><img src="https://i.loli.net/2021/05/12/QcjTKqEJZwx7LdM.png" alt="image-20210512111050519"></p>
</li>
<li><p><strong>实例示范</strong></p>
<ol>
<li><p>匹配邮箱</p>
<p><img src="https://i.loli.net/2021/05/12/Lvo56GHie2Qqla1.png" alt="img"></p>
</li>
<li><p>匹配电话号码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配电话号码</span></span><br><span class="line">String phone = <span class="string">&quot;18637866964&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;^1[3,5,7,8,9]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li>
<li><p>匹配第一个出现的数字</p>
<p>下面好像是不对的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String phone = <span class="string">&quot;avss1sdp22&quot;</span>;</span><br><span class="line">String reg = <span class="string">&quot;\d?&quot;</span>;</span><br><span class="line">System.out.println(phone.matches(reg));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="4-（补充例子）请你简单描述一下正则表达式及其用途。"><a href="#4-（补充例子）请你简单描述一下正则表达式及其用途。" class="headerlink" title="4. （补充例子）请你简单描述一下正则表达式及其用途。"></a>4. <strong>（补充例子）请你简单描述一下正则表达式及其用途。</strong></h4><p>在编写处理字符串的程序时，经常会有查找 <u>符合某些复杂规则的字符串</u> 的需要。</p>
<ul>
<li>计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具；</li>
<li>绝大多数语言都提供了对正则表达式的支持。</li>
</ul>
<h4 id="5-amp-和-amp-amp-区分？"><a href="#5-amp-和-amp-amp-区分？" class="headerlink" title="5. &amp;和&amp;&amp;区分？"></a>5. <strong>&amp;和&amp;&amp;区分？</strong></h4><ul>
<li><strong>共同点：</strong>都要求运算符左右两端的布尔值 <u>都是true</u> 整个表达式的值才是true </li>
<li>区别：&amp;&amp;之称为短路运算，<u>如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</u>。 好处：<ul>
<li><em>e.g.</em> ：右边判别式有如果有空指针<code>NullPointerException</code>异常判断风险，可以避免。</li>
</ul>
</li>
</ul>
<h4 id="6-值传递和引用传递区分？"><a href="#6-值传递和引用传递区分？" class="headerlink" title="6. 值传递和引用传递区分？"></a>6. <strong>值传递和引用传递区分？</strong></h4><ul>
<li><p>值传递是<strong>该变量</strong>的一个<u>副本</u>， 改变副本<u>不影响</u>原变量；</p>
</li>
<li><p>引用传递是<strong>对象地址</strong>的<u>副本</u>，引用对象进行操作会同时<u>改变</u>原对象。</p>
</li>
</ul>
<h4 id="7-十进制与二进制？"><a href="#7-十进制与二进制？" class="headerlink" title="7. 十进制与二进制？"></a>7. <strong>十进制与二进制？</strong></h4><ul>
<li><p><strong>请你讲讲一个十进制的数在内存中是怎么存的？</strong></p>
<p>补码形式。</p>
</li>
<li><p><strong>为什么会出现4.0-3.6=0.40000001这种现象？</strong></p>
<p>2进制的小数无法精确的表达10进制小数，计算机在 <u>计算10进制小数的过程中要先转换为2进制进行计算</u> ，这个过程中出现了误差。</p>
</li>
</ul>
<h4 id="8-（重要）equals与-的区别"><a href="#8-（重要）equals与-的区别" class="headerlink" title="8. （重要）equals与==的区别"></a>8. <strong>（重要）equals与==的区别</strong></h4><blockquote>
<p>很清晰严谨的一篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>
</blockquote>
<ul>
<li><p><strong>==</strong></p>
<ol>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是<strong>引用（对象地址）</strong>是否相同；</li>
</ol>
</li>
<li><p><strong>equals</strong></p>
<p>要看<strong>类是否覆盖equals()方法</strong>，将它分为两种情况：</p>
<ol>
<li><p>若某个类没有覆盖equals()方法，当它的通过<strong>equals()比较两个对象</strong>时，实际上是比较两个对象（地址）是不是同一个对象。这时，<u>等价于通过“==”去比较这两个对象</u>；</p>
</li>
<li><p>我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象的内容（<strong>而不是地址</strong>）是否相等。</p>
<blockquote>
<p>String 中的 equals 方法是被重写过的：</p>
<ul>
<li>因为 object 的 equals 方法是⽐教的对象的内存地址</li>
<li>而 <strong>String 的 equals 方法（1）先比较对象地址是否相等 ，相同则ture，否则（2）再比较值是否相等</strong></li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="7-请解释hashCode-和equals-方法有什么联系？"><a href="#7-请解释hashCode-和equals-方法有什么联系？" class="headerlink" title="7. 请解释hashCode()和equals()方法有什么联系？"></a>7. <strong>请解释hashCode()和equals()方法有什么联系？</strong></h4><blockquote>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode方法？”</p>
<ul>
<li>建议看文中例子理解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li>
</ul>
</blockquote>
<ul>
<li><p><strong>hashCode()介绍</strong></p>
<p>hashCode() 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该 <u>对象在哈希表中的索引位置</u>。</p>
<blockquote>
<p>我们仅在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。  其它情况下hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p>
<ul>
<li>在这种情况下对象相等，hashcode值也会不相等。</li>
</ul>
</blockquote>
</li>
<li><p><strong>为什么要有hashcode()</strong> </p>
<p>hashCode() 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回⼀个 int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。 <strong>hashCode()</strong> <strong><u>在散列表中</u>才有用，在其它情况下没用</strong>。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<p><strong>先判断hashcode，而不是直接遍历O(n)复杂度用equals()判断，减少判断时间。</strong> </p>
<blockquote>
<p><strong>如果hashcode一样，会调用equals()去比较。</strong></p>
<ul>
<li><strong>HashSet</strong> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="7-1-为什么重写了equals-一定要重写hashcode-方法？"><a href="#7-1-为什么重写了equals-一定要重写hashcode-方法？" class="headerlink" title="7.1 为什么重写了equals()一定要重写hashcode()方法？"></a>7.1 为什么重写了equals()一定要重写hashcode()方法？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xyh269/article/details/69171545">为什么重写了equals()，还要重写hashCode()？</a> </p>
</blockquote>
<p>在Hashmap / Hashset中，通过计算hash = hash(key.hashcode) 然后进行取余操作，快速定位到数组中。</p>
<p>因为<strong>map中是不允许重复key</strong>的，所以对内部get()/add()方法：对于散列到数组同一位置的对象来说，<strong>如果hash相等 &amp;&amp; equals()判断相等</strong> ，是要进行<strong>覆盖</strong>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br></pre></td></tr></table></figure>

<p>如果我们只重写了equals方法：用来判断两个对象是否相等。但是依旧可能出现：两个相同对象<strong>equals相等，但hashcode不等，被散列到不同桶上，map中依旧出现了重复键值对！</strong></p>
<p><img src="https://i.loli.net/2021/05/26/v5aHJGt8qErx6P9.png" alt="hashcode"></p>
<p>所以，需要重写hashcode方法，保证<strong>相同对象一定是散列到同一个位置（具有同样的hash值）</strong>。</p>
<h5 id="7-2-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？"><a href="#7-2-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？" class="headerlink" title="7.2 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？"></a>7.2 <strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？</strong></h5><p>不一定正确，<u>如果在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中</u>，两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。</p>
<p>其它情况下可能会出现题目描述的情况。</p>
<h4 id="8-自动拆箱和装箱？"><a href="#8-自动拆箱和装箱？" class="headerlink" title="8. 自动拆箱和装箱？"></a>8. 自动拆箱和装箱？</h4><ul>
<li><p><strong>介绍一下int&amp;Integer？</strong> </p>
<p>  Java为了编程的方便还是引入了基本数据类型，但是 <u>为了能够将这些基本数据类型当成对象操作</u>，Java为每一个基本数据类型都引入了对应的<strong>包装类型</strong>（wrapper class）</p>
<ul>
<li><p>int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.g. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;          <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == b);  </span><br><span class="line">        <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">        System.out.println(a == c);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Java 为<u>每个原始类型</u>提供了包装类型：</p>
<ul>
<li>（<strong>8种基本类型</strong>）原始类型: boolean，char，byte，short，int，long，float，double</li>
<li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拆箱、装箱存在的意义？</strong></p>
<blockquote>
<p>为什么要有装箱、拆箱，它们的作用是什么？</p>
</blockquote>
<p><em>java</em> 是 面对对象编程，而基本数据类型不是对象，<strong>所有才有封装类 引用基本数据类型进行操作</strong>。比如，下面打印出<em>int</em>型数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>； </span><br><span class="line">System.out.println(i); <span class="comment">// 自动装箱</span></span><br></pre></td></tr></table></figure>

<p>其实，查看源码，实际经过以下几个过程：</p>
<ul>
<li>将 <em>i</em> 自动装箱成封装类 <em>Integer</em></li>
<li>然后调用 <em>Integer</em>中 <em>toString</em>() 方法，打印出字符串输出到控制台。</li>
</ul>
<blockquote>
<p>自动装箱和拆箱？</p>
</blockquote>
<ul>
<li>自动装箱：就是自动将基本数据类型转换为包装器类型</li>
<li>自动拆箱：就是自动将包装器类型转换为基本数据类型</li>
</ul>
</li>
</ul>
<h4 id="9-String-amp-StringBuffer-amp-StringBuilder-区别？为什么String不可变"><a href="#9-String-amp-StringBuffer-amp-StringBuilder-区别？为什么String不可变" class="headerlink" title="9.  String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变?"></a>9.  String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变?</h4><ul>
<li><p><strong>请解释String &amp; StringBuffer区别？</strong></p>
<ul>
<li><p><strong>共同点</strong>：它们可以<strong>储存和操作</strong>字符串，即包含多个字符的字符数据；</p>
</li>
<li><p><strong>可否修改</strong>：String类提供了数值不可改变的字符，StringBuffer可以修改字符串，需要 <u>字符数据要改变</u> 时用。</p>
</li>
</ul>
<p>典型地，你可以使用StringBuffers来动态构造字符数据。</p>
</li>
<li><p><strong>请解释 StringBuilder&amp; StringBuffer 区别？</strong></p>
<ul>
<li><p><strong>共同点：</strong> <code>AbstractStringBuilder</code> 是 StringBuilder 与 StringBuffer 的公共⽗类。都可以修<u>改字符串，操作字符串方法丰富</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">char</span>[] value;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The count is the number of characters used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> count;</span><br><span class="line"> AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"> value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><u><strong>线程安全</strong>：</u>单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；在多线程且操作大量字符串用<strong>StringBuffer，线程安全，可修改。</strong></p>
<blockquote>
<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>为什么String 不可变？</strong></p>
<p>String 类中使用 final 关键字修饰字符数组来保存字符串， 所以 String 对象是不可变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-说说深拷贝和浅拷贝？"><a href="#10-说说深拷贝和浅拷贝？" class="headerlink" title="10. 说说深拷贝和浅拷贝？"></a>10. <strong>说说深拷贝和浅拷贝？</strong></h4><ul>
<li><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址；</p>
<blockquote>
<p>因此，可能会出现出现浅拷贝时释放同一个内存的错误。</p>
</blockquote>
</li>
<li><p>深拷贝（deepCopy）是增加了一个指针<strong>并且申请了一个新的内存</strong>，使这个增加的指针指向这个新的内存。</p>
</li>
</ul>
<h4 id="11-【新增】介绍一下JDK1-8的新特性？"><a href="#11-【新增】介绍一下JDK1-8的新特性？" class="headerlink" title="11. 【新增】介绍一下JDK1.8的新特性？"></a>11. 【新增】介绍一下JDK1.8的新特性？</h4><p>JDK1.8新增了非常多的特性，如：</p>
<ul>
<li><strong>Lambda表达式</strong>：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong>：默认方法就是一个<strong>在接口里面有了一个实现的方法</strong>。</li>
<li><strong>新工具</strong>：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的<strong>函数式编程风格</strong>引入到Java中。</li>
<li><strong>Date Time API</strong>：加强对日期与时间的处理。</li>
<li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决<strong>空指针异常</strong>。</li>
<li><strong>Nashorn，JavaScript引擎</strong>：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h4 id="12-【新增】java一个程序能不能有多个main方法？一个类里呢？"><a href="#12-【新增】java一个程序能不能有多个main方法？一个类里呢？" class="headerlink" title="12. 【新增】java一个程序能不能有多个main方法？一个类里呢？"></a>12. 【新增】java一个程序能不能有多个main方法？一个类里呢？</h4><ul>
<li><p><strong>一个程序里，多个class都有main方法</strong></p>
<p>可以，默认第一个为入口，其余为普通函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>一个类有多个main方法</strong></p>
<p>可以，其余就相当是重载。但是具有以下sigature（签名）的主要方法将被视为app入口点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-2-关键字"><a href="#1-1-2-关键字" class="headerlink" title="1.1.2 关键字"></a>1.1.2 关键字</h3><h4 id="1-请你讲讲Java里面的final关键字是怎么用的？"><a href="#1-请你讲讲Java里面的final关键字是怎么用的？" class="headerlink" title="1. 请你讲讲Java里面的final关键字是怎么用的？"></a>1. <strong>请你讲讲Java里面的final关键字是怎么用的？</strong></h4><ul>
<li><p><strong>修饰类</strong>：表示不能被继承，final类 <u>成员变量</u> 可以设为final；但final类<u>所有方法</u> ，都被隐式指定为final方法；</p>
</li>
<li><p><strong>修饰方法</strong>：防任何继承类修改它的含义 ； 在早期的Java实现版本中，会将final方法转为内嵌调用，效率会更高；</p>
</li>
<li><p><strong>修饰变量、引用</strong>：<u>基本类型</u>的话一旦初始化不能修改；<u>引用类型</u>，不能指定其他对象 。</p>
<h4 id="2-【重点】请你谈谈关于Synchronized和lock-？"><a href="#2-【重点】请你谈谈关于Synchronized和lock-？" class="headerlink" title="2. 【重点】请你谈谈关于Synchronized和lock ？"></a>2. 【<strong>重点</strong>】<strong>请你谈谈关于Synchronized和lock ？</strong></h4><ul>
<li><p><strong>Synchronized</strong>：是一个关键字，修饰<u>类、方法 </u> 或 <u>代码块</u> ，保证在同一时刻最<strong>多只有一个线程</strong>执行该段代码；</p>
<blockquote>
<p>作用范围：</p>
<ol>
<li>修饰一个类/静态方法， <strong>作用的对象是这个类的所有对象</strong>。</li>
<li>修饰一个方法/代码块， <strong>作用的对象是调用这个方法/代码块的对象</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>Lock： <strong>是一个接口</strong>，Lock能完成synchronized所实现的所有功能。</p>
<blockquote>
<p>Lock接口是不能直接实例化的，需要靠它的实现类ReentrantLock来进行实例化。</p>
</blockquote>
<ul>
<li><p>区别：</p>
<ul>
<li><u>锁释放：</u><strong>synchronized在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放。；</li>
<li><u>线程等待：</u> <u>Lock可以让<strong>等待锁的线程可以响应中断</strong></u>，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</li>
<li><u>成功获取锁：</u> 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-instanceof-关键字的作用-？"><a href="#3-instanceof-关键字的作用-？" class="headerlink" title="3. instanceof 关键字的作用 ？"></a>3. <strong>instanceof</strong> <strong>关键字的作用</strong> ？</h4><p>  instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过 i必须是引用类型，不能是基本类型</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-final有哪些用法"><a href="#4-final有哪些用法" class="headerlink" title="4. final有哪些用法?"></a>4. <strong>final有哪些用法?</strong></h4><ul>
<li><p>被final修饰的类不可以被继承 ；</p>
</li>
<li><p>被final修饰的方法<strong>不可以被重写</strong>，<u>而且JVM会尝试将其内联，以提高运行效率</u>；</p>
</li>
<li><p>被final修饰的<u>变量</u>不可以被改变；</p>
<ul>
<li><p>被final修饰的<u>引用</u>，那么表示引用不可变，<u>引用指向的内容可变</u>；</p>
</li>
<li><p>被final修饰的<u>常量</u>，在编译阶段会存入常量池中。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-static都有哪些用法"><a href="#5-static都有哪些用法" class="headerlink" title="5. static都有哪些用法 ?"></a>5. <strong>static都有哪些用法 ?</strong></h4><ul>
<li><p><strong>修饰静态变量和静态方法</strong> ：都属于类的静态资源，类实例所共享 ；</p>
</li>
<li><p><strong>修饰静态块</strong>：用于初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line"> <span class="comment">//执行相关操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>修饰静态包：</strong> 在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且<strong>不需要使用类名,<strong>可以直接</strong>使用方法名</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-谈一谈transient关键字？"><a href="#6-谈一谈transient关键字？" class="headerlink" title="6. 谈一谈transient关键字？"></a>6. 谈一谈transient关键字？</h4><blockquote>
<p><strong>参考</strong> : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpi/p/6185773.html">Java中的关键字 transient</a></p>
</blockquote>
<ul>
<li><p><strong>Java中序列化操作</strong></p>
<p>Java中对象的序列化指的是将<strong>对象转换成以【字节序列】的形式来表示</strong>，这些字节序列<strong>包含了对象的数据和信息</strong>。</p>
<blockquote>
<p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p>
</blockquote>
<ul>
<li><u>一个序列化后的对象可以<strong>被写到数据库或文件</strong>中</u>，也可用于<strong>网络传输</strong>，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</li>
</ul>
</li>
<li><p><strong>关于transient关键字</strong> </p>
<p>Java中transient关键字的作用，向虚拟机表明: <strong><code>transient</code>变量不是对象的<u>持久状态</u>的一部分。</strong></p>
<p>简单地说，就是让某些被修饰的成员属性变量不被序列化，例如：</p>
<ol>
<li><p>类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p>
</li>
<li><p>其它，看具体业务需求吧，哪些字段不想被序列化；</p>
</li>
</ol>
</li>
</ul>
<h5 id="7-1-HashMap中源码modCount为什么用tranisent修饰？"><a href="#7-1-HashMap中源码modCount为什么用tranisent修饰？" class="headerlink" title="7.1 HashMap中源码modCount为什么用tranisent修饰？"></a>7.1 HashMap中源码modCount为什么用tranisent修饰？</h5><p>modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增）。</p>
<p>对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p>
<h3 id="1-1-3-Java异常"><a href="#1-1-3-Java异常" class="headerlink" title="1.1.3 Java异常"></a>1.1.3 Java异常</h3><h4 id="1-Java常见异常和分类？"><a href="#1-Java常见异常和分类？" class="headerlink" title="1. Java常见异常和分类？"></a>1. Java常见异常和分类？</h4><p><img src="https://i.loli.net/2021/05/26/1ctoGfDdrj6Wapv.png" alt="Java异常的分类和类结构图1"></p>
<p>常见分为两类，Error和Exception ：</p>
<ul>
<li><strong>Error</strong> ：指程序无法恢复的异常情况，对于其所有类型，都不要求程序处理。<ul>
<li>常见错误：Stackoverflow，outOfMemory</li>
</ul>
</li>
<li><strong>Exception：</strong> 程序有可能恢复的错误，又分为IOException &amp; RuntimeException ，常见错误：<ul>
<li><strong>IOException</strong>：FileNotFoundExcepetion </li>
<li><strong>RuntimeException</strong>  : 空指针，参数不合法，类未找到等</li>
</ul>
</li>
</ul>
<h4 id="2-OOM产生原因和分析？"><a href="#2-OOM产生原因和分析？" class="headerlink" title="2. OOM产生原因和分析？"></a>2. OOM产生原因和分析？</h4><blockquote>
<p>OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError 。</p>
</blockquote>
<ol>
<li><p><strong>java.lang.OutOfMemoryError: Java heap space</strong> （堆溢出）</p>
<ul>
<li><p><strong>产生原因</strong></p>
<ol>
<li><strong>内存泄漏</strong>；</li>
<li>堆分配太小；</li>
</ol>
</li>
<li><p><strong>解决办法</strong></p>
<ol>
<li><strong>内存泄漏要手动去释放内存</strong>，比如数据库连接池，单例模式</li>
<li>通过虚拟机参数**-Xms,-Xmx**等修改，对内存大小</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>java.lang.OutOfMemoryError: PermGen space</strong> （永久代（方法区）溢出）</p>
<ul>
<li><p><strong>产生原因</strong></p>
<p>即方法区溢出了：</p>
<ol>
<li>一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生<strong>大量的Class信息存储于方法区</strong> ；</li>
<li><strong>过多的常量</strong>尤其是字符串也会导致方法区溢出。</li>
</ol>
</li>
<li><p><strong>解决办法</strong></p>
<ol>
<li>永久代的内存分配增大 ：-XX:PermSize和-XX:MaxPermSize</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。</strong> </p>
<p>线程栈相关的内存异常有两个：</p>
<ul>
<li>StackOverflowError(方法调用层次太深，内存不够新建栈帧)</li>
<li>OutOfMemoryError（线程太多，内存不够新建线程）</li>
</ul>
</li>
<li><p><strong>java.lang.OutOfMemoryError: Metaspace</strong> </p>
<blockquote>
<p>Java中<strong>普通I/O</strong>采用<strong>输入/输出流</strong>方式实现，输入流InputStream（  终端—&gt;直接内存-&gt;JVM），输出流（JVM-&gt;直接内存-&gt;终端），这一过程中有kenel与JVM之间的拷贝（很多次）。</p>
</blockquote>
<p>为了使用<strong>直接内存</strong>，Java是有一块区域叫<strong>DirectBuffer</strong>，不是JavaHeap而是<strong>cHeap</strong>的一部分。 </p>
<p>但由于直接内存没有被java虚机完全托管，若使用不当，也容易触发溢出，导致宕机。</p>
</li>
</ol>
<h4 id="3-try-catch-finally，try里有return，finally还执行么？"><a href="#3-try-catch-finally，try里有return，finally还执行么？" class="headerlink" title="3. try catch finally，try里有return，finally还执行么？"></a><strong>3. try catch finally，try里有return，finally还执行么？</strong></h4><p>执行，并且finally的执行早于try里面的return ：</p>
<ol>
<li>不管有木有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>finally是<strong>在return后面的表达式运算后执行</strong>的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以<strong>函数返回值是在finally执行前确定</strong>的。</li>
</ol>
<h4 id="4-说说你是怎么处理异常的？"><a href="#4-说说你是怎么处理异常的？" class="headerlink" title="4. 说说你是怎么处理异常的？"></a>4. <strong>说说你是怎么处理异常的？</strong></h4><p><em><strong>try-catch-finally</strong></em></p>
<p><img src="https://i.loli.net/2021/05/05/JfavipzFPb6GI2t.png" alt="image-20210505154833171"></p>
<ul>
<li><p>try 块负责监控可能出现异常的代码</p>
</li>
<li><p>catch 块负责捕获可能出现的异常，并进行处理</p>
</li>
<li><p>finally 块负责清理各种资源，不管是否出现异常都会执行</p>
</li>
<li><p>其中 try 块是必须的，<strong>catch 和 finally 至少存在一个标准异常处理流程</strong></p>
</li>
</ul>
<h2 id="1-2-面对对象"><a href="#1-2-面对对象" class="headerlink" title="1.2 面对对象"></a>1.2 面对对象</h2><h3 id="1-2-1-基本问题"><a href="#1-2-1-基本问题" class="headerlink" title="1.2.1 基本问题"></a>1.2.1 基本问题</h3><h4 id="1-介绍一下面对对象七大原则？三大特性？"><a href="#1-介绍一下面对对象七大原则？三大特性？" class="headerlink" title="1. 介绍一下面对对象七大原则？三大特性？"></a>1. <strong>介绍一下面对对象七大原则？三大特性？</strong></h4><h5 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h5><ul>
<li><p><strong>单一职责原则：</strong> 就一个类来说，应该仅有一个引起它变化的原因。也就是说，<strong>一个类应该只有一个职责</strong>。</p>
<blockquote>
<p>如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。</p>
</blockquote>
</li>
<li><p><strong>开闭原则(OCP)：</strong> 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。</p>
<blockquote>
<p>这个原则很好的实现了面向对象的封装性和可重用性。</p>
</blockquote>
</li>
<li><p><strong>李氏替换原则(LSP)：</strong> 子类应当可以替换父类并出现在父类能够出现的任何地方。</p>
<blockquote>
<p>以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。</p>
</blockquote>
</li>
<li><p><strong>依赖倒置原则(DIP)：</strong> 在进行业务设计时，与<u>特定业务有关的依赖</u>关系应该尽量依赖<strong>接口和抽象类</strong>，<strong>而不是依赖于具体类</strong>。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。</p>
<blockquote>
<p>为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。</p>
</blockquote>
</li>
<li><p><strong>接口分离原则(ISP)：</strong>  <u>采用多个与特定客户类有关的接口</u> 比采用一个通用的涵盖多个业务方法的接口要好。</p>
<blockquote>
<p>举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将<u>比直接加载客户所需所有方法有效</u>。</p>
</blockquote>
</li>
<li><p> <strong>组合重用原则</strong> ：能用组合实现的地方，<strong>尽量用组合来</strong>实现，而<strong>不要使用继承</strong>来扩展功能。</p>
</li>
</ul>
<blockquote>
<p>097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。</p>
</blockquote>
<ul>
<li><strong>迪米特原则 :</strong> <u>一个对象应该对于其他对象有最少的了解</u>，这样做的好处就是可以有效地降低类之间的耦合要求。</li>
</ul>
<h5 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h5><ul>
<li><p><strong>封装。</strong><u>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法</u>，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
</li>
<li><p><strong>继承。</strong> <u>继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能</u>，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地<strong>复用</strong>以前的代码。</p>
<blockquote>
<ol>
<li>子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。</li>
<li>子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。</li>
<li>子类可以用⾃⼰的方式实现⽗类的方法。</li>
</ol>
</blockquote>
</li>
<li><p><strong>多态。</strong>（1）<strong>静态多态：重载</strong> （2）<strong>动态多态</strong>：所谓多态就是指程序中定义的**<u>引用变量所指向的具体类型</u><strong>和<u>通过该</strong>引用变量发出的方法调用**</u>在<strong>编程时并不确定</strong>，而是在<strong>【程序运行期间】才确定</strong>。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<blockquote>
<p>在 Java 中有<strong>两种形式可以实现多态</strong>：<strong>继承</strong>（多个子类对同⼀方法的重写）和<strong>接口</strong>（实现接口并覆盖接口中同⼀方法）。</p>
</blockquote>
</li>
</ul>
<h5 id="1-1-java多态的原理？【阿里-amp-待重写】"><a href="#1-1-java多态的原理？【阿里-amp-待重写】" class="headerlink" title="1.1 java多态的原理？【阿里&amp;待重写】"></a>1.1 java多态的原理？【阿里&amp;待重写】</h5><p>多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。</p>
<ol>
<li><p><strong>静态多态</strong></p>
<p><strong>重载</strong>（overload）就是编译时多态的一个例子，<strong>编译时</strong>多态在编译时就已经<strong>确定</strong>。</p>
<p>运行时运行的时候调用的是确定的方法。</p>
</li>
<li><p><strong>动态多态</strong></p>
<blockquote>
<p>我们通常所说的多态指的都是运行时多态，也就是<strong>编译时不确定究竟调用哪个具体方法</strong>，一直延迟到运行时（<strong>链接过程</strong>）才能确定。</p>
</blockquote>
<p>通常动态多态的实现方法：</p>
<ol>
<li>子类继承父类（extends）</li>
<li>类实现接口（implements）</li>
</ol>
<p>核心之处就在于<strong>对父类方法的改写或对接口方法的实现</strong>，以取得在运行时不同的执行效果。</p>
</li>
<li><p><strong>多态运行的原理</strong></p>
<blockquote>
<p>详细建议查看：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94086109">深入理解Java多态的实现原理</a></p>
</blockquote>
<ul>
<li><p><strong>背景介绍</strong></p>
<p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p>
<p><u>类加载</u> 时会将<strong>类的元数据信息</strong>（<strong>类的方法代码、类变量、成员变量的定义</strong>等等）保存到方法区，<strong>方法区</strong>主要分为两部分：</p>
<ol>
<li><strong>常量池</strong>：Java 类引用的一些常量信息，比如<strong>类的符号引用信息</strong></li>
<li><strong>方法区其它部分：</strong> 保存<strong>方法表</strong>等</li>
</ol>
<p><u>链接过程</u> <strong>类的多态就发生在 <u>链接的解析</u></strong> 过程，将 <u>符号引用替换为直接引用</u>。</p>
</li>
<li><p><strong>原理简述（子类方法继承）</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html">https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html</a></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="2-请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#2-请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="2. 请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>2. <strong>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</strong></h4><ul>
<li><strong>构造函数：</strong> 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；<strong>对象被创建时，构造函数被调用</strong>；</li>
<li><strong>构造函数重载：</strong> 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有<strong>唯一参数列表</strong>；</li>
<li><strong>复制构造函数：</strong> Java不支持像C++中那样的复制构造函数。</li>
</ul>
<h4 id="3-请说明Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？构造函数能否被重写？"><a href="#3-请说明Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？构造函数能否被重写？" class="headerlink" title="3. 请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？"></a>3. <strong>请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？</strong></h4><ul>
<li><p>Overriding ： 方法重写是说<u>子类重新定义了父类的方法</u>，有<u>相同的方法名，参数列表和返回类型</u> ；</p>
</li>
<li><p>Overloading： 同一个类里面两个或者是多个方法<u>同名</u> ，但 <u>参数列表不同</u>不同。</p>
<blockquote>
<p>特别的重写要求返回类型一致，但<strong>重载不要求返回类型一致</strong>！</p>
</blockquote>
</li>
</ul>
<p><strong>构造函数不能被 override（重写）！</strong>但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。</p>
<h5 id="3-1-f（List-lt-String-gt-l）-f（List-lt-Integer-gt-l）是重载么？"><a href="#3-1-f（List-lt-String-gt-l）-f（List-lt-Integer-gt-l）是重载么？" class="headerlink" title="3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？"></a>3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</h5><p>不是重载。</p>
<p>静态类型一致，并<strong>不会因为泛型而改变</strong>。因为<strong>编译</strong>期间，会对泛型进行<strong>擦除</strong>。</p>
<h4 id="4-介绍一下接口和抽象类的区别？"><a href="#4-介绍一下接口和抽象类的区别？" class="headerlink" title="4. 介绍一下接口和抽象类的区别？"></a>4. <strong>介绍一下接口和抽象类的区别？</strong></h4><ul>
<li><p><strong>设计层面</strong></p>
<p>接口，是对类的行为进行约束<strong>，强制要求</strong>不同类实现相同行为 ； 抽象类，既 1.<strong>非抽象类实现代码复用</strong> 2.又同时有<strong>抽象方法使得被继承类各自实现。</strong></p>
</li>
<li><p><strong>方法实现</strong></p>
<p>抽象类可以<strong>有非抽象方法，有方法体</strong> ； 接口不能有。</p>
<blockquote>
<p><strong>抽象类中添加新的方法，你可以给它提供默认的实现</strong>。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
</blockquote>
</li>
<li><p><strong>构造函数</strong></p>
<p>抽象类有；接口没有。</p>
</li>
<li><p><strong>修饰符</strong></p>
<p>抽象类除private 都有（抽象类目的是被继承，所以<strong>抽象方法是为被重写，不能私有</strong>）；接口<strong>默认public</strong>。</p>
</li>
<li><p><strong>继承个数 [接口优]</strong></p>
<p>抽象类只能被继承一次；接口可以有多个。</p>
</li>
</ul>
<h4 id="5-Java的四种引用？强软弱虚-？"><a href="#5-Java的四种引用？强软弱虚-？" class="headerlink" title="5. Java的四种引用？强软弱虚 ？"></a>5. <strong>Java的四种引用？强软弱虚</strong> ？</h4><ul>
<li><p><strong>强引用</strong> ：强引用是平常中使用最多的引用，强引用<strong>在程序内存不足（OOM）</strong>的时候也不会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>软引用：</strong> 软引用<strong>在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫）</strong>，使用方式：</p>
<blockquote>
<p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收<u>早先创建的对象</u>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>弱引用：</strong>是只要**<u>JVM垃圾回收器发现了弱引用</u>，就会将之回收**，使用方式：</p>
<blockquote>
<p><strong>可用场景：</strong>  Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>虚引用：无法通过虚引用来获取对一个对象的真实引用</strong>； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个<strong>对象</strong>，如果发现<strong>它还有虚引用</strong>，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</p>
<blockquote>
<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-JAVA创建对象的机制？"><a href="#6-JAVA创建对象的机制？" class="headerlink" title="6. JAVA创建对象的机制？"></a>6. <strong>JAVA创建对象的机制？</strong></h4><ul>
<li><p>new创建新对象</p>
</li>
<li><p>通过反射机制</p>
</li>
<li><p>采用clone机制</p>
</li>
<li><p>通过序列化机制</p>
</li>
</ul>
<h4 id="7-简述Java的对象结构？"><a href="#7-简述Java的对象结构？" class="headerlink" title="7. 简述Java的对象结构？"></a>7. <strong>简述Java的对象结构？</strong></h4><p>Java对象由三个部分组成：对象头、实例数据、<u>对齐填充</u>。</p>
<ol>
<li><p><strong>对象头。</strong> 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：**<code>mark word</code>和类型指针**。 如果是数组对象，还有数组长度。</p>
<ol>
<li> <u><code>mark word(32位)</code></u></li>
</ol>
<p>   <img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p>
<ul>
<li>具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。</li>
<li>当对象状态为偏向锁时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；<strong>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针</strong>。</li>
</ul>
<ol start="2">
<li><p><u>存储类型指针</u>，也就是指向类的元数据的指针，通过这个指针才能确定对象是<strong>属于哪个类的实例</strong>；</p>
</li>
<li><p><u>数组长度：</u>另外对于数组而言还会有一份记录数组长度的数据。</p>
</li>
</ol>
</li>
<li><p><strong>实例数据。</strong> 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）；</p>
</li>
<li><p><strong>对齐填充。</strong>JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。</p>
</li>
</ol>
<h4 id="8-Object-有哪些常用方法？"><a href="#8-Object-有哪些常用方法？" class="headerlink" title="8. Object 有哪些常用方法？"></a>8. <strong>Object</strong> <strong>有哪些常用方法？</strong></h4><ul>
<li><strong>equals</strong> <strong>方法</strong> </li>
<li><strong>hashCode</strong> <strong>方法</strong> </li>
<li><strong>wait</strong> <strong>方法</strong> </li>
<li><strong>notify</strong> <strong>方法</strong> </li>
<li><strong>notifyAll</strong> <strong>方法</strong></li>
</ul>
<h3 id="1-2-2-反射"><a href="#1-2-2-反射" class="headerlink" title="1.2.2 反射"></a>1.2.2 反射</h3><h4 id="1-请说明一下JAVA中反射的实现过程和作用分别是什么？-（快手）优缺点？"><a href="#1-请说明一下JAVA中反射的实现过程和作用分别是什么？-（快手）优缺点？" class="headerlink" title="1. 请说明一下JAVA中反射的实现过程和作用分别是什么？ （快手）优缺点？"></a>1. <strong>请说明一下JAVA中反射的实现过程和作用分别是什么？</strong> （快手）优缺点？</h4><ul>
<li><p><strong>定义</strong></p>
<p>反射机制是<strong>在运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<blockquote>
<p>jdbc就是典型的反射 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>实现和作用</strong></p>
<p>JAVA语言编译之后会生成一个<code>.class</code>文件，反射就是通过<strong>字节码</strong>文件<strong>找到某一个类、类中的方法以及属性</strong>等。 </p>
<ul>
<li><p><strong>实现：</strong> （1）<strong>代码会编译成一个.class文件</strong> （2） <strong>类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象</strong> </p>
<blockquote>
<p>不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。</p>
</blockquote>
<p>我们便是通过这个class对象来进行反射获取类的信息。</p>
</li>
<li><p><strong>作用：</strong></p>
<ol>
<li>反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，**<u>只要给定类的名字</u>**，那么就可以通过反射机制来获取类的所有信息。</li>
<li>根据类名在<strong>运行时创建实例</strong>（类名可以从配置文件读取，不用new）</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>反射优缺点</strong></p>
<ul>
<li><strong>优点</strong>：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法</li>
<li><strong>缺点：</strong> <ul>
<li><strong>性能降低</strong> ： 反射包括了一些<strong>动态类型</strong>，所以JVM<strong>无法对这些代码进行优化</strong></li>
<li><strong>安全限制：</strong> 使用反射技术要求程序必须在一个<strong>没有安全限制的环境</strong>中运行 </li>
<li><strong>内部暴露</strong>：由于反射允许代码执行一些在正常情况下不被允许的操作（比如<strong>访问私有的属性和方法</strong>），所以使用反射可能会导致意料之外的副作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-（未）解释一下JAVA代理模式？动态代理的原理？"><a href="#2-（未）解释一下JAVA代理模式？动态代理的原理？" class="headerlink" title="2. （未）解释一下JAVA代理模式？动态代理的原理？"></a>2. （未）<strong>解释一下JAVA代理模式？动态代理的原理？</strong></h4><blockquote>
<p> 参考这个：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54733692">JAVA面试50讲之9：动态代理的原理是什么？</a></p>
</blockquote>
<p>代理模式是给某一个对象提供一个代理，并由**【代理对象】控制对【原对象】的引用(使用)**。</p>
<ul>
<li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li>
<li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li>
</ul>
<p>根据代理模式又可以分为：静态代理和动态代理。</p>
<h5 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h5><blockquote>
<p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在<strong>编译时</strong>就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p>
</blockquote>
<p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。 </p>
<ul>
<li><p>一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。</p>
</li>
<li><p><strong>公共Person接口</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Student实现Person接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>StudentsProxy实现Person接口</strong></p>
<p>实现了Peson接口，<strong>同时持有一个Student对象</strong>，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p>
<blockquote>
<p> :warning: 自己实现的giveMoney，调用的是<strong>被代理的学生对象.giveMoney()</strong> 方法！ </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被【代理学生的上交班费】行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用实例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> StudentsProxy(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//班长代理上交班费，实际上是调用被代理对象的giveMoney方法</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用实例2：</strong>扩充增强原对象方法</p>
<p>班长在帮张三上交班费之前，想要先反映一下<strong>张三最近学习有很大进步</strong>，通过代理模式很轻松就能办到 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h5><blockquote>
<p>上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就<strong>已经编译</strong>完成 。</p>
</blockquote>
<p>然而动态代理，代理类<strong>并不是在Java代码中定义</strong>的，而是在运行时根据我们在Java代码中的“指示”<strong>动态生成</strong>“的 。</p>
<ul>
<li><p><strong>优点：</strong> 可以很方便的对代理类的函数进行统一的处理，<strong>而不用修改每个代理类中的方法 。</strong> 比如说，想要在每个代理的方法前<u>都加上</u>一个处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理类其它方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveHomework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveHomework();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。 </p>
</li>
<li><p><strong>简单实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>公共Person接口</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Student实现Person接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个计算方法执行时间的检测方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>StuInvocationHandler 实现 InvocationHandler接口</strong></p>
<blockquote>
<p>并没有像之前一样：用一个代理类 StudentsProxy实现公共<strong>Person</strong>接口，而是代理类StuInvocationHandler 实现<strong>InvocationHandler</strong>接口。</p>
<p>但二者<strong>都是持有被代理的对象Student引用</strong>。</p>
</blockquote>
<p>InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p>
<ul>
<li>通过<strong>反射</strong>，可以执行被代理对象Student的相应方法giveMoney()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="comment">// 原来的代理对象Student中的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>具体实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/26/bIVRJdO5vKX36nQ.jpg" alt="img"></p>
</li>
</ul>
<h5 id="2-3-动态代理的原理"><a href="#2-3-动态代理的原理" class="headerlink" title="2.3 动态代理的原理"></a>2.3 动态代理的原理</h5><p> 从 JVM 角度来说，动态代理是在运行时<u>，通过<strong>反射</strong>动态生成类<strong>字节码</strong>，</u>并加载到 JVM 中的。</p>
<h2 id="1-3-集合"><a href="#1-3-集合" class="headerlink" title="1.3 集合"></a>1.3 集合</h2><h3 id="1-3-1-集合类"><a href="#1-3-1-集合类" class="headerlink" title="1.3.1 集合类"></a>1.3.1 集合类</h3><h4 id="1-请说明Java集合类框架的基本接口有哪些？"><a href="#1-请说明Java集合类框架的基本接口有哪些？" class="headerlink" title="1. 请说明Java集合类框架的基本接口有哪些？"></a>1. <strong>请说明Java集合类框架的基本接口有哪些？</strong></h4><ul>
<li><code>Collection</code>：代表一组对象，每一个对象都是它的子元素。</li>
<li><code>Set</code>：不包含重复元素的Collection。</li>
<li><code>List</code>：有顺序的collection，并且可以包含重复元素。</li>
<li><code>Map</code>：可以把键(key)映射到值(value)的对象，键不能重复。</li>
</ul>
<h4 id="2-（补充：举例说明）说说什么是fail-fast？"><a href="#2-（补充：举例说明）说说什么是fail-fast？" class="headerlink" title="2. （补充：举例说明）说说什么是fail-fast？"></a>2. <strong>（补充：举例说明）说说什么是fail-fast？</strong></h4><p>fail-fast 机制是 Java 集合（Collection）中的一种错误<strong>快速反馈</strong>机制。当<strong>多个线程对同一个集合的内容进行操作时</strong>，就可能会产生 fail-fast 事件。</p>
<blockquote>
<p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，<strong>若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModifificationException 异常</strong>，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p>
</blockquote>
<h4 id="3-请说明List、Map、Set三个接口区分？"><a href="#3-请说明List、Map、Set三个接口区分？" class="headerlink" title="3. 请说明List、Map、Set三个接口区分？"></a>3. <strong>请说明List、Map、Set三个接口区分？</strong></h4><ul>
<li><strong>重复元素：</strong>List以特定索引来存取元素，可以有重复元素；Map以键值对映射，不能有重复key；Set元素不能重复</li>
<li><strong>继承collection：</strong> List、Set继承于collection；Map和前二者明显区分，不继承collection </li>
<li><strong>实现方式：</strong> List是线性结构的容器 ，典型实现有<u>ArrayList 、LinkedList、Vector</u>； Map、Set都有 <u>基于哈希存储和排序树</u> 的两种实现版本，前者实现有 <u>HashMap和Hashtable</u> ，后者有<u>HashSet</u> </li>
</ul>
<h4 id="4-请讲讲你所知道的常用集合类以及主要方法？"><a href="#4-请讲讲你所知道的常用集合类以及主要方法？" class="headerlink" title="4. 请讲讲你所知道的常用集合类以及主要方法？"></a>4. <strong>请讲讲你所知道的常用集合类以及主要方法？</strong></h4><p>最常用的集合类是List 和 Map。</p>
<ul>
<li><strong>List：</strong>典型实现有<u>ArrayList 、LinkedList、Vector</u> ，大小可变，适合用于按数值索引元素类型；</li>
<li><strong>Map：</strong> 其中每个键映射到一个值，实现有 <u>HashMap和Hashtable</u> 。</li>
</ul>
<h3 id="1-3-2-Map-amp-Set"><a href="#1-3-2-Map-amp-Set" class="headerlink" title="1.3.2 Map &amp; Set"></a>1.3.2 <strong>Map &amp; Set</strong></h3><h4 id="1-请你介绍一下map的分类和常见的情况？"><a href="#1-请你介绍一下map的分类和常见的情况？" class="headerlink" title="1. 请你介绍一下map的分类和常见的情况？"></a>1. <strong>请你介绍一下map的分类和常见的情况？</strong></h4><p>java为数据结构中的映射定义了一个接口<code>java.util.Map</code>  ， 它有四个实现类,分别是<code>HashMap、 Hashtable、 LinkedHashMap、 和TreeMap</code>.</p>
<ul>
<li><p><strong>Hashmap</strong>  ：根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</p>
<ul>
<li>遍历：访问快，遍历时取得的<u>数据随机</u></li>
<li>线程：不支持线程同步（但可以用Collections的synchronizedMap 实现同步）</li>
<li>key和记录：<strong>HashMap允许键和值是null</strong></li>
</ul>
</li>
<li><p><strong>Hashtable</strong> ：和Hashmap类似，是其子类。但其：</p>
</li>
<li><p>线程： 支持线程同步，也导致写入比较慢（一个时候只能一个线程写入）</p>
</li>
<li><p>key和记录：不允许记录的键或者值为空 ；</p>
</li>
<li><p><strong>LinkedHashMap</strong> ：HashMap的一个子类，<u>保存了记录插入顺序</u>：</p>
</li>
<li><p>遍历：<strong>遍历</strong>先得到的记录是先插入、一般情况比HashMap慢。</p>
</li>
<li><p><strong>TreeMap</strong> ： 实现SortMap接口，默认是按键值的升序排序，</p>
</li>
<li><p>遍历：当用<strong>遍历</strong>TreeMap时，得到的记录是<u>排过序</u>的</p>
<ul>
<li>线程：线程安全</li>
</ul>
</li>
</ul>
<p>一般情况下，我们用的最多的是HashMap, 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但<u>如果您要按自然顺序或自定义顺序遍历键</u>，那么TreeMap会更好。如果需要<u>输出的顺序和输入的相同</u>,那么用LinkedHashMap 可以实现,它还<strong>可以按读取顺序来排列。</strong></p>
<h5 id="1-1-【百度】-TreeMap的底层实现"><a href="#1-1-【百度】-TreeMap的底层实现" class="headerlink" title="1.1 【百度】 TreeMap的底层实现"></a>1.1 【百度】 TreeMap的底层实现</h5><h4 id="2-请问HashMap和Hashtable区别？"><a href="#2-请问HashMap和Hashtable区别？" class="headerlink" title="2. 请问HashMap和Hashtable区别？"></a>2. <strong>请问HashMap和Hashtable区别？</strong></h4><ul>
<li><strong>共同点</strong>：都实现Map接口</li>
<li><strong>不同点：</strong><ol>
<li> <strong>对Null key 和Null value的支持：</strong>HashMap<u>允许键和值是null</u>，而Hashtable不允许键或者值是null；</li>
<li> <strong>线程安全：</strong>Hashtable是同步的线程安全，而HashMap不是；</li>
<li> <strong>初始容量大小和每次扩充容量大小不同：</strong>  （1）创建时如果不指定容量初始值，Hashtable 默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为<strong>16</strong>，之后每次扩充，容量变为原来的<strong>2</strong>倍 ；（2）创建时如果给定了容量初始值，那么 Hashtable 会直接使用<strong>你给定的大小</strong>，而 HashMap 会将其<strong>扩充为2的幂次方大小</strong>，也就是说 <u>HashMap 总是使用2的幂作为哈希表的大小</u>；</li>
<li>  <strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表⻓度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有转换为红黑树这样的机制；</li>
<li> <strong>继承父类：</strong>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。</li>
</ol>
</li>
</ul>
<h4 id="3-请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？"><a href="#3-请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？" class="headerlink" title="3. 请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？"></a>3. <strong>请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？</strong></h4><p>都是key-value存储形式。</p>
<ul>
<li><p><strong>底层数据结构</strong>：<code>HashMap</code>与<code>ConcurrentHashMap</code>底层数据结构相似（数组+链表+红黑树），<code>Hashtable</code>没有红黑树；</p>
</li>
<li><p><strong>线程安全</strong>：<code>Hashtable</code>的<code>synchronized</code>修饰在方法，是对象级的加锁，同一时间只有一个线程能对数据进行操作；<code>ConcurrentHashMap</code>使用了修饰具体对象的<code>synchronized</code>（锁一个桶）和CAS机制，实现了更细粒度的锁；</p>
</li>
<li><p><strong>地址计算</strong>：</p>
</li>
</ul>
<ul>
<li><code>HashMap</code>使用<code>key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)</code>；-<ul>
<li><code>Hashtable</code>使用<code>(key.hashCode() &amp; 0x7fffffff) % tab.length()</code> </li>
</ul>
</li>
<li><code>ConcurrentHashMap</code>使用<code>(key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff</code>。</li>
</ul>
<h4 id="4-说一说红黑树特征？"><a href="#4-说一说红黑树特征？" class="headerlink" title="4. 说一说红黑树特征？"></a>4. <strong>说一说红黑树特征？</strong></h4><blockquote>
<p>紧接上个问题，面试官很有可能会问红黑树。</p>
</blockquote>
<ul>
<li>每个节点是黑色是红色</li>
<li><strong>根节点和叶子节点是黑色</strong></li>
<li>红色节点不能相邻</li>
<li>从一个节点到子孙节点路径上相同数目的黑节点</li>
</ul>
<p><img src="https://i.loli.net/2021/05/05/yismA9xYt5MEeFw.png" alt="image-20210505132113159"></p>
<h4 id="5-hashmap的基本原理，扩容方式（rehash）？"><a href="#5-hashmap的基本原理，扩容方式（rehash）？" class="headerlink" title="5. hashmap的基本原理，扩容方式（rehash）？"></a>5. <strong>hashmap的基本原理，扩容方式（rehash）？</strong></h4><blockquote>
<p>很棒的一篇文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dde9b12343c1">https://www.jianshu.com/p/dde9b12343c1</a> </p>
<p>更棒的一篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/81587796">https://zhuanlan.zhihu.com/p/81587796</a></p>
</blockquote>
<ul>
<li><p><code>HashMap定义</code></p>
<p>HashMap继承了Map端口，实现了Serializable等接口。存储HashMap的是一个Entry[]数组，Entry是一个单向链表：</p>
<blockquote>
<p>所以我们说HashMap实现的是一个<code>数组+链表</code> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Entry类</code></p>
<p>Entry在HashMap中实现为一个静态内部类，封装了key和value，还有<u>类型为Entry的next指向下一个Entry引用</u>。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">int</span> hash;</span><br></pre></td></tr></table></figure></li>
<li><p><code>图解HashMap</code></p>
<p>根据前面所知，我们可以得到HashMap的实现如下（默认初始化容量为16）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4843132-05b3a55bd2686dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="img"></p>
</li>
<li><p><code>put方法实现</code></p>
<ol>
<li><p>输入的<code>key</code>根据<code>hash(key)</code> 计算出hash值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对key为null的处理</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 根据key算出hash值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>hash方法如下（JDK1.8版本）</strong></p>
<p>下面这段代码也叫 <strong>“扰动函数”</strong> ，参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20733617">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>
<p><img src="https://i.loli.net/2021/05/15/OZT8G6PdxkAtQVi.png" alt="img"></p>
<p>混合原始哈希码的高位和低位，以此来加大低位的随机性 。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;⽆符号右移，忽略符号位，空位都以0补⻬</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相⽐于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差⼀点点，因为毕竟扰动了 4 次。</p>
</li>
<li><p><strong>Object类HashCode实现</strong></p>
<blockquote>
<p>详细源码分析参考 ：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903487432556551">Java Object.hashCode()返回的是对象内存地址？</a></p>
</blockquote>
<p>JDK8 的<strong>默认</strong>hashCode的计算方法是通过和当前线程有关的<strong>一个随机数+三个确定值</strong>，运用Marsaglia’s xorshift scheme随机数算法得到的一个随机数 。</p>
<p>可以通过在JVM启动参数中添加**-XX:hashCode=4**，<u>改变默认的hashCode计算方式</u>：</p>
<ul>
<li> hashCode == 0 ：返回一个Park-Miller伪随机数生成器生成的随机数 ，OpenJdk 6 &amp;7的默认实现；</li>
<li>hashCode == 1：此类方案将对象的内存地址，做移位运算后与一个随机数进行异或得到结果 ；</li>
<li>hashCode == 2：此类方案返回固定的1；</li>
<li>hashCode == 3：此类方案返回一个自增序列的当前值；</li>
<li>hashCode == 4：此类方案返回当前对象的内存地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>根据<code>indexFor(hash, table.length)</code> ，计算在table中下标</p>
<p><code>key.hashcode得到hash → 经过高低16异或扰动得到行hash →  indexFor计算下标</code></p>
<blockquote>
<p><code>indexFor()</code>  实际就是hash值取余：<code>hash%(table.lenght-1)</code> 。但在具体实现中通过位运算实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>计算原理。</strong> 顺便说一下，这也正好解释了<strong>为什么HashMap的数组长度要取2的整次幂</strong>。因为这样（数组长度-1）正好相当于一个<strong>“低位掩码”</strong>。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是<strong>截取了最低的四位值</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          10100101 11000100 00100101</span><br><span class="line">&amp;         00000000 00000000 00001111 （16）</span><br><span class="line">------------------------------------------</span><br><span class="line">          00000000 00000000 000000101</span><br></pre></td></tr></table></figure></li>
<li><p><strong>位运算要求<code>length</code> 一定是偶数。</strong><code>length-1</code>则一定是奇数。 这样<code>h &amp; (length-1)</code>进行位运算出现的结果可奇可偶，不会一直是偶数，浪费奇数空间。而length为2的幂次，可以保证length一定是偶数，<strong>这也是扩容为什么要求一定是2的幂次</strong>。</p>
</li>
</ul>
</li>
<li><p><u>遍历table中下标为i的Entry单向链表</u>，找是否有相同的key已经在HashMap中，如果有，就替换value为最新的值；没有就直接插入。所以HashMap中只能存储唯一的key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 先判断hash值是否一样，如果一样，再判断key是否一样</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果是第一次put上面<code>for</code>循环不会执行，而是<code>addEntry</code>方法直接把key和value封装成Entry，然后加入到table中的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这涉及到HashMap的<strong>扩容机制</strong>。</p>
</li>
</ol>
</li>
<li><p><code>扩容机制</code></p>
<blockquote>
<p>当HashMap中存储的元素个数达到扩容的阀值 ，那如何进行扩容？</p>
</blockquote>
<blockquote>
<p>:warning: 在jdk1.8版本以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<img src="https://i.loli.net/2021/05/04/PoScN7yntJRhFvd.png" alt="在这里插入图片描述" style="zoom: 50%;" />
</blockquote>
<p>我们再来看看addEntry方法中的扩容相关代码：</p>
<ul>
<li>扩容就是通过<code>resize()</code>方法创建一个长度为原来<strong>2</strong>倍的新table ；</li>
<li><code>resize()</code>方法内部通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计HashMap的扩容阀值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">      <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">          threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">     <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     transfer(newTable);     </span><br><span class="line">     <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     table = newTable;  </span><br><span class="line">     <span class="comment">//修改阈值</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                  <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                 newTable[i] = e; <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next; <span class="comment">//访问下一个Entry链上元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式 。下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="https://i.loli.net/2021/05/15/nCYJf3KPqBdEU4G.png" alt="image-20210515115619336"></p>
</li>
<li><p><code>get方法实现</code></p>
<p>用key的hash值算出key对应的Entry所在链表在在table的下标，然后遍历下标即可。</p>
<img src="4843132-9b5f706433247a6c.webp" alt="img" style="zoom:80%;" /></li>
</ul>
<h5 id="5-1-为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？"><a href="#5-1-为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？" class="headerlink" title="5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？"></a>5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？</h5><ul>
<li><p>在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。源码中注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure>

<p>这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p>
</li>
<li><p>特别的，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想。<strong>长度较小时，使用链<u>表空间占用少</u>，时间也不会长（因为链表短）。</strong> </p>
</li>
</ul>
<h5 id="5-2-HashMap-多线程操作导致死循环问题？"><a href="#5-2-HashMap-多线程操作导致死循环问题？" class="headerlink" title="5.2  HashMap 多线程操作导致死循环问题？"></a>5.2  HashMap 多线程操作导致死循环问题？</h5><p><strong>总结：</strong> HashMap之所以在并发下的扩容造成死循环，是因为，多个线程并发进行时，<strong>因为一个线程先期完成了扩容</strong>，将原的链表重新散列到自己的表中，并且链表变成了<strong>倒序</strong>，后一个线程再扩容时，又进行自己的散列，再次将<strong>倒序链表变为正序链表</strong>，于是形成了一个环形链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      Entry[] src = table;                   </span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                  <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">               e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">               newTable[i] = e;    <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;    <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>map初始化为一个长度为2的数组，loadFactor=0.75，<code>threshold=2*0.75</code>=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
</li>
<li><p>设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="https://i.loli.net/2021/05/15/9wiAnOHdBe7hjLs.png" alt="image-20210515120319361"></p>
</li>
<li><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，<strong>指向了线程二重组后的新链表</strong>。 </p>
</li>
<li><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="https://i.loli.net/2021/05/15/NFfwAOguQmsyeWh.png" alt="image-20210515120436107"></p>
</li>
<li><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="https://i.loli.net/2021/05/15/ApClYedO6JTWmnx.png" alt="image-20210515120503570"></p>
</li>
</ol>
<h5 id="5-3-说说HashMap的put方法？"><a href="#5-3-说说HashMap的put方法？" class="headerlink" title="5.3 说说HashMap的put方法？"></a>5.3 说说HashMap的put方法？</h5><p>根据key值计算在数组中的位置：</p>
<ul>
<li> 如果定位到的数组位置没有元素 就直接插入；</li>
<li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，<u>依次和插入的 key 比较，如果 <strong>hash值&amp;equals对象相同</strong>就直接<strong>覆盖</strong>，<strong>不同</strong>就采用<strong>头插法</strong>插入元素</u>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//table[i]的位置已经存在元素，遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;    </span><br><span class="line">    Object k;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 equals 方法判断key是否相等，若相等，该key对应的键值对已经存在，用新的value取代旧的value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </span><br><span class="line">        V oldValue = e.value;    </span><br><span class="line">        e.value = value;    </span><br><span class="line">        e.recordAccess(<span class="keyword">this</span>);    </span><br><span class="line">        <span class="keyword">return</span> oldValue;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h5 id="5-4-说说HashMap的get方法？"><a href="#5-4-说说HashMap的get方法？" class="headerlink" title="5.4 说说HashMap的get方法？"></a><strong>5.4 说说HashMap的get方法？</strong></h5><p>根据key值计算在数组中的位置：</p>
<ul>
<li>遍历链表或者在红黑树，比较key来获取value</li>
</ul>
<h5 id="5-5-【百度】rehash扩容时机？在插入前还是插入后？"><a href="#5-5-【百度】rehash扩容时机？在插入前还是插入后？" class="headerlink" title="5.5 【百度】rehash扩容时机？在插入前还是插入后？"></a>5.5 【百度】rehash扩容时机？在插入前还是插入后？</h5><p>rehash过程在put函数中，其大致扩容时机如下：</p>
<ol>
<li><p>计算hash，定位到桶；且遍历桶外挂链表，如果有相同key则覆盖；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)  <span class="comment">// 【百度】怎么处理key或value为NULL的情况？</span></span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//通过hash值对应到桶位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//顺序遍历桶外挂的单链表</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;/</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//遍历单链表完毕，没有找到与键相对的Entry，需新建一个Entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>【如果没有找到相同key，说明要插入一个新entry】</strong> ，执行addEntry，<strong>插入前</strong>先验证下是否扩容；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//将容量扩容为原来的2倍</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);<span class="comment">//扩容后的，该hash值对应的新的桶位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);<span class="comment">//在指定的桶位置上，创建一个新的Entry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<span class="comment">//链表的头插法插入新建的Entry</span></span><br><span class="line">        size++;<span class="comment">//更新size</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因此总结扩容时机如下：</p>
<ul>
<li>在执行put时，如果遍历指定桶外挂链表<strong>没有找到相同key</strong>的节点时，说明需要<strong>新建一个entry</strong>，这个时候在<strong>插入前</strong>验证下是否要扩容。</li>
</ul>
<h5 id="5-6-hashmap在1-7版本之前为什么使用头插法？"><a href="#5-6-hashmap在1-7版本之前为什么使用头插法？" class="headerlink" title="5.6 hashmap在1.7版本之前为什么使用头插法？"></a>5.6 hashmap在1.7版本之前为什么使用头插法？</h5><blockquote>
<p>1.7版本之前采用头插法，1.8之后采用尾插法。</p>
</blockquote>
<p><strong>头插法</strong>会改变链表中元素原本的顺序，以至于在并发场景下<strong>导致链表成环</strong>的问题；而<strong>尾插法</strong>，在扩容时<strong>会保持链表元素原本的顺序</strong>，就不会出现链表成环的问题 。 </p>
<blockquote>
<p>既然有多线程并发问题，那为什么1.8之前还要使用头插法？</p>
</blockquote>
<ol>
<li><strong>局部性原理：</strong> 最近访问过的数据下次大概率会再次访问，把刚访问过的元素<strong>放在链表最前面</strong>可以直接被查询到，减少查找次数</li>
<li><strong>不是为了适应多线程而设计：</strong>　只有在并发情况下，头插法才会出现链表成环的问题，多线程情况下，HashMap 本就非线程安全，这就<strong>相当于你在它的规则之外</strong>出了问题。</li>
</ol>
<h5 id="5-7-Hashmap-怎么处理key和value为null的情况？"><a href="#5-7-Hashmap-怎么处理key和value为null的情况？" class="headerlink" title="5.7 Hashmap 怎么处理key和value为null的情况？"></a>5.7 Hashmap 怎么处理key和value为null的情况？</h5><h4 id="6-Hashtable-源码分析"><a href="#6-Hashtable-源码分析" class="headerlink" title="6. Hashtable 源码分析"></a>6. Hashtable 源码分析</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903509725282317">Java集合之Hashtable源码解析</a></p>
</blockquote>
<ul>
<li><p><strong>构造函数</strong></p>
<p>和HashMap还是挺相似的，但是默认初始容量是11（HashMap是16）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;<span class="comment">//键值对的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;<span class="comment">//阀值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;<span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;<span class="comment">//修改次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//下面的三个构造函数都是调用这个函数，来进行相关的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];<span class="comment">//这里是与HashMap的区别之一，HashMap中table</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        initHashSeedAsNeeded(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定初始数组长度</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;<span class="comment">//从这里可以看出容量的默认值为16，加载因子为0.75f.</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>put方法</strong> </p>
<p>和HashMap整体过程依旧很像，但有4点注意：</p>
<ol>
<li><p>put方法是加锁synchronized，所以线程安全</p>
</li>
<li><p>Hashtable计算hash值的hash(key)，不允许为null，所以会抛出异常</p>
</li>
<li><p>获取数组散列的下标 <code>(hash &amp; 0x7FFFFFFF) % tab.length</code> 和HashMap <code>hash &amp; length-1</code> 不同</p>
<blockquote>
<ul>
<li><code>(hash &amp; 0x7FFFFFFF) % tab.length</code>  是（1）<code>hash &amp; 0x7FFFFFFF</code>  保证hash是正数 （2）然后取余</li>
<li>相比之下，HashMap是位运算进行了优化，更高效</li>
</ul>
</blockquote>
</li>
<li><p>Hashtable没有链表转红黑树的机制</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;<span class="comment">//这里方法修饰符为synchronized,所以是线程安全的。</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//value如果为Null,抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//hash里面的代码是hashSeed^key.hashcode（）,null.hashCode（）会抛出异常，所以这就解释了Hashtable的key和value不能为null的原因。</span></span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;<span class="comment">//获取数组元素下标,先对hash值取正，然后取余。</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;<span class="comment">//修改次数。</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;<span class="comment">//键值对的总数大于其阀值</span></span><br><span class="line">            rehash();<span class="comment">//在rehash里进行扩容处理</span></span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>rehash方法（扩容）</strong></p>
<p>和HashMap依旧很像，但是扩容每次是 <code>old*2+1</code> 。</p>
</li>
<li><p><strong>get方法</strong></p>
<p>也是相比Hashmap直接加了 synchronized 进行修饰，保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;<span class="comment">//没有什么特殊性，就是加了一个synchronized，就是根据index来遍历索引处的单链表。</span></span><br><span class="line">       Entry tab[] = table;</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">return</span> e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="6-1-（容易忘）HashMap-和-Hashtable-的区别-？"><a href="#6-1-（容易忘）HashMap-和-Hashtable-的区别-？" class="headerlink" title="6.1 （容易忘）HashMap 和 Hashtable 的区别 ？"></a>6.1 （容易忘）HashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><ol>
<li><p><strong>关于null</strong>，HashMap允许key和value都可以为null，而Hashtable则不接受key为null或value为null的键值对。</p>
</li>
<li><p><strong>关于线程安全</strong>，HashMap是线程不安全的，Hashtable是线程安全的，因为Hashtable的许多操作函数都用synchronized修饰。</p>
</li>
<li><p><strong>Hashtable与HashMap实现的接口不一致</strong>，但Hashtable继承Dictionary，而HashMap继承自AbstractMap，即父类不同</p>
</li>
<li><p><strong>默认初始容量不同</strong>，扩容大小不同。HashMap的hash数组的默认大小是16，而且一定是2 的指数<code>old*2</code>；Hashtable中hash数组默认大小是11，增加的方式是<code>old*2+1</code>。</p>
</li>
</ol>
<h5 id="6-2-ConcurrentHashMap-和-Hashtable-的区别-？"><a href="#6-2-ConcurrentHashMap-和-Hashtable-的区别-？" class="headerlink" title="6.2 ConcurrentHashMap 和 Hashtable 的区别 ？"></a>6.2 ConcurrentHashMap <strong>和</strong> Hashtable <strong>的区别</strong> ？</h5><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构⼀样，数组+链表/红黑⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采用 <strong>数组+链表/红黑树</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7</strong>的时候ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和CAS 来操作</strong>。（JDK1.6以后 对 synchronized锁做了很多优化） <u>整个看起来就像是优化过且线程安全的 HashMap</u>，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同⼀把锁，全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当⼀个线程访问同步方法时，其他线程也访问同步方法，可能会进⼊阻塞或轮询状态，如使用 put 添加元素，另⼀个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h4 id="7-ConcurrentHashMap线程安全的具体实现方式-底层具体实现-？"><a href="#7-ConcurrentHashMap线程安全的具体实现方式-底层具体实现-？" class="headerlink" title="7.  ConcurrentHashMap线程安全的具体实现方式/底层具体实现 ？"></a>7.  ConcurrentHashMap<strong>线程安全的具体实现方式</strong>/<strong>底层具体实现</strong> ？</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangjuncong/p/9478505.html">https://www.cnblogs.com/huangjuncong/p/9478505.html</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81%2B%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md">javaGuide</a></p>
</blockquote>
<p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
<p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<ul>
<li><p><strong>JDK 1.7 实现</strong> </p>
<p>Java 7 中 ConcurrentHashMap 的存储结构如下图。</p>
<img src="https://i.loli.net/2021/05/15/iT9npPGIdazS4vw.png" alt="img" style="zoom:150%;" />

<ul>
<li><p><strong>存储结构</strong></p>
<p>ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，<strong>一个 Segment 其实就是一个类 HashTable 的结构</strong>，Segment 内部维护了一个链表数组。</p>
<blockquote>
<p><strong>两次Hash。</strong>ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p>
<p>因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment。</p>
</blockquote>
<p><strong>1. ConcurrentHashMap的成员变量和构造函数</strong></p>
<blockquote>
<p><strong>ConcurrentHashMap扩容：</strong> 元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而<strong>只会增加Segment中链表数组的容量大小</strong>。 需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p>
</blockquote>
<p>核心初始化函数逻辑如下：</p>
<blockquote>
<p>2的指数是为了可以使用移位操作加快hash计算过程。</p>
</blockquote>
<ol>
<li><p>计算出Segment的数量<code>ssize</code>，是不大于concurrencyLevel的最大的2的指数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">          ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">      ++c;</span><br><span class="line">      <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">      <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>下面是完整代码：</p>
<blockquote>
<ul>
<li>segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到 。<strong>默认是 32 - sshift = 28</strong></li>
<li>segmentMask，默认是 ssize - 1 = 16 -1 = 15</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数：指定初始容量，负载因子，并发级别</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// 找到两种大小的最匹配参数</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方，</span></span><br><span class="line">        <span class="comment">// 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4</span></span><br><span class="line">        <span class="comment">// sshift相当于ssize从1向左移的次数</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift; </span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 段偏移量，默认值情况下此时segmentShift = 28</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="comment">// 散列算法的掩码，默认值情况下segmentMask = 15</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        <span class="comment">// 创建ssize长度的Segment数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.来查看具体代码定义，Segment的成员变量：</strong></p>
<blockquote>
<p>Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;    <span class="comment">//Segment中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;      <span class="comment">//对table的大小造成影响的操作的数量(比如put或者remove操作)</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">//阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;   <span class="comment">//负载因子,用于确定threshold</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">//链表数组,数组中的每一个元素代表了一个链表的头部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 继续查看HashEntry组成：</strong></p>
<blockquote>
<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 <strong>value ，以及链表都是 volatile 修饰的</strong>，保证了获取时的可见性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    　<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置具有volatile写语义的next字段。</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">      UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面不太重要，略。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>put() 方法实现</strong></p>
<blockquote>
<p>相比Hashtable，1.7版本concurrentHashmap的更加细粒度，只有定位到段，才会锁住。也就是段锁！</p>
<p>而Hashtable直接锁住整个方法。</p>
</blockquote>
<ol>
<li><p>计算key的hash值 ; </p>
</li>
<li><p>根据<strong>hash值，segmentShift，segmentMask定位到哪个Segment</strong>；</p>
</li>
<li><p>如果指定位置的 Segment 为空，则初始化这个 Segment； </p>
</li>
<li><p>在对应的 Segment 中进行具体的 put。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Segment 中进行具体的 put的源码如下：</p>
<blockquote>
<p>判断元素个数是否超过了阈值或者segment中数组的长度超过了MAXIMUM_CAPACITY，如果满足条件则rehash扩容！</p>
</blockquote>
<p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>
<ol>
<li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取；</p>
<blockquote>
<p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。</p>
</blockquote>
</li>
<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry ；</p>
</li>
<li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待；</p>
<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>
<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接<strong>头插法</strong>插入。</li>
</ol>
<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>
<ol>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致，<strong>一致则替换值</strong></li>
<li>不一致，<u>获取链表下一个节点</u>，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>
<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>
<li>直接链表<strong>头插法</strong>插入。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>扩容 rehash</strong> </p>
<blockquote>
<p>rehash在put()内部被触发。</p>
</blockquote>
<p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，<strong>位置要么不变，要么变为 index+ oldSize</strong>，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = e.hash &amp; sizeMask;  <span class="comment">// 新位置计算</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不变或者是：老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>get方法</strong></p>
<blockquote>
<p>注意，Hashtable 会使用Synchronized进行修饰，所以不支持并发。但是ConcurrentHashmap <strong>没有使用同步机制</strong>：</p>
<ul>
<li>1.7版本 。<strong>使用unsafe方法（）等方式直接操作来保证并发处理的安全性</strong>，使用的是硬件的安全机制。</li>
<li>1.8版本。没有使用同步，也没有使用unsafe方式。所以<strong>是并发</strong>的。</li>
</ul>
</blockquote>
<ul>
<li><p>到这里就很简单了，get 方法只需要两步即可。</p>
<pre><code>1. 计算得到segment的位置 u 
2. **CAS方式获取segment数组对象 segment[u]**
3. 计算HashEntry数组的下标 i
4. **CAS方式获取HashEntry[i]，即数组首节点**
</code></pre>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>JDK 1.8 实现</strong></p>
<blockquote>
<p>1.8版本分析，建议参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zerotomax/p/8687425.html">https://www.cnblogs.com/zerotomax/p/8687425.html</a> 。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/15/F6UhuXNQGKnldVk.png" alt="image-20210515224441806"></p>
<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。 </p>
<blockquote>
<p>和JDK1.8的HashMap是很相似 , 抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
</blockquote>
<ul>
<li><p><strong>存储结构和属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">// hashmap也是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 超过8扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 超过64红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Node数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果在实例化对象的时候指定了容量，则初始化sizeCtl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapDebug</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>put方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>再来看putVal ：</p>
<blockquote>
<p>可以发现相比HashTable直接对方法进行加锁synchronized / 1.7版本的ConcurrentHashMap 进入的开头尝试获取锁，1.8版本的ConcurrentHashMap 锁更加细粒度化。</p>
<ul>
<li>只有：（1）table不为初始化 （2）定位到table位置<code>i</code>不存在元素（此时会用CAS方式进行添加）（3）数组也没有在进行扩张（MOVED=-1）</li>
</ul>
<p>此时才会进行synchronized 添加元素（不会锁住rehash方法，最后才判断是否扩容）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，</span></span><br><span class="line"><span class="comment">     * 如果没有的话就初始化数组</span></span><br><span class="line"><span class="comment">     *  然后通过计算hash值来确定放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来</span></span><br><span class="line"><span class="comment">     * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</span></span><br><span class="line"><span class="comment">     * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作</span></span><br><span class="line"><span class="comment">     *    然后判断当前取出的节点位置存放的是链表还是树</span></span><br><span class="line"><span class="comment">     *    如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，</span></span><br><span class="line"><span class="comment">     *          则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾</span></span><br><span class="line"><span class="comment">     *    如果是树的话，则调用putTreeVal方法把这个元素添加到树中去</span></span><br><span class="line"><span class="comment">     *  最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话，</span></span><br><span class="line"><span class="comment">     *  则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());    <span class="comment">//取得key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)    </span><br><span class="line">                tab = initTable();    <span class="comment">//第一次put的时候table没有初始化，则初始化table</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;    <span class="comment">//通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,        <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的</span></span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))        <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line"><span class="comment">             * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                 *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                 *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                 *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                 *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                 *  </span></span><br><span class="line"><span class="comment">                 *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                 *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;        <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2</span></span><br><span class="line">                            binCount = <span class="number">1</span>;            </span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    <span class="comment">//遍历这个链表</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;        <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)        <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;    <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,        <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                        treeifyBin(tab, i);    </span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);    <span class="comment">//计数，可能也会触发扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩容<code>transfer</code> </p>
<blockquote>
<p>扩容主要是通过transfer方法来进行的。</p>
<ul>
<li>只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，调用<strong>treeifyBin()</strong> 触发数组的扩容/转换为数；</li>
<li>使用**addCount()**添加元素数组元素，会进行判断达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容</li>
</ul>
</blockquote>
<ul>
<li><p><strong>treeifyBin()</strong></p>
<p>某一个节点的数目已经超过了8个，执行treeifyBin() 。</p>
<ol>
<li><p>当需要扩容的时候，调用的时候tryPresize方法 </p>
<p>（1）<strong>tryPresize方法并没有加锁</strong>，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容使用<strong>transfer</strong>方法</p>
<p> （2）<u>transfer比较复杂还没有详细看，它里面使用的synchronized 进行单个节点处理扩容</u>  （查看上面看transfer源码）</p>
</li>
<li><p>否则synchronized进行链表转换为树 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;treeifyBin方\t==&gt;数组长：&quot;</span>+tab.length);</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">                                hd = p;    <span class="comment">//设置head</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>addCount()</strong> </p>
<p>addCount也主要是调用transfer，这里主要还是寄一下transfer的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);    </span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>get方法</strong></p>
<p>get操作中，根本没有使用同步机制，<strong>也没有使用unsafe方法</strong>，所以读（get）操作是支持并发操作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 相比put方法，get就很单纯了，支持并发操作，</span></span><br><span class="line"><span class="comment">     * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">     * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">     * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="7-1-你知道-ConcurrentHashMap-的工作原理吗？"><a href="#7-1-你知道-ConcurrentHashMap-的工作原理吗？" class="headerlink" title="7.1 你知道 ConcurrentHashMap 的工作原理吗？"></a>7.1 你知道 ConcurrentHashMap 的工作原理吗？</h5><ul>
<li>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。<ul>
<li><strong>主要采用锁机制</strong>，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作</li>
</ul>
</li>
<li>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<ul>
<li><strong>CAS无锁算法</strong>，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行</li>
</ul>
</li>
</ul>
<h5 id="7-2-请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？"><a href="#7-2-请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？" class="headerlink" title="7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？"></a>7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？</h5><p>ConcurrentHashMap被final修饰的变量，（部分）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 默认segment层级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// segment最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一个segment最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>HashEntry中被volatile修饰的部分变量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;  <span class="comment">// 保证可见性</span></span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用final 。</strong>用来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</li>
<li><strong>使用volatile。</strong>保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持。</li>
</ul>
<h5 id="7-3-HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。"><a href="#7-3-HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。" class="headerlink" title="7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。"></a>7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。</h5><ul>
<li><strong>锁机制。</strong> 所有访问HashTable的线程都必须竞争同一把锁，效率更低；ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
<li><strong>底层数据结构。</strong> 1.8之后很相似，都是数组+链表/红黑树 ； 1.8之前，ConcurrentHashMap是Segement数组 + HashEntry数组 + 链表。</li>
</ul>
<h5 id="7-4-（阿里·淘特）ConcurrentHashMap1-8为什么不使用分段锁？"><a href="#7-4-（阿里·淘特）ConcurrentHashMap1-8为什么不使用分段锁？" class="headerlink" title="7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？"></a>7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？</h5><p>先说分段锁的优点：</p>
<ol>
<li>保证在<strong>操作不同段 map</strong> 的时候<strong>可以并发执行</strong>；操作<strong>同段 map</strong> 的时候，进行<strong>锁的竞争和等待</strong>。这相<strong>对于直接对整个map同步synchronized</strong>是有优势的。</li>
</ol>
<p>但是分段锁也有一些不可忽视的缺点：</p>
<ol>
<li>分成很多段时会比较<strong>浪费内存空间</strong>(不连续，碎片化)；</li>
<li><strong>操作map时竞争同一个分段锁的概率非常小（段散列比较好的时候）</strong>时，分段锁反而会造成更新等操作的长时间等待；</li>
<li>当某个段很大时，分段锁的性能会下降。</li>
</ol>
<p>综上考虑1.8不再使用分段锁。</p>
<h5 id="7-5-为什么1-8中-get-方法不加锁？"><a href="#7-5-为什么1-8中-get-方法不加锁？" class="headerlink" title="7.5 为什么1.8中 get() 方法不加锁？"></a>7.5 为什么1.8中 get() 方法不加锁？</h5><p>因为链表每个节点的val和next都使用volatile修饰，保证了可见性。</p>
<h5 id="7-6-为什么1-8不使用lock而是使用sync？"><a href="#7-6-为什么1-8不使用lock而是使用sync？" class="headerlink" title="7.6 为什么1.8不使用lock而是使用sync？"></a>7.6 为什么1.8不使用lock而是使用sync？</h5><ol>
<li>因为sync加入锁升级机制（jdk1.6之后），已经优化的不错了；</li>
<li>lock通过reentranclock实现，reentranlock是通过AQS实现，需要增加额外内存开销（CLH双向队列）。</li>
</ol>
<h4 id="8-HashMap-和-HashSet区别-？"><a href="#8-HashMap-和-HashSet区别-？" class="headerlink" title="8. HashMap 和 HashSet区别 ？"></a>8. HashMap <strong>和</strong> HashSet<strong>区别</strong> ？</h4><blockquote>
<p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"><strong>HashMap</strong></th>
<th align="center"><strong>HashSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了Map接⼝</td>
<td align="center">实现Set接⼝</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调⽤ <code>put()</code> 向map中添加元素</td>
<td align="center">调⽤ <code>add()</code> ⽅法向Set中添加元素</td>
</tr>
<tr>
<td align="center">HashMap使⽤键（Key）计算Hashcode：<code>int hash = hash(key);</code></td>
<td align="center">HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性。</td>
</tr>
</tbody></table>
<h4 id="9-说说HashSet的基本原理？"><a href="#9-说说HashSet的基本原理？" class="headerlink" title="9. 说说HashSet的基本原理？"></a>9. 说说HashSet的基本原理？</h4><ul>
<li><p><strong>底层结构</strong> </p>
<p><code>HashSet</code>底层原理完全就是包装了一下<code>HashMap</code> ，只不过存储的时候<code>value</code>是默认存储了一个<code>Object</code>的静态常量，取的时候也是只返回<code>key</code>，所以看起来就像<code>List</code>一样。</p>
</li>
<li><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>add()方法</strong></p>
<p>可以看到这三个方法都是直接调用的<code>HashMap</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>add其实就是调用HashMap的put方法，那么如何保证<strong>唯一性</strong>？</p>
</blockquote>
<p><strong>如果<code>哈希值</code>和<code>key</code>都一样</strong>，就会直接拿新值<strong>覆盖旧值</strong>，而<code>HashSet</code>就是利用这个特性来保证唯一性。</p>
<p>其实和HashMap就是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>contains方法</strong>（<del>Get()方法</del> ）</p>
<p><strong>hashset没有get方法</strong>，因为没有意义：不需要获取某个键值对应的value。</p>
<p>具体实现直接调用hashmap的containsKey()方法：</p>
<blockquote>
<p>过程和hashmap的get方法过程差不多，返回为null则是不存在。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="9-1-HashSet如何检查重复-？"><a href="#9-1-HashSet如何检查重复-？" class="headerlink" title="9. 1 HashSet如何检查重复 ？"></a>9. 1 HashSet<strong>如何检查重复</strong> ？</h5><ol>
<li>把对象加⼊ HashSet 时，HashSet先计算对象的hashcode 值；</li>
<li>根据hashcode值计算出要加⼊的位置，同时也会与其他加⼊的对象的hashcode值作⽐教；</li>
<li>如果没有相符的hashcode，HashSet会假设对象没有重复出现；</li>
<li><strong>如果发现有相同hashcode值的对象，这时会调用 equals()</strong> 方法来检查hashcode相等的对象是否真的相同，如果两者相同，HashSet就不会让加⼊操作成功。</li>
</ol>
<h5 id="9-2-【新】contains-方法在HashSet和ArrayList的实现区别？"><a href="#9-2-【新】contains-方法在HashSet和ArrayList的实现区别？" class="headerlink" title="9.2 【新】contains()方法在HashSet和ArrayList的实现区别？"></a>9.2 【新】contains()方法在HashSet和ArrayList的实现区别？</h5><ul>
<li><p><strong>Arraylist</strong></p>
<p>因为底层是object数组，判断某个对象是否存在，其实是通过遍历来进行判断的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Hashset</strong></p>
<p>Hashset是<strong>hash值 &amp;&amp; 遍历链表equals()</strong> 都相等，来判断的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-comparable-和-Comparator-的区别-？"><a href="#10-comparable-和-Comparator-的区别-？" class="headerlink" title="10. comparable 和 Comparator**的区别 **？"></a>10. comparable <strong>和</strong> Comparator**的区别 **？</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xujian2014/p/5215082.html">https://www.cnblogs.com/xujian2014/p/5215082.html</a></p>
</blockquote>
<ul>
<li><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。</p>
<blockquote>
<p>例如Person类，实现Comparable接口，使得所有Person类对象可以按照各自年龄大小进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age-p.getAge();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p>
<blockquote>
<p>Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。。</p>
</li>
</ul>
<h4 id="11-如何选用集合"><a href="#11-如何选用集合" class="headerlink" title="11.  如何选用集合?"></a>11.  <strong>如何选用集合</strong>?</h4><p><img src="https://img-blog.csdn.net/20140630092900390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaml1cWl5dWxpYW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><strong>需要存储键值对</strong>：</p>
<ul>
<li><strong>Map接口的集合</strong> <ul>
<li>需要排序时选择TreeMap</li>
<li>不需要排序时就选择HashMap</li>
<li>需要保证线程安全就选⽤ConcurrentHashMap</li>
</ul>
</li>
</ul>
<p><strong>只需要存储元素，实现collection接口的集合，又分为：</strong></p>
<ul>
<li><strong>需要保证元素唯一–Set接口的集合</strong><ul>
<li>HashSet</li>
</ul>
</li>
<li><strong>不需要元素唯一–List接口结合</strong><ul>
<li>查找比较多：ArrayList</li>
<li>增删比较多：LinkedList</li>
</ul>
</li>
</ul>
<h3 id="1-3-3-List"><a href="#1-3-3-List" class="headerlink" title="1.3.3 List"></a>1.3.3 <strong>List</strong></h3><h4 id="1-用过-ArrayList-吗？说一下它有什么特点？"><a href="#1-用过-ArrayList-吗？说一下它有什么特点？" class="headerlink" title="1. 用过 ArrayList 吗？说一下它有什么特点？"></a>1. <strong>用过 ArrayList 吗？说一下它有什么特点？</strong></h4><ul>
<li><strong>自动扩容：</strong> 当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小 ；</li>
<li><strong>底层实现：</strong> <strong>底层是使用数组实现</strong> <strong>，add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制</strong>；</li>
<li><strong>线程不安全</strong></li>
</ul>
<h4 id="2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="2. ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>2. ArrayList <strong>与</strong> Vector <strong>区别呢</strong>?<strong>为什么要用</strong>Arraylist<strong>取代</strong>Vector<strong>呢？</strong></h4><ul>
<li><p><strong>线程安全：</strong> Vector线程安全，ArrayList 不是；</p>
</li>
<li><p><strong>Vector耗时：</strong>Vector 类的所有方法都是同步的。可以由两个线程安全地访问⼀个Vector对象、但是⼀个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
</li>
</ul>
<h4 id="3-Array-amp-ArrayList不同点"><a href="#3-Array-amp-ArrayList不同点" class="headerlink" title="3. Array &amp; ArrayList不同点?"></a>3. Array &amp; ArrayList不同点?</h4><ol>
<li><strong>Array可以包含基本类型和对象类型</strong>，<strong>ArrayList只能包含对象类型</strong> ；</li>
<li>Array大小是固定的，ArrayList的大小是 <u>动态变化</u> 的 ；</li>
<li>ArrayList提供了更多的方法和特性: addAll()，removeAll()，iterator()。</li>
</ol>
<h4 id="4-Arraylist-与-LinkedList-区别"><a href="#4-Arraylist-与-LinkedList-区别" class="headerlink" title="4. Arraylist 与 LinkedList 区别?"></a>4. Arraylist <strong>与</strong> LinkedList <strong>区别</strong>?</h4><ul>
<li><p><strong>索引/插入：</strong>ArrayList按序号索引，索引快插入慢；LinkedList不是，索引慢，插入快；</p>
</li>
<li><p><strong>内存方面：</strong> Arraylist 是线性连续存储， 内存利用更低；LinkedList 是链表，内存利用更高（将内存零散空间串联），但也更占有内存（每个节点存储了两个引用）；</p>
</li>
<li><p><strong>线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是<strong>都不</strong>保证线程安全；</p>
</li>
<li><p> <strong>底层数据结构：</strong> Arraylist 底层使用的是 <strong>Object</strong> <strong>数组</strong>； LinkedList  底层使用的是 <strong>双向链表</strong> 数据结构 ；</p>
</li>
</ul>
<blockquote>
<p>JDK1.6之前为循环链表，JDK1.7取消了循环。</p>
</blockquote>
<h4 id="5-【源码解读】说说ArrayList的扩容机制吧-？为什么是扩容1-5倍？默认大小是多少。"><a href="#5-【源码解读】说说ArrayList的扩容机制吧-？为什么是扩容1-5倍？默认大小是多少。" class="headerlink" title="5. 【源码解读】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。"></a>5. 【<u>源码解读</u>】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a></p>
</blockquote>
<p>先把回答写在下面：</p>
<blockquote>
<p><strong>ArrayList/vector默认大小都是10，但vectot扩容是2倍。</strong></p>
</blockquote>
<p><strong>1. 扩容机制：</strong>  </p>
<p>使用无参构造函数创建的数组长度为0，当第一次add后数组长度为10 ； 如果继续add超过10后，也就是不满足**<code>minCapacity（最小需要容量） - elementData.length &gt; 0</code>** 会触发扩容机制。 将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p>
<p>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> : </p>
<ul>
<li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li>
</ul>
<p> <strong>2. 为什么是1.5倍？</strong></p>
<p>因为，<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同。</p>
<p>比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p>
<ul>
<li><p><strong>ArrayList总览</strong></p>
<p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问；</li>
<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆；</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
</li>
<li><p><strong>ArrayList 核心源码解读（先耐心看一遍）</strong></p>
<p>直接点击上面链接 <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81%2B%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90.md">逐源码分析扩容机制</a> 查看。</p>
</li>
<li><p><strong>【重点】JDK8 <u>扩容机制</u> 解读</strong></p>
<ol>
<li><p><strong>从构造函数说起</strong> </p>
<p>（JDK8）ArrayList 有三种方式来初始化 :</p>
<ul>
<li>以<strong>无参数构造方法</strong>创建 ArrayList 时，实际上初始化赋值的是一个<strong>空数组</strong>。<u>当真正对数组进行添加元素操作时，才真正分配容量</u>。即向数组中添加第一个元素时，数组容量扩为 10。</li>
<li>jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。JDK8的内存优化也值得我们在平时开发中学习。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line">  <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">   <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> /**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>再看<code>add</code>方法</strong></p>
<blockquote>
<p>这里<u>以无参构造函数创建的 ArrayList</u> 为例分析 。</p>
</blockquote>
<blockquote>
<p>JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>再看 <code>ensureCapacityInternal()</code> 方法</strong></p>
<p>第2步（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code> 。</p>
<ul>
<li><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong> </li>
<li>然后开始调用 <code>ensureExplicitCapacity()</code> 方法 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>调用 <code>ensureCapacityInternal()</code> 进入<code>ensureExplicitCapacity()</code>这个方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们来仔细分析一下：</p>
<ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，<strong>所以 minCapacity 此时为 10</strong>。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 9 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 10 个元素，<code>minCapacity &lt; elementData.length</code><strong>不成立</strong>。进入 grow 方法进行扩容。</p>
</li>
<li><p><strong>elementData.length（实际容量）&gt;= minCapacity（最小需要容量）  , 执行 grow()</strong> </p>
<blockquote>
<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数。</p>
</blockquote>
<p>将新容量更新为旧容量的1.5倍 ，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】。</p>
<ul>
<li>最后检查设置的新容量是否大于最大容量MAX_ARRAY_SIZE ，进入<code>hugeCapacity()</code> : <ul>
<li>如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法grow。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把【最小需要容量当作数组的新容量】，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置完新容量 newCapacity ，进行<code>Arrays.copyOf</code></strong></p>
<p>Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。</p>
<ul>
<li><u>第二个自变量指定要建立的新数组长度</u>，如果新数组的长度超过原数组的长度，则保留数组默认值，例如：</li>
</ul>
<p>使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容。</p>
</li>
</ol>
</li>
<li><p><strong>contains()方法</strong></p>
<p>就是遍历数组看是否存在该元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;<span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回指定元素在列表中第一次出现的索引，如果该列表不包含该元素，则返回-1。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-1-多线程操作ArrayList会出现什么错误？"><a href="#5-1-多线程操作ArrayList会出现什么错误？" class="headerlink" title="5.1 多线程操作ArrayList会出现什么错误？"></a>5.1 多线程操作ArrayList会出现什么错误？</h5><p>从ArrayList的（1）添加元素（<code>add</code>/<code>addAll</code>）和（2）获取元素（<code>get</code>）  两个角度来说：</p>
<ol>
<li><p><strong>多线程添加元素</strong></p>
<p>假设此时<code>minCapacity（最小需要容量）= 10</code> ，此时数组容量是10。A,B两个线程各需要添加若干元素，<strong>同时</strong> 判断此时不需要扩容，后续可能就会发生<strong>数组越界</strong>。</p>
</li>
<li><p><strong>多线程获取元素</strong></p>
<p>一个线程正在修改某个元素，另外一个线程此时正在读，那么读到的就是修改前的元素，也就是<strong>脏数据</strong>。</p>
</li>
</ol>
<h4 id="6-说一下LinkedList底层原理？"><a href="#6-说一下LinkedList底层原理？" class="headerlink" title="6. 说一下LinkedList底层原理？"></a>6. 说一下LinkedList底层原理？</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021433760">Java集合系列之三：LinkedList底层原理</a></p>
</blockquote>
<p>LinkedList实现了<strong>List</strong>接口和<strong>Deque</strong>接口的，底层的<strong>双端链表</strong>结构使它支持高效的插入和删除操作，<u>也具有队列的特性</u>，非线程安全的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2192701-9c26f117619ad840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp" alt="img"></p>
<blockquote>
<p>相比ArrayList要简单很多，主要是双向链表那些操作。</p>
</blockquote>
<ul>
<li><p><strong>底层结构</strong></p>
<p>核心属性、构造方法和Node定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;   <span class="comment">//LinkedList中存放的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;   <span class="comment">//尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，创建一个空的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node节点    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>add() 方法</strong></p>
<p><strong>朴实无华的双向链表尾插法。</strong>获得当前最后一个节点最为当前节点的前置节点，同样把当前节点设置为前置节点的后置节点，然后把当前节点作为最后一个节点，因为只需要创建一个节点与前一个节点建立前后关系即可，时间复杂度是O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前最后一个节点作为前置节点，可能为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化当前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 把当前节点作为最后的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 第一次添加设置为第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 把当前节点设置为前置节点的后置节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>add(int index,E e)</strong></p>
<p>按索引插入元素，首先判断是不是第一个添加的元素，如果是的话，直接使用add()方法添加就可以了，如果不是则需要根据索引来遍历寻找链表上对应位置。</p>
<ul>
<li>这里用了个小技巧，<strong>判断索引是在前半段还是在后半段</strong>，从短的那头开始遍历，找到之后，新建一个节点，建立新的前置节点和后置节点的关系。时间复杂度是O(n)，n为size/2。</li>
</ul>
</li>
<li><p><strong>get(int index)方法</strong> </p>
<p>get()方法是用的上面介绍过的node()方法，时间复杂度是O(n)，n为size/2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 判断数组越界</span></span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     <span class="comment">// 遍历寻找节点</span></span><br><span class="line">     <span class="keyword">return</span> node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得被插入索引上的元素</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 获得第一个节点</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="comment">// 往后找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果索引是在链表的前半段</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获得最后个节点</span></span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="comment">// 往前找到插入索引位置上的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-4-迭代器"><a href="#1-3-4-迭代器" class="headerlink" title="1.3.4 迭代器"></a>1.3.4 迭代器</h3><h4 id="1-请简单说明一下什么是迭代器？"><a href="#1-请简单说明一下什么是迭代器？" class="headerlink" title="1. 请简单说明一下什么是迭代器？"></a>1. <strong>请简单说明一下什么是迭代器？</strong></h4><p>Iterator提供了统一遍历操作集合元素的统一接口, <strong>Collection接口实现Iterable接口</strong>。</p>
<ul>
<li>每个集合<strong>都通过实现Iterable接口中iterator()方法</strong>返回Iterator接口的实例, 然后对集合的元素进行迭代操作；</li>
<li>在<u><strong>迭代元素的时候不能通过集合的方法删除元素</strong></u>, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除。</li>
</ul>
<h4 id="2-请你说说Iterator和ListIterator的区别？"><a href="#2-请你说说Iterator和ListIterator的区别？" class="headerlink" title="2. 请你说说Iterator和ListIterator的区别？"></a>2. <strong>请你说说Iterator和ListIterator的区别？</strong></h4><ul>
<li><strong>遍历类型：</strong><code>Iterator</code>可用来遍历Set和List集合，但是<code>ListIterator</code>只能用来遍历List；</li>
<li><strong>遍历方向：</strong><code>Iterator</code>对集合只能是前向遍历，<code>ListIterator</code>既可以前向也可以后向；</li>
<li><strong>功能区别：</strong><code>ListIterator</code>实现了Iterator接口，并包含其他的功能</li>
</ul>
<h2 id="1-4-多线程"><a href="#1-4-多线程" class="headerlink" title="1.4 多线程"></a>1.4 多线程</h2><h4 id="0-三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1-100呢？交替打印奇偶10次呢？"><a href="#0-三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1-100呢？交替打印奇偶10次呢？" class="headerlink" title="0. 三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？"></a>0. <strong>三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</strong></h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/370130458">https://zhuanlan.zhihu.com/p/370130458</a></p>
</blockquote>
<h5 id="0-1-synchronized-条件变量"><a href="#0-1-synchronized-条件变量" class="headerlink" title="0.1 synchronized + 条件变量"></a>0.1 <strong>synchronized + 条件变量</strong></h5><ol>
<li><p><strong>synchronized + 条件变量</strong>（循环打印1次）</p>
<p>思路如下：</p>
<ul>
<li>新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：<code>num%3==当前线程条件变量?</code> ；</li>
<li>把打印的代码用synchronized 加锁，每个线程拿到锁后，<strong>while循环判断</strong>是否满足当前线程的条件变量 ； </li>
<li><strong>如果满足</strong> ，便执行后续逻辑打印当前线程，之后<strong>notifyall()唤醒其它线程</strong>；</li>
<li><strong>如果不满足</strong>，执行wait等待释放锁；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>synchronized + 条件变量</strong>（循环打印10次）</p>
<p>打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在<strong>synchronized前加上for循环</strong>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>synchronized + 条件变量</strong>（打印1~100)</p>
<p>设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_100</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxnum = <span class="number">10</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123; <span class="comment">//想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章</span></span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + num);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_100  wait_notify_100 = <span class="keyword">new</span> Wait_Notify_100 ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>synchronized + 条件变量</strong>（奇偶打印10次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Wait_Notify_Odd_Even</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    Wait_Notify_Odd_Even(<span class="keyword">int</span> initCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOddEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="comment">// 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print( Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    System.out.println(++count);</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Wait_Notify_Odd_Even waitNotifyOddEven = <span class="keyword">new</span> Wait_Notify_Odd_Even(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">//为了保证线程odd先拿到锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="0-2-join"><a href="#0-2-join" class="headerlink" title="0.2 join"></a>0.2 join</h5><p><code>join()</code>方法：<strong>在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行</strong>。</p>
<p>基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Join_ABC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(<span class="keyword">null</span>),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t1),<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t2),<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printABC</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">printABC</span><span class="params">(Thread beforeThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(beforeThread!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join(); </span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="0-3-Lock"><a href="#0-3-Lock" class="headerlink" title="0.3 Lock"></a>0.3 Lock</h5><p>该方法很容易理解，不管哪个线程拿到锁，<strong>只有符合条件的才能打印</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Lock_ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock(); <span class="comment">// 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock_ABC lockABC = <span class="keyword">new</span> Lock_ABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="0-4-Semaphore"><a href="#0-4-Semaphore" class="headerlink" title="0.4 Semaphore"></a>0.4 <strong>Semaphore</strong></h5><p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p>
<ul>
<li>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠；</li>
<li>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，<strong>并将信号量内部的计数器加1</strong>，之前进入休眠的线程将被唤醒并再次试图获得信号量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">//因为先执行线程A，所以这里设s1的计数器为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(Semaphore currentThread, Semaphore nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentThread.acquire();       <span class="comment">//阻塞当前线程，即信号量的计数器减1为0</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.release();          <span class="comment">//唤醒下一个线程，即信号量的计数器加1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SemaphoreABC printer = <span class="keyword">new</span> SemaphoreABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s1, s2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s2, s3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s3, s1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-1-线程基本"><a href="#1-4-1-线程基本" class="headerlink" title="1.4.1 线程基本"></a>1.4.1 线程基本</h3><h4 id="1-什么是线程和进程？-如何保证线程安全？"><a href="#1-什么是线程和进程？-如何保证线程安全？" class="headerlink" title="1. 什么是线程和进程？ 如何保证线程安全？"></a>1. 什么是线程和进程？ <strong>如何保证线程安全？</strong></h4><h5 id="1-1-什么是线程和进程？"><a href="#1-1-什么是线程和进程？" class="headerlink" title="1.1 什么是线程和进程？"></a>1.1 什么是线程和进程？</h5><ul>
<li><p><strong>什么是进程？</strong></p>
<p><strong>进程是程序的⼀次执行过程，是系统运行程序的基本单位</strong>，因此进程是<strong>动态</strong>的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。</p>
<blockquote>
<p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。</p>
<p><img src="https://i.loli.net/2021/05/16/cxYPKI1LnR4V3Mt.png" alt="image-20210516101110229"></p>
</blockquote>
</li>
<li><p><strong>什么是线程？</strong></p>
<p><strong>线程与进程相似，但线程是⼀个⽐进程更小的执行单位</strong>。⼀个进程在其执行的过程中可以产⽣多个线程。</p>
<ul>
<li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li>
</ul>
<p>所以系统在产⽣⼀个线程，或是在各个线程之间作<u>切换⼯作</u>时，<strong>负担要⽐进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p>⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p>
</blockquote>
</li>
</ul>
<h5 id="1-2-如何保证线程安全？"><a href="#1-2-如何保证线程安全？" class="headerlink" title="1.2 如何保证线程安全？"></a>1.2 如何保证线程安全？</h5><ol>
<li><strong>原子性</strong>，简单说就是<u>相关操作不会中途被其他线程干扰，一般通过同步机制实现</u>；</li>
<li><strong>可见性</strong>，<u>是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓</u>，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的；</li>
<li><strong>有序性</strong>，<u>是保证线程内串行语义，避免指令重排</u>等。</li>
</ol>
<h5 id="1-3-为什么程序计数器、虚拟机栈和本地方法栈是线程私有的"><a href="#1-3-为什么程序计数器、虚拟机栈和本地方法栈是线程私有的" class="headerlink" title="1.3 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的?"></a>1.3 为什么<strong>程序计数器、</strong>虚拟机栈和本地方法栈是<u>线程</u>私有的?</h5><ul>
<li><p><strong>程序计数器为什么是私有</strong> </p>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。</p>
<p>所以，程序计数器<u>私有</u>主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
</li>
<li><p><strong>虚拟机栈和本地方法栈为什么私有</strong></p>
<ul>
<li><p><strong>虚拟机栈：</strong> <u>每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息</u>。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中<strong>⼊栈和出栈</strong>的过程。</p>
</li>
<li><p><strong>本地方法法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行</strong> <strong>Java</strong> 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <strong>Native</strong> <strong>方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p>
</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
</li>
</ul>
<h4 id="2-创建线程的方式（非线程池）？-哪种最好？"><a href="#2-创建线程的方式（非线程池）？-哪种最好？" class="headerlink" title="2. 创建线程的方式（非线程池）？ 哪种最好？"></a>2. <strong>创建线程的方式（非线程池）？ 哪种最好？</strong></h4><p>一般有三种方式来进行创建：</p>
<ol>
<li><p><strong>继承Thread类：</strong>（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法</p>
<blockquote>
<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程；</li>
<li>缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</li>
</ul>
</blockquote>
</li>
<li><p><strong>实现Runnable接口：</strong>（1）定义runnable接口的<strong>实现类</strong>，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程</p>
</li>
<li><p><strong>通过Callable和Future创建线程：</strong>（1）创建Callable接口的实现类，<strong>并实现call()方法</strong>（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
</li>
</ol>
<p>其中 <u>实现Runnalbe接口更好</u>  ，使用实现Runnable接口的方式创建的线程<strong>可以处理同一资源</strong>，从而实现资源的共享。</p>
<h4 id="3-如何停止一个正在运行的线程？"><a href="#3-如何停止一个正在运行的线程？" class="headerlink" title="3. 如何停止一个正在运行的线程？"></a>3. <strong>如何停止一个正在运行的线程？</strong></h4><ol>
<li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止；</p>
</li>
<li><p>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法；</p>
</li>
<li><p>使用interrupt方法中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">           sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;week up from blcok...&quot;</span>);</span><br><span class="line">            stop = <span class="keyword">true</span>; <span class="comment">// 在异常处理代码中修改共享变量的状态</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    System.out.println(getName() + <span class="string">&quot; is exiting...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadDemo3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>          InterruptedException </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">          MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">          System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">          m1.start();</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Interrupt thread...: &quot;</span> +           m1.getName());</span><br><span class="line">          m1.stop = <span class="keyword">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">          m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br><span class="line">          Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程休眠3秒以便观察线程m1的中断情况</span></span><br><span class="line">          System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-什么是Daemon线程？它有什么意义？"><a href="#4-什么是Daemon线程？它有什么意义？" class="headerlink" title="4. 什么是Daemon线程？它有什么意义？"></a>4. <strong>什么是Daemon线程？它有什么意义？</strong></h4><p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p>
<ul>
<li><strong>意义：</strong>JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</li>
</ul>
<h4 id="5-说说CyclicBarrier和CountDownLatch的区别？"><a href="#5-说说CyclicBarrier和CountDownLatch的区别？" class="headerlink" title="5. 说说CyclicBarrier和CountDownLatch的区别？"></a>5. <strong>说说CyclicBarrier和CountDownLatch的区别？</strong></h4><p>两个看上去有点像的类，都在<code>java.util.concurrent</code>下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>
<ol>
<li>CyclicBarrier的某个线程运行到某个点上之后，<strong>该线程即停止运行</strong>，<strong>直到所有的线程都到达了这个点</strong>，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行；</li>
<li>CyclicBarrier<strong>只能唤起一个任务</strong>，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，<strong>CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</strong></li>
</ol>
<h4 id="6-请你简要说明一下线程的基本状态以及状态之间的关系？"><a href="#6-请你简要说明一下线程的基本状态以及状态之间的关系？" class="headerlink" title="6. 请你简要说明一下线程的基本状态以及状态之间的关系？"></a>6. <strong>请你简要说明一下线程的基本状态以及状态之间的关系？</strong></h4><p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p>
<ol>
<li><strong>新建状态</strong>：<strong>new语</strong>句创建的线程对象处于新建状态，仅被<strong>分配了内存</strong> </li>
<li><strong>等待状态：</strong> 当线程在new之后，并且<u>在调用start方法前</u>，线程处于等待状态 ;</li>
<li><strong>就绪状态：</strong> 其他线程调用它的**start()**方法，该线程就进入就绪状态，<u>只差等待cpu的使用权 </u> ;</li>
<li><strong>运行状态：</strong> <u>线程占用CPU，执行程序代码</u>  ; </li>
<li><strong>阻塞状态：</strong> 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。<u>阻塞状态分为三种：</u> <ul>
<li><u>等待阻塞:</u> 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中；</li>
<li><u>同步阻塞:</u> 运行的线程在获取<strong>对象同步锁</strong>时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中；</li>
<li><u>其他阻塞:</u> 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。</li>
</ul>
</li>
<li><strong>死亡状态：</strong> 线程执行完<strong>run()方法中的代码</strong>，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期</li>
</ol>
<h4 id="7-notify-和notifyAll-有什么区别？"><a href="#7-notify-和notifyAll-有什么区别？" class="headerlink" title="7. notify()和notifyAll()有什么区别？"></a>7. <strong>notify()和notifyAll()有什么区别？</strong></h4><ul>
<li><strong>notify可能会导致死锁（why？）</strong>，而notifyAll则不会；</li>
<li>使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li>
</ul>
<h4 id="8-sleep-和wait-有什么区别？"><a href="#8-sleep-和wait-有什么区别？" class="headerlink" title="8. sleep()和wait() 有什么区别？"></a>8. <strong>sleep()和wait() 有什么区别？</strong></h4><ul>
<li><p><strong>继承的类：</strong>sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的；</p>
<blockquote>
<p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。</p>
</blockquote>
</li>
<li><p><strong>是否释放锁：</strong>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<strong>在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池；</p>
</li>
<li><p><strong>用处：</strong> <strong>Wait 通常被用于线程间交互/通信</strong>，sleep 通常被用于暂停执行；</p>
</li>
<li><p><strong>再次唤醒：</strong> wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。</p>
</li>
</ul>
<h5 id="8-1-Thread类中的yield方法有什么作用？"><a href="#8-1-Thread类中的yield方法有什么作用？" class="headerlink" title="8.1 Thread类中的yield方法有什么作用？"></a>8.1 <strong>Thread类中的yield方法有什么作用？</strong></h5><p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h5 id="8-2-java-中Wait、Sleep和Yield方法的区别？"><a href="#8-2-java-中Wait、Sleep和Yield方法的区别？" class="headerlink" title="8.2 java 中Wait、Sleep和Yield方法的区别？"></a>8.2 <strong>java 中Wait、Sleep和Yield方法的区别？</strong></h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p>
<h4 id="9-volatile-是什么-可以保证有序性吗"><a href="#9-volatile-是什么-可以保证有序性吗" class="headerlink" title="9. volatile 是什么?可以保证有序性吗?"></a>9. <strong>volatile 是什么?可以保证有序性吗?</strong></h4><ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存；</li>
<li>禁止进行指令重排序。</li>
</ol>
<p><strong>能保证有序性</strong>，因为禁止指令重排。</p>
<h4 id="10-（要深入了解wait方法，这里先跳过）为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#10-（要深入了解wait方法，这里先跳过）为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="10. （要深入了解wait方法，这里先跳过）为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>10. （要深入了解wait方法，这里先跳过）<strong>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</strong></h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/321674476">https://www.zhihu.com/question/321674476</a> </p>
<p>明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的</strong>，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。<u>如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了</u>。</p>
<ul>
<li>简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</li>
</ul>
<h4 id="11-为什么wait和notify方法要在同步块中调用？"><a href="#11-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="11. 为什么wait和notify方法要在同步块中调用？"></a>11. <strong>为什么wait和notify方法要在同步块中调用？</strong></h4><ul>
<li><u>wait()方法<strong>强制当前线程释放对象锁</strong></u>。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法；</li>
<li>在调用对象的notify()和notifyAll()方法之前，<u>调用线程必须<strong>已经得到该对象的锁</strong></u>。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</li>
</ul>
<h4 id="12-（没细看）Java中interrupted-和-isInterruptedd方法的区别？"><a href="#12-（没细看）Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="12. （没细看）Java中interrupted 和 isInterruptedd方法的区别？"></a>12. （没细看）<strong>Java中interrupted 和 isInterruptedd方法的区别？</strong></h4><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。</p>
<h3 id="1-4-2-线程池"><a href="#1-4-2-线程池" class="headerlink" title="1.4.2 线程池"></a>1.4.2 线程池</h3><h4 id="1-请你解释一下什么是线程池（thread-pool）？"><a href="#1-请你解释一下什么是线程池（thread-pool）？" class="headerlink" title="1. 请你解释一下什么是线程池（thread pool）？"></a>1. <strong>请你解释一下什么是线程池（thread pool）？</strong></h4><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，<u>使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</u>。 除此之外：</p>
<ul>
<li>提高性能，利用多线程压榨CPU算力；</li>
<li>提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。</li>
</ul>
<h5 id="1-1-请介绍一下使用线程池任务执行过程？"><a href="#1-1-请介绍一下使用线程池任务执行过程？" class="headerlink" title="1.1 请介绍一下使用线程池任务执行过程？"></a><strong>1.1 请介绍一下使用线程池任务执行过程？</strong></h5><p><strong>核心参数：</strong>其中<code>corePool</code>是核心线程池（保活线程），<code>maximumPool</code>是总线程池（保活线程+工作线程），<code>blockQueue </code>是等待任务队列，<code>rejectedExecutionHandler</code>是拒绝策略：</p>
<p><img src="https://i.loli.net/2021/04/19/Pn4wc5621hqIXpl.png" alt="image-20210419235537833" style="zoom: 33%;" /><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom: 67%;" /></p>
<p><strong>流程：corePoolSize→队列→maximumPool→拒绝策略</strong> </p>
<ol>
<li>未达到corePoolSize时，核心线程池会开辟新线程运行任务（<u>可以使用已有线程吗？</u>），<strong>任务结束后线程不销毁</strong>；</li>
<li>达到corePoolSize，而任务队列未满时，新任务提交到等待队列，<strong>线程空闲时间超过keepAliveTime时被销毁；</strong></li>
<li>任务队列也满了，但未超过最大线程数，新建工作线程执行任务；</li>
<li>超过最大线程数时，<strong>按拒绝策略处理</strong>，包括：<u>抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务</u>等。</li>
</ol>
<h5 id="1-2-线程池会回收核心线程吗？"><a href="#1-2-线程池会回收核心线程吗？" class="headerlink" title="1.2 线程池会回收核心线程吗？"></a>1.2 线程池会回收核心线程吗？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038836285">线程池是怎么回收空闲线程的</a></p>
</blockquote>
<p>会，可以通过allowCoreThreadTimeOut参数来进行设置。</p>
<ul>
<li><p>先回忆一下整体线程池流程</p>
<img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom:67%;" /></li>
<li><p><strong>excute方法</strong></p>
<p>我们的任务放到线程池后，是从调用execute执行开始的。</p>
<img src="https://i.loli.net/2021/05/26/hc4w6ZIbm57CpOQ.png" alt="image-20210526234652655" style="zoom: 67%;" />

<ul>
<li><p>核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。</p>
</li>
<li><p>Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法：</p>
<p><img src="https://i.loli.net/2021/05/26/39woAvIR4QjNfxd.png" alt="iShot2021-01-03 20.39.22.png"></p>
<p>也就是说：①处是一个while循环，<strong>getTask</strong>方法就是从线程池队列取任务，<strong>如果取不到任务</strong>就会执行</p>
<p>​                   ②<strong>一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker</strong></p>
</li>
</ul>
</li>
<li><p><strong>getTask方法</strong></p>
<p>可以看到，①判断是否回收线程的条件，<strong>timed</strong> ，有两种情况要回收线程：</p>
<ol>
<li><strong>wc&gt;corePoolSize</strong> ，当前线程数大于核心线程数</li>
<li><strong>allowCoreThreadTimeOut</strong>，核心线程超时，所以<strong>核心线程是会被回收</strong>的</li>
</ol>
<p>然后②处就是从任务队列取任务了，<strong>带了timeOut参数的poll方法超时</strong> ，未能从任务队列获取任务即返回null，从而实现最终的<strong>线程回收</strong>。</p>
<blockquote>
<p>不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/26/hxJerXAo16msf38.png" alt="image-20210526235850331"></p>
</li>
</ul>
<h4 id="2-请介绍一下什么是生产者消费者模式？"><a href="#2-请介绍一下什么是生产者消费者模式？" class="headerlink" title="2. 请介绍一下什么是生产者消费者模式？"></a>2. <strong>请介绍一下什么是生产者消费者模式？</strong></h4><p><img src="https://uploadfiles.nowcoder.com/images/20180925/308572_1537880635592_7142B8354CA8A352B2B805F997C71549" alt="img"></p>
<p>生产者消费者问题是线程模型中的经典问题：</p>
<ul>
<li>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</li>
</ul>
<h4 id="3-线程池的拒绝策略有哪些？"><a href="#3-线程池的拒绝策略有哪些？" class="headerlink" title="3. 线程池的拒绝策略有哪些？"></a>3. <strong>线程池的拒绝策略有哪些？</strong></h4><p>主要有4种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li>
<li><strong>CallerRunsPolicy</strong>：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：<strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常</li>
</ol>
<h4 id="4-如何创建一个线程池（四大方法）？相关参数（七大参数）是什么"><a href="#4-如何创建一个线程池（四大方法）？相关参数（七大参数）是什么" class="headerlink" title="4. 如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?"></a>4. <strong>如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</strong></h4><p>java通过Executors提供<strong>四大方法</strong>：</p>
<ol>
<li><strong>newCachedThreadPool：</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，<strong>可灵活回收空闲线程，若无可回收，则新建线程</strong>；</li>
<li><strong>newFixedThreadPool ：</strong>创建一个定长线程池，<u>可控制线程最大并发数</u>，**超出的线程会在<u>队列中等待</u>**；</li>
<li><strong>newScheduledThreadPool ：</strong>创建一个定长线程池，<u>支持定时及周期性任务执行</u>；</li>
<li><strong>newSingleThreadExecutor：</strong> 创建一个<u>单线程化的线程池</u>，它只会用<strong>唯一的工作线程</strong>来执行任务，保证<u>所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</u>。</li>
</ol>
<p><strong>七大参数设置：</strong></p>
<ol>
<li><p><strong>corePoolSize</strong>：当使用了<code>LinkedBlockingQueue = new LinkedBlockQueue</code>的时候，<strong>队列长度默认无限长</strong>，会导致线程数量永远等于<code>corePoolSize</code>，任务激增时任务响应时间也激增；</p>
</li>
<li><p><strong>maximumPoolSize</strong>：线程池中线程个数，增加线程的公式：$(任务数-queueCapacity) \times (原线程数 \div 原任务数)$；</p>
</li>
<li><p><strong>keepAliveTime</strong>：线程最大（空闲）存活时间；</p>
</li>
<li><p><strong>rejectedExecutionHandler</strong>：线程被拒绝的解决方案，可以自己重写；</p>
</li>
<li><p><strong>workQueue</strong> ： 阻塞队列；</p>
</li>
<li><p><strong>unit：</strong>keepAliveTime的单位 ；</p>
</li>
<li><p><strong>threadFactory：</strong>表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</p>
</li>
</ol>
<h4 id="5-线程池核心线程数corePoolSize怎么设置呢？"><a href="#5-线程池核心线程数corePoolSize怎么设置呢？" class="headerlink" title="5. 线程池核心线程数corePoolSize怎么设置呢？"></a>5. <strong>线程池核心线程数corePoolSize怎么设置呢？</strong></h4><p>分为CPU密集型和IO密集型来考虑：</p>
<ul>
<li><p><strong>CPU密集型。</strong>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <code>N（CPU 核心数）+1</code>。</p>
<blockquote>
<p><u>比 CPU 核心数多出来的一个线程</u> ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
</blockquote>
</li>
<li><p><strong>IO密集型。</strong>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： <code>核心线程数=CPU核心数量*2</code></p>
</li>
</ul>
<h4 id="6-（不熟悉）Java线程池中队列常用类型有哪些？"><a href="#6-（不熟悉）Java线程池中队列常用类型有哪些？" class="headerlink" title="6. （不熟悉）Java线程池中队列常用类型有哪些？"></a>6. <strong>（不熟悉）Java线程池中队列常用类型有哪些？</strong></h4><ul>
<li><code>ArrayBlockingQueue</code> ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序；</li>
<li><code>LinkedBlockingQueue</code> :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ；</li>
<li><code>SynchronousQueue</code> : 一个不存储元素的阻塞队列；</li>
<li><code>PriorityBlockingQueue</code>： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。</li>
</ul>
<h4 id="7-有三个线程T1-T2-T3-如何保证顺序执行？"><a href="#7-有三个线程T1-T2-T3-如何保证顺序执行？" class="headerlink" title="7. 有三个线程T1,T2,T3,如何保证顺序执行？"></a>7. <strong>有三个线程T1,T2,T3,如何保证顺序执行？</strong></h4><p>因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// t2线程内run方法最开始，引用t1.join，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// t3线程内run方法最开始，引用t2.join，等待t2线程执行完</span></span><br><span class="line">                        t2.join();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                          &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                         System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//这里三个线程的启动顺序可以任意，大家可以试下！</span></span><br><span class="line">         t3.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-3-多线程"><a href="#1-4-3-多线程" class="headerlink" title="1.4.3 多线程"></a>1.4.3 多线程</h3><h4 id="1-请简述一下实现多线程同步的方法？-为什么需要使用多线程？使用多线程会带来什么问题？"><a href="#1-请简述一下实现多线程同步的方法？-为什么需要使用多线程？使用多线程会带来什么问题？" class="headerlink" title="1. 请简述一下实现多线程同步的方法？ 为什么需要使用多线程？使用多线程会带来什么问题？"></a>1. <strong>请简述一下实现多线程同步的方法？</strong> 为什么需要使用多线程？使用多线程会带来什么问题？</h4><ul>
<li><p><strong>同步方法：</strong>可以使用synchronized、lock、volatile和ThreadLocal来实现同步。 </p>
</li>
<li><p><strong>为什么需要使用多线程？</strong></p>
<ul>
<li>减少<strong>上下文切换开销</strong>（共享进程的堆和方法区 ，注意，减少≠没有）</li>
<li>利用好多线程机制可以大大提<strong>高系统整体的并发能⼒</strong>以及性能</li>
<li><strong>多核时代</strong> ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU <strong>只会⼀个 CPU 核⼼</strong>被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。****</li>
</ul>
</li>
<li><p><strong>带来的问题？</strong></p>
<ul>
<li><u>内存泄漏、上下⽂切换、死锁</u>还有受限于硬件和软件的资源闲置问题。</li>
</ul>
</li>
</ul>
<h4 id="2-什么是线程安全？如何保证线程安全？"><a href="#2-什么是线程安全？如何保证线程安全？" class="headerlink" title="2. 什么是线程安全？如何保证线程安全？"></a>2. <strong>什么是线程安全？</strong>如何保证线程安全？</h4><blockquote>
<p>好文：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94762520">一文搞懂CAS</a></p>
</blockquote>
<ul>
<li><p><strong>什么是线程安全？</strong></p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。<u>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的</u>，就是线程安全的。</p>
</li>
<li><p><strong>如何保证线程安全？</strong> </p>
<ol>
<li><strong>使用 synchronized 关键字</strong> 。开销比较大</li>
<li><strong>使用Lock 锁</strong> 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。</li>
<li><strong>使用 Atomic 原子类</strong> 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。</li>
<li><strong>使用Volatile？不可行！</strong> 因为无法保证原子性。</li>
</ol>
</li>
</ul>
<h4 id="3-线程安全需要保证几个基本特征？"><a href="#3-线程安全需要保证几个基本特征？" class="headerlink" title="3. 线程安全需要保证几个基本特征？"></a>3. <strong>线程安全需要保证几个基本特征？</strong></h4><ul>
<li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li><strong>可见性，</strong>是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将<br>线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h4 id="4-【待补充】如何在线程安全的情况下实现一个计数器？"><a href="#4-【待补充】如何在线程安全的情况下实现一个计数器？" class="headerlink" title="4. 【待补充】如何在线程安全的情况下实现一个计数器？"></a>4. 【待补充】<strong>如何在线程安全的情况下实现一个计数器？</strong></h4><p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p>
<h4 id="5-多线程中的i-线程安全吗？请简述一下原因？"><a href="#5-多线程中的i-线程安全吗？请简述一下原因？" class="headerlink" title="5. 多线程中的i++线程安全吗？请简述一下原因？"></a>5. <strong>多线程中的i++线程安全吗？请简述一下原因？</strong></h4><p>不安全，因为<strong>i++不是原子性操作</strong>。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p>
<h4 id="6-介绍一下ThreadLocal原理？"><a href="#6-介绍一下ThreadLocal原理？" class="headerlink" title="6. 介绍一下ThreadLocal原理？"></a>6. <strong>介绍一下ThreadLocal原理？</strong></h4><blockquote>
<p>一篇讲的不错的文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wupeixuan/p/12638203.html">https://www.cnblogs.com/wupeixuan/p/12638203.html</a></p>
</blockquote>
<p>当多线程访问共享可变数据时，涉及到线程间同步的问题，<u><strong>并不是</strong>所有时候，都要用到共享数据</u>，所以就需要线程封闭出场了。<strong>数据都被封闭在各自的线程之中</strong>，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p>
<p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，<u>每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量</u>，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p>
<ul>
<li><p><strong>使用示例</strong></p>
<p>在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal变量，每个线程都有一个副本，互不干扰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 主线程设置值</span></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;wupx&quot;</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之前，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                <span class="comment">// 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">&quot;huxy&quot;</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;重新设置之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值为：&quot;</span> + v);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 等待所有线程执行结束</span></span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出结果 */</span></span><br><span class="line"><span class="comment">// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0线程执行之前，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">Thread-0线程取到的值：null</span></span><br><span class="line"><span class="comment">重新设置之后Thread-0线程取到的值为：huxy</span></span><br><span class="line"><span class="comment">Thread-0线程执行结束</span></span><br><span class="line"><span class="comment">Thread-0线程执行之后，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>ThreadLocal原理</strong></p>
<p>ThreadLocal有一个<strong>静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组</strong>，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p>
<p><img src="https://i.loli.net/2021/05/16/MXKyQxYDjWdOku2.png" alt="image-20210516142348550"></p>
<ul>
<li><p><strong>ThreadLocalMap</strong></p>
<blockquote>
<p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个<strong>线程有多个 ThreadLocal 对象时</strong>时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p>
</blockquote>
<p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，<strong>Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值</strong>。ThreadLocalMap 解决 hash 冲突的方式采用的是<strong>线性探测法</strong>，如果发生冲突会继续寻找下一个空的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 键值对实体的存储结构</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// 当前线程关联的 value，这个 value 并没有用弱引用追踪</span></span><br><span class="line">		Object value;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 构造键值对</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> v v 作 value</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">			<span class="keyword">super</span>(k);</span><br><span class="line">			value = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始容量，必须为 2 的幂</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂</span></span><br><span class="line">	<span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ThreadLocalMap 元素数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扩容的阈值，默认是数组大小的三分之二</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Set方法</strong></p>
<blockquote>
<p>调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 <code>threadLocal</code> 对象作为 key，想要保存的对象作为 value，存入 map。</p>
</blockquote>
<p>set 方法的流程主要是：</p>
<ul>
<li>先获取到当前线程的引用</li>
<li>利用这个引用来获返回当前线程到 ThreadLocalMap</li>
<li>如果 map 为空，则去创建一个 ThreadLocalMap</li>
<li>如果 map 不为空，就利用 ThreadLocalMap 的 <code>set (this当前对象，value)</code> 添加键值对</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前 ThreadLocal 对象关联 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要存储在此线程的线程副本的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回当前ThreadLocal所在的线程</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 返回当前线程持有的map</span></span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对</span></span><br><span class="line">        <span class="comment">// 此时this是ThreadLocal对象，这是在ThreadLocal类中</span></span><br><span class="line">		map.set(<span class="keyword">this</span>, value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt;</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程 thread 持有的 ThreadLocalMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Get方法</strong></p>
<blockquote>
<p>调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。</p>
</blockquote>
<p>get 方法的主要流程为：</p>
<ul>
<li>先获取到当前线程的引用</li>
<li>获取当前线程内部的 ThreadLocalMap对象</li>
<li>如果 map 存在，则获取当前 ThreadLocal 对应的 value 值</li>
<li>如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前 ThreadLocal 对象关联的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回当前 ThreadLocal 所在的线程</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 从 map 中拿到 entry</span></span><br><span class="line">		ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">			T result = (T) e.value;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value</span></span><br><span class="line">	<span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> <strong>resize 方法</strong></p>
</li>
</ul>
<p>  当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-为什么ThreadLocal造成内存泄漏？"><a href="#7-为什么ThreadLocal造成内存泄漏？" class="headerlink" title="7. 为什么ThreadLocal造成内存泄漏？"></a>7. <strong>为什么<code>ThreadLocal</code>造成内存泄漏？</strong></h4><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p>
<blockquote>
<p>源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构：</p>
<p>底层是数组<code>Entry[] table</code>，数组的元素是 Entry类：<strong>Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值</strong>。</p>
</blockquote>
<ul>
<li><strong>原因：</strong><code>ThreadLocalMap</code>的key为<strong>弱引用</strong>（有用但非必需，下一次GC会被回收），value为<strong>强引用</strong>（GC过程不会被回收），<u>有可能造成key被GC，value没被G</u>C，<code>ThreadLocalMap</code>中出现<code>null</code>为key的<code>Entry</code>，产生<u>内存泄漏</u>（<strong>软引用</strong>：有用但非必需，内存溢出之前被回收）；</li>
<li><strong>解决：</strong> 调用<code>set()</code>、<code>get()</code>和<code>remove()</code>方法时，会自动清理掉key为<code>null</code>的记录，但使用<code>ThreadLocal</code>方法后**手动<code>remove()</code>**。</li>
</ul>
<h4 id="8-什么是多线程中的上下文切换？"><a href="#8-什么是多线程中的上下文切换？" class="headerlink" title="8. 什么是多线程中的上下文切换？"></a>8. <strong>什么是多线程中的上下文切换？</strong></h4><p><u>一个线程<strong>让出处理器使用权</strong>，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。</u>在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。</p>
<h4 id="9-请问什么是死锁-deadlock"><a href="#9-请问什么是死锁-deadlock" class="headerlink" title="9. 请问什么是死锁(deadlock)?"></a>9. <strong>请问什么是死锁(deadlock)?</strong></h4><p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p>
<h4 id="10-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"><a href="#10-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？" class="headerlink" title="10. JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？"></a>10. <strong>JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</strong></h4><p><u>最简单方法：<strong>指定获取锁的顺序，并强制线程按照指定的顺序获取锁</strong>。</u></p>
<p>因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件：</p>
<ul>
<li><strong>互斥</strong> ： 不可能破坏。</li>
<li><strong>破坏请求和保持条件：</strong>进程必须 <u>等所有要请求的资源都空闲时才能申请资源</u>， 这种方法会使<strong>资源浪费严重</strong> 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。</li>
<li><strong>破坏不可抢占条件：</strong> 方法代价大，实现复杂。</li>
<li><strong>破坏循坏等待条件</strong> ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对<u>资源的利用率比前两种都高</u>，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</li>
</ul>
<h2 id="1-5-锁-重点记忆部分"><a href="#1-5-锁-重点记忆部分" class="headerlink" title="1.5 锁(重点记忆部分)"></a>1.5 锁(重点记忆部分)</h2><h4 id="0-【新增，但不够完善】-java常用的并发工具类？"><a href="#0-【新增，但不够完善】-java常用的并发工具类？" class="headerlink" title="0.【新增，但不够完善】 java常用的并发工具类？"></a>0.【新增，但不够完善】 java常用的并发工具类？</h4><blockquote>
<p>这篇不错：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163654320">《今天面试了吗》- 并发编程之AQS同步工具类</a></p>
</blockquote>
<p>JUC就是java.util.concurrent包，这个包俗称JUC，里面都是<strong>解决并发问题</strong>。 </p>
<p>常用四大并发工具包（以下都是基于<strong>AQS</strong>实现的）：</p>
<ol>
<li><p><strong>CountDownLatch</strong>： CyclicBarrier描述的是“允许一组线程相互等待，直到<strong>到达某个公共屏障点</strong>，才会进行后续任务”。</p>
<p>而<strong>CountDownLatch</strong>所描述的是“在<strong>完成一组正在其他线程中</strong>执行的操作之前，它允 一个或多个线程一直等待”。</p>
<p>在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：CyclicBarrier是一个同步辅助类。它允许<strong>一组线程互相等待</strong>，<strong>直到到达某个公共屏障点</strong>。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。</p>
<blockquote>
<p>使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。</p>
</blockquote>
</li>
<li><p><strong>Semaphore</strong>：信号量Semaphore是一个控制访问<strong>多个共享资源的计数器</strong>，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。</p>
</li>
<li><p><strong>ExChanger</strong> ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点<strong>类似CyclicBarrier</strong>，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会<strong>以成对的方式交换各自携带的信息</strong>，因此Exchanger非常适合<strong>两个线程</strong>之间的<strong>数据交换</strong>。 </p>
</li>
</ol>
<h4 id="15-1-synchronized-相关"><a href="#15-1-synchronized-相关" class="headerlink" title="15.1 synchronized 相关"></a>15.1 synchronized 相关</h4><h5 id="1-1-重点-说一说自己对于-synchronized-关键字的了解-synchronized-底层原理"><a href="#1-1-重点-说一说自己对于-synchronized-关键字的了解-synchronized-底层原理" class="headerlink" title="1.1 [重点]说一说自己对于 synchronized 关键字的了解? synchronized 底层原理 ?"></a>1.1 [重点]<strong>说一说自己对于 synchronized 关键字的了解? synchronized 底层原理</strong> ?</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理(阿里面试题)</a></p>
</blockquote>
<ul>
<li><p><strong>基本了解</strong></p>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<ul>
<li>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是<strong>依赖于底层的操作系统的<u>Mutex Lock</u></strong> 来实现的；</li>
<li>Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，<strong>而操作系统实现线程之间的切换</strong>时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</li>
</ul>
</li>
<li><p><strong>moniter介绍</strong> </p>
<blockquote>
<p><strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</strong></p>
</blockquote>
<p>在HotSpot虚拟机中，Monitor是基于C++的<strong>ObjectMonitor类</strong>实现的，其主要成员包括：</p>
<ul>
<li>_owner：指向持有ObjectMonitor对象的线程</li>
<li>_WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程</li>
<li>EntryList：存放处于等待锁block状态的线程队列</li>
<li>_count：约为_WaitSet 和 _EntryList 的节点数之和</li>
<li>_cxq: 多个线程争抢锁，会先存入这个单向链表</li>
<li>_recursions: 记录重入次数</li>
</ul>
</li>
<li><p><strong>底层原理</strong></p>
<p>synchronized 关键字底层原理属于 JVM 层面。</p>
<p><strong>① synchronized</strong> <strong>同步语句块的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：</p>
<ul>
<li><p>⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 <code>javap -c -s-v -l SynchronizedDemo.class</code></p>
</li>
<li><p><img src="https://i.loli.net/2021/05/16/DTSB86Z2GcRy9XC.png" alt="image-20210516130259067"></p>
</li>
</ul>
<p><strong>synchronized</strong> <strong>同步语句块的实现使用的是</strong> <strong>monitorenter</strong> <strong>和</strong> <strong>monitorexit</strong> <strong>指令，其中</strong> <strong>monitorenter指令指向同步代码块的开始位置，monitorexit</strong> <strong>指令则指明同步代码块的结束位置。</strong> </p>
<ol>
<li><p>当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ;</p>
<blockquote>
<p>monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p>
</blockquote>
</li>
<li><p>相应的在执行monitorexit 指令后，<strong>将锁计数器设为0</strong>，表明锁被释放；</p>
</li>
<li><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>
</li>
</ol>
</li>
</ul>
<p><strong>② synchronized</strong> <strong>修饰方法的的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/16/oElScfCHI978Qtw.png" alt="image-20210516131938787"></p>
<ul>
<li><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。</p>
<blockquote>
<p> 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></p>
</blockquote>
<p>两种同步方式<strong>本质上没有区别</strong>，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的<strong>互斥原语mutex</strong>来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
</li>
</ul>
<h5 id="1-2-请你谈谈关于Synchronized和ReentrantLock？"><a href="#1-2-请你谈谈关于Synchronized和ReentrantLock？" class="headerlink" title="1.2 请你谈谈关于Synchronized和ReentrantLock？"></a>1.2 <strong>请你谈谈关于Synchronized和ReentrantLock？</strong></h5><ul>
<li><p><strong>相似点</strong></p>
<ul>
<li><p><strong>都是阻塞式同步：</strong>一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待；</p>
<blockquote>
<p>线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p>
</blockquote>
</li>
<li><p><strong>都是可重入锁：</strong> 是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
</li>
</ul>
</li>
<li><p><strong>不同点</strong></p>
<ul>
<li><p><strong>实现原理：</strong> Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要<u>lock()和unlock()方法配合try/finally语句块来完成</u>；</p>
<blockquote>
<p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p>
</blockquote>
</li>
<li><p><strong>是否避免死锁</strong>： synchronized<strong>在发生异常时</strong>，会自动释放线程占有的锁，<strong>因此不会导致死锁现象</strong>发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p>
</li>
<li><p><u><strong>线程等待可中断：</strong></u> Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</p>
</li>
<li><p><strong>公平锁：</strong> synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁；</p>
<ul>
<li><strong>选择性通知：</strong> synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。<br>Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，<u>而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</u>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1-3-synchronized锁住的是什么，在项目中遇到了吗？"><a href="#1-3-synchronized锁住的是什么，在项目中遇到了吗？" class="headerlink" title="1.3 synchronized锁住的是什么，在项目中遇到了吗？"></a>1.3 <strong>synchronized锁住的是什么，在项目中遇到了吗？</strong></h5><p>synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。</p>
<p>（<strong>重点</strong>）Java中的每一个对象都可以作为锁，具体表示有三种形式：</p>
<p><img src="https://i.loli.net/2021/05/04/LzjeqdIi5rbM819.png" alt="image-20210504232344320"></p>
<blockquote>
<p>面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton       <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">       <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>这段代码其实是分为三步执行：</p>
<ol>
<li><p>为 uniqueInstance 分配内存空间</p>
</li>
<li><p>初始化 uniqueInstance</p>
</li>
<li><p>将 uniqueInstance 指向分配的内存地址</p>
</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，<u>但此时 uniqueInstance 还未被初始化</u>。</p>
<h5 id="1-4-synchronized锁的优化机制了解吗？"><a href="#1-4-synchronized锁的优化机制了解吗？" class="headerlink" title="1.4 synchronized锁的优化机制了解吗？"></a>1.4 <strong>synchronized锁的优化机制了解吗？</strong></h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903726545633287">死磕Synchronized底层实现</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队</a></p>
</blockquote>
<p>synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括：</p>
<ul>
<li>自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁；</li>
<li>锁的状态从低到高依次为：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li>
</ul>
<p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p>
<p>常见的锁：</p>
<ul>
<li><p><strong>无锁：</strong> 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，<strong>但同时只有一个线程能修改成功</strong>。</p>
<blockquote>
<p>锁到底存在哪里呢？答案就是对象头中。</p>
<p>对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。</p>
</blockquote>
<ol start="0">
<li><p>初始mark word 将是可偏向状态，此时的 <u>是否偏向锁</u> 为 0，表示当前没有任何一个线程持有该锁。</p>
<p><img src="https://i.loli.net/2021/05/21/bNepQwU6scYXCv5.png" alt="image-20210521210754337"></p>
</li>
</ol>
</li>
<li><p><strong>偏向锁：</strong>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<blockquote>
<p> JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在<strong>第一次</strong>获得锁时，会有一个 CAS 操作（见下）；<strong>之后</strong>该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。</p>
</blockquote>
<ol>
<li><p><strong>CASE 1 :</strong> 线程<strong>第一次</strong>获得锁，如果<strong>未偏向</strong>，通过 <strong>CAS</strong> 指令：</p>
<p><img src="https://i.loli.net/2021/05/21/fwEX4OAMFnyWrbJ.png" alt="image-20210521210949942"></p>
<ul>
<li><strong>插入线程ID :</strong> 向mark word插入线程ID</li>
<li><strong>偏向锁标识：</strong>将 mark word 中的偏向锁标识从<code>0→1</code></li>
<li><del><strong>锁标志位：</strong>不修改！因为不变！</del></li>
</ul>
<p>如果操作成功：，则说明获得了偏向锁，以后当前<u>线程等于owner</u>就可以<strong>零成本</strong>的直接获得锁；</p>
<p>如果操作失败，说明有其它线程获取了锁：</p>
<ul>
<li><strong>如果偏向线程还存在：</strong>直接进行升级为轻量级锁；</li>
<li><strong>如果偏向线程不存在：</strong> <strong>先修改锁标识为01→00</strong> ，再升级为轻量级锁。</li>
</ul>
</li>
<li><p><strong>CASE 2 :</strong>  这是<strong>一次可重入</strong>，偏向线程是自己。</p>
<p>在<u>当前线程栈</u>中找到一个可用的 <strong>Lock Record</strong> ：<strong>并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null</strong></p>
<img src="https://i.loli.net/2021/05/18/LXj2NZi7fVOzpox.png" alt="img" style="zoom:50%;" /></li>
</ol>
</li>
<li><p><strong>轻量级锁</strong>：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看<u>偏向的线程是否还存活</u>。</p>
<p><img src="https://i.loli.net/2021/05/18/anN1S6AD7MI9gK8.jpg" alt="img"></p>
<ol>
<li>如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），<strong>重新偏向新的线程</strong>；</li>
<li>如果存活且还在<strong>同步块</strong>中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中；</li>
</ol>
<p>轻量级锁的处理流程 ：</p>
<ol start="3">
<li>发现已经有偏向的线程了，则会**<u>先 撤 销</u>偏向锁，然后升级为轻量锁** 。通过<strong>CAS命令更新</strong>：</li>
</ol>
<p><img src="https://i.loli.net/2021/06/02/BMyh36f2OPCGkKe.png" alt="image-20210602161303534"></p>
<ul>
<li><strong>修改此前 <u>当前线程栈帧Lock Record</u>：</strong> （1）Displaced Mark Word 复制 mark word （此时<strong>无锁</strong>状态）中的现有内容 </li>
<li><strong>修改mark word ：</strong><u>mark word 指向 <strong>当前线程栈帧Lock Record的</strong> <strong>Displaced Mark Word</strong>的地址</u>，见上图；</li>
<li><strong>修改锁标志位</strong>： <code>01 → 00</code>   <img src="https://i.loli.net/2021/05/21/QNDEreAK6Ulohvg.png" alt="image-20210521214141329"></li>
</ul>
<ol start="4">
<li><p>上述CAS更新成功，则<strong>当前线程获得了对象的锁</strong>  ；</p>
<p>如果不成功：</p>
<ul>
<li><p>检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次<strong>可重入</strong> </p>
<blockquote>
<p>设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用。然后结束。</p>
</blockquote>
</li>
<li><p>如果不是则是进行<strong>自旋等待</strong> </p>
</li>
</ul>
</li>
<li><p>当<strong>（1）自旋超过一定的次数</strong>（默认10），或者<strong>（2）一个线程在持有锁，一个在自旋，又有第三个来访时</strong>，轻量级锁升级为重量级锁。</p>
</li>
</ol>
</li>
<li><p><strong>重量级锁：</strong>内置锁在Java中被抽象为<strong>监视器锁（monitor）</strong>。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种<strong>同步方式的成本非常高</strong>，<u>包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</u>。</p>
<blockquote>
<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。<strong>每一个Java对象就有一把看不见的锁Monitor</strong>，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个<strong>Owner</strong>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
</blockquote>
<p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。<u>线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。</u> </p>
<blockquote>
<p>即将 monitor锁的 <strong>Owner字段修改为当前线程ID</strong> 。</p>
</blockquote>
<p>如果获取成功，此时线程获得了锁，<strong>CAS修改</strong> ： </p>
<ol start="2">
<li><p> <strong>修改mark word</strong> ：然后将对象头mark word 改为<strong>指向该 monitor 的指针</strong>。</p>
</li>
<li><p><strong>锁标志位</strong>：<code>00 → 10</code></p>
<p><img src="https://i.loli.net/2021/05/21/NLFv3fKIh14RlzY.png" alt="image-20210521214213205"></p>
</li>
</ol>
</li>
</ul>
<h5 id="1-5-为什么说Synchronized是非公平锁，这样的优缺点是什么？"><a href="#1-5-为什么说Synchronized是非公平锁，这样的优缺点是什么？" class="headerlink" title="1.5 为什么说Synchronized是非公平锁，这样的优缺点是什么？"></a>1.5 <strong>为什么说Synchronized是非公平锁，这样的优缺点是什么？</strong></h5><p>并非是按照申请锁的时间前后给等待线程分配锁的，<strong>每当锁被释放后，任何一个线程都有机会竞争到锁</strong>。</p>
<ul>
<li><strong>优点：</strong>这样做的目的是为了提高执行性能；</li>
<li><strong>缺点：</strong>是可能产生线程饥饿现象。</li>
</ul>
<h5 id="1-6-为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？"><a href="#1-6-为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？" class="headerlink" title="1.6  为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？"></a>1.6  <strong>为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？</strong></h5><blockquote>
<p>没看完，了解了下核心问题：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jojop/p/14022029.html">https://www.cnblogs.com/jojop/p/14022029.html</a></p>
</blockquote>
<ul>
<li><p><strong>synchronized悲观锁</strong> </p>
<p>Synchronized显然是一个悲观锁，因为它的并发策略是悲观的：</p>
<ul>
<li><strong>不管是否会产生竞争，任何的数据都必须加锁</strong>。</li>
</ul>
</li>
<li><p><strong>synchronized原理</strong> </p>
<p>Synchronized是通过<strong>获取对象内部的一个叫做监视器锁（monitor）</strong>来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。</p>
<blockquote>
<p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p>
</blockquote>
<ol>
<li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p>
</li>
<li><p>如果线程已经占有该monitor，<u>只是重新进入</u>，则进入monitor的进入数加1；</p>
</li>
<li><p>如果<u>其他线程已经占用了monitor，则该线程进入阻塞状态</u>，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ol>
</li>
<li><p><strong>乐观锁实现原理：CAS</strong> </p>
<blockquote>
<p>  参考好文：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94762520">一文彻底搞懂CAS实现原理</a></p>
</blockquote>
</li>
</ul>
<h5 id="1-7-（CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？"><a href="#1-7-（CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？" class="headerlink" title="1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？"></a>1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</h5><p>乐观锁的核心算法是CAS（Compared And Swap，比较并交换）：</p>
<ul>
<li><p><strong>关键逻辑：</strong> CAS，有几个重要的参数：</p>
<p>（1）<strong>this</strong>，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。</p>
<p>（2）<strong>valueOffset</strong>，value 变量的内存偏移地址。</p>
<p>（3）<strong>expect</strong>，期望更新的值。</p>
<p>（4）<strong>update</strong>，要更新的最新值。</p>
<p>如果原子变量中的 <strong>value 值等于 expect</strong>，则使用 update 值更新该值并返回 true，否则返回 false。</p>
</li>
<li><p><strong>CAS特性：</strong> CAS具有原子性，它的原子性由CPU硬件指令实现保证。</p>
<ul>
<li>【<strong>缺点1</strong>】<strong>ABA问题：</strong> 如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。<ul>
<li><strong>解决ABA：</strong> 在变量前面加上版本号，每次变量更新的时候变量的**版本号都<code>+1</code>**，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code></li>
</ul>
</li>
<li>【<strong>缺点2】只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li>
<li>【<strong>缺点3</strong>】<strong>循环时间长开销大：</strong>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
</li>
<li><p><strong>CAS源码分析</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014858404?utm_source=sf-similar-article">Java CAS 原理分析</a></p>
</blockquote>
<blockquote>
<p>CAS 全称是 compare and swap，是一种用于在<strong>多线程环境下实现同步</strong>功能的机制。</p>
</blockquote>
<p>CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。</p>
<p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。</p>
<ul>
<li><p><strong>背景介绍</strong></p>
<p>在多核心时代下，<strong>多个核心通过同一条总线和内存以及其他硬件进行通信</strong>。</p>
<p><img src="https://segmentfault.com/img/remote/1460000014858409?w=1598&h=710" alt="img"></p>
<p><strong>CPU 的多个核心同时对同一片内存进行操作</strong>，会导致错误。例如，递增指令<code>inc dword ptr [...]</code>，等价于<code>DEST = DEST + 1</code>。该指令包含三个操作<code>读-&gt;改-&gt;写</code>，涉及两次访存。</p>
<ol>
<li>核心1,2从内存读取数据<code>1</code>，并写到各自寄存器中</li>
<li>核心1将寄存器中数据<code>1→2</code> </li>
<li>核心2将寄存器中数据<code>1→2</code></li>
<li>然后都写回主存，此时为<code>2</code> </li>
</ol>
<p>可以看到，由于核心2在核心1<strong>写入主存操作完成前进行读取</strong>，导致并不是我们期望的<code>3</code> 。</p>
<p>通过在递增<code>inc</code> 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式：</p>
<ol>
<li><strong>总线锁</strong>。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作；</li>
<li><strong>缓存锁</strong>。若<strong>某处</strong>内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是<strong>锁定缓存对应的内存区域</strong>。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（<strong>不是乐观机制都可以操作吗？不能写入内存？</strong>）</li>
</ol>
</li>
<li><p><strong>源码分析</strong></p>
<blockquote>
<p>我们分析，<code>java.util.concurrent.atomic</code> 包下的原子类 <code>AtomicInteger</code> 中的 <code>compareAndSet</code> 方法 。</p>
</blockquote>
<ol>
<li><p>AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中；</p>
</li>
<li><p>compareAndSwapInt是一个native方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算变量 value 在类对象中的偏移</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compareAndSwapInt 是 native 类型的方法，继续往下看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，</span></span><br><span class="line"><span class="comment"> * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset</span></span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载</span></span><br><span class="line"><span class="comment">   * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic_windows_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line"><span class="meta">                       __asm je L0      \</span></span><br><span class="line"><span class="meta">                       __asm _emit 0xF0 \</span></span><br><span class="line"><span class="meta">                       __asm L0:</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是多核 CPU</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">// 将参数值放入寄存器中</span></span><br><span class="line">    mov edx, dest  <span class="comment">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中</span></span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, <span class="function">compare_value</span></span><br><span class="line"><span class="function">    <span class="title">LOCK_IF_MP</span><span class="params">(mp)</span>  <span class="comment">// 核心比较写入操作</span></span></span><br><span class="line"><span class="function">    cmpxchg dword ptr [edx], ecx</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中LOCK_IF_MP实际内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// LOCK_IF_MP</span></span><br><span class="line">    cmp mp, <span class="number">0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，</span></span><br><span class="line"><span class="comment">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    je L0</span><br><span class="line">     <span class="comment">/* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/</span></span><br><span class="line">    _emit <span class="number">0xF0</span></span><br><span class="line">L0:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span></span><br><span class="line"><span class="comment">     *   cmpxchg: 即“比较并交换”指令</span></span><br><span class="line"><span class="comment">     *   dword: 全称是 double word，在 x86/x64 体系中，一个</span></span><br><span class="line"><span class="comment">     *          word = 2 byte，dword = 4 byte = 32 bit</span></span><br><span class="line"><span class="comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元</span></span><br><span class="line"><span class="comment">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。</span></span><br><span class="line"><span class="comment">     *          那么 [edx] 表示内存地址为 dest 的内存单元</span></span><br><span class="line"><span class="comment">     *        </span></span><br><span class="line"><span class="comment">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值</span></span><br><span class="line"><span class="comment">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>实际举例说明</strong></p>
<p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p>
<blockquote>
<p>下面以 getAndIncrement实现来说明。</p>
</blockquote>
<ol>
<li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1</p>
<blockquote>
<p>:warning: <strong>为什么不传value的值，而是偏移量？</strong> 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。 </p>
</blockquote>
</li>
<li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p>
<ul>
<li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li>
</ul>
</li>
<li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p>
<p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p>
<p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p>
<p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ； </p>
<p>（4）否则写入失败，通过不断自旋（循环）期望得到执行</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="1-8-请说明一下synchronized的可重入怎么实现？"><a href="#1-8-请说明一下synchronized的可重入怎么实现？" class="headerlink" title="1.8 请说明一下synchronized的可重入怎么实现？"></a>1.8 <strong>请说明一下synchronized的<u>可重入</u>怎么实现？</strong></h5><p>每个锁关联一个线程持有者对象和一个计数器。</p>
<ol>
<li>当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。</li>
<li>当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。</li>
<li>而该持有锁的线程如果<strong>再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增</strong>。</li>
<li>当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</li>
</ol>
<h5 id="1-9-在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？"><a href="#1-9-在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？" class="headerlink" title="1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？"></a>1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</h5><p>第一次调用Hashcode：当<u>对象的hashCode()方法</u>（非用户自定义）第一次被调用时，JVM会生成对应的<strong>identity hash code</strong>值，并将该值<u>存储到Mark Word</u>中 。</p>
<blockquote>
<p>后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，<strong>而是直接从Mark Word中获取，保证唯一相同。</strong></p>
</blockquote>
<ul>
<li><strong>无锁状态</strong>：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ；</li>
<li><strong>偏向锁状态：</strong> 需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ；</li>
<li><strong>轻量锁状态：</strong> <u>线程栈帧</u>的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code <strong>共存</strong> ；</li>
<li><strong>重量级锁状态： ** <strong><u>ObjectMonitor</u>类里有字段HashCode</strong>可以记录</strong>非加锁状态<strong>下的mark word，所以重量级锁也可以和identity hash code</strong>共存** ；</li>
</ul>
<h5 id="1-10-Synchronized-确定不可中断吗？如果一个线程访问Synchronized-代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？"><a href="#1-10-Synchronized-确定不可中断吗？如果一个线程访问Synchronized-代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？" class="headerlink" title="1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？"></a>1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/deel_feel/article/details/105771902">https://blog.csdn.net/deel_feel/article/details/105771902</a></p>
</blockquote>
<p>正确说法时：<strong>只有获取到锁之后才能中断，等待锁时不可中断。</strong></p>
<h4 id="15-2-Reetrantlock-相关"><a href="#15-2-Reetrantlock-相关" class="headerlink" title="15.2 Reetrantlock 相关"></a>15.2 Reetrantlock 相关</h4><p>ReentrantLock意思为可重入锁 。</p>
<h5 id="2-1-非公平锁和公平锁在reetrantlock里的实现过程是怎样的？"><a href="#2-1-非公平锁和公平锁在reetrantlock里的实现过程是怎样的？" class="headerlink" title="2.1  非公平锁和公平锁在reetrantlock里的实现过程是怎样的？"></a>2.1  <strong>非公平锁和公平锁在reetrantlock里的实现过程是怎样的？</strong></h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术文章-java-lock</a></p>
</blockquote>
<ul>
<li><p>公平锁：那么锁的 <u>获取顺序</u> 就应该符合请求的 <u>绝对时间顺序</u>，FIFO</p>
</li>
<li><p>非公平锁：只要<strong>CAS</strong>设置同步状态成功state，则表示当前线程获取了锁</p>
<blockquote>
<p>但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。</p>
</blockquote>
</li>
</ul>
<p>【<strong>源码分析</strong>】</p>
<ul>
<li><p><strong>基本结构</strong></p>
<p>根据代码可知，ReentrantLock里面有一个内部类<strong>Sync</strong>，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。</p>
<ul>
<li>Sync有公平锁FairSync和非公平锁NonfairSync两个子类；</li>
<li>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</li>
</ul>
<p><img src="https://i.loli.net/2021/05/21/YDAreyBEImxQfj2.png" alt="img"></p>
</li>
<li><p><strong>公平和非公平锁区分</strong></p>
<p><img src="https://i.loli.net/2021/05/21/zsPnT7qrXN5ovKZ.png" alt="img"></p>
<p>公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在<strong>CAS获取同步状态时</strong>，多了一个限制条件：**hasQueuedPredecessors()**。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"></p>
<ul>
<li><strong>该方法主要做一件事情：</strong>主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</li>
</ul>
</li>
</ul>
<h5 id="2-2-ReentrantLock的实现原理？"><a href="#2-2-ReentrantLock的实现原理？" class="headerlink" title="2.2 ReentrantLock的实现原理？"></a>2.2 ReentrantLock的实现原理？</h5><p>ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。</p>
<p>ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。</p>
<h5 id="2-3-希望等待一段时间锁没有获取，可以自动放弃用哪种锁？"><a href="#2-3-希望等待一段时间锁没有获取，可以自动放弃用哪种锁？" class="headerlink" title="2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？"></a>2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</h5><p>Lock（ReentranLock）</p>
<p>但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。</p>
<h4 id="15-3-AQS-相关"><a href="#15-3-AQS-相关" class="headerlink" title="15.3 AQS 相关"></a>15.3 AQS 相关</h4><h5 id="3-1-什么是AQS请你简单介绍一下？"><a href="#3-1-什么是AQS请你简单介绍一下？" class="headerlink" title="3.1 什么是AQS请你简单介绍一下？"></a>3.1 什么是AQS请你简单介绍一下？</h5><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p>
<p><img src="https://i.loli.net/2021/05/16/QhJg8pnTv3zWj4w.png" alt="image-20210516144436982"></p>
<p><strong>AQS是⼀个用来构建锁和同步器的框架</strong>，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。</p>
<ul>
<li>例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。</li>
</ul>
<h5 id="3-2-请介绍一下AQS原理？"><a href="#3-2-请介绍一下AQS原理？" class="headerlink" title="3.2 请介绍一下AQS原理？"></a>3.2 请介绍一下AQS原理？</h5><blockquote>
<p>后续建议研读：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p>
</blockquote>
<p>先带着问题来进行看下面内容：</p>
<blockquote>
<p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是CLH变体的FIFO双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：可以详细看下2.3.1.3小节。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p>
<p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>
</blockquote>
<ul>
<li><p><strong>核心原理概览</strong></p>
<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，<u>这个机制AQS是⽤CLH队列锁实现的</u>，即将暂时获取不到锁的线程加⼊到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是⼀个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/16/XqshLCnMYKbB7Ip.png" alt="image-20210516145134124"></p>
<p>AQS使用⼀个int成员变量<code>state</code>来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。<strong>AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使⽤volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。</p>
<img src="https://i.loli.net/2021/05/28/g7GORpXKhuo8aS4.png" alt="image-20210526122910138" style="zoom:67%;" /></li>
<li><p><strong>AQS 对资源的共享方式</strong><br>AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。</p>
<p><img src="https://i.loli.net/2021/05/26/YdcSGMs5jgiFnmk.png" alt="img"></p>
<ul>
<li><strong>Exclusive（独占）</strong>：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share（共享）</strong>：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>
</ul>
</li>
<li><p><strong>AQS详细原理</strong></p>
<blockquote>
<p> 最终参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/90851418">从源码角度彻底理解ReentrantLock(重入锁)</a> </p>
</blockquote>
<blockquote>
<p>以下是基于ReentractLock语境下进行分析。</p>
</blockquote>
<ul>
<li><p><strong>加锁过程：非公平锁</strong> </p>
<blockquote>
<p>简单来说：<strong>新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁</strong></p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-28c16752466cd95dfe0504f0306d6352_720w.jpg" alt="img"></p>
<p>加锁流程从<code>lock.lock()</code>开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法：</p>
</li>
</ul>
<ol>
<li><strong>CAS尝试快速加锁</strong>，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源）</li>
<li>获取锁失败执行acquire方法</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 加锁流程真正意义上的入口</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以cas方式尝试将AQS中的state从0更新为1</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          acquire(<span class="number">1</span>);<span class="comment">//获取锁失败则执行该方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>acquire</code> 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>acquire流程1：tryAcquire()</strong></p>
<p>tryAcquire()在公平和非公平下获取的方式不一样，这里<strong>只说非公平</strong>实现。</p>
<ol>
<li>如果<strong>state==0（未被其它线程持有）</strong>，<strong>CAS</strong>尝试获取锁,</li>
</ol>
</li>
<li><p>如果当前线程==持有锁的线程，<strong>可重入</strong> ，<strong>state+1</strong></p>
</li>
<li><p>否则 reture false获取锁失败，加入等待队列</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程实例</span></span><br><span class="line">     <span class="keyword">int</span> c = getState();<span class="comment">//获取state变量的值,即当前锁被重入的次数</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">//state为0,说明当前锁未被任何线程持有</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//以cas方式获取锁</span></span><br><span class="line">             setExclusiveOwnerThread(current);  <span class="comment">//将当前线程标记为持有锁的线程</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获取锁成功,非重入</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//当前线程就是持有锁的线程,说明该锁被重入了</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//计算state变量要更新的值</span></span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);<span class="comment">//非同步方式更新state值</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//获取锁成功,重入</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//走到这里说明尝试获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p><strong>acquire流程2：addWaiter()</strong> </p>
<ol>
<li>首先通过new Node()创建一个空结点；</li>
<li><strong>如果队列不空，</strong>以<strong>CAS</strong>方式让新节点插入到队尾；</li>
<li>如果队列为空，执行<code>enq(node)</code> 逻辑</li>
</ol>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">         Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null</span></span><br><span class="line">         <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">         Node pred = tail;</span><br><span class="line">         <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">             node.prev = pred;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                 pred.next = node;</span><br><span class="line">                 <span class="keyword">return</span> node;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         enq(node);<span class="comment">//入队的逻辑这里都有</span></span><br><span class="line">         <span class="keyword">return</span> node;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             Node t = tail;<span class="comment">//t指向当前队列的最后一个节点,队列为空则为null</span></span><br><span class="line">             <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  //队列为空</span></span><br><span class="line">                 <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//构造新结点,CAS方式设置为队列首元素,当head==null时更新成功</span></span><br><span class="line">                     tail = head;<span class="comment">//尾指针指向首结点</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;  <span class="comment">//队列不为空</span></span><br><span class="line">                 node.prev = t;</span><br><span class="line">                 <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">//CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功</span></span><br><span class="line">                     t.next = node;    <span class="comment">//原尾结点的next指针指向当前结点</span></span><br><span class="line">                     <span class="keyword">return</span> t;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>acquire流程3：acquireQueued()</strong> </p>
<blockquote>
<p><strong>线程加入同步队列后，获取锁的流程是什么呢？</strong></p>
<p>简单来说，就是不断判断当前是否是老二，并尝试去获取锁。</p>
</blockquote>
 <img src="https://pic4.zhimg.com/v2-f83b087a039a8de3f9815d9018e2273f_b.jpg" alt="img" style="zoom:80%;" />

<ul>
<li><code>SIGNAL ：</code>意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环,正常情况下线程只有获得锁才能跳出循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获得当前线程所在结点的前驱结点</span></span><br><span class="line">            <span class="comment">//第一个if分句</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                setHead(node); <span class="comment">//将当前结点设置为队列头结点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//正常情况下死循环唯一的出口</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二个if分句</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">//判断是否要阻塞当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())      <span class="comment">//阻塞当前线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>解锁：非公平锁</strong></p>
<img src="https://i.loli.net/2021/05/26/sSQZlA2paTcNKXi.png" alt="image-20210526170709280" style="zoom:67%;" /></li>
<li><p><strong>加锁：公平锁</strong> </p>
<blockquote>
<p>简单来说：<strong>新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁</strong>。</p>
</blockquote>
<p>公平锁加锁入口加锁从：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally void lock() &#123;</span><br><span class="line">    acqiuire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前非公平锁的逻辑中，线程有三次机会获取锁：</p>
<ol>
<li><strong>新创建时</strong>，CAS尝试修改state=1，去获取</li>
<li><strong>可重入</strong>，当前获取锁线程为自己</li>
<li><strong>前驱节点释放锁</strong>，自己作为老二被唤醒</li>
</ol>
<p>  而<strong>公平锁</strong>，只能按加入队列的<u>先后次序 &amp; 可重入</u>获得锁 ：</p>
<pre><code>1. 所有线程在获取锁前**必须先加入同步队列** 

2. 如果state=0，`hasQueuedPredecessors`判断当前是头节点，则获取锁 
</code></pre>
<p><img src="https://i.loli.net/2021/05/26/wZSLYOP4bTGEqRJ.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h5 id="3-3-为什么基于FIFO的同步队列可以实现非公平锁？"><a href="#3-3-为什么基于FIFO的同步队列可以实现非公平锁？" class="headerlink" title="3.3 为什么基于FIFO的同步队列可以实现非公平锁？"></a>3.3 为什么基于FIFO的同步队列可以实现非公平锁？</h5><p>因为非公平锁，除了等 <strong>前驱节点唤醒去获取锁</strong> ，还有以下三种方式获取锁：</p>
<ol>
<li><p><strong>新创建时</strong>，CAS尝试修改state=1，去获取</p>
<blockquote>
<p>公平锁：进来先执行<code>hasQueuedPredecessors()</code> , 看等待队列是否有有效节点，有的话不能获取锁！</p>
</blockquote>
</li>
<li><p><strong>可重入</strong>，当前获取锁线程为自己</p>
<blockquote>
<p>公平锁：也可以</p>
</blockquote>
</li>
<li><p><strong>同步队列等待</strong>，等待唤醒获取锁</p>
<blockquote>
<p>公平锁：也可以</p>
</blockquote>
</li>
</ol>
<p>并且在锁释放时：是<strong>先释放锁（修改state=-1），再去唤醒后继节点</strong> </p>
<ol>
<li>会导致新来的线程，可能在<strong>后继节点被唤醒前</strong>就获取了锁，这就不会公平</li>
</ol>
<h5 id="3-4-【易忘】为什么非公平锁性能好？"><a href="#3-4-【易忘】为什么非公平锁性能好？" class="headerlink" title="3.4 【易忘】为什么非公平锁性能好？"></a>3.4 【易忘】为什么非公平锁性能好？</h5><ol>
<li>.线程不必加入等待队列就可以获得锁,不仅<strong>免去了构造结点并加入队列的繁琐操作</strong> ，<strong>节省了线程阻塞、唤醒</strong>的开销（这涉及到上下文的切换）；</li>
<li><strong>减少CAS竞争</strong>。如果<strong>线程必须要加入阻塞队列才能获取锁</strong>,那<strong>0</strong>将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视</li>
</ol>
<h5 id="3-4-AQS-有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景-？"><a href="#3-4-AQS-有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景-？" class="headerlink" title="3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？"></a>3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</h5><p><img src="https://i.loli.net/2021/05/26/OWhD4Hu3GkBP2vc.png" alt="image-20210526215800096"></p>
<ul>
<li><p><strong>Semaphore(信号量)：</strong>Semaphore(信号量)可以指定<strong>多个</strong>线程<strong>同时</strong>访问某个资源； <strong>synchronized 和 ReentrantLock</strong> 都是⼀次只允许<strong>⼀个</strong>线程访问<strong>同时</strong>某个资源。</p>
<blockquote>
<p>计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。</p>
<p>运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标<strong>S减为负值</strong>时，进程会被挡住，不能继续；当<strong>信号标S不为负值</strong>时，进程可以获准进入临界区段。</p>
</blockquote>
</li>
<li><p><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，<u>它可以让<strong>某⼀个线程等待直到倒计时结束</strong></u>，再开始执行。</p>
</li>
<li><p><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。</p>
<blockquote>
<p>CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程<u>调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障</u>，然后当前线程被阻塞。</p>
</blockquote>
</li>
</ul>
<p><strong>CountDownLatch的应用场景</strong>  </p>
<p>我们要读取处理<strong>6</strong>个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。</p>
<p>为此我们定义了⼀个线程池和<strong>count为6的 CountDownLatch 对象</strong> 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理⽂件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">     ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">     <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span></span><br><span class="line">CountDownLatch(threadCount);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">         threadPool.execute(() → &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理⽂件的业务操作</span></span><br><span class="line">                ......</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示⼀个⽂件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">       System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-4-Volatile-关键字"><a href="#15-4-Volatile-关键字" class="headerlink" title="15.4 Volatile 关键字"></a>15.4 Volatile 关键字</h4><h5 id="4-0-JMM-是什么-？-缓存一致性协议MESI-CPU内存屏障？JAVA内存屏障？"><a href="#4-0-JMM-是什么-？-缓存一致性协议MESI-CPU内存屏障？JAVA内存屏障？" class="headerlink" title="4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？"></a>4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06717ac8312c">并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p>
</blockquote>
<ul>
<li><p><strong>JMM定义</strong></p>
<p>全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。</p>
</li>
<li><p><strong>MESI 缓存一致性协议协议</strong></p>
<ul>
<li><p><strong>缓存不一致问题</strong></p>
<p>CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了<strong>高速缓存</strong>。但是由此也带来了缓存不一致的问题。</p>
<ul>
<li><strong>每个线程都会缓存内存的数据在各自寄存器中</strong>，在<strong>不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样</strong>就会存在缓存不一致的问题。</li>
</ul>
</li>
<li><p><strong>MESI协议内容</strong></p>
<p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，<strong>最常见的就是 MESI 协议</strong>：<br> MESI 表示缓存行的四种状态，分别是：</p>
<blockquote>
<p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且<strong>也监听(snoop)其它 Cache 的读写操作</strong>。</p>
</blockquote>
<ul>
<li><strong>M(Modify)</strong> 表示共享<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中， 并且是被修改状态，也就是缓存的数据和主内存中的<strong>数据不一致</strong>。</li>
<li><strong>E(Exclusive)</strong> 表示缓存的独占状态，<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中，并且<strong>没有被修改</strong>。</li>
<li><strong>S(Shared)</strong> 表示<strong>数据</strong>可能被<strong>多个 CPU 缓存</strong>，并且各个缓存中的<strong>数据和主内存数据一致</strong>。</li>
<li><strong>I(Invalid)</strong> 表示缓存已经<strong>失效</strong>。</li>
</ul>
<p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：</p>
<p><img src="https://i.loli.net/2021/06/11/YbfKoySNDMX5swn.png" alt="image-20210611200929872"></p>
<ul>
<li><strong>CPU 读请求：</strong>缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据；</li>
<li><strong>CPU 写请求：</strong>缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将<strong>其他 CPU 中缓存行置为无效</strong>才可写。</li>
</ul>
</li>
<li><p><strong>Store Bufferes（存储缓存）</strong></p>
<blockquote>
<p>CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中<strong>共享的变量</strong>进行<strong>写入</strong>，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要<strong>等到他们的确认回执</strong>。CPU0 在这段时间内都会处于<strong>阻塞状态</strong>。</p>
</blockquote>
<p>为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。</p>
<ul>
<li>CPU0 写入共享数据时，<strong>直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令</strong>；</li>
<li>收到其他所有 CPU 发送了 invalidate ACK消息时<strong>，再将 store bufferes 中的数据数据存储至 cache 中</strong>；</li>
<li>最后再从<strong>本地Cache同步到主内存</strong>。</li>
</ul>
</li>
<li><p><strong>CPU层面内存屏障</strong></p>
<blockquote>
<p>内存屏障就是<strong>将 Store Bufferes 中的指令写入到内存</strong>，从而使得其他访问同一共享内存的线程的可见性。</p>
</blockquote>
<p>硬件层的内存屏障分为两种：<strong>Load Barrier （读屏障）</strong> 和 <strong>Store Barrier（写屏障）及 Full Barrier（全屏障）</strong> 是读屏障和写屏障的合集。</p>
<ul>
<li><strong>写屏障</strong>：强制<strong>把写缓冲区/高速缓存</strong>中的脏数据等<strong>写回主内存</strong></li>
<li><strong>读屏障</strong>：将缓冲区/高速缓存中相应的<strong>数据失效</strong>。</li>
</ul>
</li>
<li><p><strong>JAVA 内存屏障</strong></p>
<p>java的内存屏障通常所谓的四种，<strong>LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL）</strong>实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li><strong>LoadLoad（LL）屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreStore（SS）屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><strong>LoadStore（LS）屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreLoad（SL）屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-什么是HappenBefore原则？"><a href="#4-1-什么是HappenBefore原则？" class="headerlink" title="4.1 什么是HappenBefore原则？"></a>4.1 什么是HappenBefore原则？</h5><p>在 JMM 中，<strong>如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系</strong>。这两个操作可以是同一个线程，也可以是不同的线程。</p>
<p><strong>它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</strong> 。</p>
<ul>
<li><p><strong>HappenBefore原则</strong></p>
<ul>
<li><p><strong>as-if-serial 规则（程序顺序执行）</strong>：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。</p>
</li>
<li><p><strong>volatile 变量规则</strong>，对于 volatile 修饰的变量的<strong>写操作</strong>， 一定 happen-before 后续对于 volatile 变量的<strong>读操作</strong>;</p>
</li>
<li><p><strong>监视器锁规则（monitor lock rule）</strong>：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。</p>
</li>
<li><p><strong>传递性规则</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</li>
<li><p><strong>start 规则</strong>：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。</p>
</li>
<li><p><strong>join 规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。</p>
</li>
</ul>
</li>
<li><p><strong>举例说明：什么是指令重排序？</strong></p>
<p>请看下面代码：</p>
<blockquote>
<p><strong>假设</strong> 线程A执行writer()方法之<strong>后</strong>，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;           <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;     <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;       <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;    <span class="comment">//4</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是<strong>肯定的</strong>。因为根据happens-before规则，我们可以得到如下关系：</p>
<ol>
<li>根据<strong>程序顺序规则</strong>，1 happens-before 2；3 happens-before 4</li>
<li>根据<strong>volatile规则</strong>，2 happens-before 3；</li>
<li>根据<strong>传递性规则</strong>，1 happens-before 4 。</li>
</ol>
<p>因此，综合运用<strong>程序顺序规则、volatile规则及传递性规则</strong>，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。</p>
</li>
</ul>
<h5 id="4-2-Volatile-关键字原理"><a href="#4-2-Volatile-关键字原理" class="headerlink" title="4.2 Volatile 关键字原理"></a>4.2 Volatile 关键字原理</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5428507.html">https://www.cnblogs.com/paddix/p/5428507.html</a> 。</p>
</blockquote>
<p>此题考察的是<code>volatile</code>这个关键字。可以从<code>volatile</code>的作用和<code>volatile</code>的原理这三个方面来进行回答。<strong>volatile只能保证变量的可见性、有序性，但是不能保证原子性。</strong> </p>
<ul>
<li><strong>可见性实现原理</strong></li>
</ul>
<blockquote>
<p>为了实现<strong>volatile可见性</strong>和<strong>happen-befor</strong>的语义。JVM底层是通过一个叫做“<strong>内存屏障（基于MESI）</strong>”的东西来完成（也实现了<strong>有序性</strong> ？）。</p>
</blockquote>
<p><strong>线程本身并不直接与主内存进行数据的交互</strong>，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。</p>
<p>使用<strong>MESI</strong> 协议，使得<strong>任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值</strong>。 </p>
<blockquote>
<p>最终目标：保证了<strong>缓存的一致性</strong>。</p>
<p>具体的话，下面是用<strong>内存屏障</strong>来实现的。</p>
</blockquote>
<ol>
<li>修改本地工作内存，强制刷回主内存；</li>
</ol>
<p><img src="https://i.loli.net/2021/06/11/JTFaYRu13pfQg9d.png" alt="image-20210611204633903"></p>
<ol start="2">
<li>强制让其他线程的工作内存失效过期；<img src="https://i.loli.net/2021/06/11/2kphvOoJu4K65Hb.png" alt="image-20210611204715422"></li>
<li>其他线程重新从主内存加载最新值；  <img src="https://i.loli.net/2021/06/11/rvo58ueDB6CPyMa.png" alt="image-20210611204743839"></li>
</ol>
<ul>
<li><p><strong>有序性实现原理</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42764468/article/details/106898608">https://blog.csdn.net/qq_42764468/article/details/106898608</a></p>
</blockquote>
<p>从源代码到最终执行的指令，可能会经过三种重排序：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2845835-8fc217f556cd34f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p>
</li>
<li><p><strong>【指令】重排序</strong>，<strong>JMM</strong> 会要求编译器生成指令时，会<strong>插入内存屏障</strong>来禁止处理器重排序。</p>
</li>
</ul>
<blockquote>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
<ul>
<li><p><strong>编译器重排序</strong>，<strong>JMM</strong>  <strong>禁止了特定类型的编译器</strong>重排序（不是所有的编译器重排序都要禁止）。</p>
</li>
<li><p><strong>内存重排序</strong>：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序</p>
</li>
</ul>
<p>JVM 是<strong>使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性</strong>效果。</p>
<blockquote>
<p><strong>lock前缀指令实际相当于一个内存屏障</strong>？ 下面不是可见性吗？？？</p>
</blockquote>
<p>  对volatile变量的<strong>写</strong>操作与普通变量的主要区别有两点：</p>
<ol>
<li>修改volatile变量<strong>前</strong>，<strong>会强制将修改后的值刷新的主内存中</strong>。<blockquote>
<p>每个volatile写操作前插入<strong>StoreStore（SS）屏障</strong> </p>
</blockquote>
</li>
<li>修改volatile变量<strong>后</strong>，<strong>会导致其他线程工作内存中对应的变量值失效</strong>，因此，再读取该变量值的时候就需要重新从读取主内存中的值。<blockquote>
<p>在写操作后插入StoreLoad屏障；</p>
</blockquote>
</li>
</ol>
<pre><code>对volatile变量的**读**操作类似：
</code></pre>
<ol>
<li>在每个volatile读操作前插入<strong>LoadLoad（LL）屏障</strong>；<blockquote>
<p>确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。</p>
</blockquote>
</li>
<li>在读操作后插入<strong>LoadStore（LS）</strong>屏障。<blockquote>
<p>确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。</p>
</blockquote>
</li>
</ol>
<h5 id="4-3-volatile为什么不能保证原子性？"><a href="#4-3-volatile为什么不能保证原子性？" class="headerlink" title="4.3 volatile为什么不能保证原子性？"></a>4.3 volatile为什么不能保证原子性？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/simpleDi/p/11517150.html">为什么volatile能保证有序性不能保证原子性</a></p>
</blockquote>
<p>对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>

<p>上述<code>i++</code>操作，其实分为三个操作：</p>
<ol>
<li><p>线程读取i</p>
</li>
<li><p>temp = i + 1</p>
</li>
<li><p>i = temp</p>
</li>
</ol>
<p>A,B两个线程多线程操作时：</p>
<ol>
<li><p>A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化 </p>
</li>
<li><p>此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化</p>
<blockquote>
<p>:warning: 虽然有MESI协议，但是<code>temp</code>不保存变量<code>i</code>所在内存区域，<strong>是cpu内部的计算</strong>，不会被立马刷新内存！ </p>
</blockquote>
</li>
<li><p>当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1</p>
</li>
<li><p>当B也写入i = temp时，<strong>此时A依旧是1，而不是2</strong></p>
</li>
</ol>
<h5 id="4-4-并发编程的三个重要特性-？"><a href="#4-4-并发编程的三个重要特性-？" class="headerlink" title="4.4  并发编程的三个重要特性 ？"></a>4.4  <strong>并发编程的三个重要特性</strong> ？</h5><ol>
<li><strong>原子性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，<strong>要么所有的操作都执行，要么都不执行</strong>。 <code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性 ：</strong>当<strong>⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值</strong>。 volatile 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性 ：</strong>代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 <code>volatile</code> 关键字可以禁⽌指令进行重排序优化。</li>
</ol>
<h5 id="4-5-说说-synchronized-关键字和-volatile-关键字的区别？"><a href="#4-5-说说-synchronized-关键字和-volatile-关键字的区别？" class="headerlink" title="4.5 说说 synchronized 关键字和 volatile 关键字的区别？"></a>4.5 <strong>说说</strong> synchronized <strong>关键字和</strong> volatile <strong>关键字的区别</strong>？</h5><p>synchronized关键字和volatile关键字比较：</p>
<ul>
<li><p><strong>volatile关键字是线程同步的轻量级实现</strong>，所以volatile性能肯定⽐synchronized关键字要好。</p>
</li>
<li><p><strong>volatile关键字只能用于变量</strong>，而synchronized关键字可以修饰方法以及代码块。</p>
<blockquote>
<p>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用<br>synchronized 关键字的场景还是更多⼀些。</p>
</blockquote>
</li>
<li><p><strong>volatile关键字只能保证数据的可见性</strong>，但不能保证数据的原子性。synchronized关键字两者都能保证。</p>
</li>
<li><p><strong>多线程访问volatile关键字不会发生阻塞</strong>，而synchronized关键字可能会发⽣阻塞</p>
</li>
</ul>
<h4 id="15-5-Atomic-原子类"><a href="#15-5-Atomic-原子类" class="headerlink" title="15.5 Atomic 原子类"></a>15.5 Atomic 原子类</h4><h5 id="5-1-什么是Atomic-原子类？"><a href="#5-1-什么是Atomic-原子类？" class="headerlink" title="5.1 什么是Atomic 原子类？"></a>5.1 什么是Atomic 原子类？</h5><p>所以，所谓原子类说简单点就是<strong>具有原子/原子操作特征的类</strong>。</p>
<blockquote>
<p>在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。</p>
</blockquote>
<h5 id="5-2-JUC-包中的原子类是哪4类"><a href="#5-2-JUC-包中的原子类是哪4类" class="headerlink" title="5.2 JUC 包中的原子类是哪4类?"></a>5.2 JUC <strong>包中的原子类是哪</strong>4<strong>类</strong>?</h5><p><img src="https://i.loli.net/2021/05/16/vS4DHpKCN9bjnTF.png" alt="image-20210516152124223"></p>
<h5 id="5-3-Volatile-和-atomic-变量区别？"><a href="#5-3-Volatile-和-atomic-变量区别？" class="headerlink" title="5.3 Volatile 和  atomic  变量区别？"></a>5.3 Volatile 和  atomic  变量区别？</h5><ul>
<li>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</li>
<li>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h5 id="5-4-讲讲-AtomicInteger-的使用-？"><a href="#5-4-讲讲-AtomicInteger-的使用-？" class="headerlink" title="5.4 讲讲 AtomicInteger 的使用 ？"></a>5.4 讲讲 AtomicInteger 的使用 ？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并⾃增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并⾃减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 基本类型也要是原子类</span></span><br><span class="line">       <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="comment">//使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5（重点提问）-AtomicInteger-原理？"><a href="#5-5（重点提问）-AtomicInteger-原理？" class="headerlink" title="5.5（重点提问） AtomicInteger 原理？"></a>5.5（重点提问） AtomicInteger 原理？</h5><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 和 <strong>native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>我们以自增方法为例： <code>getAndIncrement</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，本质是在调用 unsafe中的 <code>getAndAddInt</code> </p>
<blockquote>
<p>unsafe中的compareAndSwapInt方法参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSwapInt(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x);  <span class="comment">// x是准备更新的值</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="comment">// getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到）</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">    <span class="comment">// 计算传入compareAndSwapInt的四个参数</span></span><br><span class="line">    <span class="comment">// var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终总结如下</strong></p>
<p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p>
<p>下面以 getAndIncrement实现来说明。</p>
<ol>
<li><p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1</p>
<blockquote>
<p>:warning: <strong>为什么不传value的值，而是偏移量？</strong> 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。 </p>
</blockquote>
</li>
<li><p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p>
<ul>
<li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li>
</ul>
</li>
<li><p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p>
<p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p>
<p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p>
<p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ； </p>
<p>（4）否则写入失败，通过不断<strong>自旋（循环）</strong>期望得到执行</p>
</li>
</ol>
<h2 id="1-6-JVM相关"><a href="#1-6-JVM相关" class="headerlink" title="1.6 JVM相关"></a>1.6 JVM相关</h2><h4 id="1-（被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）"><a href="#1-（被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）" class="headerlink" title="1. （被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）"></a>1. （被问过）<strong>JVM启动的基本配置参数有哪些？</strong>（或者说调优参数）</h4><p><strong>「堆栈内存相关」</strong></p>
<ul>
<li><p>-Xms： 设置初始堆的大小</p>
</li>
<li><p>-Xmx： 设置最大堆的大小</p>
</li>
<li><p>-Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</p>
</li>
<li><p>-Xss： 每个线程的堆栈大小</p>
</li>
<li><p>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</p>
</li>
<li><p>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</p>
</li>
<li><p>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</p>
</li>
<li><p>-XX:SurvivorRatio Eden区与Survivor区的的比值</p>
</li>
<li><p>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</p>
</li>
<li><p>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</p>
</li>
</ul>
<p><strong>「垃圾收集器相关」</strong></p>
<p> -XX:+UseParallelGC：选择垃圾收集器为并行收集器。</p>
<ul>
<li><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</p>
</li>
<li><p>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</p>
</li>
<li><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
</li>
</ul>
<p><strong>「辅助信息相关」</strong></p>
<ul>
<li><p>-XX:+PrintGCDetails 打印GC详细信息</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用</p>
</li>
<li><p>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.</p>
</li>
<li><p>-XX:+PrintTLAB 查看TLAB空间的使用情况</p>
</li>
</ul>
<h4 id="2-说说堆和栈的区别？"><a href="#2-说说堆和栈的区别？" class="headerlink" title="2.说说堆和栈的区别？"></a>2.<strong>说说堆和栈的区别？</strong></h4><ol>
<li><p><strong>功能不同：</strong>栈内存用来存储<u>局部变量和方法调用</u>，而堆内存用<u>来存储Java中的对象</u>；</p>
<blockquote>
<p>注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>
</blockquote>
</li>
<li><p><strong>共享性不同：</strong>栈内存是线程私有的； 堆内存是所有线程共有的；</p>
</li>
<li><p><strong>异常错误不同：</strong>如果栈内存或者堆内存不足，都会抛出异常但不同；</p>
<blockquote>
<p>栈空间不足：<code>java.lang.StackOverFlowError</code>。 堆空间不足：<code>java.lang.OutOfMemoryError</code>；</p>
</blockquote>
</li>
<li><p><strong>空间大小：</strong>栈的空间大小远远小于堆的。</p>
</li>
</ol>
<h4 id="3-【重点】请问JVM运行时内存布局分布？-哪些是线程共享的？"><a href="#3-【重点】请问JVM运行时内存布局分布？-哪些是线程共享的？" class="headerlink" title="3. 【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？"></a>3. <strong>【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？</strong></h4><p>从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。</p>
<ul>
<li>总的来看，JVM 把内存划分为<u>“栈(stack)”与“堆(heap)”</u>两大类</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/dd/a9/dd614bf56417939aa0e0694fedf2caa9.png" alt="img"></p>
<p><u>线程私有的：</u></p>
<ul>
<li><p><strong>程序计数器</strong>：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，<u>每个线程就需要一个属于自己的计数器来记录下一条要运行的指令</u>；</p>
</li>
<li><p><strong>虚拟机栈：</strong> <u>每个java方法执行时都会创建一个<strong>桢栈</strong></u>来存储方法的：</p>
<ul>
<li><p>变量表、操作数栈、动态链接方法、返回值、返回地址等信息；</p>
</li>
<li><p>栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">栈帧参考</a>” ；</p>
</li>
</ul>
</li>
<li><p><strong>本地方法栈 ：</strong> 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。</p>
<ul>
<li>本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li>
</ul>
</li>
</ul>
<p><u>线程共享的：</u></p>
<ul>
<li><p><strong>堆：</strong>GC 垃圾回收的主站场，用于<u>存放类的实例对象及 数组实例</u>等；</p>
<p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p>
</li>
<li><p><strong>方法区：</strong> 线程共享的，用于存放被虚拟机加载的<strong>类的元数据信息</strong>：</p>
<ul>
<li>如 <u><strong>常量</strong>、<strong>静态变量</strong></u>和 <u> 即时<strong>编译器编译后的代码</strong></u><strong>；</strong></li>
<li><strong>运行时常量池</strong> ：<strong>字符串</strong>，int -128~127 范围的值等，它是 <u>方法区</u> 中的一部分。</li>
</ul>
</li>
</ul>
<h4 id="4-（新）说一下Java创建对象的过程？"><a href="#4-（新）说一下Java创建对象的过程？" class="headerlink" title="4. （新）说一下Java创建对象的过程？"></a>4. （新）说一下Java创建对象的过程？</h4><p><img src="https://i.loli.net/2021/05/16/EBIujUDhkF9VRtg.png" alt="image-20210516205754856"></p>
<ol>
<li><p><strong>类加载检查：</strong> 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在<strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的<strong>类是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p><strong>分配内存：</strong> 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 <u>Java 堆中划分出来</u>。</p>
<blockquote>
<p><strong>（重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="https://i.loli.net/2021/05/16/S27KdREVrpGqt5I.png" alt="image-20210516210222497"></p>
</blockquote>
</li>
<li><p><strong>初始化对象字段零值。</strong> 内存分配完成后，进行对象初始化操作。</p>
<blockquote>
<p> 例如给<strong>对象中（区分类加载过程，初始化类变量）</strong>所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。</p>
</blockquote>
</li>
<li><p><strong>设置对象头：</strong> 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是<u>哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息</u>。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用<u>偏向锁</u>等，对象头会有不同的设置方式。</p>
</li>
<li><p><strong>执行init() &amp; 构造函数。</strong>然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。</p>
</li>
<li><p><strong>内存地址赋给引用：</strong> 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。</p>
</li>
</ol>
<h5 id="4-1-什么是指针碰撞？空闲列表？TLAB"><a href="#4-1-什么是指针碰撞？空闲列表？TLAB" class="headerlink" title="4.1 什么是指针碰撞？空闲列表？TLAB?"></a>4.1 <strong>什么是指针碰撞？</strong>空闲列表？TLAB?</h5><p>三种虚拟机<strong>划分堆内存</strong>区域的方法，TLAB也可用来给堆内存分配空间。</p>
<ul>
<li><p><strong>指针碰撞</strong></p>
<p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。</p>
<ul>
<li>如果Java堆中内存是绝对规整的，所有被<strong>使用过的的内存都被放到一边，空闲的内存放到另外一边</strong>，中间放着一个<strong>指针作为分界点</strong>的指示器，<u>所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例</u>，这种分配方式就是指针碰撞。</li>
</ul>
</li>
<li><p><strong>空闲列表</strong></p>
<p><u>如果Java堆内存中的内存并不是规整的</u>，已被使用的内存和空闲的内存相互交错在一起，<u>不可以进行指针碰撞</u>。</p>
<ul>
<li>虚拟机必须维护一个列表，<strong>记录哪些内存是可用的</strong>，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li>
</ul>
</li>
<li><p><strong>TLAB</strong></p>
<p>TLAB 是虚拟机在内存的<u><strong>eden 区</strong>划分出来的一块专用空间，是线程专属的</u>。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。 </p>
<blockquote>
<p>虚拟机通过 -XX:UseTLAB 设定它的。</p>
</blockquote>
</li>
</ul>
<h5 id="4-2-JVM如何保证对象分配的线程安全问题？"><a href="#4-2-JVM如何保证对象分配的线程安全问题？" class="headerlink" title="4.2 JVM如何保证对象分配的线程安全问题？"></a>4.2 JVM如何保证对象分配的线程安全问题？</h5><p> 因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>TLAB</strong>： 为<strong>每⼀个线程预先在Eden区分配⼀块⼉内存TLAB</strong>，JVM在<strong>给线程中的对象分配内存时，⾸先在TLAB分配</strong>，当<u>对象大于TLAB中的剩余内存或TLAB的内存已用尽时</u>，再采用的CAS进行内存分配。</li>
<li><strong>CAS+失败重试</strong>： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
</ul>
<h4 id="5-描述一下对象分配【原则】？（区分前面new对象【过程】）"><a href="#5-描述一下对象分配【原则】？（区分前面new对象【过程】）" class="headerlink" title="5. 描述一下对象分配【原则】？（区分前面new对象【过程】）"></a>5. <strong>描述一下对象分配【原则】？（区分前面new对象【过程】）</strong></h4><p>JVM 中的堆可划分为两大部分，<u>新生代和老年代</u>，大小比例为1:2：</p>
<ul>
<li>新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区</li>
</ul>
<p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p>
<p>具体回收过程：</p>
<p><img src="https://i.loli.net/2021/04/19/p2LqRv6krQnbga4.png" alt="image-20210419224230046"></p>
<p>对象的正常流程：<em>Eden 区 -&gt; Survivor 区 -&gt; 老年代</em>。</p>
<ol>
<li>新的对象<strong>优先在 Eden 区分配</strong>（<em>大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制</em>） , <strong>当 Eden 区没有足够空间时</strong>，会发起一次 <em><strong>Minor GC</strong></em>；</li>
<li><em><strong>Minor GC</strong></em>采用<strong>复制回收算法</strong>的改进版本回收Eden中对象：<ul>
<li>先将Eden存活对象迁移到 to 区，然后清空Eden</li>
<li>最后交换to和from区域<strong>标签</strong></li>
</ul>
</li>
<li>每经过一次 <em><strong>Minor GC</strong></em>  （在交换区）后对象年龄加1，对象年龄达到<em><strong>15次</strong></em>后将会晋升到老年代； </li>
<li>对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相<u>同年龄所有对象大小总和大于 Survivor 区大小的一半</u>， 年龄大于或等于该年龄的对象就可以直接进入老年代；</li>
<li>老年代空间不够时进行 <em><strong>Full GC</strong></em>。</li>
</ol>
<h5 id="5-1-对象一定分配到堆上吗？"><a href="#5-1-对象一定分配到堆上吗？" class="headerlink" title="5.1 对象一定分配到堆上吗？"></a>5.1 对象一定分配到堆上吗？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&mid=2650500024&idx=1&sn=0997c486387bf56bbe8ca909d55a7edf&chksm=83c88c44b4bf05521d66f6a396550cd9c8379c3fdddee1ee198968f6a9ddd172550d3329a94d&scene=21#wechat_redirect">面试官：是不是所有的对象和数组都会在堆内存分配空间</a></p>
</blockquote>
<blockquote>
<p>小伙，来给我讲一下是不是<strong>所有的对象和数组</strong>都会在堆内存分配空间？</p>
</blockquote>
<p>并不是，这涉及到<strong>对象逃逸</strong>。请看下面的代码：</p>
<p>StringBuffer对象，最终会被return，也就是<strong>会被该方法之外的给利用</strong>。 发生了对象逃逸。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/9AGZ6gT0cFLwmz482FwbF4R7uGG2DMh1obk7hibSE9b98w24vTAOy5Z3sGlGAOvJMvaCPuybNa3q0ibo63rzry3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。</strong> 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一<strong>个对象并没有逃逸出方法的话</strong>，那么就可能被<strong>优化成栈上分配</strong>。</p>
<h4 id="6-对象的访问定位有哪两种方式"><a href="#6-对象的访问定位有哪两种方式" class="headerlink" title="6. 对象的访问定位有哪两种方式?"></a>6. <strong>对象的访问定位有哪两种方式</strong>?</h4><p>建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：<strong>①使用句柄和 ②直接指针两种。</strong> </p>
<ol>
<li> <strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据（存放在方法区）</strong>各⾃的具体地址信息；</li>
</ol>
<blockquote>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
</blockquote>
<p>   <img src="https://i.loli.net/2021/05/16/4XShu2w1nRbZl5x.png" alt="image-20210516211902118"></p>
<ol start="2">
<li> <strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，<strong>而reference 中存储的直接就是对象的地址</strong>。</li>
</ol>
<blockquote>
<p>使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。</p>
</blockquote>
<p>   <img src="https://i.loli.net/2021/05/16/lTvrqnOFu5X9VJk.png" alt="image-20210516212141885"></p>
<h4 id="7-如何判断对象是否需要回收（死亡）？"><a href="#7-如何判断对象是否需要回收（死亡）？" class="headerlink" title="7. 如何判断对象是否需要回收（死亡）？"></a>7. <strong>如何判断对象是否需要回收（死亡）？</strong></h4><ul>
<li><strong>可达性分析</strong>：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的；</li>
<li><strong>引用计数</strong>：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。</li>
</ul>
<h4 id="8-如何判断一个常量是废弃变量？如何判断一个类是无用类？"><a href="#8-如何判断一个常量是废弃变量？如何判断一个类是无用类？" class="headerlink" title="8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？"></a>8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</h4><ul>
<li><p><strong>判断常量是废弃变量</strong></p>
<p>运行时常量池主要回收的是废弃的常量。</p>
<p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc” 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>
</li>
<li><p><strong>判断类是无用类？</strong></p>
<p>虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</p>
</li>
<li><p>加载该类的 ClassLoader 已经被回收；</p>
</li>
<li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-6-1-GC相关"><a href="#1-6-1-GC相关" class="headerlink" title="1.6.1 GC相关"></a>1.6.1 GC相关</h3><blockquote>
<p>不错的GC介绍文章：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">一文看懂 JVM 内存布局及 GC 原理</a></p>
</blockquote>
<h4 id="1-请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？"><a href="#1-请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？" class="headerlink" title="1. 请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？"></a>1. <strong>请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？</strong></h4><p>当程序员创建对象时，GC就开始监控这个对象的<u>地址、大小</u>及<u>使用情况</u> ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ：</p>
<ul>
<li><p><strong>基本原理</strong>： GC采用<u><strong>有向图</strong></u>的方式记录和管理 **堆(heap)**中的所有对象 ，并确定对象 <strong>是否“可达”</strong> </p>
</li>
<li><p><strong>GC优点：</strong>（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域” （3）有效防止内存泄漏</p>
</li>
<li><p><strong>马上回收：</strong> 程序员<strong>不能实时</strong>的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p>
</li>
<li><p><strong>主动回收：</strong> 手动执行<code>System.gc()</code> ，但是Java语言规范 <u>并不保证</u> GC一定会执行。</p>
</li>
</ul>
<h4 id="2-什么是GC-Root？可以作为GC-Root的对象？"><a href="#2-什么是GC-Root？可以作为GC-Root的对象？" class="headerlink" title="2. 什么是GC Root？可以作为GC Root的对象？"></a>2. <strong>什么是GC Root？可以作为GC Root的对象？</strong></h4><ul>
<li><p><strong>GC Root ：</strong>  判断对象是通过可达性分析，所以所有的可达性算法<strong>都会有起点</strong> ，这就是 GC Root。</p>
<ul>
<li><strong>特点：</strong> <strong>当前时刻存活的对象</strong>！</li>
</ul>
<p>通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p>
<p><img src="https://pic1.zhimg.com/80/v2-38552a00d9bfb53f0c780e26a0d4b078_720w.jpg" alt="img"></p>
</li>
<li><p><strong>GC Root对象：</strong> （1）虚拟机栈中<strong>引用</strong>的<strong>对象</strong>；（2）方法区中的<strong>静态</strong>变量、<strong>常量</strong>对象；（3）本地方法<strong>引用</strong>的<strong>对象</strong>；（4）被<code>synchronized</code>修饰的对象等。</p>
</li>
</ul>
<h4 id="3-哪些内存区域需要GC"><a href="#3-哪些内存区域需要GC" class="headerlink" title="3. 哪些内存区域需要GC?"></a>3. <strong>哪些内存区域需要GC?</strong></h4><ul>
<li><p><strong>（无需）线程独享区域</strong>：<code>PC Regiester、JVM Stack、Native Method Stack</code>，其生命周期都与线程相同（即：与线程共生死），所以无需 GC;</p>
</li>
<li><p><strong>（需）线程共享</strong>的 Heap 区、Method Area 则是 GC 关注的重点对象。</p>
</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/e3/71/e36c624e8b4300775123f95a34b86571.png" alt="img"></p>
<h4 id="4-什么时候会触发Full-GC？"><a href="#4-什么时候会触发Full-GC？" class="headerlink" title="4. 什么时候会触发Full GC？"></a>4. <strong>什么时候会触发Full GC？</strong></h4><ol>
<li><p><strong>调用 System.gc()</strong> ；</p>
</li>
<li><p><strong>老年代空间不足</strong>；</p>
</li>
<li><p><strong>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</strong>；</p>
<blockquote>
<p>如果发现<strong>统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大</strong>，则不会触发Minor GC而是转为触发full GC。</p>
</blockquote>
</li>
<li><p><strong>方法区空间不足</strong>。</p>
<blockquote>
<p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些<u><strong>class的信息、常量、静态变量等数据</strong></u>，当系统中<strong>要加载的类、反射的类和调用的方法较多</strong>时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code> 。<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
</blockquote>
</li>
</ol>
<h4 id="5-什么时候触发-Minor-GC-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？"><a href="#5-什么时候触发-Minor-GC-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？" class="headerlink" title="5. 什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？"></a>5. <strong>什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？</strong></h4><ul>
<li><p><strong>什么时候触发Minor GC ?</strong></p>
<p><strong>当Eden区不足时</strong>就会触发 Minor GC 。</p>
</li>
<li><p><strong>minor gc运行频繁</strong></p>
</li>
</ul>
<ol>
<li>产生了太多朝生夕灭的对象导致需要频繁minor gc</li>
<li>新生代空间设置太小</li>
</ol>
<ul>
<li><p><strong>minor gc运行很慢</strong></p>
<ol>
<li><u>新生代空间设置过大</u>； </li>
<li><u>对象引用链较长</u>，进行可达性分析时间较长；</li>
<li><u>新生代survivor区设置的比较小</u>，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销；</li>
<li><u>内存分配担保失败</u>，由minor gc转化为full gc；</li>
<li><u>采用的垃圾收集器效率较低</u>，比如新生代使用serial收集器。</li>
</ol>
</li>
</ul>
<h4 id="6-描述一下GC算法？"><a href="#6-描述一下GC算法？" class="headerlink" title="6. 描述一下GC算法？"></a>6. <strong>描述一下GC算法？</strong></h4><p>GC算法包含：引用计数法，标记清除，标记复制，标记压缩。</p>
<ul>
<li><strong>引用计数：</strong>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用；</li>
<li><strong>标记清除：</strong> 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，<u>清除所有未被标记的对象，<strong>但会产生很多垃圾碎片</strong></u> ；</li>
<li><strong>标记复制：</strong> 将内存对半分，总是<strong>保留一块空着</strong>（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。<strong>避免了内存碎片问题，但是内存浪费很严重</strong>，<u>相当于只能使用 50%的内存</u>；</li>
<li><strong>标记压缩（标记整理）：</strong>标记过程仍然与<u>“标记-清除”</u>算法一样，但后续步骤<strong>不是直接对可回收对象进行清理</strong>，而是让<strong>所有存活的对象都向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>（类似于 windows 的磁盘碎片整理），避免垃圾碎片。</li>
</ul>
<h4 id="7-什么是Stop-The-World-什么是安全点？安全区域？"><a href="#7-什么是Stop-The-World-什么是安全点？安全区域？" class="headerlink" title="7. 什么是Stop The World ? 什么是安全点？安全区域？"></a>7. <strong>什么是Stop The World ?</strong> 什么是安全点？安全区域？</h4><ul>
<li><p><strong>Stop The World</strong></p>
<p>进行<strong>垃圾回收</strong>的过程中，<u>会<strong>涉及对象的移动。为了保证对象引用更新的正确性</strong>，必须暂停所有的用户线程</u>，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。</p>
<p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了<strong>安全点</strong>的概念。</p>
</li>
<li><p><strong>安全点</strong></p>
<blockquote>
<p>安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p>
</blockquote>
<p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，<strong>Java虚拟机的堆栈不会发生变化</strong>。这么一来，<strong>垃圾回收器便能够“安全”地执行可达性分析</strong>。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>
</li>
<li><p><strong>如何保证中断时所有线程都在安全点</strong> </p>
<ul>
<li><p><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，<strong>如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上</strong>。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p>
</li>
<li><p><strong>主动式中断（Voluntary Suspension）</strong><br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外再加上创建对象需要分配内存的地方。</p>
</li>
</ul>
</li>
</ul>
<h4 id="8-常见的垃圾回收器有哪些（比如G1）？"><a href="#8-常见的垃圾回收器有哪些（比如G1）？" class="headerlink" title="8. 常见的垃圾回收器有哪些（比如G1）？"></a>8. 常见的垃圾回收器有哪些（比如G1）？</h4><p><img src="https://i.loli.net/2021/05/16/ypmn6LRB5trC3Dl.png" alt="image-20210516215006746"></p>
<ul>
<li><p><strong>Serial收集器 。</strong> Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须<strong>暂停其他所有的⼯作线程（ “Stop The World”）</strong>，直到它收集结束。</p>
</li>
<li><p><strong>ParNew收集器。</strong> ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。 </p>
<ul>
<li>新⽣代采用<u><strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li>
</ul>
</li>
<li><p><strong>Parallel Scavenge收集器。</strong> Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p>
<blockquote>
<p>如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。-</p>
</blockquote>
<ul>
<li><u>新⽣代采用<strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li>
</ul>
</li>
<li><p><strong>（重点）CMS收集器。</strong>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p>
<ul>
<li>CMS收集器仅作用于<strong>老年代</strong>的收集，基于 <u>“<strong>标记-清除</strong>”</u> 。</li>
<li><strong>优点：</strong> 并发收集、低停顿。</li>
<li><strong>缺点（快手）：</strong> CMS收集器<strong>对CPU资源非常敏感</strong>；CMS收集器<strong>无法处理浮动垃圾</strong>（Floating Garbage）。</li>
</ul>
</li>
<li><p><strong>（重点）G1收集器。</strong> G1重新定义了堆空间，<strong>打破了原有的分代模型，将堆划分为一个个区域</strong>。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
<ul>
<li><strong>并行与并发：</strong>G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li><strong>分代收集：</strong>虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合：</strong>与CMS的<u>“标记–清除”</u>算法不同，G1从整体来看是基于<strong>“标记-整理”</strong>算法实现的收集器；从局部上来看是<strong>基于<u>“标记-复制”</u>算法</strong>实现的。</li>
<li><strong>可预测的停顿：</strong>这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。</li>
</ul>
</li>
</ul>
<h5 id="8-1-介绍一下CMS-和-G1-垃圾回收器原理？"><a href="#8-1-介绍一下CMS-和-G1-垃圾回收器原理？" class="headerlink" title="8.1 介绍一下CMS 和 G1 垃圾回收器原理？"></a>8.1 介绍一下CMS 和 G1 垃圾回收器原理？</h5><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></p>
</blockquote>
<ul>
<li><p><strong>CMS收集器</strong> </p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p>
<p>CMS收集器仅作用于老年代的收集，是基于<u>标记-清除</u>算法的，它的运作过程分为4个步骤：</p>
<ol>
<li><strong>初始标记（CMS initial mark） :</strong> 需要<strong>STW</strong>，标记一下GC Roots能<strong>直接</strong>关联到的对象 ；</li>
<li><strong>并发标记（CMS concurrent mark）：</strong>从GC Roots开始堆中对象进<strong>行可达性分析</strong>，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li>
<li><strong>重新标记（CMS remark）：</strong>需要<strong>STW</strong> ，<strong>修正并发标记期间</strong>因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分对象的标记记录 ；</li>
<li><strong>并发清除（CMS concurrent sweep）：</strong> 清除对象。</li>
</ol>
</li>
<li><p><strong>G1收集器</strong> </p>
<p>在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多<strong>相同大小</strong>的区域单元，每个单元称为<strong>Region</strong>。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p>
<blockquote>
<p>区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
</blockquote>
<p>和CMS挺像的。</p>
<ol>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能<strong>直接关联</strong>到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行<strong>可达性分</strong>析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：首先<strong>对各个Region的回收价值和成本进行排序</strong>，根据用户<strong>所期望的GC停顿时间来制定回收计划</strong>。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ol>
</li>
</ul>
<h5 id="8-2-为什么CMS不用标记-压缩算法？"><a href="#8-2-为什么CMS不用标记-压缩算法？" class="headerlink" title="8.2 为什么CMS不用标记-压缩算法？"></a>8.2 为什么CMS不用标记-压缩算法？</h5><p>CMS主要关注<strong>低延迟</strong>，因而采用并发方式。</p>
<p>在<strong>并发清理垃圾</strong>时，如果采用压缩算法，这<strong>涉及到移动存活的对象。如果不进行停顿会很难处理</strong>，违背了CMS初衷，所以采用<strong>标记-清除</strong>算法。</p>
<h4 id="9-什么是内存泄漏？"><a href="#9-什么是内存泄漏？" class="headerlink" title="9. 什么是内存泄漏？"></a>9. <strong>什么是内存泄漏？</strong></h4><p>广义并通俗的说，就是：<u>不再会被使用的<strong>对象</strong>的内存不能被回收</u>，就是内存泄漏。</p>
<p><strong>内存泄漏场景：</strong></p>
<ul>
<li><p>静态集合类、数组<strong>添加对象以后遗漏了对于他们的处理</strong>，例如HashMap和Vector；</p>
</li>
<li><p>各种连接，如数据库连接、网络连接、IO连接；</p>
</li>
<li><p>单例模式；</p>
</li>
<li><p>变量不合理的作用域。</p>
</li>
</ul>
<h3 id="1-6-2-类加载"><a href="#1-6-2-类加载" class="headerlink" title="1.6.2 类加载"></a>1.6.2 类加载</h3><h4 id="1-（没记）介绍一下类文件结构？"><a href="#1-（没记）介绍一下类文件结构？" class="headerlink" title="1. （没记）介绍一下类文件结构？"></a>1. （没记）介绍一下类文件结构？</h4><p>Class⽂件字节码结构组织示意图 。</p>
<p><img src="https://i.loli.net/2021/05/16/VkMjgwfFb9NGr2L.png" alt="image-20210516220600929"></p>
<ol>
<li><strong>魔数:</strong> 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。</li>
<li><strong>Class ⽂件版本 ：</strong>Class ⽂件的版本号，保证编译正常执行。</li>
<li><strong>常量池</strong> ：常量池主要存放两大常量：字面量和符号引用。</li>
<li><strong>访问标志 ：</strong>标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</li>
<li><strong>当前类索引,⽗类索引</strong> ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引<br>都不为 0。</li>
<li><strong>接口索引集合 ：</strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。</li>
<li><strong>字段表集合 ：</strong>描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li>
<li><strong>方法表集合</strong> ：类中的方法。</li>
<li><strong>属性表集合 ：</strong> 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。</li>
</ol>
<h4 id="2-什么是类加载器？请你解释一下java程序运行的过程？"><a href="#2-什么是类加载器？请你解释一下java程序运行的过程？" class="headerlink" title="2. 什么是类加载器？请你解释一下java程序运行的过程？"></a>2. 什么是类加载器？请你解释一下java程序运行的过程？</h4><blockquote>
<p>参考 ： <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1350078">一个简单java程序的运行全过程</a></p>
</blockquote>
<p><u>类加载器是一个用来加载类文件的<strong>类</strong></u> 。</p>
<p>我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载</strong>进内存。主要分为以下3大步、5小步：</p>
<p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p>
<ol>
<li><p><strong>编译。</strong> 将编译的<code>.java</code> 文件编译为<code>.class</code>字节码文件，然后交给JVM运行；</p>
</li>
<li><p><strong>加载</strong> ：class字节码文件从各个来源通过**<u>类加载器</u>**装载入<u>内存</u>中 。</p>
<blockquote>
<ul>
<li><strong>来源</strong>：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong> ：一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>系统类加载器</strong>，以及用户的<u><strong>自定义类加载器</strong> （代码加密防止反编译）</u>。</li>
</ul>
</blockquote>
</li>
<li><p><strong>链接：</strong> 分为，验证、准备、解析（”正-中-准-心“）三阶段</p>
<ul>
<li><p><strong>验证：</strong> 保证加载进来的<u>字节流符合虚拟机规范</u>；</p>
<blockquote>
<p><strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
<p><strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
<p><strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证<u>类型转换的合理性</u>。</p>
<p><strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
</blockquote>
</li>
<li><p><strong>准备：</strong>类变量（<strong>注意，不是实例变量</strong> ）分配内存，并且赋予<strong>初值</strong>（虚拟机根据不同类型设定的初始值）；</p>
<blockquote>
<p>这些变量所使用的内存都将在<strong>方法区</strong>中进行分配 ，进行<strong>零初始化</strong>：</p>
<ul>
<li>即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等</li>
</ul>
</blockquote>
</li>
<li><p><strong>解析：</strong>将常量池内的 <u>符号引用</u> 替换为 <u>直接引用</u> 的过程。</p>
<blockquote>
<p><u>符号引用：</u>即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br><u>直接引用：</u>可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p>
<p>:ear_of_rice: 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>初始化。</strong> 初始化就是执行类的<code> cinit</code>()的过程。</p>
<blockquote>
<p>:grey_question: 和准备阶段那个初始化看得我有点迷糊？</p>
<ul>
<li><strong>在编译阶段</strong>，编译器收集所有的<strong>静态字段的赋值语句及静态代码块</strong>，并按 <u>语句出现的顺序</u> 拼接出一个类初始化方法 <code>&lt;clinit&gt;()</code>。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。</li>
</ul>
</blockquote>
</li>
</ol>
<h5 id="2-1-（C-版本）一个程序从开始到完整结束的过程？"><a href="#2-1-（C-版本）一个程序从开始到完整结束的过程？" class="headerlink" title="2.1 （C++版本）一个程序从开始到完整结束的过程？"></a>2.1 （C++版本）一个程序从开始到完整结束的过程？</h5><ol>
<li><p><strong>预编译。</strong> 主要处理源代码文件中的以“#”开头的预编译指令 ；</p>
<blockquote>
<ol>
<li>删除所有的#define，展开所有的宏定义 ;</li>
<li>处理所有的条件预编译指令，如 “#if”、“#endif”、“#ifdef”、“#elif” 和 “#else” ;</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件 ；</li>
<li>删除所有的注释，“//”和“/**/” ；</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用；</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告 能够显示行号。</li>
</ol>
</blockquote>
</li>
<li><p><strong>编译。</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列<strong>词法分析、语法分析、语义分析及优化</strong>后，生成相应的汇编代码文件 ；</p>
</li>
<li><p><strong>汇编。</strong> 将汇编代码转变成机器可以执行的指令(机器码文件)；</p>
<blockquote>
<p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Windows下)。</p>
</blockquote>
</li>
<li><p><strong>链接</strong> 。将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序：</p>
<ol>
<li><p><strong>静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来，创建最终的可执行文件。</p>
<blockquote>
<ul>
<li><strong>执行速度快：</strong><u>可执行程序中已经具备了所有执行程序所需要的任何东西</u>， 在执行的时候运行速度快；</li>
<li><strong>空间浪费：</strong>因为<u>每个可执行程序中对所有需要的目标文件都要有一份副本，</u>所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li>
<li><strong>更新困难：</strong>每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
</ul>
</blockquote>
</li>
<li><p><strong>动态链接：</strong> 把程序按照模块拆分成各个相对独立部分<strong>，在程序运行时才将它们链接在一起形成一个完整的程序</strong>。</p>
<blockquote>
<ul>
<li><strong>性能损耗</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失；</li>
<li><strong>共享库：</strong>就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</li>
<li><strong>更新简单：</strong>更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="3-知道类的生命周期吗？"><a href="#3-知道类的生命周期吗？" class="headerlink" title="3. 知道类的生命周期吗？"></a>3. <strong>知道类的生命周期吗？</strong></h4><p><strong>在类加载的过程</strong>再加上：</p>
<ol start="4">
<li><strong>使用。</strong>new出对象程序中使用</li>
<li><strong>卸载。</strong>执行垃圾回收</li>
</ol>
<h4 id="4-请你介绍一下类加载器？"><a href="#4-请你介绍一下类加载器？" class="headerlink" title="4. 请你介绍一下类加载器？"></a>4. <strong>请你介绍一下类加载器？</strong></h4><img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" />

<p>JVM预定义的三种类型类加载器：</p>
<ul>
<li><strong>启动类加载器（BootstrapClassLoader）</strong>：是一般用本地代码实现，负责将 <code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中；</li>
<li><strong>标准扩展类加载器（ExtensionClassLoader）</strong>：<code>&lt; Java_Runtime_Home &gt;/lib/ext</code>或者由系统变量 <code>java.ext.dir</code>指定位置中的类库加载到内存中；</li>
<li><strong>系统类加载器（AppClassLoader）</strong>：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从<u>环境变量或者系统属性<code>java.class.path</code></u>所指定的目录中加载类，是<strong>用户自定义加载器的默认父加载器</strong>。</li>
</ul>
<h4 id="5-请你介绍一下双亲委派机制？为什么要这么做？"><a href="#5-请你介绍一下双亲委派机制？为什么要这么做？" class="headerlink" title="5. 请你介绍一下双亲委派机制？为什么要这么做？"></a>5. <strong>请你介绍一下双亲委派机制？为什么要这么做？</strong></h4><ul>
<li><p><strong>双亲委派机制。</strong>某个特定的类加载器在接到加载类的请求时，首先将加载任务<strong>委托给父类加载器</strong>，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong>；</p>
</li>
<li><p><strong>为什么要这么做？</strong>  <strong>防止内存中出现多份同样的字节码</strong> 。</p>
<blockquote>
<p>比如两个类A和类B都要加载System类：</p>
<ul>
<li>如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，<strong>这样内存中就出现了两份System字节码。</strong></li>
<li>如果使用委托机制：会递归的向父类查找，也就是<strong>首选用Bootstrap尝试加载</strong>，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时<strong>Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载</strong>，这样内存中就只有一份System的字节码了。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="1-7-面经补充"><a href="#1-7-面经补充" class="headerlink" title="1.7 面经补充"></a>1.7 面经补充</h2><h3 id="1-7-1-美团买菜专场"><a href="#1-7-1-美团买菜专场" class="headerlink" title="1.7.1 美团买菜专场"></a>1.7.1 美团买菜专场</h3><ol>
<li><p><strong>怎么查看指定端口是否开放</strong></p>
<p>通过 netstat 命令，注意加上-a参数，看是否有<code>0.0.0.0:22</code> 在被监听。</p>
<p><img src="D:/hwh/images/image-20210906215822732.png" alt="image-20210906215822732"></p>
<p>通过lsof命令，如果没有任何显示，则端口没有被打开。</p>
<p><img src="D:/hwh/images/image-20210906215941036.png" alt="image-20210906215941036"></p>
</li>
<li><p><strong>join和left join区别</strong></p>
<p><strong>join相当于我们平时用的where</strong>，就是把两张表中同时满足a.id=b.id的数据找出来；left join是以左表（a）为参考对象，相当于做一个for循环，把a表的数据一条一条的读取出来，然后根据a.id=b.id的条件到b表中查找数据。</p>
</li>
<li><p><strong>unio和unio all的区别</strong></p>
<p>如果我们需要将<strong>两个select语句的结果作为一个整体显示出来</strong>，我们就需要用到union或者union all关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select employee_id,job_id from employees union select employee_id,job_id from job_history</span><br></pre></td></tr></table></figure>

<p><strong>union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来</strong>，不管是不是重复。</p>
</li>
<li><p><strong>unio 和 join的区别</strong></p>
<blockquote>
<p> 参考：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/30975.htm">https://www.jb51.net/article/30975.htm</a></p>
</blockquote>
<p>join是对两个表进行联合，相当于where，满足条件的行会被选出，<strong>其中列会被扩充！</strong>  但unio是连接结果集，需要满足列个数相同，<strong>只会保存第一个表列个数，列个数不会被扩充！</strong></p>
</li>
<li><p>.<strong>数据库的事务如何实现的？</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://draveness.me/mysql-transaction/">https://draveness.me/mysql-transaction/</a></p>
</blockquote>
<p>数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。</p>
<ul>
<li><p><strong>原子性</strong></p>
<p>想要保证<strong>事务的原子性</strong>，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，而在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong>实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p>
</li>
<li><p><strong>持久性</strong></p>
<p>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</p>
<p>当我们在一个事务中尝试对数据进行修改时，它会先将数<strong>据从磁盘读入内存，并更新内存中缓存的数据</strong>，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，<strong>MySQL 会将重做日志缓存中的内容刷新到重做日志文件</strong>，再将内存中的数据更新到磁盘上，图中的第 4、5 步就是在事务提交时执行的。</p>
</li>
<li><p><strong>隔离性</strong></p>
<p>在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；</p>
<p>数据库对于隔离级别的实现就是使用<strong>并发控制机制</strong>对在同一时间执行的事务进行控制：</p>
<ol>
<li><p><strong>锁</strong>： MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p>
</li>
<li><p><strong>mvcc实现</strong>：实现RC和RR。</p>
</li>
</ol>
</li>
<li><p><strong>一致性</strong></p>
<p>数据库对于 ACID 中的一致性的定义是这样的：<strong>如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的</strong>。</p>
<ul>
<li>它的第一层意思就是对<strong>于数据完整性的约束</strong>，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</li>
<li>第二层意思其实是指逻辑上的对<strong>于开发者的要求</strong>，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>binlog日志是做什么的？</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5907254.html">https://www.cnblogs.com/kevingrace/p/5907254.html</a></p>
</blockquote>
<p>MySQL的二进制日志binlog可以说是MySQL最重要的日志，<strong>它记录了所有的DDL和DML语句（除了数据查询语句select）</strong>，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p>
<blockquote>
<p>DDL<br>- Data Definition Language 数据库定义语言<br>主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>
<p>DML<br>- Data Manipulation Language 数据操纵语言<br>主要的命令是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</p>
</blockquote>
<p>binlog日志有两个最重要的使用场景<br>1）<strong>MySQL主从复制</strong>：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到<br>master-slave数据一致的目的。<br>2）<strong>自然就是数据恢复了</strong>，通过使用mysqlbinlog工具来使恢复数据。</p>
</li>
<li><p><strong>arraylist可以存多少数据</strong></p>
<p>Integer.MAX_VALUE 2147483647 。arraylist底层是一个数组对象Object[] arr = new Object[10]; 数组的大小只能设置int类型。</p>
</li>
<li><p><strong>如何自定义类加载器 ，如何打破双亲委派机制</strong></p>
<p>在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line"> 2     throws ClassNotFoundException</span><br><span class="line"> 3     &#123;</span><br><span class="line"> 4     // First, check if the class has already been loaded</span><br><span class="line"> 5     Class c = findLoadedClass(name);</span><br><span class="line"> 6     if (c == null) &#123;</span><br><span class="line"> 7         try &#123;</span><br><span class="line"> 8         if (parent != null) &#123;</span><br><span class="line"> 9             c = parent.loadClass(name, false);</span><br><span class="line">10         &#125; else &#123;</span><br><span class="line">11             c = findBootstrapClass0(name);</span><br><span class="line">12         &#125;</span><br><span class="line">13         &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">14             // If still not found, then invoke findClass in order</span><br><span class="line">15             // to find the class.</span><br><span class="line">16             c = findClass(name);</span><br><span class="line">17         &#125;</span><br><span class="line">18     &#125;</span><br><span class="line">19     if (resolve) &#123;</span><br><span class="line">20         resolveClass(c);</span><br><span class="line">21     &#125;</span><br><span class="line">22     return c;</span><br><span class="line">23     &#125;</span><br></pre></td></tr></table></figure>

<p>1、<strong>如果不想打破双亲委派模型，那么只需要重写findClass方法即可</strong></p>
<p><strong>（1）继承ClassLoader</strong></p>
<p><strong>（2）重写findClass()方法</strong></p>
<p>2、<strong>如果想打破双亲委派模型，那么就重写整个loadClass方法</strong></p>
<p><strong>（1）继承ClassLoader</strong></p>
<p><strong>（2）重写findClass()方法</strong>6</p>
<p><strong>（3）调用defineClass()方法</strong></p>
<p>tomcat 为什么要违背双亲委托机制</p>
<blockquote>
<p>1） 双亲委托机制不能满足tomcat的业务需求</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>2） Webapp类加载器需要独立加载自身的class以及依赖的jar</p>
<ol start="3">
<li>例如，<strong>webapp1</strong>依赖的spring版本为4.x，另一个<strong>webapp2</strong>依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求</li>
</ol>
</blockquote>
<ol start="9">
<li><p><strong>syn锁静态和非静态</strong></p>
<p><strong>锁静态方法的是当前类；锁方法是当前对象，锁代码块就是（）中配置的对象。</strong></p>
<ol>
<li>直接作用于实例方法，相当于给当前对象加锁，进入同步代码前要获得当前实例的锁。这个锁称为对象锁，加锁的对象是当前实例，<strong>两个线程使用的是同一个对象</strong>。其他同步方法需要等待其执行结束并释放锁后才能执行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Something()&#123;</span><br><span class="line">    public synchronized void isSyncA()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized void isSyncB()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void cSyncA()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized void cSyncB()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现又Something的两个实例，x和y</span><br><span class="line"></span><br><span class="line">x.isSyncA()与 x.isSyncB()--------------------互斥（同一个实例）</span><br><span class="line"></span><br><span class="line">x.isSyncA()与 y.isSyncA()--------------------互相不影响（不同实例）</span><br><span class="line"></span><br><span class="line">x.cSyncA()与 y.cSyncB()----------------------互相不影响（不同实例之间不会被限制）</span><br><span class="line"></span><br><span class="line">x.isSyncA()与 Something.cSyncA()--------互相不影响（锁不同）</span><br><span class="line">Something.cSyncA() 和 Something.cSyncB() 应该是锁住了，同一个类调用</span><br></pre></td></tr></table></figure></li>
<li><p><strong>本地java程序默认启动的是什么垃圾回收器？</strong></p>
<p>cmd执行命令：</p>
<p>java -XX:+PrintCommandLineFlags -version。</p>
<p>输出：<a target="_blank" rel="noopener" href="http://codewenda.com/xx%EF%BC%9Auseparallelgc%E5%92%8C-xx%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-useparnewgc/">-XX：UseParallelGC</a>，</p>
</li>
<li><p><strong>分布式锁和分布式事务？</strong></p>
<p>见之前总结。</p>
</li>
<li><p><strong>什么时候需要使用分布式锁？</strong> </p>
<ul>
<li>在<strong>单体应用的</strong>时候，如果<strong>多个线程要访问共享资源的时候，我们通常线程间加锁的机制</strong>，在某一个时刻，只有一个线程可以对这个资源进行操作，其他线程需要等待锁的释放，Java中也有一些处理锁的机制，比如synchronized。</li>
<li>而到了<strong>分布式的环境</strong>中，当<strong>某个资源可以被多个系统访问使用到的时候（例如，有多个客户端需要访问并操作同一个资源，还需要保持这个资源一致性的时候，就需要使用【分布式锁）</strong>，为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这时候<strong>线程之间的锁机制就无法起到作用</strong>了，因为分布式环境中，系统是会部署到不同的机器上面的，那么就需要【分布式锁】了。</li>
</ul>
</li>
<li><p><strong>JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111809384">https://zhuanlan.zhihu.com/p/111809384</a></p>
</blockquote>
<ul>
<li><p><strong>堆划分：</strong>堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。</p>
</li>
<li><p><strong>为什么划分新生代、老年代？</strong></p>
<p>因为有的对象寿命长，有的对象寿命短<strong>。应该将寿命长的对象放在一个区，寿命短的对象放在一个区</strong>。<strong>不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率</strong>。</p>
</li>
<li><p><strong>代替：</strong> 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。<strong>但在物理上来说，它们又是连续的一块内存。</strong></p>
<img src="D:/hwh/images/image-20210906224656302.png" alt="image-20210906224656302" style="zoom:50%;" />

<p><strong>也就是说，方法区和前面讲到的Eden和老年代是连续的。</strong></p>
<p><strong>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</strong></p>
<img src="D:/hwh/images/image-20210906224744446.png" alt="image-20210906224744446" style="zoom:50%;" />

<p>在Java8中，元空间(Metaspace)登上舞台，<strong>方法区存在于元空间(Metaspace)<strong>。同时，元空间不再与堆连续，</strong>而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap</strong>，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p>
<img src="D:/hwh/images/image-20210906224848120.png" alt="image-20210906224848120" style="zoom:50%;" />

<p><strong>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了。</strong></p>
</li>
</ul>
</li>
<li><p><strong>新生代和老年代用哪些<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>？stw问题会发生在新生代吗？</strong></p>
<ul>
<li><p><strong>针对新生代，采用标记复制算法</strong>。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p>
</blockquote>
<p>大多数对象在新生代中被创建，其中很多对象的生命周期很短。<strong>每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活</strong>，所以选用复制算法，只需要<strong>少量的复制成本</strong>就可以完成回收。</p>
<p>HotSpot实现的<strong>复制算法流程</strong>如下:</p>
<p>  1. 当Eden区满的时候,<strong>会触发第一次Minor gc,把【还活着的对象】拷贝到Survivor From区</strong>；当Eden区<strong>【再次触发Minor gc】</strong>的时候,会扫描Eden区和From区域,<strong>对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域</strong>,并将Eden和From区域清空。<br>  2. 当后续Eden又发生Minor gc的时候,会对<strong>Eden和To区域进行垃圾回收</strong>,存活的对象复制到From区域,并将Eden和To区域清空。<br>  3. 部分对象会在From和To区域中复制来复制去**,如此交换15次**(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p>
</li>
<li><p><strong>针对老年代对象存活率高的特点</strong></p>
<p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，<strong>该区域中对象存活率高</strong>。老年代的垃圾回收（又称Major GC）通常使用<strong>“标记-清理”或“标记-整理”算法</strong>。<strong>整堆包括新生代和老年代的垃圾回收称为Full GC</strong>（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</p>
</li>
</ul>
</li>
<li><p><strong>程序计数器存哪些东西？能为空吗？</strong> </p>
<p>程序计数器是用于存放下一条指令所在单元的地址的地方，如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。</p>
</li>
<li><p><strong>为什么 HashMap 的负载因子设置成 0.75，而不是 1 也不是 0.5？</strong></p>
<p><strong>在 HashMap 中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。</strong>    </p>
<p><strong>那么如何能有效的避免哈希碰撞呢？</strong></p>
<p>我们先反向思维一下，你认为什么情况会导致 HashMap 的哈希碰撞比较多？</p>
<p>无外乎两种情况：</p>
<p>1、容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。</p>
<p>2、hash 算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。</p>
<p><strong>为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容</strong>。那就是当其中的元素个数达到临界值的时候（<strong>【等全满了再扩容，那么在此之前容量太少，导致碰撞的概率过高】</strong>），而这个临界值前面说过和 loadFactor 有关，换句话说，<strong>设置一个合理的 loadFactor</strong>，可以有效的避免哈希冲突。</p>
<blockquote>
<p>JVM中原话：</p>
<p><strong>一般来说，默认的负载因子 (0.75) 在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在 HashMap 类的大多数操作中，包括 get 和 put)。</strong></p>
<p>另一方面，<strong>为了保证负载因子（loadFactor） * 容量（capacity）的结果是一个整数，这个值是 0.75(3/4) 比较合理，因为这个数和任何 2 的幂乘积结果都是整数。</strong></p>
</blockquote>
</li>
<li><p><strong>ConcurrenthashMap使用的时候有可能出现不安全的情况？</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luzhensmart/article/details/108133560">https://blog.csdn.net/luzhensmart/article/details/108133560</a></p>
</blockquote>
<p>查了一些资料后发现，<strong>原来ConcurrentHashMap的线程安全指的是，它的【每个方法】单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制。</strong>以上面的代码为例，最后一行中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            this.addup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void addup() &#123;</span><br><span class="line">        if (!map.containsKey(KEY)) &#123;</span><br><span class="line">            map.put(KEY, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(KEY, map.get(KEY) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在上面一个线程内部进行了100次加法，但是其实加1在线程内部本身也并不是原子操作。</strong></p>
<p>实际上并不是原子操作，它包含了三步：</p>
<ol>
<li>map.get</li>
<li>加1</li>
<li>map.put</li>
</ol>
<p>是由于在上面的代码中，map本身是一个共享变量。<strong>当线程A执行map.get的时候，其它线程可能正在执行map.put</strong>，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，然后脏数据覆盖了真值，导致线程不安全。</p>
</li>
<li><p><strong>同步和异步的区别？</strong></p>
<ul>
<li><p>同步，可以理解为在执行完一个函数或方法之后，<strong>一直等待系统返回值或消息，这时程序是出于阻塞的</strong>，只有接收到返回的值或消息后才往下执行其他的命令。  </p>
</li>
<li><p>异步，执行完函数或方法后，<strong>不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程</strong>，那么当系统接收到返回值或消息时，系统会<strong>自动触发委托的异步过程</strong>，从而完成一个完整的流程。 </p>
</li>
</ul>
</li>
<li><p><strong>wait和notify为什么要放在同步锁里？</strong></p>
<p>结合多线程循环打印的例子来看，不放在同步块里，要唤醒等待对象是哪个锁就不够明显。</p>
</li>
<li><p><strong>说说Treemap的底层原理？</strong></p>
<p>TreeMap实现了SotredMap接口，它是有序的集合。<strong>而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。</strong>如果在调用<strong>TreeMap的构造函数时没有指定比较器，则根据key执行自然排序</strong>。这点会在接下来的代码中做说明，如<strong>果指定了比较器则按照比较器来进行排序</strong>。</p>
<ul>
<li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li>
<li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li>
</ul>
</li>
</ol>
<h3 id="1-7-2-Shoope-SG专场"><a href="#1-7-2-Shoope-SG专场" class="headerlink" title="1.7.2 Shoope SG专场"></a><strong>1.7.2 Shoope SG专场</strong></h3><ol>
<li><p><strong>char和byte的区别 ， 能否强制转换？</strong></p>
<p>区别：</p>
<ul>
<li>Char是无符号型的，可以表示一个整数，不能表示负数，大小范围 是0—65535；而byte是有符号型的，可以表示-128—127 的数</li>
<li>char可以表中英文字符，byte不可以</li>
</ul>
<p>强制转换：</p>
<p>可以，但是会出现精度丢失。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>哪些是稳定的，稳定性体现在哪？</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">直接选择排序</a>是不稳定的排序算法，而<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">折半插入排序</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>是稳定的排序算法。</p>
<ul>
<li><strong>稳定性</strong>：<strong>2个相等的数其在序列的前后位置顺序</strong>，和排序后它们两个的前后位置顺序<strong>相同</strong></li>
</ul>
</li>
<li><p><strong>数据库乐观锁和悲观锁，如何实现</strong></p>
<p>乐观锁：</p>
<ol>
<li>版本号</li>
<li>时间戳：乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ol>
<p>悲观锁：</p>
<p>直接加上读锁或者写锁，SELECT … FOR UPDATE</p>
</li>
<li><p><strong>如何以UDP为基础设计实现TCP协议优点的新协议</strong> </p>
</li>
<li><p><strong>web网页卡怎么排查？cpu100%怎么排查？OOM怎么排查？</strong></p>
<p>web卡：</p>
<ol>
<li><strong>用户端：</strong>硬件配置低、资源不足；CPU 或者内存资源不足, 比如用户是否使用了 Chrome 这种 “吃内存大户” 的浏览器并且打开了很多网页?</li>
<li><strong>网络分析：</strong> <strong>DNS 解析慢</strong>；<strong>未设置 CDN</strong>，如果没有设置 CDN, 在跨线路访问(比如用户是铁通, 但是服务器部署在联通, 这种情况就是跨线路), 地理位置相差很远 等情况 ；用户端的带宽不足或所处环境网络不佳；</li>
<li><strong>服务端：</strong> 服务端响应慢，性能比较差 </li>
</ol>
<p>cpu100%：</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dennyzhangdd/p/11585971.html">https://www.cnblogs.com/dennyzhangdd/p/11585971.html</a></p>
</blockquote>
<ol>
<li><p><strong>执行“top”命令</strong><code>：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</code></p>
</li>
<li><p>执行“<strong>top -Hp 进程号</strong>”命令：查看java进程下的<strong>所有线程占CPU的情况</strong>。</p>
</li>
<li><p>执行“printf “%x\n 10”命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf “%x\n 10-》打印：a，那么在jstack中线程号就是0xa.</p>
</li>
<li><p>执行 <strong>“jstack 进程号 | grep 线程ID” 查找某进程下</strong>-》线程ID（jstack堆栈信息中的nid）=0xa的<strong>线程状态</strong>。如果“”VM Thread” os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了。</p>
<p>代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢, </p>
<blockquote>
<ol>
<li><p>jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。</p>
</li>
<li><p> 如果有死锁，会直接提示关键字：deadlock。步骤4，会打印出业务死锁的位置。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，<strong>查看某进程GC持续变化情况</strong>，<strong>如果发现返回中FGC很大且一直增大-》确认Full GC!</strong> 也可以使用“<strong>jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了</strong>，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p>
<blockquote>
<p>jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加</p>
</blockquote>
</li>
<li><p>执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多</p>
</li>
</ol>
<p>OOM排查：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/valjeanshaw/p/13130102.html">https://www.cnblogs.com/valjeanshaw/p/13130102.html</a></p>
</blockquote>
<p>先通过内存映像工具对Dump出来的堆转储快照进行分析，<strong>重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=$java_pid.hprof     #java_pid为java进程ID</span><br></pre></td></tr></table></figure>

<p>然后看具体是报什么错：很明显下面是堆溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to oom.out ...</span><br><span class="line">Heap dump file created [3196858 bytes in 0.016 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at java.util.Arrays.copyOf(Arrays.java:3332)</span><br><span class="line">        at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span><br><span class="line">        at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700)</span><br><span class="line">        at java.lang.StringBuilder.append(StringBuilder.java:214)</span><br><span class="line">        at jvm.OomDemo.main(OomDemo.java:13)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如何利用反射创建一个对象？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 得到Stu类的运行时Class描述符</span></span><br><span class="line">            <span class="comment">//简单理解为你现在有了这个类，可以调用相应的方法进行实例化了</span></span><br><span class="line">            Class&lt;?&gt; stu = Class.forName(<span class="string">&quot;Stu&quot;</span>);</span><br><span class="line">            <span class="comment">//2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器</span></span><br><span class="line">            <span class="comment">//这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">            <span class="comment">//3. 使用newInstance()方法创建对象并传入参数</span></span><br><span class="line">            <span class="comment">//简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01)</span></span><br><span class="line">            Stu o = (Stu) declaredConstructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">01</span>&#125;);</span><br><span class="line">            <span class="comment">//4.调用Stu这个类里面的方法</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod()方法能调用到所有声明的方法</span></span><br><span class="line">            Method method = stu.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">            <span class="comment">//5. 简单的理解为o.toStirng()</span></span><br><span class="line">            String invoke = (String)method.invoke(o, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">            System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>加密了解的<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a> 说说具体怎么实现的 ？</strong></p>
</li>
<li><p><strong>我现在有个字段比如，它的值可能正，可能负（形容方向），而我的sql查询该字段时要计算它的绝对值，这样因为计算了索引会失效，你会怎么优化？</strong></p>
<ol>
<li>拆成两列1列只存绝对值，另起一列tinyint来表示正负或者方向；</li>
<li>先查询到结果，然后再查询的结果上进行操作（取绝对值）？</li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/">http://example.com/2021/11/25/校招笔记（一）_JAVA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a></div><div class="post_share"><div class="social-share" data-image="/img/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库（二）Redis基础</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（二）_计算机基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="校招笔记（二）_计算机基础"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">校招笔记（二）_计算机基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JAVA"><span class="toc-text">一、JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JAVA%E5%85%A5%E9%97%A8"><span class="toc-text">1.1  JAVA入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-JAVA%E5%9F%BA%E6%9C%AC"><span class="toc-text">1.1.1 JAVA基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJVM-amp-JRE-amp-JDK%EF%BC%9F-JAVA%E8%AF%AD%E8%A8%80%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">1. 介绍一下JVM&amp;JRE&amp;JDK？ JAVA语言有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFJava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A2%AB%E7%A7%B0%E4%B8%BA%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-text">2. 什么是Java虚拟机？为什么Java被称为平台无关的编程语言？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88Java%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%E5%AE%9E%E4%BE%8B%EF%BC%89"><span class="toc-text">3. 请你谈谈Java中是如何支持正则表达式操作的？（补充实例）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E7%A4%BA%E8%8C%83%EF%BC%88PCG%E9%97%AE%E8%BF%87%EF%BC%89"><span class="toc-text">实例示范（PCG问过）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%EF%BC%88%E8%A1%A5%E5%85%85%E4%BE%8B%E5%AD%90%EF%BC%89%E8%AF%B7%E4%BD%A0%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94%E3%80%82"><span class="toc-text">4. （补充例子）请你简单描述一下正则表达式及其用途。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-amp-%E5%92%8C-amp-amp-%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">5. &amp;和&amp;&amp;区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">6. 值传递和引用传递区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%9F"><span class="toc-text">7. 十进制与二进制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89equals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. （重要）equals与&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B7%E8%A7%A3%E9%87%8AhashCode-%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-text">7. 请解释hashCode()和equals()方法有什么联系？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99%E4%BA%86equals-%E4%B8%80%E5%AE%9A%E8%A6%81%E9%87%8D%E5%86%99hashcode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">7.1 为什么重写了equals()一定要重写hashcode()方法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%80%BC%E7%9B%B8%E5%90%8C-x-equals-y-true-%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hash-code%EF%BC%8C%E8%AF%A5%E8%AF%B4%E6%B3%95%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7.2 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，该说法是否正确，为什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%9F"><span class="toc-text">8. 自动拆箱和装箱？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-String-amp-StringBuffer-amp-StringBuilder-%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88String%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">9.  String &amp; StringBuffer&amp; StringBuilder 区别？为什么String不可变?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%AF%B4%E8%AF%B4%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">10. 说说深拷贝和浅拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E3%80%90%E6%96%B0%E5%A2%9E%E3%80%91%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJDK1-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">11. 【新增】介绍一下JDK1.8的新特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E3%80%90%E6%96%B0%E5%A2%9E%E3%80%91java%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E8%83%BD%E4%B8%8D%E8%83%BD%E6%9C%89%E5%A4%9A%E4%B8%AAmain%E6%96%B9%E6%B3%95%EF%BC%9F%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%87%8C%E5%91%A2%EF%BC%9F"><span class="toc-text">12. 【新增】java一个程序能不能有多个main方法？一个类里呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1.1.2 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%AE%B2%E8%AE%B2Java%E9%87%8C%E9%9D%A2%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">1. 请你讲讲Java里面的final关键字是怎么用的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8ESynchronized%E5%92%8Clock-%EF%BC%9F"><span class="toc-text">2. 【重点】请你谈谈关于Synchronized和lock ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-instanceof-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8-%EF%BC%9F"><span class="toc-text">3. instanceof 关键字的作用 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-final%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-text">4. final有哪些用法?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-static%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-text">5. static都有哪些用法 ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%B0%88%E4%B8%80%E8%B0%88transient%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="toc-text">6. 谈一谈transient关键字？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-HashMap%E4%B8%AD%E6%BA%90%E7%A0%81modCount%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8tranisent%E4%BF%AE%E9%A5%B0%EF%BC%9F"><span class="toc-text">7.1 HashMap中源码modCount为什么用tranisent修饰？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-Java%E5%BC%82%E5%B8%B8"><span class="toc-text">1.1.3 Java异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-text">1. Java常见异常和分类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-OOM%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-text">2. OOM产生原因和分析？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-try-catch-finally%EF%BC%8Ctry%E9%87%8C%E6%9C%89return%EF%BC%8Cfinally%E8%BF%98%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F"><span class="toc-text">3. try catch finally，try里有return，finally还执行么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="toc-text">4. 说说你是怎么处理异常的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.2 面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.1 基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9F%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">1. 介绍一下面对对象七大原则？三大特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">七大原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">三大特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-java%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E3%80%90%E9%98%BF%E9%87%8C-amp-%E5%BE%85%E9%87%8D%E5%86%99%E3%80%91"><span class="toc-text">1.1 java多态的原理？【阿里&amp;待重写】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E8%A7%A3%E9%87%8AJava%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">2. 请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E8%AF%B4%E6%98%8EJava%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-Overriding-%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-Overloading-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-text">3. 请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-f%EF%BC%88List-lt-String-gt-l%EF%BC%89-f%EF%BC%88List-lt-Integer-gt-l%EF%BC%89%E6%98%AF%E9%87%8D%E8%BD%BD%E4%B9%88%EF%BC%9F"><span class="toc-text">3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4. 介绍一下接口和抽象类的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9F%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A-%EF%BC%9F"><span class="toc-text">5. Java的四种引用？强软弱虚 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-JAVA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">6. JAVA创建对象的机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%AE%80%E8%BF%B0Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">7. 简述Java的对象结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Object-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">8. Object 有哪些常用方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%8F%8D%E5%B0%84"><span class="toc-text">1.2.2 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8BJAVA%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E5%92%8C%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%EF%BC%88%E5%BF%AB%E6%89%8B%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">1. 请说明一下JAVA中反射的实现过程和作用分别是什么？ （快手）优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%EF%BC%88%E6%9C%AA%EF%BC%89%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJAVA%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">2. （未）解释一下JAVA代理模式？动态代理的原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.1 静态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.2 动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">2.3 动态代理的原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%9B%86%E5%90%88"><span class="toc-text">1.3 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">1.3.1 集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E8%AF%B4%E6%98%8EJava%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1. 请说明Java集合类框架的基本接口有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%9A%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%89%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%EF%BC%9F"><span class="toc-text">2. （补充：举例说明）说说什么是fail-fast？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E8%AF%B4%E6%98%8EList%E3%80%81Map%E3%80%81Set%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">3. 请说明List、Map、Set三个接口区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E8%AE%B2%E8%AE%B2%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">4. 请讲讲你所知道的常用集合类以及主要方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-Map-amp-Set"><span class="toc-text">1.3.2 Map &amp; Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bmap%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">1. 请你介绍一下map的分类和常见的情况？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E3%80%90%E7%99%BE%E5%BA%A6%E3%80%91-TreeMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.1 【百度】 TreeMap的底层实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E9%97%AEHashMap%E5%92%8CHashtable%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. 请问HashMap和Hashtable区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E9%97%AEMap%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%9AHashMap%E3%80%81Hashtable%E5%92%8CConcurrentHashMap%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3. 请问Map接口实现：HashMap、Hashtable和ConcurrentHashMap区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%BA%A2%E9%BB%91%E6%A0%91%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-text">4. 说一说红黑树特征？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-hashmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%8C%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F%EF%BC%88rehash%EF%BC%89%EF%BC%9F"><span class="toc-text">5. hashmap的基本原理，扩容方式（rehash）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E9%BB%98%E8%AE%A4%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E8%B6%85%E8%BF%878%E8%BD%AC%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF6%E3%80%817%E6%88%969%EF%BC%9F"><span class="toc-text">5.1 为什么HashMap默认链表长度超过8转为红黑树，而不是6、7或9？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-HashMap-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">5.2  HashMap 多线程操作导致死循环问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E8%AF%B4%E8%AF%B4HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">5.3 说说HashMap的put方法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E8%AF%B4%E8%AF%B4HashMap%E7%9A%84get%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">5.4 说说HashMap的get方法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-%E3%80%90%E7%99%BE%E5%BA%A6%E3%80%91rehash%E6%89%A9%E5%AE%B9%E6%97%B6%E6%9C%BA%EF%BC%9F%E5%9C%A8%E6%8F%92%E5%85%A5%E5%89%8D%E8%BF%98%E6%98%AF%E6%8F%92%E5%85%A5%E5%90%8E%EF%BC%9F"><span class="toc-text">5.5 【百度】rehash扩容时机？在插入前还是插入后？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-hashmap%E5%9C%A81-7%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95%EF%BC%9F"><span class="toc-text">5.6 hashmap在1.7版本之前为什么使用头插法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-Hashmap-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86key%E5%92%8Cvalue%E4%B8%BAnull%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">5.7 Hashmap 怎么处理key和value为null的情况？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Hashtable-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">6. Hashtable 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%EF%BC%88%E5%AE%B9%E6%98%93%E5%BF%98%EF%BC%89HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%9F"><span class="toc-text">6.1 （容易忘）HashMap 和 Hashtable 的区别 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%9F"><span class="toc-text">6.2 ConcurrentHashMap 和 Hashtable 的区别 ？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-ConcurrentHashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-%EF%BC%9F"><span class="toc-text">7.  ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-%E4%BD%A0%E7%9F%A5%E9%81%93-ConcurrentHashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">7.1 你知道 ConcurrentHashMap 的工作原理吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-%E8%AF%B7%E9%97%AEConcurrentHashMap%E4%B8%AD%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8final%E5%92%8Cvolatile%E4%BF%AE%E9%A5%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2%EF%BC%9F%E5%85%B6%E4%B8%AD%E9%93%BE%E8%A1%A8%E6%98%AFfinal%E7%9A%84next%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%91%E7%94%9F%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">7.2 请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-HashTable%E4%B8%8EConcurrentHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%8F%8F%E8%BF%B0%E9%94%81%E5%88%86%E6%AE%B5%E6%8A%80%E6%9C%AF%E3%80%82"><span class="toc-text">7.3 HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-%EF%BC%88%E9%98%BF%E9%87%8C%C2%B7%E6%B7%98%E7%89%B9%EF%BC%89ConcurrentHashMap1-8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%9F"><span class="toc-text">7.4 （阿里·淘特）ConcurrentHashMap1.8为什么不使用分段锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5-%E4%B8%BA%E4%BB%80%E4%B9%881-8%E4%B8%AD-get-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%8A%A0%E9%94%81%EF%BC%9F"><span class="toc-text">7.5 为什么1.8中 get() 方法不加锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-6-%E4%B8%BA%E4%BB%80%E4%B9%881-8%E4%B8%8D%E4%BD%BF%E7%94%A8lock%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8sync%EF%BC%9F"><span class="toc-text">7.6 为什么1.8不使用lock而是使用sync？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-HashMap-%E5%92%8C-HashSet%E5%8C%BA%E5%88%AB-%EF%BC%9F"><span class="toc-text">8. HashMap 和 HashSet区别 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%AF%B4%E8%AF%B4HashSet%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">9. 说说HashSet的基本原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D-%EF%BC%9F"><span class="toc-text">9. 1 HashSet如何检查重复 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-%E3%80%90%E6%96%B0%E3%80%91contains-%E6%96%B9%E6%B3%95%E5%9C%A8HashSet%E5%92%8CArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">9.2 【新】contains()方法在HashSet和ArrayList的实现区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%9F"><span class="toc-text">10. comparable 和 Comparator**的区别 **？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-text">11.  如何选用集合?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-List"><span class="toc-text">1.3.3 List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E8%BF%87-ArrayList-%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">1. 用过 ArrayList 吗？说一下它有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ArrayList-%E4%B8%8E-Vector-%E5%8C%BA%E5%88%AB%E5%91%A2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Arraylist%E5%8F%96%E4%BB%A3Vector%E5%91%A2%EF%BC%9F"><span class="toc-text">2. ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Array-amp-ArrayList%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-text">3. Array &amp; ArrayList不同点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-text">4. Arraylist 与 LinkedList 区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E3%80%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E3%80%91%E8%AF%B4%E8%AF%B4ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%90%A7-%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A9%E5%AE%B91-5%E5%80%8D%EF%BC%9F%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%E3%80%82"><span class="toc-text">5. 【源码解读】说说ArrayList的扩容机制吧 ？为什么是扩容1.5倍？默认大小是多少。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9CArrayList%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-text">5.1 多线程操作ArrayList会出现什么错误？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B4%E4%B8%80%E4%B8%8BLinkedList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">6. 说一下LinkedList底层原理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">1.3.4 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-text">1. 请简单说明一下什么是迭代器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4Iterator%E5%92%8CListIterator%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. 请你说说Iterator和ListIterator的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.4 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BB%96%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0A%E3%80%81B%E3%80%81C%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B010%E6%AC%A1%E5%91%A2%EF%BC%9F%E4%BE%9D%E6%AC%A1%E6%89%93%E5%8D%B01-100%E5%91%A2%EF%BC%9F%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B610%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">0. 三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1-synchronized-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">0.1 synchronized + 条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-2-join"><span class="toc-text">0.2 join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-3-Lock"><span class="toc-text">0.3 Lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-4-Semaphore"><span class="toc-text">0.4 Semaphore</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC"><span class="toc-text">1.4.1 线程基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%9F-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">1. 什么是线程和进程？ 如何保证线程安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.1 什么是线程和进程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">1.2 如何保证线程安全？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-text">1.3 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E9%9D%9E%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89%EF%BC%9F-%E5%93%AA%E7%A7%8D%E6%9C%80%E5%A5%BD%EF%BC%9F"><span class="toc-text">2. 创建线程的方式（非线程池）？ 哪种最好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">3. 如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AFDaemon%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">4. 什么是Daemon线程？它有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. 说说CyclicBarrier和CountDownLatch的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B7%E4%BD%A0%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">6. 请你简要说明一下线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7. notify()和notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-sleep-%E5%92%8Cwait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8. sleep()和wait() 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">8.1 Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-java-%E4%B8%ADWait%E3%80%81Sleep%E5%92%8CYield%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8.2 java 中Wait、Sleep和Yield方法的区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-volatile-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E5%90%97"><span class="toc-text">9. volatile 是什么?可以保证有序性吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%EF%BC%88%E8%A6%81%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3wait%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E9%87%8C%E5%85%88%E8%B7%B3%E8%BF%87%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify-%E5%92%8C-notifyAll%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8thread%E7%B1%BB%E9%87%8C%E9%9D%A2%EF%BC%9F"><span class="toc-text">10. （要深入了解wait方法，这里先跳过）为什么wait, notify 和 notifyAll这些方法不在thread类里面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-text">11. 为什么wait和notify方法要在同步块中调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%EF%BC%88%E6%B2%A1%E7%BB%86%E7%9C%8B%EF%BC%89Java%E4%B8%ADinterrupted-%E5%92%8C-isInterruptedd%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">12. （没细看）Java中interrupted 和 isInterruptedd方法的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">1.4.2 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88thread-pool%EF%BC%89%EF%BC%9F"><span class="toc-text">1. 请你解释一下什么是线程池（thread pool）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.1 请介绍一下使用线程池任务执行过程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E5%9B%9E%E6%94%B6%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">1.2 线程池会回收核心线程吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">2. 请介绍一下什么是生产者消费者模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3. 线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E5%9B%9B%E5%A4%A7%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%9F%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%EF%BC%88%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4. 如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0corePoolSize%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%91%A2%EF%BC%9F"><span class="toc-text">5. 线程池核心线程数corePoolSize怎么设置呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%EF%BC%88%E4%B8%8D%E7%86%9F%E6%82%89%EF%BC%89Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">6. （不熟悉）Java线程池中队列常用类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9C%89%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1-T2-T3-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">7. 有三个线程T1,T2,T3,如何保证顺序执行？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.4.3 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">1. 请简述一下实现多线程同步的方法？ 为什么需要使用多线程？使用多线程会带来什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">2. 什么是线程安全？如何保证线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-text">3. 线程安全需要保证几个基本特征？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E3%80%90%E5%BE%85%E8%A1%A5%E5%85%85%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="toc-text">4. 【待补充】如何在线程安全的情况下实现一个计数器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84i-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">5. 多线程中的i++线程安全吗？请简述一下原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BThreadLocal%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">6. 介绍一下ThreadLocal原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocal%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">7. 为什么ThreadLocal造成内存泄漏？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">8. 什么是多线程中的上下文切换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%AF%B7%E9%97%AE%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81-deadlock"><span class="toc-text">9. 请问什么是死锁(deadlock)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-JAVA%E4%B8%AD%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9DN%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEN%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6%E5%8F%88%E4%B8%8D%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">10. JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E9%94%81-%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BF%86%E9%83%A8%E5%88%86"><span class="toc-text">1.5 锁(重点记忆部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E3%80%90%E6%96%B0%E5%A2%9E%EF%BC%8C%E4%BD%86%E4%B8%8D%E5%A4%9F%E5%AE%8C%E5%96%84%E3%80%91-java%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F"><span class="toc-text">0.【新增，但不够完善】 java常用的并发工具类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-synchronized-%E7%9B%B8%E5%85%B3"><span class="toc-text">15.1 synchronized 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E9%87%8D%E7%82%B9-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 [重点]说一说自己对于 synchronized 关键字的了解? synchronized 底层原理 ?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8ESynchronized%E5%92%8CReentrantLock%EF%BC%9F"><span class="toc-text">1.2 请你谈谈关于Synchronized和ReentrantLock？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-synchronized%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-text">1.3 synchronized锁住的是什么，在项目中遇到了吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-synchronized%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">1.4 synchronized锁的优化机制了解吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Synchronized%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.5 为什么说Synchronized是非公平锁，这样的优缺点是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4synchronized%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.6  为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-7-%EF%BC%88CAS%E5%8E%9F%E7%90%86%E9%87%8D%E7%82%B9%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9FCAS%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F%E8%AF%B4%E8%AF%B4CAS%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bsynchronized%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">1.8 请说明一下synchronized的可重入怎么实现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-9-%E5%9C%A8synchronized%E5%81%8F%E5%90%91%E9%94%81%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E8%B0%83%E7%94%A8hashcode%E6%96%B9%E6%B3%95%EF%BC%8Cmarkword%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-10-Synchronized-%E7%A1%AE%E5%AE%9A%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AESynchronized-%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%83%BD%E5%90%A6%E4%B8%AD%E6%96%AD%EF%BC%9F%E6%AF%94%E5%A6%82%E4%BD%BF%E7%94%A8Stop%EF%BC%9F%E6%98%AF%E5%9C%A8%E4%B8%AD%E6%96%AD%E5%89%8D%E8%BF%98%E6%98%AF%E4%B8%AD%E6%96%AD%E5%90%8E%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%9F"><span class="toc-text">1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-Reetrantlock-%E7%9B%B8%E5%85%B3"><span class="toc-text">15.2 Reetrantlock 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81%E5%9C%A8reetrantlock%E9%87%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">2.1  非公平锁和公平锁在reetrantlock里的实现过程是怎样的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">2.2 ReentrantLock的实现原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E5%B8%8C%E6%9C%9B%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E9%94%81%E6%B2%A1%E6%9C%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E6%94%BE%E5%BC%83%E7%94%A8%E5%93%AA%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="toc-text">2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-AQS-%E7%9B%B8%E5%85%B3"><span class="toc-text">15.3 AQS 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AFAQS%E8%AF%B7%E4%BD%A0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">3.1 什么是AQS请你简单介绍一下？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BAQS%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">3.2 请介绍一下AQS原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8EFIFO%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="toc-text">3.3 为什么基于FIFO的同步队列可以实现非公平锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-%E3%80%90%E6%98%93%E5%BF%98%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%80%A7%E8%83%BD%E5%A5%BD%EF%BC%9F"><span class="toc-text">3.4 【易忘】为什么非公平锁性能好？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-AQS-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCountDownLatch%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%EF%BC%9F"><span class="toc-text">3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">15.4 Volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-JMM-%E6%98%AF%E4%BB%80%E4%B9%88-%EF%BC%9F-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEMESI-CPU%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9FJAVA%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-text">4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFHappenBefore%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">4.1 什么是HappenBefore原则？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">4.2 Volatile 关键字原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-text">4.3 volatile为什么不能保证原子性？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7-%EF%BC%9F"><span class="toc-text">4.4  并发编程的三个重要特性 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.5 说说 synchronized 关键字和 volatile 关键字的区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">15.5 Atomic 原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AFAtomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9F"><span class="toc-text">5.1 什么是Atomic 原子类？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-JUC-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%93%AA4%E7%B1%BB"><span class="toc-text">5.2 JUC 包中的原子类是哪4类?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-Volatile-%E5%92%8C-atomic-%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5.3 Volatile 和  atomic  变量区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E8%AE%B2%E8%AE%B2-AtomicInteger-%E7%9A%84%E4%BD%BF%E7%94%A8-%EF%BC%9F"><span class="toc-text">5.4 讲讲 AtomicInteger 的使用 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5%EF%BC%88%E9%87%8D%E7%82%B9%E6%8F%90%E9%97%AE%EF%BC%89-AtomicInteger-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">5.5（重点提问） AtomicInteger 原理？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-JVM%E7%9B%B8%E5%85%B3"><span class="toc-text">1.6 JVM相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EF%BC%88%E8%A2%AB%E9%97%AE%E8%BF%87%EF%BC%89JVM%E5%90%AF%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E6%88%96%E8%80%85%E8%AF%B4%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-text">1. （被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.说说堆和栈的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%AF%B7%E9%97%AEJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%88%86%E5%B8%83%EF%BC%9F-%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%EF%BC%9F"><span class="toc-text">3. 【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%EF%BC%88%E6%96%B0%EF%BC%89%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">4. （新）说一下Java创建对象的过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%9F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%EF%BC%9FTLAB"><span class="toc-text">4.1 什么是指针碰撞？空闲列表？TLAB?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-JVM%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">4.2 JVM如何保证对象分配的线程安全问题？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E3%80%90%E5%8E%9F%E5%88%99%E3%80%91%EF%BC%9F%EF%BC%88%E5%8C%BA%E5%88%86%E5%89%8D%E9%9D%A2new%E5%AF%B9%E8%B1%A1%E3%80%90%E8%BF%87%E7%A8%8B%E3%80%91%EF%BC%89"><span class="toc-text">5. 描述一下对象分配【原则】？（区分前面new对象【过程】）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E5%88%86%E9%85%8D%E5%88%B0%E5%A0%86%E4%B8%8A%E5%90%97%EF%BC%9F"><span class="toc-text">5.1 对象一定分配到堆上吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">6. 对象的访问定位有哪两种方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%EF%BC%88%E6%AD%BB%E4%BA%A1%EF%BC%89%EF%BC%9F"><span class="toc-text">7. 如何判断对象是否需要回收（死亡）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%8F%98%E9%87%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%B1%BB%EF%BC%9F"><span class="toc-text">8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-GC%E7%9B%B8%E5%85%B3"><span class="toc-text">1.6.1 GC相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BB%8B%E7%BB%8DGC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9FGC%E5%8F%AF%E4%BB%A5%E9%A9%AC%E4%B8%8A%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%B8%BB%E5%8A%A8%E8%AE%A9%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-text">1. 请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFGC-Root%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Root%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">2. 什么是GC Root？可以作为GC Root的对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E9%9C%80%E8%A6%81GC"><span class="toc-text">3. 哪些内存区域需要GC?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC%EF%BC%9F"><span class="toc-text">4. 什么时候会触发Full GC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91-Minor-GC-%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E4%BC%9A%E5%AF%BC%E8%87%B4minor-gc%E8%BF%90%E8%A1%8C%E9%A2%91%E7%B9%81%EF%BC%9F%E5%90%8C%E6%A0%B7%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%8F%88%E4%BC%9A%E5%AF%BC%E8%87%B4minor-gc%E8%BF%90%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%9F"><span class="toc-text">5. 什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BGC%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">6. 描述一下GC算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AFStop-The-World-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9F%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-text">7. 什么是Stop The World ? 什么是安全点？安全区域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E6%AF%94%E5%A6%82G1%EF%BC%89%EF%BC%9F"><span class="toc-text">8. 常见的垃圾回收器有哪些（比如G1）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCMS-%E5%92%8C-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">8.1 介绍一下CMS 和 G1 垃圾回收器原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-%E4%B8%BA%E4%BB%80%E4%B9%88CMS%E4%B8%8D%E7%94%A8%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">8.2 为什么CMS不用标记-压缩算法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">9. 什么是内存泄漏？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">1.6.2 类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EF%BC%88%E6%B2%A1%E8%AE%B0%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">1. （没记）介绍一下类文件结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bjava%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">2. 什么是类加载器？请你解释一下java程序运行的过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%EF%BC%88C-%E7%89%88%E6%9C%AC%EF%BC%89%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9D%9F%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">2.1 （C++版本）一个程序从开始到完整结束的过程？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%9F%A5%E9%81%93%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">3. 知道类的生命周期吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-text">4. 请你介绍一下类加载器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">5. 请你介绍一下双亲委派机制？为什么要这么做？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E9%9D%A2%E7%BB%8F%E8%A1%A5%E5%85%85"><span class="toc-text">1.7 面经补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-1-%E7%BE%8E%E5%9B%A2%E4%B9%B0%E8%8F%9C%E4%B8%93%E5%9C%BA"><span class="toc-text">1.7.1 美团买菜专场</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-2-Shoope-SG%E4%B8%93%E5%9C%BA"><span class="toc-text">1.7.2 Shoope SG专场</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" title="前端基础（一）JavaScript基础笔记(上)">前端基础（一）JavaScript基础笔记(上)</a><time datetime="2021-11-25T12:37:58.119Z" title="发表于 2021-11-25 20:37:58">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89/" title="前端基础（一）JavaScript基础笔记(中)">前端基础（一）JavaScript基础笔记(中)</a><time datetime="2021-11-25T12:36:37.921Z" title="发表于 2021-11-25 20:36:37">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0/" title="前端基础（二）CSS基础笔记">前端基础（二）CSS基础笔记</a><time datetime="2021-11-25T10:45:45.161Z" title="发表于 2021-11-25 18:45:45">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/" title="前端基础（一）JavaScript基础笔记（下）">前端基础（一）JavaScript基础笔记（下）</a><time datetime="2021-11-25T10:44:17.432Z" title="发表于 2021-11-25 18:44:17">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Python 基础笔记">Python 基础笔记</a><time datetime="2021-11-25T10:40:15.008Z" title="发表于 2021-11-25 18:40:15">2021-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Tencent Cloud</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'Wanghui-Huang/gittalk')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>