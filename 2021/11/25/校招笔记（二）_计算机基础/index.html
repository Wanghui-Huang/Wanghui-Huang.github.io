<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（二）_计算机基础 | royhuang's blog</title><meta name="keywords" content="校招,基础"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二、Linux &amp; Git 2.1 Linux 2.1.1 常用命令   查看80端口状态？ 1netstat -ntulp | grep 80   -t : 指明显示TCP端口   -u : 指明显示UDP端口   -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)   -p : 显示进程标识符和程序名称，每一个套接字&#x2F;端口都属于">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（二）_计算机基础">
<meta property="og:url" content="https://hwh.zone/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="二、Linux &amp; Git 2.1 Linux 2.1.1 常用命令   查看80端口状态？ 1netstat -ntulp | grep 80   -t : 指明显示TCP端口   -u : 指明显示UDP端口   -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)   -p : 显示进程标识符和程序名称，每一个套接字&#x2F;端口都属于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hwh.zone/img/about-bg.jpg">
<meta property="article:published_time" content="2021-11-25T08:29:59.274Z">
<meta property="article:modified_time" content="2021-11-26T09:28:49.409Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="校招">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hwh.zone/img/about-bg.jpg"><link rel="shortcut icon" href="/img/cat.jpg"><link rel="canonical" href="https://hwh.zone/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（二）_计算机基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-26 17:28:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/about-bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">校招笔记（二）_计算机基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T08:29:59.274Z" title="发表于 2021-11-25 16:29:59">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-26T09:28:49.409Z" title="更新于 2021-11-26 17:28:49">2021-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">80.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>253分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（二）_计算机基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>二、Linux &amp; Git</h1>
<h2 id="2-1-Linux">2.1 Linux</h2>
<h3 id="2-1-1-常用命令">2.1.1 常用命令</h3>
<ol>
<li>
<p><strong>查看80端口状态</strong>？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep 80</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>-t</code> : 指明显示TCP端口</p>
</li>
<li>
<p><code>-u</code> : 指明显示UDP端口</p>
</li>
<li>
<p><code>-l</code> : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</p>
</li>
<li>
<p><code>-p</code> : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序</p>
</li>
<li>
<p><code>-n</code> : 不进行DNS轮询，显示IP(可以加速操作)</p>
</li>
</ul>
</li>
<li>
<p><strong>查看进程状态？怎么退出？怎么搜索进程？怎么查看某一个进程的内存和CPU使用情况？</strong></p>
<ul>
<li>
<p>所有进程状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  <span class="comment"># 内存中进程信息</span></span><br><span class="line">ps -l    <span class="comment"># 本次登陆所有的进程信息</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/19/ayQRIA8FcqBjtlV.png" alt="image-20210519183338193"></p>
</li>
<li>
<p>退出进程：</p>
<p><code>exit</code></p>
</li>
<li>
<p>搜索进程：</p>
<p><code>ps -ef </code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep &lt;进程名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-e</code>相当于<code>-a</code>是全部列出，<code>-f</code>是显示UID等；</li>
</ul>
</li>
<li>
<p>查看指定进程（如kalfa）CPU和内存占用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep java</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/23/r5vaDgo4sYGfA8c.png" alt="image-20210523171131744"></p>
<ul>
<li>1.3是<strong>CPU占用率</strong>，12.7是<strong>内存占用率</strong>，943100是<strong>物理内存使用量</strong></li>
</ul>
<p>还可以使用 top命令查看指定进程（PID）的内存和CPU使用率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 2913</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>查看占用指定端口的进程</strong> ？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8040</span><br></pre></td></tr></table></figure>
<p>这一步只<u>能获取进程名</u>，还要<code>ps</code> 命令进一步获取进程<code>id</code></p>
<p>如果要杀死相应进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 &lt;进程id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>任务管理器</strong>（cpu占用率、内存占用率、进程）？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>（<strong>总忘</strong>）还可以使用 top命令查看<strong>指定进程（PID）的内存和CPU使用率：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>内存使用情况 和 磁盘使用情况？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m  <span class="comment"># 内存使用情况</span></span><br></pre></td></tr></table></figure>
<p>磁盘使用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -m</span><br></pre></td></tr></table></figure>
<p><code>-m</code> : 以Mb为单位显示磁盘使用量和占用率</p>
</li>
<li>
<p><strong>统计单词个数</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o &lt;单词&gt; &lt;文件地址&gt; ｜ wc -l   <span class="comment"># -l表示统计行数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修改用户权限及常用参数？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod &lt;参数(可选)&gt; &lt;模式&gt; &lt;文件/文件夹&gt;</span><br></pre></td></tr></table></figure>
<p>常用参数：</p>
<ul>
<li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属用户</li>
</ul>
<blockquote>
<p>【示例】如何修改 <code>/test5/5.txt</code> ，权限从<code>rw-r--r--</code> —&gt; <code>r--rwxrwx </code> ？</p>
<p><img src="https://camo.githubusercontent.com/fc3e66b1514a14614059e9423b7393b39d9a79db57cdcf11f0efd07fd95d32ca/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30392f31372f527a664d625165377471756b786c452e706e67" alt="1580875509098"></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户（U）权限[减去写]权限</span></span><br><span class="line">chmod u-w /test5/5.txt</span><br><span class="line"><span class="comment"># 组（G）/其他用户（O）权限[加上写、执行]</span></span><br><span class="line">chmod go+wx /test5/5.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/20/3wrFPWplI47MTbO.png" alt="1580875689076"></p>
</li>
<li>
<p><strong>查看文件的命令有哪些？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名   <span class="comment">#编辑方式查看，可修改</span></span><br><span class="line">cat 文件名  <span class="comment">#显示全部文件内容</span></span><br><span class="line">more 文件名 <span class="comment">#分页显示文件内容</span></span><br><span class="line">less 文件名 <span class="comment">#与 more 相似，更好的是可以往前翻页</span></span><br><span class="line">tail 文件名 <span class="comment">#仅查看尾部，还可以指定行数</span></span><br><span class="line">head 文件名 <span class="comment">#仅查看头部,还可以指定行数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>你平时怎么查看日志的？</strong></p>
<p>Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。</p>
<ul>
<li>
<p><strong>tail（最常使用）</strong></p>
<p>命令格式: <code>tail[必要参数][选择参数][文件]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 test.log 查询日志尾部最后10行的日志;</span><br><span class="line">tail -n +10 test.log 查询10行之后的所有日志;</span><br><span class="line">tail -fn 10 test.log 循环实时查看最后10行记录(最常用的)</span><br></pre></td></tr></table></figure>
<p>一般还会配合着grep搜索用，例如 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -fn 1000 test.log | grep <span class="string">&#x27;关键字&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果一次性查询的数据量太大,可以进行翻页查看，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>其它配合的命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>              <span class="comment"># 所有的历史记录</span></span><br><span class="line"><span class="built_in">history</span> | grep XXX   <span class="comment"># 历史记录中包含某些指令的记录</span></span><br><span class="line"><span class="built_in">history</span> | more       <span class="comment"># 分页查看记录</span></span><br><span class="line"><span class="built_in">history</span> -c           <span class="comment"># 清空所有的历史记录</span></span><br><span class="line">!! 重复执行上一个命令</span><br><span class="line">查询出来记录后选中 : !323</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>怎么让进程后台运行？</strong></p>
<ol>
<li>
<p>命令后面加上**&amp;**即可，实际上，这样是将命令放入到一个作业队列中了；</p>
<p>通常配合<strong>nohup</strong> ，忽略发送给子命令的挂断SIGHUP信号（<strong>终端关闭</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup subcommand &amp;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程；</p>
<blockquote>
<p>ctrl + c 是进程终止。</p>
</blockquote>
</li>
<li>
<p>运行指令前面 <strong>+ setsid</strong>，使其父进程编程init进程，<strong>不受SIGHUP信号的影响</strong>。</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-1-2-其它问题">2.1.2 其它问题</h3>
<h4 id="1-请问-proc-目录有什么用？">1. <strong>请问<code>/proc</code> 目录有什么用？</strong></h4>
<p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。 /proc是一种伪文件系统（也即虚拟文件系统），存储的是<strong>当前内核运行状态</strong>的一系列特殊文件，用户可以通过这些文件：</p>
<ul>
<li><strong>查看系统有关（1）硬件及当前（2）正在运行进程</strong>的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</li>
</ul>
<h4 id="2-Linux的软-硬链接是什么？有什么区别？">2. <strong>Linux的软/硬链接是什么？有什么区别？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.linuxprobe.com/soft-and-hard-links.html">“软链接”和“硬链接”的区别</a></p>
</blockquote>
<ul>
<li>
<p><strong>什么是链接</strong> ？</p>
<p>文件在Linux上被分成两部分：<strong>用户数据 (user data) 与元数据 (metadata)</strong> 。</p>
<ul>
<li><strong>用户数据</strong>：即文件数据块，保留记录文件真实内容的地方</li>
<li><strong>元数据：</strong>  是文件的附加属性，如创建大小、时间，所有信息等。其中<strong>inode号</strong> ，是文件的唯一标识。</li>
</ul>
<p>系统通过inode号快速找到文件，有一种方式可以<strong>快速寻找到数据元信息</strong>，那就是软/硬链接。</p>
<p>现在我们创建一个新文件<code>myfile</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch myfile &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;This is a plain text file.&quot;</span> &gt; myfile</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br></pre></td></tr></table></figure>
<p>来展示二者区别。</p>
</li>
<li>
<p><strong>硬链接</strong></p>
<p>建立 <code>myfile</code> 的一个硬链接 <code>hard</code> ，可以看到二者的<code>inode</code>  是一致的，也就是说<strong>指向了同一个物理区块</strong>。</p>
<blockquote>
<p>硬链接inode ：指向文件的地址 &amp; 维护了一个引用计数，只要有文件还指向这个区块，它就不会从硬盘消失。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln myfile hard  <span class="comment"># 建立硬链接hard</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard</span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>操作硬链接更新文件，等价更新原文件</strong></p>
<p>使用hard硬链接修改文件，发现原文件也被修改了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;New line&quot;</span> &gt;&gt; hard</span><br><span class="line">$ cat myfile</span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>删除原文件，使用硬链接依旧可以显示</strong></p>
<p>因为<strong>磁盘块还有硬链接在引用，所以不会消失</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile  <span class="comment"># 删除原文件</span></span><br><span class="line">$ cat hard   <span class="comment"># 硬链接依旧可以显示</span></span><br><span class="line"></span><br><span class="line">This is a plain text file.</span><br><span class="line">New line</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>软链接</strong></p>
<p>建立一个<code>soft</code>软链接如下，可以看到二者的inode号是不一样的。</p>
<blockquote>
<p>软连接的inode ：保存真实的文件的<strong>绝对路径地址</strong>，找到软链接，还<strong>要根据inode号找到真实文件路径</strong>。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s myfile soft <span class="comment"># 建立软连接soft</span></span><br><span class="line">$ ls -li</span><br><span class="line"></span><br><span class="line">25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile</span><br><span class="line">25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>操作软链接更新文件，等价更新原文件</strong></p>
<p>因为软链接就是相当个快捷方式，当然更新原文件。</p>
</li>
<li>
<p><strong>删除原文件，使用软链接不会显示</strong></p>
<p>因为软件inode指向的绝对地址，已经不存在文件了，所以当然不存在文件了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rm myfile</span><br><span class="line">$ cat soft</span><br><span class="line"></span><br><span class="line">cat: soft: No such file or directory</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>软硬连接区别总结</strong></p>
<ol>
<li>
<p>**inode号不同。**硬链接原文件/链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件/链接文件拥有不同的inode号，表明他们是两个不同的文件；</p>
</li>
<li>
<p><strong>链接数目不同。</strong> 软链接的链接数目不会增加；硬链接每多一个链接就会+1。</p>
</li>
<li>
<p>**文件大小不同。 **硬链接文件显示的大小是跟原文件是一样 ；软链接显示的大小与原文件就不同了，BBB大小是95B，而BBBsoft是3B，因为BBB共有3个字符。</p>
</li>
<li>
<p><strong>文件系统限制。</strong> 软链接没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。</p>
<blockquote>
<p><strong>建立软链接就是建立了一个新文件</strong>：当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="3-查询日志的top10-IP">3. 查询日志的top10 IP?</h3>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq -c | sort -nr | awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> | head -n 10</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><code>cat *.log</code>  ：将文本内容打印到屏幕</p>
</li>
<li>
<p><code>cut</code>：截取指定IP那一列</p>
</li>
<li>
<p><code>sort </code>，按IP ASCII码排序：进行排序，默认是按照ascii码进行排序的</p>
</li>
<li>
<p><code>uniq -c  </code> ，统计重复的IP ：统计<strong>相邻的行</strong>的重复数量，结果是类似 <code>3 127.13.13.13</code> ，前面的数字代码重复的行数</p>
<p><code>sort|uniq -c</code>  统计重复的行数</p>
</li>
<li>
<p><code>sort -n</code>，再次排序 ：是按照数值进行由小到大进行排序， -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序</p>
</li>
<li>
<p><code>awk</code> ，只显示IP：按照分割符将一行分割为多个列，第一列用1表示，第二列用​2表示，依次类推</p>
<p><code>awk -F&quot; &quot; '&#123;print $2&#125;</code>   ，表示用空格作为分隔符进行分割，打印出第2列</p>
</li>
<li>
<p><code>head -n ：</code>表示取前n个</p>
</li>
</ol>
<h2 id="2-2-Git">2.2 Git</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96631135">讲git原理的的一篇不错文章</a></p>
</blockquote>
<h3 id="2-2-1-常问命令">2.2.1 常问命令</h3>
<h4 id="1-什么是Git？-是用什么语言编写的？">1.<strong>什么是Git？</strong> <strong>是用什么语言编写的？</strong></h4>
<ul>
<li>Git是一个 <u>分布式</u> <u>代码控制系统</u> ；</li>
<li>Git使用 C 语言编写：<u>使得 GIT 很快，C 语言减少运行时开销</u>来做到这一点。</li>
</ul>
<h4 id="2-如何在Git中创建存储库？">2. <strong>如何在Git中创建存储库？</strong></h4>
<ol>
<li>如果项目不存在，创建</li>
<li>然后运行 <code>git init</code> ，会在目录下创建一个 <code>.git</code> 目录</li>
</ol>
<h4 id="3-列举工作中常用的几个git命令？">3. <strong>列举工作中常用的几个git命令？</strong></h4>
<ul>
<li><code>git add</code> : 增加文件</li>
<li><code>git commit -m</code> ：提交文件</li>
<li><code>git status</code> ：拉取远程分支</li>
<li><code>git push</code> ：合并当前分支和主分支</li>
<li><code>git pull</code> OR <code>git fetch/git merge</code> ：拉取远程分支</li>
</ul>
<h4 id="4-讲讲Git-commit-基本参数？">4. <strong>讲讲Git commit 基本参数？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qianqiannian/p/6005628.html">https://www.cnblogs.com/qianqiannian/p/6005628.html</a></p>
</blockquote>
<ul>
<li><code>git commit -m “message”</code> ：简要说明这次提交的语句</li>
<li><code>git commit -a</code> ：即使没有经过 <code>git add</code> ，也可以将所有 <u>修改</u> 或 <u>删除</u> 的文件提交到本地仓库，<strong>但新建的文件不会提交</strong></li>
<li><code>git commit --amend</code> ：追加提交，它可以在<u>不增加一个新的commit-id</u> 的情况下将新修改的代码追加到前一次的commit-id中，</li>
</ul>
<h4 id="5-在Git中，你如何还原已经-push-并公开的提交？">5. <strong>在Git中，你如何还原已经 push 并公开的提交？</strong></h4>
<ul>
<li>
<p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-git-pull-和-git-fetch-有什么区别？">6. <strong>git pull 和 git fetch 有什么区别？</strong></h4>
<ul>
<li>
<p><code>git pull</code></p>
<p>取回远程主机某个分支的更新，<strong>再与本地的指定分支合并</strong> （可能要解决冲突）。</p>
</li>
<li>
<p><code>git fetch</code></p>
<p>从远程获取最新版本到本地，<strong>不会自动合并</strong> ，需要手动执行 <code>git merge</code></p>
</li>
</ul>
<h4 id="7-什么是-git-stash-你一般什么情况下会使用它？">7. <strong>什么是 git stash?你一般什么情况下会使用它？</strong></h4>
<blockquote>
<p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是<code>git stash</code>命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用</p>
</blockquote>
<ul>
<li><strong>使用情况：</strong> 当前分支还没处理完，不能去commit提交，但是要去处理一个紧急开发项目，使用 <code>git stash</code></li>
<li>处理完后<code>git stash pop</code> 继续处理工作</li>
</ul>
<h4 id="8-如果本次提交误操作，如何撤销？">8. <strong>如果本次提交误操作，如何撤销？</strong></h4>
<ul>
<li>
<p>**场景1:**改乱了（包括删除等）工作区某个文件的内容（<code>git add 之前</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>丢弃之前所有的修改。</p>
</li>
<li>
<p>**场景2:**撤销提交到索引区的文件 （<code>git add 之后</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>此时回到了场景1，然后再使用 <code>git checkout</code></p>
</li>
<li>
<p><strong>场景3：</strong> 撤销已经提交之后的文件（<code>git commit之后</code>）：</p>
<p>回退版本号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog  <span class="comment"># 查看版本</span></span><br><span class="line">$ git reset --hard  3928   <span class="comment"># 回退版本</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>场景4：</strong> 撤销已经push到远程分支之后的文件（<code>git push之后</code>）</p>
<ul>
<li>
<p>创建一个新的提交，<strong>撤消</strong>在错误提交中所做的所有更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除或修复新提交中的错误文件，并将其<strong>覆盖</strong>推送到远程存储库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="9-使用过git-merge和git-rebase吗？它们之间有什么区别？">9. <strong>使用过git merge和git rebase吗？它们之间有什么区别？</strong></h4>
<p>都是用来合并分支的，但是：</p>
<ul>
<li>
<p><code>git merge &lt;当前分支要合并的分支&gt;</code> ： 在当前分支合并&lt;指定要合并的分支&gt;，会自动在当前分支（下图为master）创建一个commit节点，保留了要合并的分支（下图为branch1）的提交记录</p>
<p><img src="https://i.loli.net/2021/05/02/oLOVlIs7yNazKnJ.png" alt="preview"></p>
</li>
<li>
<p><code>git rebase &lt;当前分支变基的基点分支&gt;</code> ：相当将当前分支（下图为branch1）的分支节点（5,6） 依次提交到基点分支（master）的4节点之后，保留了更干净的历史记录，没有生成行的commit 节点</p>
<p><img src="https://i.loli.net/2021/05/02/ebDoLAUMSd13QRI.png" alt="image-20210502231023075"></p>
</li>
</ul>
<h1>三、计算机网络</h1>
<h2 id="3-1-ISO-OSI模型-和-TCP-IP-模型">3.1 ISO/OSI模型  和 TCP/IP 模型</h2>
<h4 id="1-请你简要介绍一下TCP-IP-五层协议-和-ISO-OSI七层协议？">1. <strong>请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？</strong></h4>
<p><img src="https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="img"></p>
<ul>
<li>
<p><strong>应用层：<strong>为用户的</strong>应用程序</strong>（如：电子邮件、文件传输和仿真终端）<u><strong>*提供网络服务</strong></u>；</p>
</li>
<li>
<p><strong>表示层：</strong> 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取；</p>
</li>
<li>
<p><strong>会话层：</strong>  通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求；</p>
</li>
<li>
<p><strong>运输层:</strong> 任务是为两台主机中<strong>进程之间的通信</strong>提供通用的<u><strong>*数据传输服务</strong></u>，传输的是<strong>报文段（tcp）/用户数据报（udp）</strong>；</p>
<blockquote>
<p>复用：多个应用层进程可同时使用下面运输层的服务。<br>
分用：运输层把收到的信息分别交付上面应用层中的相应进程。</p>
</blockquote>
</li>
<li>
<p><strong>网络层：</strong> 为主机间<u><strong>*提供通信服务</strong></u>。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为<strong>数据报</strong></p>
</li>
<li>
<p><strong>数据链路层（忘）：</strong> 两台主机通信，总是在<strong>一段一段的链路</strong>上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的<u><strong>*IP数据报组装成帧</strong></u>，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。</p>
</li>
<li>
<p>**物理层：**主要作用是<u>传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0）</u>，定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。</p>
</li>
</ul>
<h4 id="2-请你简要介绍一下各层的协议？">2. <strong>请你简要介绍一下各层的协议？</strong></h4>
<ul>
<li>
<p><strong>物理层</strong>：暂无</p>
</li>
<li>
<p><strong>（<u>快手</u>）数据链路层</strong>：数据链路层主要是负责传输数据，</p>
<ul>
<li>
<p><strong>PPP（点到点协议</strong>）：在<strong>点对点</strong>连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为<strong>两个对等节点</strong>之间的 IP <strong>流量传输</strong>提供一种封装协议。这种链路提供<strong>全双工</strong>操作，并按照顺序传递数据包。</p>
<blockquote>
<p>设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p>
</blockquote>
</li>
<li>
<p><strong>以太网（Ethernet)：</strong></p>
</li>
<li>
<p><strong>CSMA/CD 协议：</strong> 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p>
<blockquote>
<p>许多计算机以<strong>多点接入</strong>的方式连接<strong>在一根总线</strong>上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</p>
<p>若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>网络层：</strong> <a target="_blank" rel="noopener" href="https://www.hhcycj.com/post/item/491.html">可参考</a></p>
<p><strong>IP</strong>：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作</p>
<p><strong>ICMP</strong>：非常重要的中间层协议，用于在 <u>IP主机、路由器</u> 之间传递控制消息</p>
<p><strong>IGMP</strong>：网络组消息协议，用来在<u>IP主机</u>和与其**直接相邻的<u>组播路由器</u>**之间建立、维护组播组成员</p>
<p><strong>ARP</strong>：地址解析协议，建立<code>IP→MAC</code>地址映射表</p>
<p><strong>RARP</strong>：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址</p>
</li>
<li>
<p><strong>运输层:TCP(Transmission Control Protocol)</strong> 面向连接的，数据传输的单位是<u><strong>报文段</strong></u>，能够提供可靠的交付。</p>
<p><strong>UDP(User Datagram Protocol)</strong> ：无连接的，数据传输的单位是**<u>用户数据报</u>**，不保证提供可靠的交付，只能提供“尽最大努力交付”</p>
</li>
<li>
<p><strong>应用层：<strong>如支持万维网应用的</strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议，DNS，POP3，SNMP，Telnet等等。</p>
</li>
</ul>
<h5 id="2-1-RARP-工作原理？">2.1 RARP 工作原理？</h5>
<p>RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p>
<blockquote>
<p>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。</p>
</blockquote>
<ol>
<li>主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包；</li>
<li><strong>RARP服务器</strong>收到了<strong>RARP请求数据包</strong>，<strong>为其分配IP地址</strong>，并将<strong>RARP回应发送</strong>给主机；</li>
<li>主机收到RARP回应后，就使用得到的IP地址进行通讯。</li>
</ol>
<h4 id="3-端口在哪一层？有效端口范围？">3. 端口在哪一层？有效端口范围？</h4>
<p>端口在<strong>传输层</strong>。传输层以下的包封装过程：</p>
<ul>
<li>数据报在传输层：加源端口号和目的端口号；</li>
<li>在网络层加上：源ip和目的ip ；</li>
<li>在数据链路层转化成：数据桢进行校验；</li>
<li>在物理层变成信号（电、光、等信号）发送出去。</li>
</ul>
<p>UDP和TCP报头使用<strong>两个字节存放端口号</strong>，端口一共有一共有<strong>65535</strong>个。</p>
<ul>
<li>知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ；</li>
<li>动态端口的范围是从1024~65535。</li>
</ul>
<h2 id="3-2-运输层">3.2 运输层</h2>
<h4 id="0-TCP报文头？UDP报文头？">0. TCP报文头？UDP报文头？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="http://st233.com/blog.php?id=30">IP、TCP、UDP报文头说明</a></p>
</blockquote>
<ul>
<li>
<p><strong>TCP报文头</strong></p>
<p><img src="https://i.loli.net/2021/06/11/RtnwTmysWBvVlPD.png" alt="img"></p>
<ul>
<li>
<p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p>
</li>
<li>
<p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p>
<blockquote>
<p>从这也可以看书，端口占16bit，故范围是0~65535。</p>
</blockquote>
</li>
<li>
<p><strong>顺序号</strong>：<strong>数据包编号</strong>， 表明发送的数据包的顺序 。其值通常应该为<code>上次发送包中的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机)</p>
</li>
<li>
<p><strong>确认号</strong>：通常该值是<code>接受到的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0)</p>
</li>
<li>
<p><strong>首部长度</strong>：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ：</p>
<ul>
<li>如：没有可选头TCP头为20字节 则该值为5</li>
</ul>
</li>
<li>
<p><strong>标志位</strong>：</p>
</li>
<li>
<ul>
<li>紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理</li>
<li>确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号</li>
<li>推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送</li>
<li>复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接</li>
<li>同步标志位(SYN)：开启时表明一个连接的请求或者接受报文</li>
<li>终止标志位(FIN)：开启时表明释放一个连接</li>
</ul>
</li>
<li>
<p><strong>窗口大小</strong>：表示期望接受到的每个数据包字节数</p>
</li>
<li>
<p><strong>校验和</strong>：该值为TCP报文头括数据部分中每16Bit的二进制反码求和</p>
</li>
<li>
<p><strong>紧急指针</strong>：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号</p>
</li>
<li>
<p><strong>可选字段</strong>：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0</p>
</li>
</ul>
</li>
<li>
<p><strong>UDP报文</strong></p>
<p><img src="https://i.loli.net/2021/06/11/Bfh3THSLgzZCUAu.png" alt="img"></p>
<ul>
<li>
<p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p>
</li>
<li>
<p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p>
</li>
<li>
<p><strong>数据包长度</strong>：UDP头和数据总长度字节数</p>
</li>
<li>
<p><strong>检验和</strong>：该值为UDP报文头括数据部分中每16Bit的二进制反码求和</p>
</li>
<li>
<ul>
<li><strong>注：UDP检验和不是必须的</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-请你说明一下，TCP协议的3次握手（进行连接）？">1. 请你说明一下，TCP协议的3次握手（进行连接）？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903834708344840">三次握手与四次挥手面试官想考我们什么？</a></p>
</blockquote>
<blockquote>
<p>TCP中，对<strong>确认ACK报文是不需要发送确认</strong>的 。</p>
</blockquote>
<ul>
<li>
<p><strong>简略过程</strong></p>
<blockquote>
<p>⚠️ SYN 和ACK报文是一起发的！！</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b331fb0d85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>1、第一次握手</strong>：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN©</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p>
<p><strong>2、第二次握手</strong>：（⚠️ <strong>SYN+ACK是在一个包里发的！（字节一面）</strong> ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 <strong>ISN(s)</strong>，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>
<p><strong>3、第三次握手</strong>：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>
<p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p>
</li>
</ul>
<h5 id="1-1-ISN-（Initial-Sequence-Number）是固定的吗？">1.1 ISN （Initial Sequence Number）是固定的吗？</h5>
<ul>
<li>
<p><strong>ISN作用</strong></p>
<p>三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道<strong>接下来接收数据的时候如何按序列号组装数据</strong>。</p>
</li>
<li>
<p><strong>ISN为什么不固定</strong>（还是不太理解）</p>
<blockquote>
<p>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个<strong>32比特</strong>的计数器，<strong>每4ms加1</strong> 。</p>
</blockquote>
<ul>
<li><strong>防止在网络中被延迟的分组在以后被重复传输</strong>，而导致某个连接的一端对它作错误的判断；</li>
<li>如果 ISN 是固定的，攻击者很<strong>容易猜出后续的确认号</strong>，因此 ISN 是动态生成的。</li>
</ul>
</li>
</ul>
<h4 id="2-为什么要三次握手？">2. <strong>为什么要三次握手？</strong></h4>
<p>1**.用来确定服务端和客户端的发送能力是否正常；**</p>
<ul>
<li>**第一次握手：**客户端发送网络包，服务端收到了。这样服务端就能得出结论：<u>客户端的发送能力、服务端的接收能力是正常的。</u></li>
<li><strong>第二次握手</strong>：服务端发包，客户端收到了。这样客户端就能得出结论：<u>服务端的接收、发送能力，客户端的接收、发送能力是正常的</u>。<strong>不过此时服务器并不能确认客户端的接收能力是否正常</strong>。</li>
<li>**第三次握手：**客户端发包，服务端收到了。这样服务端就能得出结论：<u>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</u></li>
</ul>
<p>2.<strong>指定自己的初始化序列号，为后面的可靠传送做准备；</strong></p>
<ul>
<li>如果只有两次握手，那么客户端的起始序列号可以确认，<u>服务端的起始序列号</u>将得不到确认。</li>
</ul>
<ol start="3">
<li><strong>如果是 https 协议的话，三次握手这个过程，还会进行数字<u>证书的验证以及加密密钥</u>的生成。</strong></li>
</ol>
<h5 id="2-1-三次握手可以携带数据吗？">2.1 三次握手可以携带数据吗？</h5>
<p><strong>第一次、第二次握手不可以携带数据 ，</strong> 第三次可以携带数据：</p>
<ul>
<li><strong>对于第一次握手</strong>，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。
<ul>
<li>如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，<strong>消耗服务器空间来接收数据</strong>；</li>
</ul>
</li>
<li><strong>对于第三次握手</strong>，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，<strong>已经知道服务器的接收、发送能力正常</strong>，所以能携带数据。</li>
</ul>
<h4 id="3-请你说明一下，TCP协议的4次挥手（断开连接）？">3. <strong>请你说明一下，TCP协议的4次挥手（断开连接）？</strong></h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/63264012">为什么不像三次握手一样执行三次即可？</a></p>
<p>因为第二次和第三次对于被动方来说，意义是不一样的。<br>
第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。<br>
第三次是为了表示“我的活儿干完了，可以结束了”。<br>
通常server接收到挥手的时候，手里还有活儿没做完。</p>
</blockquote>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</p>
<p><u>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据</u>。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a074b855ad3850?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>（1）客户端A发送一个FIN，<u>报文中会指定一个序列号</u>M，用来关闭客户A到服务器B的数据传送，此时客户端处于<strong>FIN_WAIT1</strong>状态；</p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，<u>确认序号为收到的序号M+1</u>。和SYN一样，一个FIN将占用一个序号，此时服务端处于 <strong>CLOSE_WAIT</strong>状态；</p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 <strong>LAST_ACK</strong> 的状态；</p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 <strong>TIME_WAIT</strong> 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <strong>CLOSED</strong> 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。</p>
<h5 id="3-1-为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</h5>
<blockquote>
<p>半双工：同时只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。</p>
</blockquote>
<p>在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。</p>
<p>但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（<strong>服务端</strong>）依旧<strong>可以同时发生数据</strong> ，这个时候效率更高。</p>
<h5 id="3-2（重点）-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h5>
<p>close_wait状态是在，TCP四次挥手的时候<strong>服务器收到FIN，但是没有发送自己的FIN时出现的</strong>。服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li><strong>服务器内部业务处理占用了过多时间</strong>，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候<strong>子进程处理但父进程没有处理该信号</strong>，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug</li>
</ul>
<h4 id="4-为什么要有TIME-WAIT-状态？为什么等待是2MSL？">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</h4>
<ul>
<li>
<p><strong>要确保服务器是否已经收到了客户端最后的ACK 报文</strong>，如果没有收到的话，<u>服务器会重新发 FIN + ACK报文给客户端</u>，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后<u>再次发送 ACK 报文。</u></p>
</li>
<li>
<p><strong>确保之前连接的一些数据不在滞留在网络中</strong>：确保已经失效连接请求报文段不会再出现在本连接中，<strong>客户端发完最后一个ACK报文段后</strong>，再经过<strong>2MSL</strong>可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地<strong>释放</strong>TCP占用的资源、端口号，连接任何服务器。</p>
<blockquote>
<p>如果<strong>客户端</strong>直接CLOSED，然后又再次向服务器<strong>发起一个新连接</strong>，有可能<strong>新、老连接的端口号一样</strong>的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。</p>
</blockquote>
</li>
</ul>
<h5 id="4-1-为什么是2MSL">4.1 为什么是2MSL?</h5>
<p>MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。</p>
<p>考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了：</p>
<ol>
<li>ACK从最多经过1MSL会到达服务端，<strong>超过1MSL服务端会重发FIN</strong></li>
<li>服务端重发的FIN最多经过1MSL到达A</li>
</ol>
<p>所以为了确保，客户端能<strong>接收到服务端重发的FIN报文</strong>。</p>
<h4 id="5-【重点】请问TCP为什么要更可靠？哪种场景会有所应用？">5. 【重点】<strong>请问TCP为什么要更可靠？哪种场景会有所应用？</strong></h4>
<ol>
<li>
<p><strong>超时重传</strong>：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段；</p>
</li>
<li>
<p><strong>数据排序</strong>：TCP有专门的序列号<strong>ISN字段</strong>，可提供数据re-order；</p>
</li>
<li>
<p><strong>流量控制</strong>：滑动窗口和计时器的使用。TCP窗口中会指明双方能够<u>发送接收的最大数据量；</u></p>
<blockquote>
<p><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。</p>
</blockquote>
</li>
<li>
<p><strong>拥塞控制</strong>：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、<u>“拥塞避免”</u>（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）；</p>
</li>
<li>
<p><strong>校验和：</strong> TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将<strong>丢弃这个报⽂段和不确认收到此报⽂段</strong>。</p>
</li>
</ol>
<p>【<strong>应用场景</strong>】</p>
<p><u>当对网络通讯质量有要求的时候，</u>比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用</p>
<ul>
<li>比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</li>
</ul>
<h5 id="5-1-超时重传机制原理？">5.1 超时重传机制原理？</h5>
<p>基本原理：在发送一个数据之后，就开启一个<strong>定时器</strong>，若是在这个时间内<strong>没有收到发送数据的ACK确认报文</strong>，则对该报文进行<strong>重传</strong>，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<p>TCP中有四种计时器（Timer），分别为：</p>
<ol>
<li>
<p><strong>重传计时器</strong>：在<strong>滑动窗口协议</strong>中，接受窗口会在<strong>连续收到的包序列（连续ARQ）<strong>中的</strong>最后一个包</strong>向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在<strong>重传的“时间片”<strong>到了以后，如果还没有收到对方的ACK，就</strong>重发此包</strong>，以避免陷入无限等待中。</p>
</li>
<li>
<p><strong>坚持计时器</strong>：在<strong>滑动窗口协议</strong>中，当发送TCP收到<strong>窗口大小为0</strong>的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。</p>
</li>
<li>
<p><strong>保活计时器</strong>：保活计时器使用在某些实现中，用来<strong>防止在两个TCP之间的连接出现长时间的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。</p>
<p>通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若<strong>发送了10个探测报文段</strong>（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。</p>
</li>
<li>
<p><strong>时间等待计时器</strong>：四次挥收后time waiter状态中使用。</p>
</li>
</ol>
<h5 id="5-2-介绍一下ARQ协议-？">5.2 介绍一下ARQ协议 ？</h5>
<p>⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p>
<ul>
<li><strong>停⽌等待ARQ协议。</strong> 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个<strong>分组</strong>就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。
<ul>
<li>**优点：**简单</li>
<li>**缺点：**信道利用低，等待时间长</li>
</ul>
</li>
<li><strong>连续ARQ协议。<strong>连续 ARQ 协议可提高信道利用率。发送方维持⼀</strong>个发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用<strong>累计确认</strong>，对按序到达的<strong>最后⼀个分组发送确</strong>认，表明到这个分组为⽌的所有分组都已经正确收到了。
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，<strong>中间第三条丢失（3号）</strong>，这时接收方<strong>只能对前两个发送确认</strong>。发送方无法知道后三个分组的下落，而只好把后<strong>三个全部重传</strong>⼀次。这也叫 <strong>Go-Back-N</strong>（回退 N），表示需要退回来重传已经发送过的N 个消息。</li>
</ul>
</li>
</ul>
<h5 id="5-2-介绍一下连续ARQ协议滑动窗口和流量控制？">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</h5>
<p>TCP 利用滑动窗口实现流量控制。流量控制是为了<strong>控制发送方发送速率，保证接收方来得及接收</strong>。 接收方发送的确认报⽂中的窗口字段可以用来控制<strong>发送方窗口</strong>大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h5 id="5-3-介绍一下拥塞控制？">5.3 介绍一下拥塞控制？</h5>
<p>为了进行拥塞控制，TCP 发送方要维持⼀个 <u>拥塞窗口(cwnd)</u> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的<strong>发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个</strong>。</p>
<p>TCP的拥塞控制采用了四种算法：</p>
<ul>
<li>
<p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，<strong>每经过⼀个传播轮次RTT，cwnd加倍</strong>；</p>
</li>
<li>
<p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过<strong>⼀个往返时间RTT，就把发送放的cwnd加1</strong>；</p>
</li>
<li>
<p><strong>快重传/快恢复：</strong></p>
<blockquote>
<p>区分快重传，连续ARQ中间丢失是Go back n。</p>
</blockquote>
<p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，<u>它能快速恢复丢失的数据包。</u>如果<strong>接收机</strong>接收到⼀个**【不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认**，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（<strong>而不必继续等待为该报文段设置的重传计时器的超时</strong>）。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20170823152124856" alt="img"></p>
</li>
</ul>
<h5 id="5-4-如何区分流量控制和拥塞控制？">5.4 如何区分流量控制和拥塞控制？</h5>
<ul>
<li><strong>流量控制属于通信双方协商，拥塞控制涉及通信链路全局；</strong></li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，<strong>接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定</strong>；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li>
</ul>
<h4 id="6-如何提高客户端并发数？">6. <strong>如何提高客户端并发数？</strong></h4>
<p>客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是<strong>1024</strong>。</p>
<ul>
<li>使用<code>ulimit</code> 可以修改最大进程数（<strong>最大为65535</strong>）</li>
</ul>
<h4 id="7-说说HTTP、TCP、Socket-的关系是什么？">7. <strong>说说HTTP、TCP</strong>、Socket 的关系是什么？</h4>
<ul>
<li><strong>TCP/IP</strong> 代表传输控制协议/网际协议，指的是一系列协议族；</li>
<li><strong>HTTP</strong> 本身就是一个协议，是从 <u>Web 服务器和本地浏览器</u>的超文本传送协议；</li>
<li><strong>Socket</strong> 是 TCP/IP 网络的 <strong>API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<h4 id="8-什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略-？">8. 什么是半连接队列？<strong>泛洪攻击（DDos攻击的一种），以及解决策略</strong> ？</h4>
<ul>
<li>
<p><strong>半连接队列</strong></p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<blockquote>
<p>已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p>
</blockquote>
</li>
<li>
<p><strong>泛洪攻击</strong></p>
<p>在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。</p>
<ol>
<li>服务器接收到 SYN 报文段后会为该 <u>TCP分配<strong>缓存和变量</strong></u>，如果<u>攻击分子<strong>伪造大量不存在的IP地址</strong>，大量地往服务器发送 SYN 报文段</u>，服务器的连接资源终将被耗尽，导致<strong>内存溢出</strong>无法继续服务。</li>
<li>当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为<strong>半连接</strong>，同时会被服务端写入一个 <strong>半连接队列</strong>。<br>
想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的 <strong>半连接队列很快会被写满</strong>，从而导致无法工作。</li>
</ol>
</li>
<li>
<p><strong>解决策略</strong></p>
<p><strong>设置验证机制：<strong>当服务器接受到 SYN 报文段时，<strong>不直接为该 TCP 分配资源</strong>，而只是打开一个<u>半开的套接字</u>。接着会使用 SYN 报文段的<u>源 Id，目的 Id，端口号</u>以及只有服务器自己知道的一个<u>秘密函数生成一个 cookie，并</strong>把 cookie作为序列号响应</strong></u> 给客户端。</p>
<p>如果客户端是正常建立连接，将会返回一个确认字段为 <strong>cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。</p>
<p><strong>防火墙过滤：</strong> 暂不了解具体</p>
</li>
</ul>
<h4 id="9-为什么DNS（域名解析）用UDP，而区域传送用TCP">9. <strong>为什么DNS（域名解析）用UDP，而区域传送用TCP?</strong></h4>
<ul>
<li>**DNS用UDP：**客户端向DNS服务器查询域名，一<u>般返回的内容都不超过512字节，用UDP传输即可</u>。不用经过TCP三次握手，这样<u>DNS服务器负载更低，响应更快</u>。</li>
<li><strong>区域传送用TCP：</strong> TCP协议可靠性好，<u>TCP协议传输的内容大，而UDP最大只能传512字节</u>。</li>
</ul>
<h4 id="10-说一下-TCP-粘包是怎么产生的？怎么解决粘包？">10. <strong>说一下 TCP 粘包是怎么产生的？怎么解决粘包？</strong></h4>
<p><strong>TCP粘包</strong></p>
<p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p>客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况：</p>
<ul>
<li><strong>正常情况</strong>：读取到了A和B两个数据包；</li>
<li><strong>粘包</strong>：A和B两个数据包一起读取了；</li>
<li><strong>拆包</strong>：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。</li>
</ul>
<p><strong>TCP粘包原因</strong></p>
<ul>
<li><strong>【发送方】TCP默认使用Nagle算法。<strong>客户端通过socket给服务端发送数据，为了传输更有效率，会将</strong>多次间隔较小的且数据量小的数据</strong>，通过<strong>nagle</strong>算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据；</li>
<li><strong>【接收方】来不及接收缓存区的包</strong>，导致多个包接收；</li>
<li>TCP<strong>连接复用</strong>造成的粘包问题；</li>
<li>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</li>
</ul>
<p><strong>解决粘包</strong></p>
<p>解决问题的关键在于如何给<strong>每个数据包添加边界信息</strong>：</p>
<ol>
<li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法；</li>
<li><strong>发送端给每个数据包添加包 <u>首部</u> <strong>，首部中应该至少包含数据包的</strong>长度</strong>，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了；</li>
<li><strong>数据包之间设置边界</strong>，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ；</li>
<li><strong>发送端将每个数据包封装为固定长度</strong>（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li>
</ol>
<h4 id="11-TCP-UDP的区别？">11. TCP, UDP的区别？</h4>
<ul>
<li>UDP 在<strong>传送数据之前不需要先建立连接</strong>。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信）
<ul>
<li>⽐如： <u>QQ 语⾳、 QQ 视频 、直播</u>等等</li>
</ul>
</li>
<li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。
<ul>
<li>TCP ⼀般用于<u>⽂件传输、发送和接收邮件、远程登录</u>等场景。</li>
</ul>
</li>
<li><strong>数据包：</strong> TCP是<strong>报文段</strong>，UDP是<strong>用户数据报</strong>。</li>
<li><strong>应用场景</strong> ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。</li>
<li>**长度：**UDP在DNS最长只能是512字节，TCP会更长。</li>
</ul>
<h2 id="3-3-网络层">3.3 网络层</h2>
<h4 id="1-请简单解释一下，ARP协议和ARP攻击">1. <strong>请简单解释一下，ARP协议和ARP攻击?</strong></h4>
<ul>
<li>ARP协议：地址解析协议，建立<code>IP/MAC</code>地址映射表</li>
<li>ARP攻击：</li>
</ul>
<h4 id="2-什么是ICMP协议，它的作用是什么？">2. <strong>什么是ICMP协议，它的作用是什么？</strong></h4>
<p>用于在**<u>IP主机、路由器**之间传递控制消息。</u></p>
<blockquote>
<p>控制消息是指：<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
</blockquote>
<h4 id="3-请你讲一下路由器和交换机的区别？">3. <strong>请你讲一下路由器和交换机的区别？</strong></h4>
<ol>
<li>
<p>（忘）<strong>动态IP：</strong><u>路由器可以给你的局域网自动分配IP</u>，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。<u>交换机只是用来分配网络数据的</u>。</p>
<p><u>路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP</u>。交换机可以把很多主机连起来，这些主机对外各有各的IP。</p>
</li>
<li>
<p><strong>寻址方式：<strong>路由器在</strong>网络层</strong>，<u>路由器根据IP地址寻址</u>，路由器可以处理TCP/IP协议，交换机不可以；交换机在<strong>中继层</strong>，<u>交换机根据MAC地址</u>寻址。</p>
</li>
<li>
<p>**防火墙：**路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</p>
</li>
</ol>
<h4 id="4-请解释ping命令过程？">4. <strong>请解释<code>ping</code>命令过程？</strong></h4>
<ol>
<li>域名在DNS服务器查找IP地址；</li>
<li>通过Ping程序发送<strong>ICMP包；</strong></li>
<li>同一网段的情况下，调用IP层的<strong>ARP协议</strong>请求<strong>广播</strong>（不同网段的情况下，交给路由器处理），<strong>查找目标主机的MAC地址</strong>；</li>
<li>目标主机ARP协议收到请求后，将本机<strong>MAC地址填充</strong>并<strong>发送ARP应答</strong>回到请求发送方；</li>
<li>请求发送方发送<strong>ICMP数据</strong>到目标主机；</li>
<li>（🚩*1）目标主机<strong>响应ICMP包</strong>；</li>
<li>请求主机收到目标主机的<strong>ICMP响应包</strong>。</li>
</ol>
<h4 id="5-（补充介绍）介绍一下IPV6？一共多少位？">5. （补充介绍）介绍一下IPV6？一共多少位？</h4>
<p><img src="https://i.loli.net/2021/05/17/i5Nz6lF9RXYsShw.png" alt="IPv6 协议基础_果子哥丶的博客-CSDN博客"></p>
<p>源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！</p>
<h4 id="6-介绍一下IP地址分类？C类哪些是保留地址？网络号全-0-全-1-，主机号全-0-全1-分别什么含义？">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</h4>
<ul>
<li>
<p><strong>IP地址分类</strong></p>
<p><code>IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code></p>
<p><img src="https://i.loli.net/2021/05/17/ZINJCj9l8WM7qhf.jpg" alt="img"></p>
<ul>
<li>
<p><strong>A类：</strong> 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是<strong>保留地址</strong>，意思是“本网络” ； 127（0111 1111）的IP地址也是<strong>保留地址</strong>，作为本地环回软件测试 。</p>
<blockquote>
<p>特别的，<strong>主机号全1</strong>的是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80">广播地址</a>，它代表了网络全部的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>。</p>
</blockquote>
</li>
<li>
<p><strong>B类：</strong> 第1、2位固定为10，网络号有14位可以使用 。</p>
<blockquote>
<p>B类地址网络号为128.0（1000 000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p>
</blockquote>
</li>
<li>
<p><strong>C类：</strong> 第1、2、3位固定为110，网络号有21位可以使用 。</p>
<blockquote>
<p>（快手问）C类IP地址包含<strong>私有C类地址</strong>，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从<strong>192.168.0.0 到192.168.255.255。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>全0或者全1的含义</strong></p>
<ul>
<li>
<p><strong>网络号全0：</strong>（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机</p>
</li>
<li>
<p><strong>网络号全1：<strong>全1的网络号和</strong>任意的主机号</strong>组合当做<strong>回环地址</strong>来使用。</p>
<blockquote>
<p>例如：127（0111 1111）的IP地址</p>
</blockquote>
</li>
<li>
<p><strong>主机号全0：</strong> 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个<strong>网段</strong>；</p>
</li>
<li>
<p><strong>主机号全1：</strong> 机号全1 代表的是<strong>广播地址</strong>，广播地址是不可以做源端的，但是可以做目的端。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-应用层">3.4 应用层</h2>
<h4 id="1-请你谈谈DNS的寻址过程？">1. <strong>请你谈谈DNS的寻址过程？</strong></h4>
<p>（1）检查<strong>浏览器缓存、检查本地hosts文</strong>件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p>
<p>（2）如果没有，则查找<strong>本地DNS解析器缓存</strong>：是否有这个网址的映射，如果有，返回映射，解析完成。</p>
<blockquote>
<p><strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</p>
</blockquote>
<p>（3）如果没有，则查找填写或分配的<strong>首选DNS服务器</strong>：称为本地DNS服务器。服务器接收到查询时：</p>
<ul>
<li>
<p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p>
</li>
<li>
<p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p>
</li>
</ul>
<p>（4）如果本地DNS服务器也失效：</p>
<ul>
<li>如果未采用<u>转发模式</u>（<strong>迭代</strong>，从上至下）（1）<strong>本地DNS服务器</strong>就把<strong>请求发至13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（<a target="_blank" rel="noopener" href="http://xn--bvs.com">如.com</a>）是谁来授权管理，<u>并返回一个负责该顶级域名服务器的IP</u>，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该<strong>顶级域名</strong>服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果返回**<u>本地DNS服务器</u>**，<strong>再由本地DNS服务器</strong>返回解析结果，查询完成。</li>
<li>如果采用<u>转发模式</u>（<strong>递归</strong>，从下至上）（1）则此DNS服务器就会把请求转<strong>发至上一级DNS服务器</strong>，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次<u>返回本地DNS服务器</u>，本地DNS服务器再返回给客户机，查询完成。</li>
</ul>
<h5 id="1-1-怎么获取13台根服务器？">1.1 怎么获取13台根服务器？</h5>
<p>ping -R ? 抓包？</p>
<h5 id="1-2-解释一下DNS劫持和DNS污染？">1.2 <strong>解释一下DNS劫持和DNS污染？</strong></h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903991764058126">什么是http劫持 ? </a></p>
</blockquote>
<p><strong>一、DNS劫持</strong></p>
<p>DNS劫持某些手段取得<strong>某域名的解析记录控制权</strong>，进而修改此域名的解析结果，返回给用户一个错误的查询结果。</p>
<ul>
<li>
<p><strong>劫持过程</strong></p>
<ol>
<li>
<p>客户端发起域名请求到DNS解析服务器（一般是LocalDNS），<u>但此时DNS解析服务器被攻击篡改</u>；</p>
</li>
<li>
<p>被攻击篡改后的DNS解析服务器将请求转发给虚假服务器；</p>
<blockquote>
<p>DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。</p>
</blockquote>
</li>
<li>
<p>虚假服务器返回<u>响应虚假信息</u>给被攻击篡改后的DNS解析服务器（也可能直接不响应）；</p>
</li>
</ol>
</li>
<li>
<p><strong>解决办法</strong></p>
<p>DNS劫持的本质是<strong>运营商的DNS解析服务器被攻击篡改</strong></p>
<ul>
<li>使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）</li>
<li>直接使用ip进行访问</li>
</ul>
</li>
</ul>
<p><strong>二、DNS污染</strong></p>
<p>DNS污染是一种让一般用户由于<strong>得到虚假目标主机IP</strong>而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是<u>劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。</u></p>
<ul>
<li>
<p><strong>污染原理</strong></p>
<ol>
<li>
<p>通过对UDP端口53上的<strong>DNS查询进行入侵检测</strong>；</p>
<blockquote>
<p>由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。</p>
</blockquote>
</li>
<li>
<p>一经发现与关键词相匹配的请求则<u><strong>立即伪装成目标域名的解析服务器</strong></u>（NS，Name Server）给查询者返回虚假结果。</p>
</li>
</ol>
</li>
<li>
<p><strong>解决办法</strong></p>
<ol>
<li>VPN代理或者域名远程解析的方法解决</li>
<li>通过修改Hosts，手动设置<u>域名正确的IP地址</u></li>
</ol>
</li>
</ul>
<h4 id="2-Forward-和-Redirect-的区别？">2. <strong>Forward</strong> <strong>和</strong> <strong>Redirect</strong> <strong>的区别？</strong></h4>
<ul>
<li>
<p><strong>浏览器 URL 地址</strong>：Forward 是服务器<u>内部的重定向</u>，服务器<strong>内部请求某个 servlet</strong>，然后获取响应的内容，<strong>浏览器的 URL 地址不会变化</strong>；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个 <strong>302</strong> 状态码和<strong>新的 location</strong>，客户端<u><strong>重新发起 HTTP 请求</strong></u>，服务器给客户端响<u>应 location 对应的 URL 地址，</u>浏览器的 <strong>URL 地址发生了变化</strong>。</p>
</li>
<li>
<p><strong>数据的共享</strong>：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，<strong>request 中的信息在 servlet 间是共享</strong>的。Redirect 发起了<strong>两次 HTTP 请求</strong>分别使用<strong>不同的request</strong>。</p>
</li>
<li>
<p><strong>请求的次数</strong>：Forward 只有一次请求；Redirect 有两次请求。</p>
</li>
</ul>
<h4 id="3-请你简单讲解一下，负载均衡反向代理模式的优点、缺点？">3. <strong>请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</strong></h4>
<blockquote>
<p>联系实际：<a target="_blank" rel="noopener" href="https://server.zol.com.cn/633/6339623_all.html">正反向代理、科学上网、VPN之间的关系</a> 和<a target="_blank" rel="noopener" href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">翻墙基本原理（看他的其他文章补充）</a></p>
</blockquote>
<p>【基本介绍】</p>
<ol>
<li>
<p><strong>反向代理</strong>（Reverse Proxy）：方式是指<u>以代理服务器来接受internet上的连接请求</u>，然后将请求转发给内部网络上的服务器，并将从<strong>服务器上得到的结果返回给internet上请求连接的客户端</strong>，此时代理服务器对外就表现为一个服务器；</p>
<ul>
<li>
<p><strong>优点：</strong> 网络络外部用户不能直接访问真实的服务器，具备额外的安全性</p>
</li>
<li>
<p><strong>缺点：</strong> 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围；</p>
<p><u><strong>针对每一次代理，代理服务器就必须打开两个连接</strong></u>，一个对外，一个对内，因此在并发连接请求数量非常大的时候，<strong>代理服务器的负载也就非常大了</strong>，在最后代理服务器本身会成为服务的瓶颈。</p>
</li>
</ul>
</li>
<li>
<p><strong>反向代理负载均衡技术：<strong>是把将来自internet上的连接请求以反向代理的方式动态地</strong>转发</strong>给内部网络上的<strong>多台服务器</strong>进行处理，从而达到负载均衡的目的。</p>
<ul>
<li>**实现：**apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。</li>
<li>**优点：**可以将优化的 <u>负载均衡策略和代理服务器的高速缓存技术</u>结合在一起，提升静态网页的访问速度，提供有益的性能</li>
<li><strong>缺点：</strong></li>
</ul>
</li>
</ol>
<h5 id="3-1-请解释下负载均衡的相关算法？">3.1 请解释下负载均衡的相关算法？</h5>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。</p>
<ul>
<li>给配置高、负载低的机器配置更高的权重，让其处理更多的请求；</li>
<li>给配置低、负载高的机器分配较低的权重，降低系统负载。</li>
</ul>
<p>下面是几种比较相关的算法。</p>
<ul>
<li>
<p><strong>加权轮询算法</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">加权轮询算法</a></p>
</blockquote>
<ul>
<li>
<p>基本定义</p>
<ol>
<li>假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn}</li>
<li>currentPos 表示当前选择的实例 ID，初始化为 -1；</li>
<li>currentWeight 表示当前权重，初始值为 max(S)；</li>
<li>max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。</li>
</ol>
</li>
<li>
<p>算法过程</p>
<ol>
<li>从上一次调度实例起，<strong>遍历后面</strong>的每个实例；</li>
<li>若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)；</li>
<li><strong>直到</strong> 遍历的实例的权重 &gt;= currentWeight 时结束，<strong>此时实例为需调度的实例</strong>；</li>
<li>每次调度重复步骤 1、2、3；</li>
</ol>
</li>
<li>
<p>算法实例</p>
<p><img src="https://i.loli.net/2021/05/30/YCVDN4miMvPy7sJ.png" alt="image-20210529232315965"></p>
<p>例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下：</p>
<p><img src="https://i.loli.net/2021/05/30/7A4s6i3opra8LWR.png" alt="image-20210529232350799"></p>
</li>
<li>
<p>算法优缺点</p>
<ul>
<li>
<p><strong>优点：</strong> 相比 <u>简单轮询</u> 方式，通过权重进行分配，更加均匀</p>
</li>
<li>
<p>**缺点：**如下一个极端情况</p>
<blockquote>
<p>服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。</p>
</blockquote>
<p>关于这点，可以采用  <a target="_blank" rel="noopener" href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html#">平滑加权轮询</a> 调度算法 。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>一致性哈希算法</strong></p>
<p>负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即<strong>哈希环</strong>。</p>
<p><img src="https://i.loli.net/2021/05/30/fAa2jzXxGZ7lVq1.png" alt="image-20210529232953082"></p>
<p>但是可能出现一种，<strong>哈希倾斜</strong>的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。</p>
</li>
</ul>
<h5 id="3-2-DNS-负载均衡是什么策略？">3.2 DNS 负载均衡是什么策略？</h5>
<blockquote>
<p>参考：<a href=""></a></p>
</blockquote>
<ul>
<li><strong>原理：</strong> 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？</li>
</ul>
<h4 id="4-请说明一下http和https的区别？">4. <strong>请说明一下http和https的区别？</strong></h4>
<ol>
<li>https协议要申请证书到ca，需要一定<u>经济成本</u>；</li>
<li>http是明文传输，https是加密的安全传输；</li>
<li>（🚩*1）连接的端口不一样，http是<strong>80</strong>，https是<strong>443</strong>；</li>
<li>http连接很简单，没有状态；</li>
<li>https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。</li>
</ol>
<h5 id="4-1-讲一讲http的请求报文和响应报文？协议？">4.1 讲一讲http的请求报文和响应报文？协议？</h5>
<ul>
<li>
<p><strong>请求报文和协议</strong></p>
<p>一个HTTP请求报文由<strong>请求行（request line）</strong>、<strong>请求头部（header）</strong>、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="https://i.loli.net/2021/05/17/uxX1gbcnhTsS9td.png" alt="img"></p>
<ul>
<li>
<p><strong>请求行</strong> ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。</p>
<blockquote>
<p><strong>HTTP协议</strong> :  的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
</blockquote>
</li>
<li>
<p><strong>请求头部：</strong> 请求头部由<strong>关键字/值</strong>对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部<strong>通知服务器有关于客户端请求的信息</strong>。</p>
<blockquote>
<p>User-Agent：产生请求的浏览器类型。</p>
<p>Accept：客户端可识别的内容类型列表。</p>
<p><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>
</blockquote>
</li>
<li>
<p><strong>请求数据 :</strong> 请求数据<strong>不在GET方法中使用，而是在POST方法</strong>中使用。POST方法适用于需要客户填写表单的场合。</p>
</li>
</ul>
</li>
<li>
<p><strong>响应报文和协议</strong></p>
<p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空格、响应数据</strong>。</p>
<p><img src="https://i.loli.net/2021/05/17/QNIRoY5f7jk6sHv.jpg" alt="img"></p>
<ul>
<li><strong>状态行</strong> ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如<strong>404</strong>等</li>
</ul>
</li>
</ul>
<h5 id="4-2-一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</h5>
<ul>
<li><strong>HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求</strong>。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠；</li>
<li><strong>Pipelining 技术 &amp; Multiplexing。</strong> Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；</li>
</ul>
<blockquote>
<p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？</p>
</blockquote>
<ul>
<li>维持和服务器已经建立的 TCP 连接，在同一连接上<strong>顺序处理多个请求</strong>；</li>
<li><strong>和服务器建立多个 TCP 连接</strong>。</li>
</ul>
<h4 id="5-请说明一下http1-0-和https1-1-区别？">5. <strong>请说明一下http1.0 和https1.1 区别？</strong></h4>
<ul>
<li><strong>长连接</strong>
<ul>
<li>HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用；</li>
<li>HTTP1.1支持<strong>持久连接和请求的流水线处理（但不是并发！！）</strong>，在<strong>一个TCP连接上可以传送多个HTTP请求和响应</strong>，<u>减少建立和关闭TCP连接的消耗和延迟，提高效率</u></li>
</ul>
</li>
<li><strong>host字段</strong>
<ul>
<li>在<strong>HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名</strong>（hostname）</li>
<li>HTTP1.1的请求消息和响应消息都应支持Host头域（<u>补充：F12 抓包可以看到</u>），且请求消息中如果<strong>没有Host头域</strong>，会<strong>报400 Bad Request错误</strong></li>
</ul>
</li>
<li><strong>缓存处理</strong>
<ul>
<li>HTTP1.1则引入了更多的缓存控制策略</li>
</ul>
</li>
<li><strong>带宽优化及网络连接的使用</strong>
<ul>
<li>HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却<u>将整个对象发送过来</u>；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包；</li>
<li>HTTP1.1则在请求头中引入range头域，它允许<strong>只请求资源的某个部分(因此也支持断点重传)</strong>，即返回码是206；</li>
</ul>
</li>
<li><strong>新增一些错误通知状态码</strong>
<ul>
<li>如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。</li>
</ul>
</li>
</ul>
<h4 id="6-请说明一下http1-0-和https2-0-区别？">6. <strong>请说明一下http1.0 和https2.0 区别？</strong></h4>
<h4 id="7-请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？">7. <strong>请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？</strong></h4>
<ol>
<li>
<p>在浏览器地址栏中输入URL；</p>
</li>
<li>
<p>DNS域名解析，获得域名相对应的IP地址（详见：<u>应用层DNS寻址过程</u>）；</p>
<blockquote>
<p>浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS<strong>解析器</strong>缓存中查找，如果都没有，（3）再去DNS<strong>服务器</strong>中找IP。</p>
</blockquote>
</li>
<li>
<p>浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 <u><strong>向服务器发送HTTP请求</strong></u>，请求数据包</p>
<blockquote>
<p><strong>HTTP请求是由三部分组成：请求行、请求报头和请求正文。</strong></p>
<p>与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是<u>构建HTTP请求报文</u>，并通过TCP协议发送到服务器指定端口（<u>HTTP协议80/8080，HTTPS协议443</u>）。</p>
</blockquote>
</li>
<li>
<p>服务端（由web服务器）处理收到的请求</p>
<blockquote>
<p>服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。</p>
</blockquote>
</li>
<li>
<p>服务器返回相应结果（响应报文）至浏览器</p>
<blockquote>
<p>HTTP响应报文也是由三部分组成：<strong>状态码、响应报头和响应报文。</strong></p>
<p>状态码是由三位数组成，<u>第一个数字定义了响应的类别</u>：</p>
<ul>
<li><strong>1XX</strong>：指示信息，表示请求已接受，继续处理；</li>
<li><strong>2XX</strong>：成功，表示请求已被成功接收、理解、接受；</li>
<li><strong>3XX</strong>：重定向，要完成请求必须进行更进一步的操作；</li>
<li><strong>4XX</strong>：客户端错误，请求有语法错误或无法实现；</li>
<li><strong>5XX</strong>：服务器端错误，服务器未能实现合法的请求。</li>
</ul>
</blockquote>
</li>
<li>
<p>四次挥手关闭TCP连接</p>
<blockquote>
<p>四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。</p>
</blockquote>
</li>
<li>
<p>（🚩*1）浏览器解析渲染页面</p>
<blockquote>
<p>浏览器在 <u>收到HTML、CSS、JS文件</u>后，就需要进行渲染。</p>
<p>（1）浏览器解析HTML文件构建<u>DOM树</u>，（2）然后解析CSS文件构建<u>渲染树</u>，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其<u>绘制到屏幕</u>上</p>
</blockquote>
</li>
</ol>
<h4 id="8-请解释一下SSL工作过程（Https传输过程）？">8. <strong>请解释一下SSL工作过程（Https传输过程）？</strong></h4>
<blockquote>
<p>https是http的扩展，在传输层使用了安全协议：<strong>安全套接字层SSL(Secure Socket Layer)</strong>。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
</blockquote>
<blockquote>
<p><strong>公钥</strong>通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。</p>
<ul>
<li>通过这种算法得到的密钥对能保证在世界范围内是唯一的。</li>
<li>使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。</li>
</ul>
</blockquote>
<p>SSL/TLS协议的基本思路是采用<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p><img src="https://i.loli.net/2021/04/21/aH6gjc5UT9Xu2io.png" alt="image-20210421171336262"></p>
<p>所以基本过程是：</p>
<blockquote>
<p>（1） 客户端向服务器端索要并验证公钥。</p>
<p>（2） 双方协商生成&quot;对话密钥&quot;。</p>
<p>（3） 双方采用&quot;对话密钥&quot;进行加密通信。</p>
</blockquote>
<ol>
<li>
<p>**协商加密算法。**客户端（通常是浏览器）先向服务器发出<u>加密通信的请求</u>，这被叫做ClientHello请求；</p>
<blockquote>
<p>（1） 支持的协议版本，比如TLS 1.0版。</p>
<p>（2） <u>一个客户端生成的随机数</u>，来生成&quot;对话密钥&quot;。</p>
<p>（3） 支持的加密方法，比如RSA公钥加密。</p>
<p>（4） 支持的压缩方法。</p>
</blockquote>
</li>
<li>
<p>**服务器回应。**服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello；</p>
<blockquote>
<p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p>
<p>（2） <u>一个服务器生成的随机数</u>，稍后用于生成&quot;对话密钥&quot;。</p>
<p>（3） 确认使用的加密方法，比如RSA公钥加密。</p>
<p>（4） 服务器证书。</p>
</blockquote>
</li>
<li>
<p>**客户端鉴别。**客户端收到服务器回应以后，（1）<u>首先验证服务器证书</u>：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>（2）<u>如果证书没有问题，客户端就会从证书中取出服务器的公钥</u>。然后，向服务器发送下面三项信息：</p>
<blockquote>
<p>（1） <u>一个随机数</u>。该随机数用服务器公钥加密，防止被窃听。</p>
<p>（2） <u>编码改变通知</u>，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
<p>（3） <u>客户端握手结束通知</u>，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
</blockquote>
</li>
<li>
<p><strong>会话秘钥计算。</strong> 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）；</p>
<blockquote>
<p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
</blockquote>
</li>
<li>
<p>**安全数据传输。**双方用会话秘钥加密和解密之间传送的数据。</p>
</li>
</ol>
<h5 id="8-1-公钥如何保证不被篡改？说一说证书。">8.1 公钥如何保证不被篡改？说一说证书。</h5>
<p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<ul>
<li>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
</li>
<li>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，<strong>会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
</li>
<li>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（<strong>证书不可信浏览器会提示</strong>），就可以开始通信了。</p>
</li>
</ul>
<h5 id="8-2-公钥加密计算量太大，如何减少耗用的时间？">8.2 公钥加密计算量太大，如何减少耗用的时间？</h5>
<p>每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于**&quot;对话密钥&quot;是对称加密**，所以<strong>运算速度非常快</strong>，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>
<h5 id="8-3-为什么有的时候刷新页面不需要重新建立-SSL-连接？">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</h5>
<p>TCP 连接有的时候会被浏览器和服务端维持一段时间，<strong>TCP 不需要重新建立，SSL 自然也会用之前的</strong>。</p>
<h4 id="9-介绍一下常见的几种非对称加密算法？-优缺点？">9. **介绍一下常见的几种非对称加密算法？**优缺点？</h4>
<ul>
<li>
<p><strong>非对称加密</strong></p>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p>
</li>
<li>
<p><strong>常用非对称加密算法</strong></p>
<p><img src="https://i.loli.net/2021/04/21/8cmyAzUZYDw5vJt.png" alt="面试题——对称加密和非对称加密3"></p>
<ul>
<li>RSA：由 RSA 公司发明，是一个支持<strong>变长密钥</strong>的公共密钥算法，需要加密的文件块的长度也是可变的</li>
<li>DSA（Digital Signature Algorithm）：<strong>数字签名</strong>算法，是一种标准的 DSS（数字签名标准）</li>
<li>ECC（Elliptic Curves Cryptography）：<strong>椭圆曲线加密</strong></li>
</ul>
</li>
<li>
<p><strong>非对称加密优缺点</strong></p>
<ul>
<li><strong>优点：</strong> 可以更安全地将公开密钥传输给通信发送方；</li>
<li><strong>缺点：</strong> 运算速度慢。</li>
</ul>
</li>
</ul>
<h4 id="10-公钥加密–私钥解密与公钥解密–私钥加密有什么区别">10. <strong>公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</strong></h4>
<p>主要是应用场景不同。</p>
<ul>
<li>
<p>加解密：公钥加密，私钥解密</p>
<blockquote>
<p>不希望别人知道我的消息，<u>所以只有我才能解密</u>，所以可得出公钥负责加密，私钥负责解密</p>
</blockquote>
</li>
<li>
<p>签名：私钥签名，公钥验签</p>
<blockquote>
<p>是不希望有人冒充我发消息，只有<u>我才能发布这个签名</u>，所以可得出私钥负责签名，公钥负责验证</p>
</blockquote>
</li>
<li>
<p><strong>https可以只有非对称加密吗?</strong></p>
<p>https<u>验证证书阶段是非对称加密</u>，但是在数据传输阶段是对称加密。<strong>https不可以只有非对称加密：</strong></p>
<ul>
<li><strong>非对称加密</strong>的加解密<strong>效率是非常低</strong>的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</li>
<li>在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</li>
</ul>
</li>
</ul>
<h4 id="11-HTTPS-为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS-绝对安全吗？">11. <strong>HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</strong></h4>
<ul>
<li>
<p>**安全：**因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性；</p>
</li>
<li>
<p><strong>CA证书：</strong> <u>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器</u>，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书</p>
</li>
<li>
<p><strong>证书生成：</strong> 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但<strong>浏览器通常只是提示安全风险，并不限制网站不能访问</strong>，所以从技术上<strong>谁都可以生成证书</strong>，只要有证书就可以完成网站的 HTTPS 传输。</p>
</li>
<li>
<p><strong>不绝对安全：</strong> 不是绝对安全的，可以通过中间人攻击。</p>
<blockquote>
<p>CA证书不是可以解决“中间人”吗？</p>
</blockquote>
<p>过程原理：</p>
<ol>
<li>本地请求被劫持（<u>如DNS劫持等</u>），所有请求均发送到中间人的服务器</li>
<li>中间人服务器返回中间人自己的证书（<strong>但是这一步服务器不是会对服务器证书进行验证吗？</strong>）</li>
<li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li>
<li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li>
<li>中间人以客户端的请求内容再向官方网站发起请求</li>
<li>因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据</li>
<li>中间人凭借与官方网站建立的对称加密算法对内容进行解密</li>
<li>中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输</li>
<li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li>
</ol>
</li>
</ul>
<h4 id="12-http应答码中的301-2-4、500、502、503、504状态码进行解释？">12. <strong>http应答码中的301/2/4、500、502、503、504状态码进行解释？</strong></h4>
<ul>
<li>
<p><strong>200：</strong>  请求成功。</p>
</li>
<li>
<p><img src="https://i.loli.net/2021/04/21/MRi5Oy9Ltd3v8uA.png" alt="image-20210421150625709"></p>
</li>
<li>
<p><strong>500：</strong> 500 (<strong>服务器内部错误</strong>) 服务器遇到错误，无法完成请求。 例如，服务器<strong>无法识别请求方法</strong>时可能会返回此代码。</p>
</li>
<li>
<p><strong>501：<strong>服务器</strong>不支持请求的功能</strong>，无法完成请求</p>
</li>
<li>
<p><strong>502：</strong> 作为<strong>网关或者代理工作的服务器</strong>尝试执行请求时，从<u>上游服务器</u>接收到<strong>无效</strong>的响应。</p>
</li>
<li>
<p><strong>503：</strong> 由于超载或系统维护，服务器暂时的<strong>无法处理客户端</strong>的请求。</p>
</li>
<li>
<p>**504(及时)：**作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p>
</li>
</ul>
<h4 id="13-介绍一下http请求get、post等？">13. <strong>介绍一下http请求get、post等？</strong></h4>
<p><img src="https://i.loli.net/2021/04/21/WRLspE4fvjdKq8F.png" alt="image-20210421140204266"></p>
<p><strong>重点区分一下get和post：</strong></p>
<ul>
<li>
<p><code>get</code> ：GET方法用于使用给定的URI从给定服务器中<u>检索信息</u>，即从指定资源中请求数据。</p>
<ul>
<li>**GET请求是可以缓存的，**浏览器历史记录中查找到GET请求；<strong>长度有限制</strong>；不安全，<strong>url会暴露请求的参数</strong></li>
</ul>
</li>
<li>
<p><code>post</code>：POST方法用于将数据发送到服务器以<u>创建或更新资源</u> 。</p>
<ul>
<li><strong>POST请求不会被缓存</strong>；<strong>长度无限制</strong>；更安全</li>
</ul>
</li>
<li>
<p><strong>特别的：<code>GET产生一个TCP数据包;POST产生两个TCP数据包。</code></strong></p>
<ul>
<li>
<p>get：http header和body一并发送出去 ；</p>
</li>
<li>
<p>post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。</p>
<blockquote>
<p>⚠️ post是不一定会发生两个的。</p>
<ul>
<li>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送；</li>
<li>header 和 body 分开发送<strong>是部分浏览器或框架的请求方法</strong>，不属于 post 必然行为。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="13-1-Get方法长度有限制是怎么回事？">13.1 Get方法长度有限制是怎么回事？</h5>
<p>HTTP 协议没有 Body 和 URL 的长度限制，<strong>对 URL 限制的大多是浏览器 / 服务器的原因</strong>。</p>
<ul>
<li>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制；</li>
<li>浏览器也会设置url有限。</li>
</ul>
<h5 id="13-2-POST-方法相比GET方法是绝对安全吗？">13.2 POST 方法相比GET方法是绝对安全吗？</h5>
<ul>
<li>POST 比 GET 安全，因为数据在地址栏上不可见；</li>
<li><strong>POST不是绝对安全</strong>，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</li>
</ul>
<p>想要安全，只有使用<strong>HTTPS</strong>。</p>
<h4 id="14-HTTP是不保存状态的协议-如何保存用户状态">14.  HTTP是不保存状态的协议,如何保存用户状态?</h4>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。</p>
<ul>
<li><strong>Cookie ⼀般用来保存用户<u>信息</u></strong>
<ul>
<li>我们在 Cookie 中<strong>保存已经登录过得用户信息</strong>，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了；</li>
<li>⼀般的网站都会有<strong>保持登录</strong>也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以<strong>存放了⼀个 Token 在 Cookie</strong>中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token<br>
重写)；</li>
<li>登录⼀次网站后访问网站其他页面不需要重新登录。</li>
</ul>
</li>
<li><strong>Session 的主要作用就是通过服务端记录用户的<u>状态</strong></u>。
<ul>
<li><strong>典型的场景是购物⻋</strong>，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li>
<li>**既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？**大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。</li>
</ul>
</li>
</ul>
<h4 id="15-cookie-、session的作用和区别？">15. <strong>cookie 、session的作用和区别？</strong></h4>
<ul>
<li>
<p>**Cookie **</p>
<ul>
<li>
<p><strong>作用：</strong> 服务器发送到用户浏览器并保存在本地的一小块数据，它会在<u>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</u>。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p>
<blockquote>
<p>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Session</strong></p>
<ul>
<li><strong>作用：</strong> Session 代表着服务器和客户端<strong>一次会话的过程</strong>，Session <u>对象存储特定用户会话所需的属性及配置信息</u>。</li>
</ul>
</li>
<li>
<p><strong>二者区别</strong></p>
<ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端；</li>
<li>**有效期不同，**Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效；</li>
<li><strong>安全性：</strong> Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些；</li>
<li><strong>存储大小不同：</strong>  <u>单个 Cookie 保存的数据不能超过 4K</u>，Session 可存储数据远高于 Cookie；</li>
<li><strong>存取类型的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
</ul>
</li>
</ul>
<h5 id="15-1-Session的共享方式？（好未来问过）">15.1 Session的共享方式？（好未来问过）</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jing99/p/11785070.html">Session如何共享</a></p>
</blockquote>
<ul>
<li>
<p><strong>问题描述</strong></p>
<ol>
<li>在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B；</li>
<li>访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会<strong>创建一个新的sessionId并且响应返回给客户端</strong></li>
</ol>
<p>这样就造成了不能共享Session的问题。</p>
</li>
<li>
<p><strong>解决方案</strong></p>
<ol>
<li><strong>使用Cookie实现</strong>。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。</li>
<li><strong>数据库同步session。</strong>  每次将session数据存到数据库中。这个方案还是比较可行的。
<ul>
<li><strong>缺点：</strong> Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。</li>
</ul>
</li>
<li><strong>使用token代替session。</strong> 就是Token方式替代了，但是还是没解决。</li>
<li><strong>Spring-Sesion实现</strong> 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后<strong>Web服务器之间通过连接Redis来共享数据</strong>，达到Sesson共享的目的。</li>
</ol>
</li>
</ul>
<h4 id="16-Cookie-和-Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</h4>
<blockquote>
<p>参考：[一文彻底搞懂Cookie、Session、Token到底是什么](<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904009061367821">一文彻底搞懂Cookie、Session、Token到底是什么 (juejin.cn)</a>)</p>
</blockquote>
<ul>
<li>
<p><strong>为什么需要session？</strong></p>
<blockquote>
<p>既然浏览器已经通过<code>Cookie</code>实现了有状态这一需求，那么为什么又来了一个<code>Session</code>呢？</p>
</blockquote>
<p>如果将账户的一些重要信息都存入<code>Cookie</code>中的话，一旦<strong>被拦截</strong>，那么我们所有的账户信息都会丢失掉。所以就出现了<code>Session</code>，在一次会话中将重要信息保存在<code>Session</code>中，浏览器只记录<code>SessionId</code>一个<code>SessionId</code>对应一次会话请求。</p>
</li>
<li>
<p><strong>session和cookie二者关联</strong></p>
<p><img src="https://i.loli.net/2021/05/04/jNerb9CXZ6Jpgs2.jpg" alt="img"></p>
<blockquote>
<p>以用户一次登录为例。</p>
</blockquote>
<ol>
<li>用户第一次请求服务器的时候，用户提交包含<strong>用户名和密码</strong>的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 <strong>Redis</strong> 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器；</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名；</li>
<li>当用户第二次访问服务器的时候，请求会自动判断<u>此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端</u>；</li>
<li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 <u>Session 信息，如果没有找到说明用户没有登录或者登录失效</u>，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ol>
</li>
<li>
<p><strong>什么是Token？</strong></p>
<blockquote>
<p><code>Session</code>是将要验证的信息存储在服务端，并以<code>SessionId</code>和数据进行对应，<code>SessionId</code>由客户端存储，在请求时将<code>SessionId</code>也带过去，因此实现了状态的对应。</p>
</blockquote>
<p>但是，而<code>Token</code>是在服务端将<strong>用户信息经过Base64Url【编码，不是加密】过后传给在客户端</strong>，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。</p>
<p>这个方法叫做<strong>JWT(Json Web Token)</strong>。</p>
<blockquote>
<p>一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。</p>
<ol>
<li>
<p>客户端<strong>使用用户名跟密</strong>码请求登录</p>
</li>
<li>
<p>服务端收到请求，去验证用户名与密码</p>
</li>
<li>
<p>验证成功后，服务端会<strong>签发一个 Token</strong>，再把这个 Token 发送给客户端</p>
<blockquote>
<p>Token在服务器端，可以保存在Redis缓存中。</p>
</blockquote>
</li>
<li>
<p>客户端收到 Token 以后可以把它存储起来，比如<strong>放在 Cookie 里或者 Local Storage</strong> 里</p>
</li>
<li>
<p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<blockquote>
<ol start="6">
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
</ol>
</blockquote>
<ul>
<li>
<p><strong>Token的优点</strong></p>
<ol>
<li><strong>无状态，可扩展和解耦：</strong> 使用 token 而不是 cookie 的最大优点应该就是无状态，<strong>后端不需要保持对 token 的记录，每个 token 都是独立的</strong>，包含了检查其有效性的所有数据，并通过申明传达了用户信息。</li>
<li><strong>在 JWT 中存储数据</strong> ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。</li>
<li>*自包含：**由于串包含了用户所需要的信息，避免了多次查询数据库 **</li>
</ol>
</li>
<li>
<p><strong>JWT介绍</strong></p>
<p>JWT有三部分组成：Header，Payload，Signature。</p>
<p><img src="https://i.loli.net/2021/05/26/AC6ULh5293HQngE.png" alt="image-20210526214555872"></p>
<ul>
<li>
<p><strong>Header：</strong> 一个Json对象，描述JWT的元数据，通常是下面这样子的。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 签名的算法为HS256</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>    # Token类型为JWT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Payload：</strong> 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoMing&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Signature ：</strong>  <strong>对前面的两部分的数据进行签名</strong>，<strong>防止数据篡改</strong> 。</p>
<blockquote>
<p>首先需要定义一个<strong>秘钥</strong>，这个秘钥只有服务器才知道，不能泄露给用户，然后使用<strong>Header中指定的签名算法</strong>(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，<strong>每个部分用<code>.</code>分割开来</strong>，就可以返给用户了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="16-1-session和cookie应该如何去选择（适用场景）？">16.1 session和cookie应该如何去选择（适用场景）？</h5>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在<strong>考虑数据复杂性时首选 Session</strong>；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<strong>考虑安全考虑session</strong></li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此<strong>不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的</strong>。</li>
</ul>
<h4 id="17-说说HTTP、TCP、Socket-的关系是什么？">17. <strong>说说HTTP、TCP、Socket 的关系是什么？</strong></h4>
<ul>
<li>TCP/IP 代表<u>传输控制协议/网际协议</u>，指的是一系列协议族；</li>
<li>HTTP 本身就是一个协议，是<u>从 Web 服务器传输超文本到本地浏览器</u>的传送协议；</li>
<li><strong>Socket 是 TCP/IP 网络的 API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<h2 id="3-5-其它">3.5 其它</h2>
<h4 id="1-介绍一下CDN-？-CDN分发节点各个数据都一样吗？">1. 介绍一下CDN ？ <strong>CDN</strong>分发节点各个数据都一样吗？</h4>
<ul>
<li>
<p><strong>CDN，即内容分发网络</strong></p>
<ul>
<li>
<p><strong>解决静态网页加载</strong></p>
<p>不同地区用户访问服务器速度不同，<strong>可以把静态网页放在不同地区的服务器，这样用户可以就近去连接</strong>，大大提升体验；</p>
</li>
<li>
<p>发展转换成，<strong>就近接入解决访问网络资源</strong></p>
<ol>
<li>如一个电信用户送请求，进入解析系统，会<strong>让用户连接到最近的边缘节点</strong>，然后请求数据；</li>
<li>如果边缘节点没有数据，则去访问<strong>源节点</strong>；</li>
<li>源节点也没有，就会去访问<strong>主干节点，去联通服务器中查找；</strong></li>
<li>最后返回数据。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>CDN分发节点各个数据不一样</strong></p>
<p>不一样，就相当于DNS服务器<strong>缓存</strong>了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。</p>
</li>
</ul>
<h4 id="2-什么是CDN三级溯源？">2.  什么是CDN三级溯源？</h4>
<ul>
<li><strong>CDN目的</strong>。CDN 系统设计的首要目标是<strong>尽量减少用户的访问响应时间</strong></li>
<li><strong>CDN实现思路。<strong>为达到这一目标，CDN 系统应该</strong>尽量将用户所需要的内容存放在距离用户最近的位置</strong>。也就是说，负责为用户提供内容服务的 <strong>Cache设备应部署在物理上的网络边缘位置</strong>，我们称这一层为 CDN边缘层 。</li>
<li>**CDN系统架构。**CDN 系统中负责全局性管理和控制的设备组成 中心层 ，<strong>中心层同时保存着最多的内容副本</strong>，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</li>
</ul>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210813124031742.png" alt="image-20210813124031742"></p>
<h1>四、操场系统</h1>
<h2 id="4-1-操作系统基础">4.1 操作系统基础</h2>
<h4 id="0-（百度安全一面）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？">0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</h4>
<ul>
<li>存储器：内存</li>
<li><strong>控制器：南桥北桥</strong></li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li>输出设备：显示器、网卡</li>
</ul>
<h4 id="1-什么是操作系统？">1. 什么是操作系统？</h4>
<ol>
<li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；</li>
<li>操作系统本质上是运行在计算机上的软件程序 ；</li>
<li>操作系统为用户提供⼀个与系统交互的操作界面 ；</li>
<li>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</li>
</ol>
<h4 id="2-什么是系统调用呢？-能不能详细介绍⼀下？">2. 什么是系统调用呢？ 能不能详细介绍⼀下？</h4>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode) :</strong> 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li>**系统态(kernel mode)：**可以简单的理解系统态运行的进程或程序⼏乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>我们运行的程序基本都是运行在<strong>用户态</strong>，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>这些系统调用按功能大致可分为如下⼏类：</p>
<ul>
<li><strong>设备管理</strong>。完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>⽂件管理</strong>。完成⽂件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong>。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong>。完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong>。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h4 id="3-CentOS-和-Linux的关系？">3. <strong>CentOS 和 Linux的关系？</strong></h4>
<p>Linux意思较广广义的范围，多指是Linux内核。CentOS是RedHat的一个分支，RedHat是Linux的一个发行版本，RedHat与CentOS的区别在于，RedHat收费，CentOS免费。</p>
<h4 id="4-什么是分布式，优缺点？集群？">4. 什么是分布式，优缺点？集群？</h4>
<ul>
<li>
<p><strong>分布式</strong></p>
<p>根据业务需求进行拆<strong>分成N个子系统</strong>，多个子系统相互协作才能完成业务流程<strong>子系统之间通讯</strong>使用<strong>RPC</strong>远程通讯技术。</p>
</li>
<li>
<p><strong>集群</strong></p>
<p>同一个工程部署在多个不同的服务器上。</p>
</li>
<li>
<p><strong>分布式优点</strong></p>
<p>1.把模块拆分，使用接口通信，降低模块之间的耦合度。</p>
<p>2.把项目拆分成若干个子项目，不同的团队负责不同的子项目。</p>
<p>3.增加功能时只需要再增加一个子项目，调用其它系统的接口就可以。</p>
<p>4.可以灵活的进行分布式部署。</p>
</li>
<li>
<p><strong>分布式缺点</strong></p>
<p>1.系统之间交互需要使用远程通信，接口开发增加工作量。</p>
<p>2.各个模块有一些通用的业务逻辑无法共用。</p>
</li>
</ul>
<h4 id="5-在Linux-windows栈空间的大小？">5. 在Linux/windows栈空间的大小？</h4>
<ul>
<li>
<p><strong>Linux环境下由操作系统决定</strong>，一般是<code>8KB</code> ， 通过ulimit命令查看以及修改</p>
<blockquote>
<p>在Linux下通过如下命令可查看和设置栈的大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a            <span class="comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）</span></span>       </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -s 32768      <span class="comment"># 设置当前栈的大小为32MCopy to clipboardErrorCopied</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p><strong>Windows环境下由编译器决定</strong>，VC++6.0一般是<code>1M</code> \</p>
<blockquote>
<p>Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p>
</blockquote>
</li>
</ul>
<h4 id="6-ASCII、Unicode和UTF-8编码的区别？">6. ASCII、Unicode和UTF-8编码的区别？</h4>
<ul>
<li>
<p><strong>ASCII :</strong>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号 ；</p>
<blockquote>
<p>常用中文需要两个字节，且不能和ASCII冲突，中国定制了<code>GB2312</code>编码格式。</p>
</blockquote>
</li>
<li>
<p><strong>Unicode：</strong> Unicode就是将<strong>不同语言统一到一套编码格式中</strong>，通常<strong>两个</strong>字节表示一个字符，而<strong>ASCII是一个</strong>字节表示一个字符 ；</p>
<blockquote>
<p>如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
</blockquote>
</li>
<li>
<p><strong>UTF-8 :</strong>  把Unicode编码转化为 “<strong>可变长编码</strong>” UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为<strong>1-6</strong>个字节，英文字母被编码成<strong>1</strong>个字节，常用汉字被编码成<strong>2</strong>个字节。</p>
</li>
</ul>
<h5 id="6-1-三者区别和联系">6.1 三者区别和联系</h5>
<ul>
<li>
<p>在<strong>计算机内存</strong>中，统一使用<strong>Unicode</strong>编码 ；</p>
</li>
<li>
<p>当需要<strong>保存到硬盘或者需要传输</strong>的时候，就转换为<strong>UTF-8</strong>编码</p>
</li>
</ul>
<p>举例说明：</p>
<blockquote>
<p>例1 ：记事本编辑（内存）→保存（磁盘）。</p>
</blockquote>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p>
<p><img src="https://i.loli.net/2021/06/11/9IjWniLHqrwRd2s.png" alt="image-20210611131935690"></p>
<blockquote>
<p>例2：网络传输服务器→浏览器。</p>
</blockquote>
<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p>
<p><img src="https://i.loli.net/2021/06/11/hZFaKbezvQEsxko.png" alt="image-20210611132058826"></p>
<h4 id="7-什么是并发和并行？">7. 什么是并发和并行？</h4>
<ul>
<li><strong>并发：</strong> 是指宏观上在<strong>一段时间</strong>内能同时运行多个<strong>程序</strong>；</li>
<li><strong>并行</strong> ：则指<strong>同一时刻</strong>能运行多个<strong>指令</strong>。</li>
</ul>
<h4 id="8-什么是共享？">8. 什么是共享？</h4>
<ul>
<li>
<p><strong>共享定义：</strong> 系统中的资源可以被多个并发进程共同使用 ；</p>
</li>
<li>
<p><strong>共享方式</strong>：<u>互斥</u>共享和<u>同时</u>共享：</p>
<ul>
<li><strong>互斥共享：</strong> 在<strong>同一时刻只允许一个进程访问</strong>，需要用同步机制来实现互斥访问 ，如：打印机。</li>
</ul>
</li>
</ul>
<h2 id="4-2-进程和线程">4.2 进程和线程</h2>
<h4 id="1-请问64位和32位的区别？">1. <strong>请问64位和32位的区别？</strong></h4>
<ol>
<li>**运行能力不同。**64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。</li>
<li><strong>内存寻址不同</strong>。64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。</li>
<li>**运行软件不同。**由于32位和64位<u>CPU的指令集是不同</u>的。所以需要区分32位和64位版本的软件。<br>
为了保证兼容性，64位CPU上也能运行老的32位指令，但反过来32位系统不可以运行64位的软件。</li>
</ol>
<h4 id="2-介绍一下线程和进程的区别？">2. <strong>介绍一下线程和进程的区别？</strong></h4>
<ol>
<li>
<p><strong>根本区别：<strong>进程是操作系统</strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度</strong>和执行的基本单位</p>
</li>
<li>
<p><strong>资源开销：每个进程都有独立的代码和数据空间（程序上下文）</strong>，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器</strong>（PC），线程之间切换的开销小</p>
</li>
<li>
<p>**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>
</li>
<li>
<p><strong>内存分配：<strong>同一进程的线程</strong>共享本进程的【地址空间和资源】</strong>，而进程之间的地址空间和资源是相互独立的</p>
</li>
<li>
<p>**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>，<strong>所以多进程要比多线程健壮</strong>。</p>
<blockquote>
<p>线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。</p>
</blockquote>
</li>
<li>
<p>**能否独立：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
</li>
</ol>
<h5 id="2-1-线程和协程之间的区别？">2.1 线程和协程之间的区别？</h5>
<blockquote>
<p><strong>进程是资源调度的基本单位</strong>，<strong>运行一个可执行程序会创建一个或多个进程</strong>，进程就是运行起来的可执行程序 ;</p>
<p><strong>线程是程序执行的基本单位</strong>，是轻量级的进程。<strong>每个进程中都有唯一的主线程，和多个线程</strong>，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束；</p>
<p><strong>协程</strong>是用户态的<strong>轻量级线程</strong>，<strong>也是线程内部调度的基本单位</strong> 。</p>
</blockquote>
<p>协程和线程的区别如下（补充了和进程的区别，方便对比）。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">进程</th>
<th style="text-align:left">线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">定义</td>
<td style="text-align:left">资源分配和拥有的基本单位</td>
<td style="text-align:left">程序执行的基本单位</td>
<td>用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td style="text-align:left">切换情况</td>
<td style="text-align:left">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td style="text-align:left">保存和设置程序计数器、少量寄存器和栈的内容</td>
<td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr>
<td style="text-align:left">切换者</td>
<td style="text-align:left">操作系统</td>
<td style="text-align:left">操作系统</td>
<td>用户</td>
</tr>
<tr>
<td style="text-align:left">切换过程</td>
<td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td>
<td style="text-align:left">用户态-&gt;内核态-&gt;用户态</td>
<td>用户态(没有陷入内核)</td>
</tr>
<tr>
<td style="text-align:left">调用栈</td>
<td style="text-align:left">内核栈</td>
<td style="text-align:left">内核栈</td>
<td>用户栈</td>
</tr>
<tr>
<td style="text-align:left">拥有资源</td>
<td style="text-align:left"><strong>CPU资源、内存资源、文件资源和句柄等</strong></td>
<td style="text-align:left"><strong>程序计数器、寄存器、栈和状态字</strong></td>
<td><strong>拥有自己的寄存器上下文和栈</strong></td>
</tr>
<tr>
<td style="text-align:left">并发性</td>
<td style="text-align:left">不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td style="text-align:left">一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td style="text-align:left">系统开销</td>
<td style="text-align:left">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td style="text-align:left">切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td style="text-align:left">通信方面</td>
<td style="text-align:left">进程间通信需要借助操作系统</td>
<td style="text-align:left">线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td>共享内存、消息队列</td>
</tr>
</tbody>
</table>
<h5 id="2-2-一个进程可以创建多少个线程，和什么有关？">2.2 一个进程可以创建多少个线程，和什么有关？</h5>
<p>一个进程可用虚拟空间是（C++）2G，默认情况下，（假设）<strong>线程的栈的大小是1MB</strong>（Linux是8kb），则理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p>
<h5 id="2-3-进程之间的同步方式？（区分通信方式）">2.3 进程之间的同步方式？（区分通信方式）</h5>
<ol>
<li>
<p><strong>临界区。</strong> 对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
</li>
<li>
<p><strong>同步和互斥。</strong></p>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻<strong>只有一个进程</strong>能进入临界区。</li>
</ul>
</li>
<li>
<p><strong>信号量。</strong> 常见的 P 和 V 操作。</p>
<ul>
<li>特别的，<u>如果信号量的取值只能为 0 或者 1</u>，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</li>
</ul>
</li>
<li>
<p><strong>条件变量。</strong></p>
<blockquote>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
</blockquote>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程：解决生产者、消费者问题</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function">procedure <span class="title">insert</span><span class="params">(item: integer)</span></span>;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = N then wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> then signal(empty);</span><br><span class="line">    end;</span><br><span class="line"></span><br><span class="line">    function remove: integer;</span><br><span class="line">    begin</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> then wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N <span class="number">-1</span> then signal(full);</span><br><span class="line">    end;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = produce_item;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line">procedure consumer</span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">        item = ProducerConsumer.remove;</span><br><span class="line">        consume_item(item);</span><br><span class="line">    end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-请问【进程】之间如何进行通信？">3. <strong>请问【进程】之间如何进行通信？</strong></h4>
<p>可以分为如下两个方面：</p>
<ol>
<li>本地进程之间的通信方式</li>
<li>远程进程之间的通信方式</li>
</ol>
<p><strong>1. 本地进程之间的通信方式（没有同步互斥！！）</strong></p>
<ul>
<li>
<p><strong>无名管道</strong> ：半双工通信方式，<strong>数据(消息)单向流动</strong>，只能是字节流格式的消息。</p>
<ul>
<li>
<p>**优点：**简单方便</p>
<ul>
<li>**缺点：<strong>单向通信、只能用于</strong>具有亲缘关系（一般指父子）**的进程之间、<strong>缓冲区有限</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>有名管道：半双工通信</strong>方式，数据也称为命名管道：是一种文件类型，以一种特殊设备文件形式存在于文件系统中。</p>
<ul>
<li><strong>优点</strong>：可以实现<strong>任意关系的进程</strong>间的通信（无法同步）</li>
<li><strong>缺点：</strong> 长期存于系统中，使用不当容易出错、<strong>缓冲区有限</strong></li>
</ul>
</li>
<li>
<p><strong>消息队列</strong>：消息队列是消息的<strong>链表</strong>,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点。</p>
<ul>
<li><strong>优点</strong>：<u>可以实现任意进程间的通信</u>，并通过系统调用函数来实现消息发送和接收之间的同步<u>，无需考虑同步</u>问题</li>
<li><strong>缺点</strong>：信息的复制需要<u>额外消耗CPU的时间</u>，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>
<p><strong>共享内存</strong></p>
<p>直接对内存存取，<u>通信快</u>，但是多个进程可以同时操作，<u>需要用信号量进行同步</u>。</p>
</li>
<li>
<p><strong>信号量</strong></p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<ul>
<li>
<p><strong>优点</strong>：可以同步进程；</p>
</li>
<li>
<p><strong>缺点</strong>：信号量有限</p>
<blockquote>
<p>注解：P操作就是对S减一，V操作就是对S加一</p>
</blockquote>
<ul>
<li>**同步：**S = 0，进程A执行完进行V操作，进程B执行前执行P操作，这样B就可以等A执行完再执行；</li>
<li>**互斥：**S = 1，进程执行前进行P操作，执行后进行V操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2.远程进程之间的通信方式</strong></p>
<p>首要解决的问题是如何唯一标识一个进程？本地上采用PID即可，但是网络中 <u>TCP/IP五层网络模型中传输层的 “<strong>套接字：IP+端口</strong>”</u></p>
<ul>
<li>
<p><strong>套接字交互</strong></p>
<ul>
<li><strong>优点</strong>：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强</li>
<li><strong>缺点</strong>：1) 需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
<li>
<p><strong>远程过程调用（RPC）</strong></p>
</li>
</ul>
<h4 id="4-请问【线程】间同步方式（通信方式）？">4. 请问【线程】间同步方式（通信方式）？</h4>
<p><img src="https://i.loli.net/2021/06/11/38AqLbJEZnhSPC9.png" alt="image-20210611000107784"></p>
<p>【<strong>1. Linux下线程通知方式</strong>】</p>
<ol>
<li>**互斥量(Mutex)：**采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。
<ul>
<li>⽐如 Java 中的<strong>synchronized 关键词和各种 Lock锁</strong> 都是这种机制。</li>
</ul>
</li>
<li><strong>信号量(Semphares)</strong> ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最大线程数量</li>
<li><strong>条件变量</strong> : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级
<ul>
<li>比如Wait/Notify</li>
</ul>
</li>
</ol>
<p>【<strong>2. Windows下线程通知方式</strong>】</p>
<ol>
<li>**全局变量：**需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 ；</li>
<li><strong>CEvent对象</strong>：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法；</li>
<li>**Message消息机制：**常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</li>
</ol>
<h4 id="5-什么时候用多线程-多进程？">5. <strong>什么时候用多线程 / 多进程？</strong></h4>
<ul>
<li><strong>需要<u>频繁创建销毁</u>的优先用线程</strong> ：创建和销毁的代价是很难承受的 ；</li>
<li><strong>需要进行<u>大量计算</u>的优先使用线程</strong> ：此时<strong>耗费很多CPU，切换频繁</strong>，用线程更轻量；</li>
<li><strong>任务间相关性比较强的用多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单；</li>
</ul>
<p>考虑多进程：</p>
<ul>
<li>扩展到<strong>多机分布</strong>的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong> ；</li>
<li>其它一般用多线程比较好</li>
</ul>
<h4 id="6-【线程】调度算法？">6. <strong>【线程】调度算法？</strong></h4>
<p>在资源一定的情况下，调度算法需要在<strong>吞吐量（Throughput）</strong>、<strong>平均响应时间（延迟，Average Response Time）</strong>、<strong>公平性</strong>、**调度引起的额外开销（overhead）**等几个方面做权衡。</p>
<ol>
<li>
<p><strong>先进先出算法（FIFO，First-In-First-Out）</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>（🚩*1）<strong>最少的任务切换开销</strong>（因为没有在任务执行过程中发生切换，故任务切换开销为0）</li>
<li><strong>最大的吞吐量</strong>（因没有任务切换开销，在其他一定的情况下，吞吐量肯定是最大的）</li>
<li><strong>最朴实的公平性</strong>（先来先做）</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>**平均响应时间高：**耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来，他则需要1010毫秒才能执行完成，绝大部分时间都花在等待被调度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>最短耗时任务优先算法</strong></p>
<p>优先调度耗时短的任务，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。</p>
<ul>
<li>（<strong>优点</strong>）**平均响应时间较低：**这里有一点，因为将时间长的任务无限往后推移，实际计算的平均响应时间的任务都是执行较快的任务，统计出来的平均响应时间必然较低的。</li>
<li><strong>（缺点</strong>）**耗时长任务饥饿：**耗时长的任务迟迟得不到调度，不公平，容易形成饥饿 。</li>
<li><strong>（缺点</strong>）<strong>开销大：</strong><u>频繁的任务切换</u>，调度的额外开销大。</li>
</ul>
</li>
<li>
<p><strong>时间片轮转算法</strong></p>
<p>给队列中的每个任务一个时间片，第一个任务先执行，时间片到了之后，将此任务放到队列尾部，切换到下个任务执行，<u>解决最短耗时任务优先算法中耗时长任务饥饿的问题</u> 。</p>
<ul>
<li><strong>（特点）时间片设置问题：</strong> 算法介于FIFO和SJF之间，若时间片足够<strong>大</strong>，则退化到FIFO ；若分片足够小（假设不考虑任务切换的开销），则任务的完成时间顺序是以耗时从小到大排列。</li>
<li>（<strong>优点）公平调度</strong>：每个任务都能够得到公平的调度
<ul>
<li>（**优点）不会饥饿：**耗时短的任务即使落在耗时长的任务后面，也能够较快的得到调度执行</li>
</ul>
</li>
<li><strong>（缺点）开销大：</strong><u>任务切换引起的调度开销较大</u>，需要多次切换任务上下文
<ul>
<li><strong>（缺点</strong>）时间片不太好设置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>（🚩*1）<strong>最大最小公平算法</strong></p>
</li>
</ol>
<h4 id="7-【进程】调度算法？">7.<strong>【进程】调度算法？</strong></h4>
<ul>
<li>先来先服务调度算法</li>
<li>短作业(进程)优先调度算法</li>
<li>时间片轮转法</li>
<li><strong>多级反馈队列调度算法</strong></li>
<li>优先权调度算法</li>
</ul>
<h4 id="8-CPU上下文切换？有什么类型？线程发生在什么地方？">8. <strong>CPU上下文切换？有什么类型？线程发生在什么地方？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p>
</blockquote>
<ul>
<li>
<p><strong>什么是 CPU 上下文</strong> ？</p>
<p><u>CPU 寄存器和程序计数器</u> 就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，<strong>必须的依赖环境</strong>。</p>
<blockquote>
<ul>
<li><u>CPU 寄存器</u> 是 CPU 内置的容量小、但速度极快的内存。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>什么是 CPU 上下文切换?</strong></p>
<p>通常指以下过程：</p>
<ol>
<li>前一个任务的 CPU 上下文（也就是 <strong>CPU 寄存器和程序计数器</strong>）保存起来;</li>
<li>然后加载新任务的上下文到这些寄存器和程序计数器;</li>
<li>最后再跳转到程序计数器所指的新位置，运行新任务。</li>
</ol>
</li>
<li>
<p><strong>CPU 上下文切换的类型？</strong></p>
<p>根据任务的不同，可以分为以下三种类型 :  <strong>进程上下文切换 - 线程上下文切换 - 中断上下文切换</strong> 。</p>
<ol>
<li>
<p><strong>进程上下文切换</strong></p>
<p>进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p>
<blockquote>
<ul>
<li>
<p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p>
</li>
<li>
<p>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</p>
</li>
</ul>
</blockquote>
<p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，在<u>这个过程中就发生了 <strong>CPU</strong> 上下文切换（<strong>两</strong>次，用户态-内核态-用户态））</u>。</p>
<blockquote>
<p><strong>系统调用</strong> : 查看文件时read()、wirte() 操作就发生了系统调用。</p>
<p>但是，系统调用过程中，<strong>并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-440bb1699b2fa0f0340b38eabcbd7452_720w.jpg" alt="img"></p>
<p>而<u><strong>进程</strong>上下文切换</u> ，比系统调用时多了一步：在<strong>保存内核态资源</strong>（当前进程的<u>内核状态和 CPU 寄存器</u>）之前，需要先把该进程的<strong>用户态资源</strong>（<u>虚拟内存、栈等</u>）保存下来。</p>
</li>
<li>
<p><strong>线程上下文调用</strong></p>
<p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p>
<p>【面试高频】发生线程上下文切换的场景</p>
<ul>
<li>**前后两个线程属于不同进程。**此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li>
<li>**前后两个线程属于同一个进程。<strong>此时，因为虚拟内存是共享的，所以在切换时，<u>虚拟内存</u>这些资源就保持不动，只需要切换</strong>线程的私有数据（栈、寄存器等)**不共享的数据</li>
</ul>
</li>
<li>
<p><strong>中断上下文切换</strong></p>
</li>
</ol>
</li>
</ul>
<h4 id="9-如何杀死一个进程？-进程终止的方式？">9. <strong>如何杀死一个进程？</strong> 进程终止的方式？</h4>
<ol>
<li>linux命令：<code>kill -9 &lt;pid&gt;</code></li>
<li>接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</li>
<li>main函数的自然返回，<code>return</code></li>
<li>调用<code>exit</code>函数，属于c的函数库 3、调用<code>_exit</code>函数，属于系统调用</li>
<li>调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程</li>
</ol>
<h5 id="9-1-终端退出，终端运行的进程会怎么样？">9.1 终端退出，终端运行的进程会怎么样？</h5>
<ol>
<li>
<p>终端在退出时会发送<code>SIGHUP</code>给对应的bash进程，</p>
</li>
<li>
<p>bash进程收到这个信号后首先将它发给session下面的进程</p>
<blockquote>
<p>一个session就是一个shell终端会话窗口。</p>
</blockquote>
</li>
<li>
<p>如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p>
</li>
</ol>
<h5 id="9-2-怎么让进程后台运行？">9.2 怎么让进程后台运行？</h5>
<ol>
<li><code>命令 + &amp;</code> 即可，实际上，这样是将命令放入到一个作业队列中了</li>
<li><code>ctrl + z</code> 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</li>
<li><code>nohup + &amp;</code>，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</li>
<li><code>setsid + 命令</code>，使其父进程编程init进程，不受HUP信号的影响</li>
<li>将<code>命令+ &amp;</code>放在()括号中，也可以是进程不受HUP信号的影响</li>
</ol>
<h4 id="10-外中断和异常的区别？">10. 外中断和异常的区别？</h4>
<ul>
<li>
<p><strong>外中断是指由 CPU 执行指令以外的事件引起</strong>，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
</li>
<li>
<p><strong>异常时由 CPU 执行指令的内部事件引起</strong>，如非法操作码、地址越界、算术溢出等。</p>
</li>
</ul>
<h4 id="11-什么是父进程、子进程、进程组、作业和会话？">11. 什么是父进程、子进程、进程组、作业和会话？</h4>
<ul>
<li>
<p><strong>父进程：</strong> 已创建一个或多个子进程的进程 ；</p>
</li>
<li>
<p><strong>子进程：</strong> 由<strong>fork</strong>创建的新进程被称为子进程（child process），函数被调用一次，但返回两次；</p>
<p>fork之后，操作系统会<strong>复制一个与父进程完全相同的子进程</strong>，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系：</p>
<ul>
<li>（1）它们共<strong>享代码空间</strong>，（2）<strong>数据空间是互相独立</strong>的，但<strong>子进程数据空间中的内容是父进程的完整拷贝</strong>，（3）<strong>指令指针也完全相同</strong>，（4）子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同）。</li>
</ul>
<p>除了：fork成功，<strong>子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号pid</strong> 。</p>
</li>
<li>
<p><strong>进程组：</strong> 进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID ；</p>
</li>
<li>
<p><strong>作业：</strong> shell<strong>分前后台</strong>来控制的不是进程而是作业（job）或者进程组（Process Group）。</p>
<blockquote>
<p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。、</p>
</blockquote>
</li>
<li>
<p><strong>会话。</strong> 一个或多个<strong>进程组的集合</strong>，<strong>一个会话可以有一个控制终端</strong>。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p>
</li>
</ul>
<h4 id="12-什么是守护进程、僵尸进程、孤儿进程？">12. 什么是守护进程、僵尸进程、孤儿进程？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></p>
</blockquote>
<ul>
<li>
<p><strong>守护进程</strong></p>
<p><strong>在后台运行的，没有控制终端与之相连</strong>的进程。它<strong>独立于控制终端</strong>，周期性地执行某种任务。它不需要用户输入就能运行而且提供某种服务，不是<strong>对整个系统就是对某个用户程序</strong>提供服务。</p>
<ul>
<li>举例：常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</li>
</ul>
<p>一个守护进程的父进程是init进程，也是一个<u>孤儿进程</u> ，一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。</p>
</li>
<li>
<p><strong>孤儿进程</strong></p>
<p>一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
</li>
<li>
<p><strong>僵尸进程</strong></p>
<p>一个进程使用fork创建子进程，如果<strong>子进程退出</strong>，而父进程并没有调用wait或waitpid获取子进程的状态信息（子进程必须<strong>等到父进程捕获到了子进程的退出状态才真正结束</strong>），那么<strong>子进程的进程描述符仍然保存在系统中</strong>。这种进程称之为僵死进程。</p>
</li>
</ul>
<h5 id="11-1-如何避免僵尸进程？">11.1 如何避免僵尸进程？</h5>
<ul>
<li>
<p>通过**signal(SIGCHLD, SIG_IGN)**通知内核对子进程的结束不关心，由内核回收；</p>
<blockquote>
<p>如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN); 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p>
</blockquote>
</li>
<li>
<p>父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞；</p>
<blockquote>
<p>waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p>
</blockquote>
</li>
<li>
<p>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出;</p>
</li>
<li>
<p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p>
</li>
</ul>
<h2 id="4-3-socket编程">4.3 socket编程</h2>
<p>暂略</p>
<h2 id="4-4-内存管理">4.4 内存管理</h2>
<h4 id="1-介绍一下操作系统的堆和栈？">1. <strong>介绍一下操作系统的堆和栈？</strong></h4>
<ul>
<li>
<p>**栈内存：**栈内存首先是一片内存区域，存储的都是<u>局部变量</u>，栈内存的<u>更新速度很快</u>，因为局部变量的生命周期都很短。</p>
<blockquote>
<p>局部变量：方法内的变量，for循环内部定义的也是局部变量等。</p>
</blockquote>
</li>
<li>
<p><strong>堆内存：<strong>存储的是<u><strong>数组</strong></u>和</strong>对象</strong>（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p>
</li>
</ul>
<h5 id="1-1-什么时候会栈溢出？">1.1 什么时候会栈溢出？</h5>
<p>栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。</p>
<ul>
<li>如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了；</li>
<li>一般常见的情况，如<strong>递归过深</strong></li>
</ul>
<h4 id="2-介绍一下什么内存管理？常用的内存管理机制？">2. 介绍一下什么内存管理？常用的内存管理机制？</h4>
<ul>
<li>
<p><strong>内存管理</strong></p>
<p>操作系统的内存管理主要负责内存的（1）<strong>分配与回收（<strong>malloc 函数：申请内存，free 函数：释放内存），（2）另外地址转换也就是将</strong>逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情。</p>
</li>
<li>
<p><strong>常用内存管理机制</strong></p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为⼀个用户程序分配⼀个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许⼀个程序使用的内存分在离散或者说不相邻的内存中，常见的如<strong>页式管理 和 段式管理</strong>。</p>
<ol>
<li>
<p><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。<strong>将内存分为⼏个固定大小的块</strong>，每个块中只包含⼀个进程。如果程序运行需要内存的话，操作系统就分配给它⼀块，如果程序运行只需<br>
要很小的空间的话，分配的这块内存很大⼀部分⼏乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p>
</li>
<li>
<p><strong>页式管理</strong> ：把主存分为大小相等且固定的⼀页⼀页的形式，<strong>页较小，相对相⽐于块式管理的划分⼒度更大</strong>，提高了内存利用率，减少了碎片。页式管理通过<u>页表对应逻辑地址和物理地址</u>。</p>
</li>
<li>
<p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为⼀段段的，<strong>每⼀段的空间⼜要⽐⼀页的空间小很多</strong> 。</p>
</li>
</ol>
<blockquote>
<p>但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如，有主程段 MAIN、子程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p>
</blockquote>
<ol start="4">
<li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲页，也就是说 段页式管理机制中段与段之间以及段的内部的都是离散的。</li>
</ol>
</li>
</ul>
<h5 id="2-1-介绍一下逻辑地址和物理地址？">2.1 介绍一下逻辑地址和物理地址？</h5>
<ul>
<li>我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥面存储的数值就可以理解成为<strong>内存⾥的⼀个地址</strong>，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</li>
<li>物理地址指的是<strong>真实物理内存中地址</strong>，更具体⼀点来说就是内存地址寄存器中的地址。</li>
</ul>
<h5 id="2-2-操作系统在内存管理需要做什么？">2.2 操作系统在内存管理需要做什么？</h5>
<ul>
<li>内存空间的分配与回收；</li>
<li>从逻辑上对内存空间进行扩充；</li>
<li>逻辑地址与物理地址的转换；</li>
<li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</li>
</ul>
<h4 id="3-介绍一下快表和多级页表？">3. 介绍一下快表和多级页表？</h4>
<p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，<strong>页表也会很大</strong>的问题。</li>
</ol>
<h5 id="快表介绍">快表介绍</h5>
<p>快表理解为⼀种<strong>特殊的高速缓冲存储器</strong>（Cache），其中的<strong>内容是页表的⼀部分或者全部内容</strong>。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。</p>
<blockquote>
<p>但有时快表不命中要访问两次缓存，不过总体还是提高了性能。</p>
</blockquote>
<h5 id="多级页表介绍">多级页表介绍</h5>
<p>引⼊多级页表的主要⽬的是为了 <u><strong>避免把全部页表⼀直放在内存中占用过多空间</strong></u>，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表<strong>属于时间换空间</strong>的典型场景。</p>
<h4 id="4-分页机制和分段机制的共同点和区别-？">4. 分页机制和分段机制的共同点和区别 ？</h4>
<ol>
<li>共同点 ：
<ul>
<li>分页机制和分段机制都是为了<strong>提高内存利用率，较少内存碎片</strong>。</li>
<li>页和段都是<strong>离散存储</strong>的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>区别 ：
<ul>
<li><strong>页的大小是固定的</strong>，由操作系统决定；<strong>而段的大小不固定</strong>，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了<strong>满⾜操作系统内存管理</strong>的需求，而<strong>段是逻辑信息的单位，在程序中可以体现为代码段，数据段</strong>，能够更好满⾜用户的需要。</li>
</ul>
</li>
</ol>
<h4 id="5-【待扩充】CPU-寻址了解吗-为什么需要虚拟地址空间">5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间?</h4>
<ul>
<li>
<p>现代处理器使用的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使用虚拟寻址，<strong>CPU 需要虚拟地址翻译成物理地址</strong>，这样才能访问到真实的物理内存。</p>
<blockquote>
<p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。</p>
</blockquote>
</li>
<li>
<p><strong>如果直接把物理地址暴露出来的话会带来严重问题</strong>，⽐如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p>
</li>
</ul>
<h4 id="6-如果系统中具有快表后，那么地址的转换过程变成什么样了？">6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？</h4>
<blockquote>
<p>简单来说：cup计算页号 → 快表查询是否有该页号 → 否则页表查询</p>
</blockquote>
<ol>
<li><strong>计算页号和页偏移量。</strong> CPU给出逻辑地址，由某个硬件算得页号、页内偏移量；</li>
<li><strong>快表中查找内存块号。</strong> 将页号与快表中的所有页号进行比较，如果找到匹配的页号，则直接从中取出该页对应的内存块号，再<strong>将内存块号与页内偏移量拼接形成物理地址</strong>；</li>
<li><strong>页表中查找内存块号。</strong> 如果快表中查找不存在，访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。</li>
</ol>
<h4 id="7-进程内存分配动态分区算法？">7. 进程内存分配动态分区算法？</h4>
<ol>
<li>
<p><strong>首次适应法。</strong></p>
<ul>
<li>
<p><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区；</p>
</li>
<li>
<p><strong>实现方式</strong>：空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p>
</li>
<li>
<p><strong>优点：</strong> 综合性能最好，开销小。</p>
<p><img src="https://i.loli.net/2021/06/10/PEpjmDW52eqGl4f.png" alt="image-20210610231604639"></p>
</li>
</ul>
</li>
<li>
<p><strong>最佳适应法。</strong></p>
<ul>
<li>**算法思想：**为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区；</li>
<li><strong>实现方式：</strong> 空闲分区按<strong>容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li>
<li><strong>优点：</strong> 会有更多的大分区被保留下来，<u>更能满足大进程需求</u></li>
<li><strong>缺点：</strong> 产生很多太小的、难以利用的碎片，算法开销大</li>
</ul>
</li>
<li>
<p><strong>最坏适应法。</strong></p>
<ul>
<li><strong>算法思想：</strong> 为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li>
<li><strong>实现方式：<strong>空闲分区按</strong>容量递减</strong>次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li>
<li><strong>优点：</strong> 可以减少难以利用的小碎片</li>
<li><strong>缺点：</strong> 大分区容易被用完，不利于大进程，算法开销大</li>
</ul>
</li>
<li>
<p><strong>领近适应法。</strong></p>
<ul>
<li><strong>算法思想：</strong> 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</li>
<li><strong>实现方式：<strong>空闲分区以</strong>地址递增</strong>的顺序排列(可排成一个<strong>循环链表</strong>)。每次分配内存时<u>从上次查找结束的位置开始</u> ，查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</li>
<li><strong>优点：</strong> 算法开销小</li>
</ul>
</li>
</ol>
<h4 id="8-什么是内存覆盖和内存交换？">8. 什么是内存覆盖和内存交换？</h4>
<ul>
<li><strong>内存覆盖</strong>
<ul>
<li><strong>思想：</strong> 把用户空间分成为一个<strong>固定区</strong>和<strong>若干个覆盖区</strong>。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</li>
<li><strong>特点：</strong> <strong>打破</strong>了必须将<strong>一个进程的全部信息装入内存后才能运行</strong>的限制 。</li>
</ul>
</li>
<li><strong>内存交换</strong>
<ul>
<li><strong>思想：</strong> <u>内存空间紧张</u> 时，系统将内存中<strong>某些进程暂时换出外存</strong>，把外存中某些已<strong>具备运行条件的进程换入内存</strong>。</li>
</ul>
</li>
</ul>
<h2 id="4-5-虚拟内存">4.5 虚拟内存</h2>
<h4 id="0-什么是虚拟技术-？从时间和空间两方面来说。">0. 什么是虚拟技术 ？从时间和空间两方面来说。</h4>
<p>虚拟技术<strong>把一个物理实体转换为多个逻辑实体</strong> ：</p>
<ul>
<li><strong>时分复用技术</strong> ： 如多个进程能在同一个处理器上并发执行使用了时分复用技术，让<u>每个进程轮流占用处理器，每次只执行一小个时间片并快速切换</u> ；</li>
<li>**空分复用技术： ** <u>物理内存抽象为地址空间，每个进程都有各自的地址空间</u>。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
<h4 id="1-介绍一下局部性原理吧？">1. 介绍一下局部性原理吧？</h4>
<p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装⼊部分程序到内存就开始运行。</p>
<p>局部性原理表现在以下两个⽅面：</p>
<ol>
<li><strong>时间局部性 ：<strong>如果程序中的</strong>某条指令</strong>⼀旦执行，不久以后<strong>该指令可能再次执</strong>行；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
</ol>
<blockquote>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</p>
</blockquote>
<ol start="2">
<li><strong>空间局部性 ：<strong>⼀旦程序访问了</strong>某个存储单元</strong>，在不久之后，其<strong>附近的存储单</strong>元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也⼀般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<blockquote>
<p>空间局部性通常是使用教大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p>
</blockquote>
<p>虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h4 id="2-介绍一下，什么是虚拟内存？页式存储？">2. <strong>介绍一下，什么是虚拟内存？页式存储？</strong></h4>
<ul>
<li>
<p><strong>虚拟内存</strong></p>
<p>虚拟内存是一种存储机制，可为用户提供一个拥有很大主内存的错觉。<strong>通过将辅存的一部分作为主存</strong>来完成。在虚拟内存中，用户可以存储比可用主内存更大的进程。</p>
<blockquote>
<p>每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，仅仅是每个进程“认为”自己拥有4G的内存。等到进程真正运行的时候，<strong>需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行磁盘数据拷贝到物理内存中</strong></p>
</blockquote>
<p><img src="https://i.loli.net/2021/04/20/NO5zyG824P9FSHs.jpg" alt="img"></p>
</li>
<li>
<p><strong>页式存储</strong></p>
<p>大部分虚拟存储系统采用的是一种称为**分页（paging）**的技术。这种方式叫做虚拟页式存储管理。</p>
<ul>
<li>
<p>物理内存空间划分为固定大小的内存块，称为物理页面，或者是<strong>页框</strong>（page frame）</p>
</li>
<li>
<p>虚拟地址空间也划分成大小相同的块，称为虚拟页面，或者简称<strong>页面</strong>（page）</p>
<blockquote>
<p>页表：将<strong>虚拟页面映射为</strong>相应的<strong>物理页面</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3-虚拟内存的技术实现-？">3. 虚拟内存的技术实现 ？</h4>
<p>虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建⽴在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。请求分页是⽬前最常用的⼀种实现虚拟存储器的⽅法。请求分页存储管理系统中，在作业开始运行之前，仅装⼊当前要执行的部分页即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调⼊到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理 ：<strong>建⽴在分段存储管理之上，增加了</strong>请求调段功能、分段置换功能</strong>。请求分段储存管理⽅式就如同请求分页储存管理⽅式⼀样，在作业开始运行之前，仅装⼊当前要执行的部分段即可运行；在执行过程中，可使用请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，而⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间而装⼊新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<h4 id="4-请你介绍一下页面置换算法？">4. 请你介绍一下页面置换算法？</h4>
<p>当发⽣缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择⼀个页面将其移出内存，以便为即将调⼊的页面让出空间。用来选择淘汰哪⼀页的规则叫做页面置换算法，我们可以把页<br>
⾯置换算法看成是淘汰页面的规则。</p>
<ul>
<li>
<p>**OPT （最佳页面置换算法） ：**最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最⻓时间内不再被访问的页面,这样可以保证获得最低的缺页率。</p>
<blockquote>
<p>但由于⼈们⽬前无法预知进程在内存下的若千页面中哪个是未来最⻓时间内不再被访问的，因⽽该算法无法实现。⼀般作为衡量其他置换算法的⽅法。</p>
</blockquote>
</li>
<li>
<p><strong>FIFO（First In First Out） （先进先出页面置换算法）</strong> : 总是淘汰最先进⼊内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p>
</li>
<li>
<p><strong>LRU （Least Currently Used）（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面⼀个访问字段，用来记录⼀个页面⾃上次被访问以来所经历的时间 T，当须淘汰⼀个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p>
</li>
<li>
<p><strong>LFU （Least Frequently Used）（最少使用页面置换算法）</strong> : 该置换算法选择在前时期使用最少的页面作为淘汰页。</p>
</li>
</ul>
<h4 id="5-你怎么理解操作系统里的内存碎片，有什么解决办法？">5. <strong>你怎么理解操作系统里的内存碎片，有什么解决办法？</strong></h4>
<p>内存碎片分为：内部碎片和外部碎片。</p>
<ul>
<li>
<p><strong>内部碎片：</strong> 已经<strong>被分配</strong>出去（能明确指出属于哪个进程）却<strong>不能被利用</strong>的内存空间；</p>
<blockquote>
<p><strong>内存泄漏</strong>：不再会被使用的<strong>对象</strong>的内存不能被<strong>回收</strong> 。</p>
</blockquote>
</li>
<li>
<p><strong>外部碎片：</strong> 还<strong>没有被分配</strong>出去（不属于任何进程），但由于<strong>太小了无法分配</strong>，给申请内存空间的新进程的内存空闲区域。</p>
</li>
</ul>
<h4 id="6-什么是内存抖动？">6. 什么是内存抖动？</h4>
<ul>
<li><strong>现象：<strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种</strong>频繁的页面调度行为</strong>称为抖动，或颠簸；</li>
<li><strong>原因：</strong> 程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) ；</li>
<li><strong>解决：</strong> 分配更多的物理块</li>
</ul>
<h2 id="4-6-并发和死锁">4.6 并发和死锁</h2>
<h4 id="0-介绍几种典型的锁？">0. 介绍几种典型的锁？</h4>
<ol>
<li><strong>读写锁。</strong> 可以同时读，但写必须互斥，只允许一个写；</li>
<li><strong>互斥锁。</strong> 一次只能一个线程拥有锁，其它只能等待；</li>
<li><strong>条件变量：</strong>  互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定；而条件变量<strong>通过允许线程阻塞和等待另一个线程发送信号</strong>的方法弥补了互斥锁的不足；</li>
<li><strong>自旋锁。</strong> 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</li>
</ol>
<h4 id="1-【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？">1. 【<strong>重点</strong>】<strong>什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？</strong></h4>
<ul>
<li>
<p><strong>什么是死锁</strong></p>
<p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p>
</li>
<li>
<p><strong>发生死锁的条件</strong></p>
<ol>
<li>**互斥：**一个资源只能给一个进程使用；</li>
<li><strong>占有并等待</strong>：进程持有资源并申请新资源，在申请到需要的资源之前，<u>已有的资源不释放</u>；</li>
<li><strong>不可剥夺</strong>：进程申请到的资源在使用完之前，不可以被其他进程使用；</li>
<li>**循环等待：**各个进程的资源请求形成首尾连接循环等待。</li>
</ol>
</li>
<li>
<p><strong>解决方法：预防，避免，检测与恢复三种</strong></p>
<ol>
<li><strong>预防：破坏死锁会发生的四个条件</strong>
<ul>
<li>破坏互斥：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的</li>
<li>**<u>破坏请求和保持</u>：**实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源；</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进⼀步申请其他资源时，<strong>如果申请不到</strong>，可以<strong>主动释放它占有的资源</strong>。</li>
<li><strong><u>破坏循环等待：</u></strong> <strong>资源分类标号，进行有序分配</strong></li>
</ul>
</li>
<li><strong>避免：</strong> <u>它不限制进程有关申请资源的命令</u>，而是对进程所发出的每一个申请资源命令加以<strong>动态地检查</strong>，并根据检查结果决定是否进行资源分配
<ul>
<li><strong>安全序列</strong>：找到一种能让进程安全执行完的有序序列<code>&#123;P1，P2，...，Pn&#125;</code></li>
<li>**银行家算法：（待补充）**系统在为进程分配资源之前，首先计算此次资源分配的安全性，<strong>如果是安全的，则进行分配</strong>；如果这次分配会导致进入不安全状态，不进行分配。</li>
</ul>
</li>
<li><strong>恢复：</strong> 用<u>资源分配图、进程等待图</u>来协助这种检测出死锁，然后进行恢复。
<ul>
<li>系统重新启动，但代价很大</li>
<li><strong>撤消参与死锁的全部或部分进程，剥夺资源</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-（待补充）请你解释一下，通常系统CPU比较高是什么原因？">2. （待补充）<strong>请你解释一下，通常系统CPU比较高是什么原因？</strong></h4>
<ol>
<li>首先查看是哪些进程的CPU占用率最高</li>
</ol>
<h4 id="3-说一下NIO，BIO，AIO区别">3. <strong>说一下NIO，BIO，AIO区别?</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/IO%E6%A8%A1%E5%9E%8B.md">JAVaGuide</a></p>
</blockquote>
<p>【<strong>BIO（同步阻塞）</strong>】</p>
<ul>
<li>
<p><strong>BIO</strong>：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把<u> </u>。</p>
<img src="https://i.loli.net/2021/05/06/HqJyg2Ykxtm6Wba.png" alt="图源：《深入拆解Tomcat & Jetty》" style="zoom: 67%;" />
</li>
</ul>
<p>【<strong>NIO（同步非阻塞）</strong>】</p>
<p>NIO 本身是基于 <u>事件驱动</u> 的思想来实现的，其目的就是解决 BIO 的大并发问题：</p>
<ul>
<li>BIO 模型中，<strong>如果需要并发处理多个 I/O 请求，那就需要多线程来支持</strong>；</li>
<li><strong>IO 多路复用模型</strong>中，线程首先发起 <u>select 调用，询问内核数据是否准备就绪</u>，等内核把数据准备好了，用户线程再发起 <strong>read 调用</strong>。<strong>read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</strong></li>
</ul>
<img src="https://i.loli.net/2021/05/06/9iJE3IaVOW2xAwh.png" alt="img" style="zoom:67%;" />
<p>【<strong>AIO（异步非阻塞）</strong>】</p>
<blockquote>
<p>Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型 。</p>
</blockquote>
<p><strong>AIO：</strong> 异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p>
<blockquote>
<p>异步 IO 是基于事件和<strong>回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/06/uIcCQeBUliqT2gk.png" alt="img" style="zoom:67%;" />0.</p>
<h4 id="4-【重点】介绍一下select，poll，epoll-原理？">4. 【重点】<strong>介绍一下select，poll，epoll 原理？</strong></h4>
<blockquote>
<p><strong>参考</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiejiemcu/article/details/107083724">select、poll、epoll的原理与区别</a></li>
</ol>
</blockquote>
<h5 id="4-1-从阻塞I-O-非阻塞I-O说起">4.1 从阻塞I/O &amp; 非阻塞I/O说起</h5>
<ul>
<li>
<p><strong>阻塞I/O</strong></p>
<blockquote>
<p>在linux中，默认情况下所有的socket都是阻塞的。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/17/aJFOtPvy4xiMKkI.png" alt="image-20210517125922790"></p>
<ol>
<li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li>
<li>当这个网络I/O没有数据的时候，内核就要等待数据的到来，此时<strong>用户进程被阻塞</strong>；</li>
<li>当内核空间的数据准备好了，它就会将数据从<strong>内核空间中拷贝到用户空间</strong>；</li>
<li>用户进程才解除阻塞的的状态，重新运行读取数据。</li>
</ol>
</li>
<li>
<p><strong>非阻塞I/O</strong></p>
<blockquote>
<p>linux下，可以通过设置socket使其变为非阻塞模式，这种情况下，当内核空间并无数据的时候，它会<u>马上返回结果而不会阻塞</u>。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/17/hW2DtsGBiU8AnHN.png" alt="image-20210517130232559"></p>
<ol>
<li>当用户进程调用了<code>read()/recvfrom()</code>等系统调用函数，它会进入内核空间中；</li>
<li>如果内核空间中的数据还没有准备好，那么它并不会阻塞用户进程，而是<strong>立刻返回一个error</strong>；</li>
<li>对于应用进程来说，它发起一个<code>read()</code>操作后，并不需要等待，那么它可以再次调用read()/recvfrom()等函数；</li>
<li>当内核空间的数据准备好了，它就会将数据从内核空间中拷贝到用户空间；</li>
<li>用户进程才解除阻塞的的状态，重新运行读取数据。</li>
</ol>
</li>
</ul>
<blockquote>
<p>多路复用I/O就是我们说的<code>select，poll，epoll</code>等操作，复用的好处就在于<strong>单个进程</strong>就可以同时处理<strong>多个</strong>网络连接的I/O，能实现这种功能的原理就是<code>select、poll、epoll</code>等函数会不断的<strong>轮询</strong>它们所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程。</p>
</blockquote>
<h5 id="4-2-select原理">4.2 select原理</h5>
<blockquote>
<p>更加深刻对比理解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>select函数监视的文件socket描述符分3类，分别是writefds、readfds、和exceptfds；</li>
<li>调用后select<strong>函数会阻塞（不是线程）</strong>，直到有描述符就绪（有数据 <u>可read、可write、except、超时timeout</u>），函数返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	select(socket);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		sockets = select(); <span class="comment">// 还是要从内核拷贝到用户</span></span><br><span class="line">		<span class="keyword">for</span>(socket in sockets) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(can_read(socket)) </span><br><span class="line">			&#123;</span><br><span class="line">				read(socket, buffer);</span><br><span class="line">				process(buffer);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细执行原理如下：</p>
<ol>
<li>
<p>用户首先将需要进行IO操作的<strong>socket添加到select</strong>中，然后<strong>阻塞函数select（不是线程）等待系统调用返回</strong>；</p>
</li>
<li>
<p><strong>当数据到达时，socket被激活，select函数返回</strong>，会唤醒其等待队列上睡眠的内核进程，即在<strong>socket可读写时唤醒</strong>，或者在<strong>超时</strong>后唤醒；</p>
<blockquote>
<p>每次调用<code>select</code>查看fd，都需要把fd集合拷贝进行系统调用<strong>陷入内核态</strong> 。</p>
</blockquote>
</li>
<li>
<p>返回<code>select()</code>函数的调用结果给用户进程，<strong>返回就绪socket描述符的数目</strong>，超时返回0，出错返回-1；</p>
</li>
<li>
<p>在select()函数返回后<strong>还是需要轮询</strong>去找到就绪的socket描述符的（<u>将此前传入内核空间的<code>fd_set</code>拷贝到用户空间</u>），此时用户进程才可以去操作socket；</p>
</li>
<li>
<p>进程调用<code>read() / recvfrom()</code> 读取数据 。</p>
</li>
</ol>
<p><strong>select优点 ：</strong></p>
<blockquote>
<p>从流程上来看，使用select函数进行IO请求和<strong>同步阻塞模型</strong>没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p>
<p><strong>那为什么还要使用select？</strong></p>
</blockquote>
<ul>
<li>使用select以后最大的优势是用户可以在一<strong>个线程内同时处理多个socket</strong>的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的；</li>
<li>而在<strong>同步阻塞模型</strong>中，必须通过<strong>多线程的方式才能达到这个目的</strong>。</li>
</ul>
<p><strong>select缺点 ：</strong></p>
<ol>
<li>
<p><strong>描述符数量：</strong><code>select</code>支持的文件描述符数量太小了，默认是<code>1024</code>  ；</p>
</li>
<li>
<p><strong>系统开销：<strong>每次调用<code>select</code>都需要把fd集合拷贝进行系统调用</strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p>
</li>
<li>
<p><strong>二次轮询：</strong><code>select</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p>
</li>
</ol>
<h5 id="4-3-poll原理">4.3 poll原理</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 <strong>pollfd指针</strong>实现。</p>
<blockquote>
<p>poll使用<strong>链表</strong>维护这些socket描述符，而select使用的是<strong>数组</strong>（位图）。</p>
</blockquote>
<p>其他的都差不多和select()函数一样，poll()函数返回后，需要轮询pollfd来获取就绪的描述符，根据描述符的状态进行处理，<u>但是poll没有最大文件描述符数量的限制</u>。</p>
<p><strong>poll缺点 ：</strong></p>
<p>解决了selec第一个缺点（文件描述符数量太少），但是依旧存在后面两个缺点。</p>
<ol start="2">
<li>
<p><strong>系统开销：<strong>每次调用<code>poll</code>都需要把fd集合拷贝进行系统调用</strong>陷入内核态</strong>，这个开销在fd很多时会很大 ；</p>
</li>
<li>
<p><strong>二次轮询：</strong><code>poll</code>需要二次查询拷贝所有文件描述fd_set进行遍历查看是否有描述符准备就绪。</p>
</li>
</ol>
<h5 id="4-3-epoll原理">4.3 epoll原理</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll只有epoll_create()、epoll_ctl()、epoll_wait() 3个系统调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>epoll_create</code></p>
<p>创建一个epoll文件描述符的epfd（或者称之为句柄）, <strong>epoll使用一个epfd文件描述符管理多个socket描述符。</strong></p>
<blockquote>
<p>当创建好epoll句柄后，它就是会占用一个fd值，必须调用close()关闭，否则可能导致fd被耗尽 。</p>
</blockquote>
</li>
<li>
<p><code>epoll_ctl</code></p>
<p>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，以及删除事件。相关参数：</p>
<blockquote>
<p>使用<strong>红黑树</strong>对监视的文件描述符进行：添加、修改、删除等。</p>
</blockquote>
<ul>
<li>
<p><code>epdf</code>：由epoll_create()函数返回的epoll文件描述符（句柄）；</p>
</li>
<li>
<p><code>op</code> ： op是操作的选项，注册要监听的目标socket描述符fd到epoll句柄中 ；修改epoll句柄已经注册的fd的监听事件；从epoll句柄删除已经注册的socket描述符 ；</p>
</li>
<li>
<p><code>fd</code>：指定监听的socket描述符；</p>
</li>
<li>
<p><code>event</code>：事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>epoll_wait()</code></p>
<p>epoll_wait()函数的作用就是等待监听的事件的发生，<strong>类似于调用select()函数。</strong> 相关参数如下：</p>
<blockquote>
<p>函数的返回值表示需要处理的事件数目，如返回0表示已超时。</p>
</blockquote>
<ul>
<li><code>events</code>：用来从内核得到事件的集合。</li>
<li><code>maxevents</code> ：告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的指定的size。</li>
<li><code>timeout</code>：超时时间。</li>
</ul>
</li>
</ul>
<p><strong>epoll高效运行过程</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/31cdfd6f5a48">彻底搞懂epoll高效运行的原理</a></p>
</blockquote>
<ol>
<li>
<p>执行<code>epoll_create</code>会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行<code>epoll_ctl</code> 函数添加文件描述符会在红黑树上增加相应的结点。</p>
<blockquote>
<p>select：创建3个文件描述符集并<u>拷贝到内核</u>中 ; poll：将传入的struct pollfd结构体数组<u>拷贝到内核</u>中进行监听。</p>
</blockquote>
</li>
<li>
<p>调用<code>epoll_wait</code>  <strong>阻塞，等待可读事件</strong>；</p>
</li>
<li>
<p>内核在检测到满足条件的socket描述符会调用<strong>回调函数</strong> ，回调函数将文件描述符<strong>放在就绪链表</strong>中 ；</p>
<blockquote>
<p>而select/poll 都需要 ，遍历所有文件描述符fd_set 。</p>
<p>而执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，只需调用回调函数。</p>
</blockquote>
</li>
<li>
<p>epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据<strong>返回给读写事件数组events</strong> &amp;<strong>返回就绪的数量</strong>，只用<strong>遍历events</strong>依次处理即可。</p>
<blockquote>
<p>这里返回的文件描述符是通过<strong>mmap让内核和用户空间共享同一块内存</strong>实现传递的，减少了不必要的拷贝。</p>
<p>而select/poll <u>只返回socket就绪数目</u>， 还需要将<strong>所有的文件描述符再次从内核→用户</strong>，遍历就绪的socket文件描述符。</p>
</blockquote>
</li>
</ol>
<h5 id="4-4-select，poll，epoll-各自区别？">4.4 select，poll，epoll 各自区别？</h5>
<blockquote>
<p>不错的文章：<a target="_blank" rel="noopener" href="https://www.codenong.com/cs105364662/">https://www.codenong.com/cs105364662/</a></p>
</blockquote>
<p><strong>相同点：</strong></p>
<ul>
<li>
<p>select，poll，epoll 都是 IO 多路复用的机制（NIO？yes）；</p>
<blockquote>
<p>IO 多路复用的本质是通过一种机制，让<strong>单个进程可以监视多个描述符</strong>，当发现某个描述符就绪之后，能够通知程序进行相应的操作。</p>
</blockquote>
</li>
<li>
<p>select，poll，epoll 都是同步 IO 。</p>
</li>
</ul>
<p><strong>不同点：</strong></p>
<img src="https://i.loli.net/2021/05/17/xj2ncf8VLbAGrwh.png" alt="image-20210517125057917" style="zoom: 80%;" />
<ol>
<li><strong>IO 效率：</strong>（1）select 只知道<u>有 IO 事件发生，却不知道是哪几个流</u>，只能采取轮询所有流（ fd_set 集合）的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；（2）poll 与 select 并无区别，它的时间复杂度也是O(n)；（3）epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，<u>系统注册的回调函数会被调用</u>，将就绪描述符放到 readyList 里面），<strong>它是事件驱动的</strong>，其时间复杂度为 O(1)；</li>
<li>**操作方式：**select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式；</li>
<li>**底层实现：**select 的底层实现为数组，poll 的底层实现为链表；而 epoll 的底层实现为红黑树；</li>
<li>**最大连接数：**select 的最大连接数为 1024 或 2048；而 poll 和 epoll 是无上限的；</li>
<li>**对描述符的拷贝：**select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝；</li>
<li><strong>性能：</strong><u>epoll 在绝大多数情况下性能远超 select 和 poll</u>，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 。</li>
</ol>
<h5 id="4-5-ET-LT-模式介绍？各自优缺点？">4.5 ET , LT 模式介绍？各自优缺点？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1636224">https://cloud.tencent.com/developer/article/1636224</a></p>
</blockquote>
<ul>
<li>
<p><strong>边缘触发模式</strong>（<strong>E</strong>dge <strong>T</strong>rigger，ET），只有一个事件从无到有才会触发；</p>
<blockquote>
<ol>
<li>低电平 =&gt; 高电平 。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>水平触发模式</strong>（<strong>L</strong>evel <strong>T</strong>rigger，LT），一个事件只要有，就会一直触发。</p>
<blockquote>
<ol>
<li>低电平 =&gt; 高电平 ; 2. 处于高电平状态</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>举例说明</strong></p>
<ul>
<li><strong>socket 的读事件</strong>
<ul>
<li><strong>LT模式</strong>，只要 socket 上有未读完的数据，就会一直产生 EPOLLIN 事件；</li>
<li><strong>ET模式</strong>，socket 上每新来一次数据就会触发一次，如果上一次触发后，<strong>未将 socket 上的数据读完，也不会再触发</strong>，除非再新来一次数据。</li>
</ul>
</li>
<li><strong>对于 socket 写事件</strong>
<ul>
<li>**LT模式，**如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；</li>
<li>**ET模式，**只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT 事件。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>优缺点</strong></p>
<ul>
<li>使用 LT 模式，我们可以自由决定<strong>每次收取多少字节（对于普通 socket）或何时接收连接</strong>（对于侦听 socket），但是可能会<strong>导致多次触发</strong>；</li>
<li>使用 ET 模式，我们必须<strong>每次都要将数据收完</strong>（对于普通 socket）或必须理解调用 accept 接收连接（对于侦听socket），其<strong>优点是触发次数少</strong>。</li>
</ul>
</li>
</ul>
<h4 id="5-操作系统底层是怎么实现原子操作的？">5. 操作系统底层是怎么实现原子操作的？</h4>
<p>处理器使用基于对<strong>缓存加锁</strong>或<strong>总线加锁</strong>的方式，来实现多处理器之间的原子操作。</p>
<ol>
<li>
<p><strong>总线锁：</strong> 处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器<strong>可以独占共享内存</strong>；</p>
<blockquote>
<p><strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据</p>
</blockquote>
</li>
<li>
<p>**缓存锁：**相比总线锁，缓存锁即降低了锁的力度。核心机制是基于<u>缓存一致性协议</u>来实现的。</p>
<blockquote>
<p>详细参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06717ac8312c">JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p>
</blockquote>
</li>
</ol>
<h2 id="4-7-其它">4.7 其它</h2>
<h4 id="1-常见的磁盘调度算法？">1. 常见的磁盘调度算法？</h4>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，<strong>寻道时间最长</strong>，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ol>
<li>
<p><strong>先来先服务。</strong> 按照磁盘请求的顺序进行调度。</p>
<ul>
<li>**优点 ：**公平、简单；</li>
<li>**缺点：**未对寻道做任何优化，使平均寻道时间可能较长。</li>
</ul>
</li>
<li>
<p><strong>最短寻道优先</strong>。 优先调度与当前磁头所在磁道距离最近的磁道。</p>
<ul>
<li><strong>优点：</strong> 平均寻道时间比较低；</li>
<li>**缺点：**不公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去。</li>
</ul>
</li>
<li>
<p><strong>电梯扫描算法。</strong> 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<ul>
<li><strong>优点：</strong> 性能较好，同时不会存在饥饿现象。</li>
</ul>
</li>
</ol>
<h4 id="2-服务器高并发的解决方案你知道多少？">2. 服务器高并发的解决方案你知道多少？</h4>
<ul>
<li><strong>应用数据与静态资源分离 ：<strong>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从</strong>静态资源服务器中返回静态资源</strong>，从<strong>主服务器中返回应用数据</strong>；</li>
<li><strong>客户端缓存</strong> ：例如先生成静态页面，然后用ajax异步请求获取动态数据；</li>
<li><strong>集群和分布式</strong> ：使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度；</li>
<li><strong>反向代理：</strong> 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li>
</ul>
<h1>五、MySQL</h1>
<h2 id="5-1-MySQL基本">5.1 MySQL基本</h2>
<h4 id="0-关系型数据库和非关系数据库的区别？">0. 关系型数据库和非关系数据库的区别？</h4>
<ul>
<li><strong>关系型数据库的优点</strong>
<ul>
<li>容易理解，因为它采用了关系模型来组织数据；</li>
<li>可以<strong>保持数据的一致性</strong>；</li>
<li>数据<strong>更新的开销比较小</strong>；</li>
<li><strong>支持复杂查询</strong>（带where子句的查询）。</li>
</ul>
</li>
<li><strong>非关系型数据库的优点</strong>
<ul>
<li>不需要经过SQL层的解析，<strong>读写效率高</strong>；</li>
<li><strong>基于键值对</strong>，数据的扩展性很好；</li>
<li><strong>支持多种类型数据的存储</strong>，如图片，文档等等。</li>
</ul>
</li>
</ul>
<h4 id="1-介绍一下数据库三范式？">1. <strong>介绍一下数据库三范式？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p>
</blockquote>
<ul>
<li>
<p><strong>第一范式：</strong> 数据库表中的<u>所有字段值都是不可分解的原子值</u> 。</p>
<blockquote>
<p>数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要<u>将“地址”这个属性重新拆分为省份、城市、详细地址</u>等多个部分进行存储。</p>
<p><img src="https://i.loli.net/2021/05/03/NiPm9KajxLXpRQf.png" alt="img"></p>
</blockquote>
</li>
<li>
<p><strong>第二范式：</strong> 第二范式基于第一范式，且要求：<u>数据库表中的每一列都和主键相关，且不能只与主键的某一部分相关</u>（主要针对联合主键而言）, 即<strong>不存在部分依赖</strong>；</p>
<blockquote>
<p>下表是以：<u>订单编号&amp;商品编号</u>作为联合主键。这样在该<strong>表中商品名称、单位、商品价格等信息不与该表的订单编号相关</strong>，而仅仅是与商品编号相关。</p>
<p><img src="https://i.loli.net/2021/05/03/RoCLmOBcgJKhvyx.png" alt="img"></p>
<p>所以根据第二范式，将它进行拆分三个表：</p>
<p><img src="https://i.loli.net/2021/05/03/TnN8t5k3lrWxIgp.png" alt="img"></p>
</blockquote>
</li>
<li>
<p><strong>第三范式：</strong> 基于第二范式，数据表中的每一列数据都和主键<strong>直接相关</strong>，即<strong>不存在传递依赖</strong>；</p>
<blockquote>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114105477.png" alt="img"></p>
</blockquote>
</li>
</ul>
<h4 id="2-MySQL数据库引擎有哪些？">2. <strong>MySQL数据库引擎有哪些？</strong></h4>
<blockquote>
<p>MySQL查看所有的数据引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>MySQL常用引擎包括：<code>MYISAM</code>、<code>Innodb</code>、<code>Memory</code>、<code>MERGE</code>，</p>
<ul>
<li>
<p><strong><code>MYISAM</code></strong> （读：my+i+son）</p>
<p>以select、insert为主的应用基本上可以使用这引擎。</p>
<ul>
<li><strong>优点：</strong> <strong>全表锁</strong>，拥有较高的执行速度，占用空间小；</li>
<li><strong>缺点</strong> ：不支持事务，不支持外键，并发性能差。</li>
</ul>
</li>
<li>
<p>**<code>Innodb</code> **</p>
<p>Innodb引擎提供了对数据库ACID<strong>事务</strong>的支持，并且实现了SQL标准的四种隔离级别，它的设计目标是<u>处理大容量数据库系统</u>。</p>
<ul>
<li><strong>优点：</strong> <strong>行级锁</strong>，<strong>支持事务</strong>，支持<u><strong>自动增长列</strong></u>，支持外键约束，<strong>并发能力强</strong></li>
<li><strong>缺点：</strong> 占用空间是MYISAM的2倍，处理效率相对也更低</li>
</ul>
</li>
<li>
<p><strong><code>Memory</code></strong></p>
<p>主要用于<strong>内容变化不频繁的</strong>代码表。</p>
<ul>
<li><strong>优点：</strong> <strong>全表锁</strong>，<u>存储在内存中，默认使用Hash，检索效率非常高</u></li>
<li><strong>缺点：</strong> 会占用和数据量成正比的内存空间且，mysql重启时会丢失，不适合精确查找</li>
</ul>
</li>
<li>
<p><strong><code>MERGE</code></strong></p>
<p>是一组MYISAM表的组合。</p>
</li>
</ul>
<h5 id="2-1-InnoDB、MyISAM、Memory-【索引】（按数据结构分）">2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分）</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037683781">https://segmentfault.com/a/1190000037683781</a></p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210820194526488.png" alt="image-20210820194526488"></p>
<h5 id="2-2-为什么Innodb使用自增id作为主键？">2.2 为什么Innodb使用自增id作为主键？</h5>
<ul>
<li><strong>如果不使用自增主键</strong>， 如身份证号、学号，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置（<strong>涉及到B+树分裂等</strong>）， 频繁的移动、分页操作造成了大量的碎片；</li>
<li><strong>如果使用自增主键，</strong> 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</li>
</ul>
<h4 id="3-说说InnoDB与MyISAM的区别？">3. <strong>说说InnoDB与MyISAM的区别？</strong></h4>
<p>见前。</p>
<h5 id="3-1-说说InnoDB与MyISAM在B-数索引方式区别？">3.1 说说InnoDB与MyISAM在B+数索引方式区别？</h5>
<ul>
<li>
<p><strong>MyISAm</strong> , B+Tree叶节点的data域存放的是数据<strong>记录的地址</strong>，在索引检索的时候，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” ；</p>
</li>
<li>
<p><strong>InnoDB，</strong> 树的节点data域保存了完整的数据记录，这个索引的<strong>key是数据表的主键（自增id）</strong> ；而<strong>其它索引都叫做辅助索引</strong>， 助索引的data域存储相应记录<strong>主键的值</strong>而不是记录地址。</p>
<blockquote>
<ul>
<li>在根据主索引搜索时，直接找到key所在的节点即可取出数据；</li>
<li>在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="3-2-【百度】说说InnoDB与MyISAM在适用场景上的区别？">3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？</h5>
<ul>
<li><strong>MyISAM</strong> ，没有事务， 适合<strong>插入不频繁，查询非常频繁</strong>；</li>
<li><strong>Innodb：</strong> 有事务，适合<strong>可靠性要求比较高</strong>，或者<strong>更新和查询比较频繁</strong>。</li>
</ul>
<h4 id="4-为什么-SELECT-COUNT-FROM-table-在-InnoDB-比MyISAM-慢？-3">4. **为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？**3</h4>
<p>对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。</p>
<ul>
<li>InnoDB 是去实时统计结果，会<strong>全表扫描</strong>；</li>
<li>而 MyISAM内部维持了一个<u><strong>计数器</strong></u>，<strong>预存了结果</strong>，所以直接返回即可。</li>
</ul>
<h4 id="5-简单说一说drop、delete与truncate的区别？">5. <strong>简单说一说drop、delete与truncate的区别？</strong></h4>
<p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别：</p>
<ul>
<li><strong>删除类型：</strong> drop删除表结构；delete、truncate删除表内容。</li>
<li><strong>删除速度：</strong>  <strong>drop</strong>&gt; truncate &gt;delete</li>
<li><strong>生效速度：</strong> drop和truncate ，操作立即生效，不能回滚也不触发触发器；<strong>delete事务提交后才生效，会触发相应触发器</strong>。</li>
</ul>
<h4 id="6-什么是视图？-游标？">6. <strong>什么是视图？</strong> 游标？</h4>
<p>视图是一种虚拟的表，通常是一个表或者多个表的行或列的子集，具有和物理表相同的功能。</p>
<ul>
<li>可以对视图进行增，改，查，操作，但<strong>对视图的修改不影响基本表</strong>；</li>
<li>相比多表查询，获取数据速度更容易。</li>
</ul>
<p>游标，是对<strong>查询出来的结果集</strong>作为一个单元来有效的处理。</p>
<ul>
<li>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li>
</ul>
<h4 id="7-什么是内联接、左外联接、右外联接？">7. <strong>什么是内联接、左外联接、右外联接？</strong></h4>
<ul>
<li>
<p><strong>内联接（Inner Join）</strong>：两个表（或连接）中某一数据项相等的连接称为内连接。 连接的结果是形成一个新的数据表。 内连接中参与连接的表（或连接）的地位是相等的；</p>
</li>
<li>
<p><strong>左外联接（Left Outer Join</strong>）：除了匹配2张表中相关联的记录外，<u>还会匹配左表中剩余的记录</u>，<u>右表中未匹配到的字段用NULL表示</u>；</p>
</li>
<li>
<p><strong>右外联接（Right Outer Join）</strong>：除了匹配2张表中相关联的记录外，还会<u>匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示</u>。</p>
</li>
</ul>
<h4 id="8-说说在-MySQL-中一条查询-SQL-是如何执行的？">8. <strong>说说在 MySQL 中一条查询 SQL 是如何执行的？</strong></h4>
<p>例如：<code>select name from t_user where id=1</code></p>
<ol>
<li>
<p><strong>取得链接</strong>，使用使用到 MySQL 中的<strong>连接器</strong>；</p>
</li>
<li>
<p><strong>查询缓存</strong>，key 为 SQL 语句，value 为查询结果，如果查到就直接返回；</p>
<blockquote>
<p>在 MySQL 8.0 版本已经将查询缓存删除，也就是说 MySQL 8.0 版本后不存在此功能。</p>
</blockquote>
</li>
<li>
<p><strong>分析器</strong>，分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。所以一般语法错误在此阶段；</p>
</li>
<li>
<p><strong>优化器</strong>，是在表里<strong>有多个索引的时候，决定使用哪个索引</strong>；或者一个语句中存在多表关联的时候（join），决定<strong>各个表的连接顺序</strong>；</p>
</li>
<li>
<p><strong>执行器</strong>，开始执行语句。执行语句的时候还要判断是否具备此权限，如果有权限：（1）根据表的引擎定义，使用引擎提供的接口，获取表的第一行，判断id是否等于1 ；（2）如果不是则继续调用引擎接口去获取下一行，继续判断；（3）直至取到这个表的最后一行</p>
</li>
</ol>
<h4 id="9-MySQL-中-varchar-与-char-的区别？-int-3-呢？">9. <strong>MySQL 中 varchar 与 char 的区别？</strong> int(3) 呢？</h4>
<ul>
<li>
<p>char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p>
<p><img src="https://i.loli.net/2021/05/03/SoHv6lyhp94TwWP.png" alt="image-20210503214113219"></p>
</li>
<li>
<p><strong>float(3,2) 和 int(3)</strong></p>
<ul>
<li><code>float(3,2)</code> : &quot;浮点型&quot;的长度是用来<strong>限制数字存储范围</strong>的。比如 float(3,2) 只能够写入 <code>0.00~999.99</code>。</li>
<li><code>int(3)</code> ：&quot;整型&quot;的长度并<strong>不会限制存储的数字范围</strong>，都是<code>-2147483648 ~ 2147483647</code> 。只<strong>限制显示长度</strong>。</li>
</ul>
</li>
</ul>
<h4 id="10-超键、主键、候选键和外键有什么区别？">10. <strong>超键、主键、候选键和外键有什么区别？</strong></h4>
<ul>
<li><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键；</li>
<li>**候选键(candidate key)：**不含有多余属性的超键称为候选键，<u>是超键的子集</u>；</li>
<li>**主键(primary key)：**用户选作元组标识的一个候选键程序主键，<u>是候选键的子集</u> ；</li>
<li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li>
</ul>
<p>下面举例说明（<strong>假设姓名不重复唯一</strong>）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">身份证</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li><u>超键：</u> 身份证、姓名、（姓名、性别）、（姓名、性别、年龄）都可以作为超键；</li>
<li><u>候选键</u> ：身份证、姓名 都唯一，都可以作为候选键；</li>
<li><u>主键：</u> 在候选键选一个作为主键，例如：身份证。</li>
</ul>
<h4 id="11-解释⼀下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池">11.  解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h4>
<ul>
<li>
<p><strong>池化设计思想</strong></p>
<p>我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会<u>初始预设资源</u>，<strong>解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销</strong>等。</p>
</li>
<li>
<p><strong>数据库连接池</strong></p>
<p>数据库连接本质就是⼀个 <strong>socket</strong> 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的所以<strong>占⽤了⼀些内存</strong>。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以<strong>重⽤这些连接</strong>。</p>
</li>
<li>
<p><strong>为什么要用数据库连接池？</strong></p>
<p>为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应⽤程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。</p>
</li>
</ul>
<h4 id="12-如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？">12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangtao_20/p/3643994.html">为什么hash作为内存使用的经典数据结构?</a></p>
</blockquote>
<p>数据放在磁盘，使用<strong>B+树</strong>，<strong>核心是为了减少磁盘IO</strong>，因为磁盘IO的代价很大（是内存的十万倍）。</p>
<p>我们使用<strong>hash</strong>寻找数据的时候，<strong>数据随机分散到各个物理位置</strong>，不是有序的数据。而<strong>内存设备也是随机访问设备</strong>，内存很适合用hash方式来读取数据。</p>
<ul>
<li>
<p><strong>随机访问：<strong>存储器单元的内容可以根据需要自由取出或存储，而且</strong>访问的速度与存储器单元的位置</strong>无关 。(通过行，列地址总线就可以快速定位存储的数据)</p>
<blockquote>
<p>但是磁盘，每次访问数据，是需要先定位，然后<strong>顺序</strong>移动；如果下个数据不在磁头附近，又要重新定位。</p>
<p>如果Hash索引磁盘数据，（1）每次访问都要IO<strong>不能范围</strong>（2）数据太多，Hash索引保存不了键值，而<strong>高度为3的B+数就能保存千万级别的数据</strong>（3）当数据量很大时，<strong>hash冲突</strong>的概率也会非常大（4）组合索引可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了阿和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，<strong>没办法支持部分索引</strong> （5）当需要按照索引进行order by时，hash值<strong>没办法支持排序</strong> 。</p>
</blockquote>
</li>
</ul>
<h4 id="13-【字节】Mysql-Join的原理？">13.【字节】Mysql Join的原理？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54275505">https://zhuanlan.zhihu.com/p/54275505</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user tb1 left join level tb2 on tb1.id=tb2.user_id</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>简单嵌套循环</strong></p>
<p><strong>双层for 循环</strong> ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。</p>
<img src="https://i.loli.net/2021/09/04/u3LJnMgZsIV6Atd.png" alt="image-20210904063419237" style="zoom:50%;" />
</li>
<li>
<p><strong>索引嵌套循环连接</strong></p>
<p>通过外层表匹配条件 <strong>直接与内层表索引进行匹配</strong>，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数。</p>
<ul>
<li>从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能；</li>
<li>注意，<strong>要为表user_level 去建立索引</strong></li>
</ul>
<img src="https://i.loli.net/2021/09/04/1gkP9upMosUtYS4.png" alt="image-20210904063546011" style="zoom:80%;" />
</li>
<li>
<p><strong>缓存块嵌套循环连接</strong></p>
<p>其优化思路是<strong>减少内层表的扫表次数</strong>。</p>
<ul>
<li>通过简单的嵌套循环查询的图，我们可以看到，左表的每一条记录都会对右表进行一次扫表，扫表的过程其实也就是<strong>从内存读取数据</strong>的过程，那么这个过程其实是比较消耗性能的。</li>
</ul>
<p><img src="https://i.loli.net/2021/09/04/s1nE7IzYZ6TGlkK.jpg" alt="img"></p>
<p>所以缓存块嵌套循环连接算法意在通过<strong>一次性缓存外层表的多条数据</strong>，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用<strong>Index Nested-Loop Join</strong>的时候，数据库是默认使用的是<strong>Block Nested-Loop Join算法的</strong>。</p>
<ul>
<li><strong>当level 表的 user_id 不为索引</strong>的时候，默认会使用Block Nested-Loop Join算法。</li>
</ul>
<p><img src="https://i.loli.net/2021/09/04/iP9o6OpU8ZxcIwF.jpg" alt="img"></p>
</li>
</ol>
<h2 id="5-2-分布式数据库">5.2 分布式数据库</h2>
<h4 id="0-【字节】分布式数据库锁如何实现？">0. 【字节】分布式数据库锁如何实现？</h4>
<ul>
<li><strong>什么时候用到分布式数据库？</strong>
<ol>
<li><strong>水平拆分</strong> ：<strong>数据量大到单机数据库已存储不下</strong>时， 可以对数据进行拆分，化整为零，将数据均匀分布到多个数据库节点中。</li>
<li><strong>读写分离：<strong>主要用在</strong>数据量并不大</strong>，单机数据库能够hold得住，<strong>但读请求很高</strong>的情况下。此时，可以配置多个只读数据库节点，来分担主节点的读请求。通过数据复制机制，<strong>在主节点和只读节点之间进行数据的实时同步</strong>，保证主从节点的数据一致性。</li>
</ol>
</li>
<li><strong>分布式数据库锁？</strong>
<ol>
<li><strong>直接锁表</strong>，代价比较大</li>
<li><strong>加入排它锁</strong>，查询语句后面增加<strong>for update</strong>（这里我们希望使用行级锁，就要给method_name添加索引）</li>
<li><strong>Zookeeper实现分布式锁</strong></li>
</ol>
</li>
</ul>
<h4 id="1-请说说-MySQL-数据库的锁？">1. <strong>请说说</strong> <strong>MySQL</strong> <strong>数据库的锁？</strong></h4>
<p><img src="https://i.loli.net/2021/05/24/S7HoKh8EcpXT1Mz.png" alt="img"></p>
<p>MySQL 中常见锁如下：</p>
<p>【<u>按使用方式划分</u>】</p>
<ul>
<li>
<p><strong>共享锁：<strong>不堵塞，多个用户可以同一时刻</strong>读取</strong>同一个资源，相互之间没有影响；</p>
</li>
<li>
<p><strong>排它锁（写锁）：</strong><u>一个写操作阻塞其他的读锁和写锁</u>，<strong>只允许一个用户进行写入</strong>，<strong>防止其他用户读取正在写入的资源</strong>。</p>
</li>
</ul>
<p>【<u>按锁粒度划分</u>】</p>
<ul>
<li>
<p>**表锁：**系统开销最小，会锁定整张表，<u>不会出现死锁</u>；但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。<strong>MyISAM 使用表锁。</strong></p>
</li>
<li>
<p><strong>行锁：</strong><u>容易出现死锁</u>，发生冲突概率低，并发性能高。<strong>InnoDB 支持行锁</strong>。</p>
<blockquote>
<p><strong>必须有索引才能实现</strong>，否则会自动锁全表，那么就不是行锁。</p>
</blockquote>
</li>
</ul>
<p>【<u>按思想划分</u>】</p>
<ul>
<li><strong>乐观锁</strong></li>
<li><strong>悲观锁</strong></li>
</ul>
<h4 id="2-说说什么是锁升级？什么情况发生锁升级？">2. <strong>说说什么是锁升级？什么情况发生锁升级？</strong></h4>
<blockquote>
<p>区分一下sycronized锁升级。</p>
</blockquote>
<p>锁升级是指将当前锁的粒度降低：<code>行锁→页锁→表锁</code>。</p>
<p>发生锁升级的情况：</p>
<ol>
<li>当一条SQL语句对<u>同一个对象</u>上持有的锁数量超锁了阈值，默认这个阈值为5000，<strong>但是对于不同对象不会发生锁升级</strong></li>
<li>锁资源占用的内存超过<u>激活内存</u>的百分之40 就会发生锁升级</li>
</ol>
<h5 id="2-1-为什么说innoDB-引擎不存在锁升级的问题-？">2.1 为什么说innoDB 引擎不存在锁升级的问题 ？</h5>
<p>待补充。</p>
<h5 id="2-2-什么时候触发行锁和表级锁？">2.2 什么时候触发行锁和表级锁？</h5>
<p>mysql默认存储引擎都是<strong>innodb</strong>，默认是使用<strong>行锁</strong> 。</p>
<ul>
<li>
<p>触发行级锁 ，<strong>行级锁锁的是索引记录</strong> ，使用了索引所以就会触发行级锁。</p>
</li>
<li>
<p>触发表级锁，有以下三种情况</p>
<blockquote>
<p>其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，<strong>如果筛选条件中没有用到索引</strong>，就会触发全表扫描。</p>
</blockquote>
<ol>
<li><strong>全表更新</strong>：事务<strong>需要更新大部分数据或全部数</strong>据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突</li>
<li><strong>多表级联：事务涉及多张表</strong>，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销</li>
<li><strong>筛选条件中未用到索引</strong>： 全表扫描</li>
<li><strong>用到索引，但区分度程度不高</strong> ：innodb认为全表扫描比走索引效率更高导致索引失效，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引</li>
</ol>
</li>
</ul>
<h5 id="2-3-行锁适合的场景？">2.3 行锁适合的场景？</h5>
<p>A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for update # 操作该记录时加上</span><br></pre></td></tr></table></figure>
<p>否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。</p>
<h4 id="3-怎样尽量避免死锁的出现？">3. <strong>怎样尽量避免死锁的出现？</strong></h4>
<ol>
<li>
<p><strong>设置获取锁的超时时间</strong>，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；</p>
</li>
<li>
<p><strong>设置按照同一顺序访问资源</strong>，类似于串行执行；</p>
</li>
<li>
<p><strong>避免事务中的用户交叉</strong>；</p>
</li>
<li>
<p>保持事务简短并在一个批处理中；</p>
</li>
<li>
<p>使用<strong>低隔离级别</strong>。</p>
</li>
</ol>
<h4 id="4-解释一下悲观锁和乐观锁？">4. <strong>解释一下悲观锁和乐观锁？</strong></h4>
<ul>
<li>
<p><strong>悲观锁：</strong> 悲观锁是基于一种悲观的态度类来防止一切数据冲突。它是以一种预防的姿态 <u>在修改数据之前把数据锁住</u>，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p>
<ul>
<li>
<p><strong>特点：</strong> 完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁；但是造成性能消耗</p>
</li>
<li>
<p><strong>实现</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 加读锁</span><br><span class="line">LOCK tables test_db READ </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br><span class="line"># 加写锁</span><br><span class="line">LOCK tables test_db WRITE </span><br><span class="line"># 释放锁</span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>乐观锁：</strong> 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，使得<u>多个任务可并行对数据操作</u>。但是<u>使用一种验证机制来避免数据冲突</u> （一般通过加版本后对比来实现）。</p>
<ul>
<li>
<p><strong>特点：</strong> 并发类型的锁，<u>本身不加锁但通过业务实现锁的功能</u> ，没有锁操作因此性能更高。</p>
</li>
<li>
<p><strong>实现形式：</strong></p>
<p>（1）两个请求同时操作操作标Name字段，二者查询需检索的数据都是一样的：</p>
<p><img src="https://i.loli.net/2021/04/20/H6wyLdqZN8BJipx.png" alt="img"></p>
<p>（2）请求1修改字段数据<code>“zhangsan”→“lisi”</code> ，并将版本号增加+1 ，验证版本号一直后提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update A set Name=lisi,version=version+1 where ID=#&#123;id&#125; and version=#&#123;version&#125;</span><br></pre></td></tr></table></figure>
<p>（3）请求2也想修改<code>“zhangsan”→“liming”</code>  ，但是提交时由于 <u>版本号不一致，无法提交成功</u></p>
</li>
</ul>
</li>
</ul>
<h4 id="5-介绍一下分布式数据库全局ID唯一且自增，如何生成？-（或者问分库分表之后，id-主键如何处理？）">5. <strong>介绍一下分布式数据库全局ID唯一且自增，如何生成？</strong> （<strong>或者问分库分表之后，id 主键如何处理？</strong>）</h4>
<p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id来支持。</p>
<ol>
<li>
<p>**UUID：**不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p>
</li>
<li>
<p>ID自增量为<u>分布式数据库个数</u>，缺点是扩展性不好；</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangxinlingdu/p/8440413.html">snow flake算法</a>：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b3a91b9e3f6468be39f3dc3345e9f4f2_720w.jpg" alt="img"></p>
<ul>
<li><strong>核心思想：</strong> 使用41bit作为毫秒数，10bit作为机器的ID（<strong>5个bit是数据中心，5个bit的机器ID</strong>），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 <u>不同ID</u>），最后还有一个符号位，永远是0。</li>
</ul>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/minkeyto/article/details/104943883">Leaf算法</a>：分号段</p>
</li>
</ol>
<h4 id="8-介绍一下哈希算法？和一致性哈希算法？">8. <strong>介绍一下哈希算法？和一致性哈希算法？</strong></h4>
<ul>
<li>
<p><strong>哈希算法</strong></p>
<ul>
<li><strong>介绍：</strong> 哈希算法<u>将任意长度的二进制值映射为较短的固定长度的二进制值</u>，这个小的二进制值称为<strong>哈希值</strong>。哈希值是一段数据唯一且<strong>极其紧凑的数值表示形式</strong>。</li>
<li><strong>分布式应用中缺点：</strong> 在分布式的存储系统中，<u>要将数据存储到具体的节点上</u>。如果采用哈希算法：<code>key%N</code>（key是数据的key，N是机器节点数） 。出现机器加入或退出集群（<strong>N变了，映射值不一样了</strong>），所有的数据映射都无效了。</li>
</ul>
</li>
<li>
<p><strong>一致性哈希算法</strong></p>
<ul>
<li>
<p><strong>介绍：<strong>解决普通哈希算法造成负载均衡时，在</strong>服务节点数量变动</strong>时出现 <strong><u>哈希失效</u></strong> 问题</p>
</li>
<li>
<p><strong>实现：</strong></p>
<ol>
<li>
<p><strong>构建环：<strong>按照常用的hash算法来将对应的key哈希到一个具有</strong>2^32</strong>次方个节点的空间中（即0 ~ (2^32)-1）。</p>
<blockquote>
<p>Note: 节点的个数可以自定义, hash环我们可以用TreeMap来实现, 因为treeMap是排序的，我们刚好可以利用上。</p>
</blockquote>
<img src="https://i.loli.net/2021/04/20/Al6k3ZmHJO2qbe9.jpg" alt="img" style="zoom:50%;" />
</li>
<li>
<p><strong>映射服务器节点：</strong> 将各个服务器使用Hash进行一个哈希，确定每台机器其在哈希环上的位置。</p>
<blockquote>
<p>一般用服务器ip或唯一主机名进行哈希。</p>
</blockquote>
<img src="https://i.loli.net/2021/04/20/1ZKalnT9CStVc8s.jpg" alt="img" style="zoom:50%;" />
</li>
<li>
<p><strong>映射数据。</strong> 对于要存储的数据：<code>ojectA、objectB、objectC、objectD</code> ，首先通过特定哈希函数计算出<code>hash</code>值 ，散列到环上。然后从数据所在位置<u>沿环顺时针“行走”</u>，第一台遇到的服务器就是其应该定位到的服务器。</p>
<img src="https://i.loli.net/2021/04/20/SwUijYkyJPp34v1.jpg" alt="img" style="zoom:50%;" />
</li>
<li>
<p><strong>出现服务器变动。</strong> 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D。<u>避免了大量数据迁移，减小了服务器的的压力</u> 。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="9-（再理解）介绍一下MVVC？">9. （再理解）<strong>介绍一下MVVC？</strong></h4>
<p>MVCC（Multi-Version Concurrency Control）多版本并发控制，是</p>
<p>数据库控制并发访问的一种手段。</p>
<blockquote>
<ul>
<li>特别要注意<strong>MVCC</strong>只在 <strong>读已提交(RC)</strong> 和 <strong>可重复读（RR）</strong> 这两种事务隔离级别下才有效</li>
<li>是 <strong>数据库引擎（InnoDB）</strong> 层面实现的，用来处理读写冲突的手段（不用加锁），提高访问性能</li>
</ul>
</blockquote>
<ul>
<li>
<p>MVCC协议中，事务提交不会覆盖原数据，而是产生新版本数据，<strong>每个数据有多个历史版本</strong>，但同一时刻只有最新的版本有效；</p>
</li>
<li>
<p>MVCC是在并发访问数据库时，通过对数据做多版本管理，避免<u>【<strong>因为写锁的阻塞而造成读数据的并发阻塞</strong>】</u>问题。可以让<strong>读取数据同时修改，【修改数据时同时可读取】</strong>。简单来说，就是<strong>不对数据库加上读写锁！</strong></p>
</li>
</ul>
<h5 id="9-1-MVCC-如何实现-？">9.1 MVCC 如何实现 ？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52977862">Innodb MVCC实现原理</a></p>
</blockquote>
<ul>
<li>
<p><strong>总结性回答</strong></p>
<p>MVCC是以一个多版本并发控制系统，它主要通过以下两个部分实现：</p>
<ul>
<li>每行记录：记录最近操作该行记录的事务ID，和上一版本数据的指针（指向undo log）</li>
<li>readview：每次<strong>读（写不可以）</strong> 可以获取一个readview，记录当前活跃的事务ID ，可以在<strong>写的过程进行读</strong></li>
</ul>
<p>写的时候并发读，通过比较当前行记录的事务ID和readview活跃的事务ID，来决定是否读取该行记录还是上一版本的数据。</p>
</li>
</ul>
<p>MVCC实现的核心部分为：</p>
<ol>
<li>
<p><strong>事务版本号</strong>：每次<strong>事务开启前</strong>都会从数据库获得一个自增长的<strong>事务ID</strong>，可以从事务ID判断事务的执行先后顺序。</p>
</li>
<li>
<p><strong>表的隐藏列</strong> ：<strong>每一行</strong> 有如下三个重要字段属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隐藏列</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>DB_TRX_ID</strong></td>
<td style="text-align:center">记录操作该行事务的ID</td>
</tr>
<tr>
<td style="text-align:center"><strong>DB_ROLL_PTR</strong></td>
<td style="text-align:center">指向上一个版本的数据（在undo log）的指针</td>
</tr>
<tr>
<td style="text-align:center"><strong>DB_ROW_ID</strong></td>
<td style="text-align:center">隐藏ID，当表没有合适的索引作为聚簇索引时，会用该ID创建聚簇索引</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>undo log</strong> ：每一行记录被修改之前的日志。</p>
<blockquote>
<p>当事务被回滚时，可以用通过undo log日志对数据进行还原。</p>
</blockquote>
<p>一个小例子：修改某行记录name从 <code>“张三→李四”</code></p>
<p><img src="https://pic1.zhimg.com/v2-1daaeab59495ff3378dae24ea21dc158_r.jpg" alt="preview"></p>
</li>
<li>
<p><strong>read view</strong>。在innodb 中<strong>每个SQL语句执行前</strong>都会得到一个read_view，保存了当前数据库系统中正**处于活跃（没有提交）**的事务的ID号。</p>
<blockquote>
<p>根据事务的隔离性，这些事务ID列表不会被其它事务看到。</p>
</blockquote>
<p>其相关重要属性如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>trx_ids</strong></td>
<td style="text-align:center">当前系统：活跃<code>（未提交）事务版本号集合</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>low_limit_id</strong></td>
<td style="text-align:center">当前系统：<code>最大版本事务号+1</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>up_limit_id</strong></td>
<td style="text-align:center">当前系统：<code>活跃的最小事务版本号</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>creator_trx_id</strong></td>
<td style="text-align:center">当前read view：<code>事务版本号</code></td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>具体原理可以描述如下：</p>
<blockquote>
<p>举个例子，假设有一个user_info表，初始数据如下：</p>
<p><img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428"></p>
<p>现在有事务A，B<strong>同时对<code>id=1</code> 这行数据进行操作</strong>，先开启事务A（未提交），此时执行事务B，最后返回什么结果呢？</p>
</blockquote>
<ol>
<li>
<p>事务A（写），执行 <code>update user_info set name =”李四”</code></p>
<ul>
<li>
<p>获得事务编号：102</p>
</li>
<li>
<p>当前事务A的视图为：<strong>（写）不会获得read view！</strong></p>
</li>
</ul>
</li>
<li>
<p>事务B（读），执行 <code>select * fom user_info where id=1</code></p>
<ul>
<li>
<p>获得事务B编号：103</p>
</li>
<li>
<p>当前事务B的视图为：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>trx_ids</strong></th>
<th style="text-align:center">当前活跃的事务：102,103</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>low_limit_id</strong></td>
<td style="text-align:center">当前最大事务id+1:<strong>104</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>up_limit_id</strong></td>
<td style="text-align:center">当前最小事务id：<strong>102</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>creator_trx_id</strong></td>
<td style="text-align:center">当前事务id：<strong>103</strong></td>
</tr>
</tbody>
</table>
</li>
</ul>
<blockquote>
<p><strong>不同隔离级别下，read view的工作方式：</strong></p>
<ol>
<li>
<p><strong>读未提交</strong>：不会获得read view的副本（等于没有并发控制所以会出现脏读）</p>
</li>
<li>
<p>**读提交：**每一次select都会获得一个read view的副本，所以会造成【不可重复读】</p>
<p><img src="https://i.loli.net/2021/05/30/EQSJBYZMeUljA3g.png" alt="image-20210529222746175"></p>
</li>
<li>
<p>**可重复读：**同一个事务select只会获得一次read view副本（select的时候不允许修改），所以不会出现不可重复读。</p>
<p><img src="https://i.loli.net/2021/05/30/ITXb5OukhL1EJ4N.png" alt="image-20210529222905837"></p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>事务A（写），开始执行update语句：（1）把原数据拷贝到undo log，（2）然后进行修改name字段：<code>“张三→李四”</code>，（3）并设置DB_TRX_ID 隐藏字段：<code>99→102</code> （4）设置DB_ROLL_PTR隐藏字段：<code>执行上个事务版本地址</code></p>
<p><img src="https://i.loli.net/2021/05/30/zjCi4AeRQsbHaPO.png" alt="image-20210529213739125"></p>
<p>此时，<strong>事务A还并未提交</strong>，依旧是处于活跃状态。</p>
</li>
<li>
<p>事务B（读），开始执行select语句，<strong>查询到是事务A修改后的语句</strong></p>
<p><img src="https://i.loli.net/2021/05/30/xspAhSDXbOGroqC.png" alt="image-20210529214159799"></p>
<p>把<strong>数据和read view （视图）匹配</strong>： <u>保证</u>（1）<strong>数据已提交，没有其他事物修改，否则去找上一版本的数据</strong>。</p>
<blockquote>
<ol>
<li><code>当前数据记录的事务id &lt; 事务B视图中最小活跃事务id</code> : 说明<strong>数据</strong>，是在<strong>事务B的read view 创建前</strong>就存在，所以可以显示。</li>
<li><code>当前数据记录的事务id &gt; 事务B视图中最大活跃事务id</code> ：说明<strong>数据</strong>，是在<strong>事务B的read view 创建后</strong>才存在，此时不应该显示。</li>
<li><code>事务B视图中最小活跃事务id&lt;= 当前数据记录的事务id &lt;= 事务B视图中最大活跃事务id</code> ： 说明有<strong>其它事务在修改这行记录数据</strong>，但可能还没有提交。把id和事务B的read view的活跃事务集合trx_ids进行匹配：
<ul>
<li>如果数据记录的ID不存在trx_ids，说明已经提交了事务，可以显示</li>
<li>如果存在trx_ids，说明<strong>数据还没提交，此时事务B查询到数据不能显示</strong>（除非此时数据记录的事务id == 事务B的id，由于是自己的当然可以显示）</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li>
<p>事务B（读），根据上述匹配规则，<strong>此时不能读</strong>，应该去undo log中找到上一版本数据。</p>
<blockquote>
<p>此时<code>事务B的id=103，数据记录的事务id=102</code> ：满足条件3，且此时trx_ids存在事务id=102，说明事务A（id=102）还没提交，因此<strong>不能显示。</strong></p>
</blockquote>
<p>故，最终查找的数据为：</p>
<img src="https://i.loli.net/2021/05/30/ATDHgI7sKeziOxE.png" alt="image-20210529211818428" style="zoom:80%;" />
</li>
</ol>
<p>可以看到，整个过程MVCC<strong>事务A【写】没有加锁</strong>，只是进行版本号控制 &amp; undo log，可以进行<strong>并发【读】</strong>。</p>
<h5 id="9-2-MVCC-版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？">9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？</h5>
<ul>
<li>
<p><strong>版本号变化</strong></p>
<p>每条记录有三个隐藏列：（1）<strong>DB_TRX_ID</strong> （2）<strong>DB_ROLL_PTR</strong> （3）<strong>DB_ROW_ID</strong></p>
<p>每一次新事务，<strong>update更新语句</strong>，都会将（1）拷贝数据到undo log（2）DB_ROLL_PTR指向上个数据的版本undo log（3）DB_TRX_ID修改为新事务的id 。</p>
</li>
<li>
<p><strong>为什么MVCC可解决幻读</strong></p>
<p><strong>在RR（可重复读级别下）不会出现幻读</strong>。例如：</p>
<ol>
<li>开启事务1，获得事务ID为1；</li>
<li>事务1执行查询，得到readview；</li>
<li>开始事务2；</li>
<li>执行insert；</li>
<li>提交事务2；</li>
<li>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)；</li>
<li>最后得到的结果是，插入的数据不会显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</li>
</ol>
</li>
</ul>
<h5 id="9-3-mvvc-和-for-update的区别">9.3 mvvc 和 for update的区别</h5>
<ol>
<li><strong>是否加锁：</strong>  mvvc不加锁，只通过多版本来进行并发控制；for update会加锁（<strong>即X/写锁</strong>）。</li>
</ol>
<h5 id="9-4-（快手）MVCC作用，如何实现RC，RR">9.4 <strong>（快手）MVCC作用，如何实现RC，RR?</strong></h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73078137">https://zhuanlan.zhihu.com/p/73078137</a></p>
</blockquote>
<p><strong>作用如下：</strong></p>
<ol>
<li>最简单的描述，<strong>读写不阻塞，读的时候可以写</strong></li>
<li>提高性能</li>
</ol>
<p><strong>实现RC，RR两个隔离级别：</strong></p>
<blockquote>
<p>MVCC <strong>读</strong>某一个数据时，<strong>根据隔离级别</strong>，事务选择要读取哪个版本的数据，过程中完全不需要加锁。</p>
</blockquote>
<ol>
<li>
<p><strong>Read Committed</strong> ：一个事务读取数据时总是读这个数据<strong>最近一次被commit</strong>的版本 ，<strong>所以可以避免脏读（快手）</strong>；</p>
</li>
<li>
<p><strong>Repeatable Read</strong> ： 一个事务读取数据时总是读取当前**【事务开始之前】最后一次被commit**的版本（所以底层实现时需要比较当前事务和数据被commit的版本号），<strong>所以避免了幻读（快手）</strong>。</p>
</li>
</ol>
<p><strong>举个简单的例子：</strong></p>
<ol>
<li><strong>一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了</strong></li>
<li><strong>另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。</strong></li>
<li><strong>第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了</strong></li>
<li><strong>事务B又一次读取了X。这时</strong>
<ul>
<li><strong>如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2</strong></li>
<li><strong>如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。</strong></li>
</ul>
</li>
</ol>
<p>注意，这里B不论是Read Committed，还是Repeatable Read**，都不会被锁**，都能立刻拿到结果。这也就是MVCC存在的意义。</p>
<h2 id="5-3-索引相关">5.3 索引相关</h2>
<blockquote>
<p>🛰 强烈建议对索引更深刻理解，先看完美团这篇技术文章：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p>
</blockquote>
<h4 id="0-MySQL索引原理及慢查询优化">0. <a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></h4>
<h5 id="0-1-为什么要需要索引">0.1 为什么要需要索引</h5>
<blockquote>
<p>答到：遍历磁盘开销太大这个关键。</p>
</blockquote>
<p>数据库实现比较复杂，数据保存在<strong>磁盘</strong>上，而为了提高性能，每次又可以把<strong>部分读入内存</strong>来计算 。</p>
<p>磁盘的成本大概是访问内存的<strong>十万倍</strong>左右 ， 每次去遍历磁盘找到数据再读入内存，是难以接受的。因此需要一种快速找到磁盘数据的方式，就像字典通过<strong>字母索引→快速定位单词</strong>。因此索引由此而出现。</p>
<h5 id="0-2-局部性原理（磁盘IO一次读取大小）">0.2 局部性原理（磁盘IO一次读取大小）</h5>
<blockquote>
<p>在继续往下讲之前，先来讲讲磁盘读取局部性原理。</p>
</blockquote>
<p>局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与<strong>其相邻的数据也会很快被访问到</strong>。</p>
<ul>
<li>因此，当<strong>一次</strong>IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。</li>
</ul>
<p>每次IO读取的数据，分为下面情况：</p>
<ul>
<li>Linux：上以<strong>页</strong>为单位，一次一页（<strong>4K</strong>）</li>
<li>数据库：mysql（InnoDB引擎）一页（<strong>16K</strong>）; SQL Server/ Oracle，默认<strong>块</strong>，大小都是<strong>8KB</strong></li>
</ul>
<h5 id="0-3-索引→B-树">0.3 索引→B+树</h5>
<p>相比二叉树，平衡树等，<strong>B+树</strong> 作为<strong>高度可控的多路搜索树</strong> ，可以很好的满足要求。（详细选择原因，可以参考：<u>5.3 索引相关–问答6</u>）</p>
<ul>
<li>
<p><strong>B+树基本结构</strong></p>
<p><img src="https://i.loli.net/2021/05/23/xXQFuqgEfpreHdG.jpg" alt="b+树"></p>
<p>浅蓝色是一个磁盘块，数据项就是被组织索引那<strong>列</strong>的字段值。</p>
<blockquote>
<p>如果是Innodb引擎，使用聚簇索引就是按照每张表的 <strong>主键</strong> 构造索引，那么此时<strong>数据项就是主键值</strong>。</p>
</blockquote>
<ul>
<li>
<p>蓝色部分（如17,35）是数据项；黄色部分（如P1,P2,P3）是指针，指向<strong>下个磁盘块（页地址）</strong>。</p>
</li>
<li>
<p><strong>1. 为什么B+树非叶子节点不存放数据？</strong></p>
<p>IO次数取决于b+数的高度h，每个磁盘块大小也是一定（一页）的。<strong>如果数据项占的空间越小，一个磁盘块数据项的数量越多，树的高度越低，B+可以更高阶（指针占用先忽略）</strong>。</p>
<p>所以磁盘<strong>非叶子</strong>节点不保存数据，是为了保存更多的数据项和指针，这样一颗B+树<strong>叶子</strong>节点就能存储更多的数据。</p>
</li>
<li>
<p><strong>2. 数据查找过程？</strong></p>
<p>以查找<code>数据项=28</code> ，过程为例：<br>
（1） 先 <u>加载（一般常驻内存）</u> 根页面1（磁盘块1），因为<code>17&lt;28&lt;35</code> 所以使用<code>P2</code>指针 ， 找到磁盘块3（页面3）<strong>地址</strong></p>
<p>（2）在 <u>IO加载</u> 磁盘块3，因为 <code>26&lt;28&lt;30</code>  ，因此根据此时的<code>P2</code> 指针，找到磁盘块8所在的地址</p>
<p>（3） <u>IO加载</u> 磁盘块8，因为此时是叶子节点，可以得到<code>数据项=28</code>对应的<strong>那行记录</strong> 。</p>
<p>仅仅最多<strong>3</strong>次磁盘IO就找到了数据，这提升是巨大的。</p>
</li>
<li>
<p><strong>3. 高度为3的B+数可以存储多少数据？</strong></p>
<ul>
<li>
<p><strong>叶子节点一页存储的记录数</strong></p>
<p>mysql一页16K，所以一页存储<code>16K/1K = 16条</code> 记录。（实际真实业务场景一条记录一般就是1K）</p>
</li>
<li>
<p><strong>非叶子节点一页存储的指针数</strong></p>
<p>由于数据项也要占用空间，其和指针只相差1，按<strong>成对</strong>算。</p>
<p>假设主键ID（数据项）为bigint类型，长度为<code>8</code>字节，而<code>指针大小</code>在InnoDB源码中设置为<code>6字节</code> 。那么一共<code>14</code>字节。</p>
<p>所以一页可以存储：<code>16K / 14B ≈ 1K</code> 个指向页面的指针。</p>
</li>
<li>
<p><strong>计算可以存储多少页</strong></p>
<p>高度为3的B+树，第3层叶子节点存储真实<strong>数据页</strong>，前2层是存储<strong>数据项+指针</strong>。<strong>第二层指针</strong>==叶子节点存储的页面数。</p>
<ol>
<li>第一层：根页面可以存储1K个指针，每个指针指向一个新的页面</li>
<li>第二层：存储 <code>1K*1K = 1M</code> ，约一百万个指针，指向一百万个叶子数据页面</li>
</ol>
<p>所以一共存储：<code>1M*16≈16M</code> ，即千万级别的数据。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="0-4-慢查询优化">0.4 慢查询优化</h5>
<p>（暂略）</p>
<h4 id="1-MySQ索引的原理和数据结构能介绍一下吗？-索引的缺点？">1. <strong>MySQ索引的原理和数据结构能介绍一下吗？</strong> <strong>索引的缺点？</strong></h4>
<ul>
<li>
<p><strong>索引原理：</strong> 本质是用来优化查询速度。<u>用一个数据结构组织某一列的数据</u>，然后如果你要根据那一列的数据查询的时候，就可以<u>不用全表扫描</u>，只要根据那个特定的数据结构快速去找到那一列的值。</p>
</li>
<li>
<p><strong>数据结构：</strong> MySQL索引通过B+树来实现（按数据结构分也有hash索引、fulltext索引）。</p>
</li>
<li>
<p><strong>索引缺点：</strong> （1）占用磁盘存储空间 （2）降低表更新速度，表发生变化，索引也要发生变化</p>
</li>
</ul>
<h4 id="2-MySQL-索引类型有哪些？">2. <strong>MySQL 索引类型有哪些？</strong></h4>
<p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。<br>
按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。<br>
按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。<br>
按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p>
<ul>
<li>
<p><strong>主键索引</strong>：索引列中的值必须是唯一的，不允许有空值；</p>
</li>
<li>
<p><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值；</p>
</li>
<li>
<p><strong>普通索引</strong>：MySQL中<u>基本索引类型</u>，没有什么限制，允许在定义索引的列中插入重复值和空值；</p>
</li>
<li>
<p><strong>全文索引</strong>：只能在<strong>文本类型CHAR,VARCHAR,TEXT</strong>类型字段上创建全文索引；</p>
<blockquote>
<p>字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引；</p>
<p>MyISAM和InnoDB中都可以使用全文索引。</p>
</blockquote>
</li>
<li>
<p><strong>前缀索引</strong>：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定；</p>
</li>
<li>
<p><strong>空间索引</strong>： MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。</p>
<blockquote>
<p>MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p>
</blockquote>
</li>
</ul>
<h5 id="2-1-什么是覆盖索引？">2.1 什么是覆盖索引？</h5>
<p>我们在<u>非聚簇索</u>引一般只获得了，记录的key值（Innodb引擎），还需要回到聚簇索引中<strong>再次查询</strong>。</p>
<ul>
<li><strong>覆盖索引：</strong> 从<strong>非主键索引中就能查到的记录</strong>，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</li>
</ul>
<blockquote>
<p>一个小例子。</p>
</blockquote>
<p>以name和age两个字段建立<strong>联合索引</strong>，sql命令与建立后的索引树结构如下：</p>
<img src="https://i.loli.net/2021/05/28/V2ApYvt9zWGFhcf.png" alt="image-20210526230732546" style="zoom:80%;" />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX I_name;</span><br><span class="line">ALTER TABLE student ADD INDEX I_name_age(name, age);</span><br></pre></td></tr></table></figure>
<p>此时执行如下sql：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT age FROM student WHERE name = &#x27;小李&#x27;；</span><br></pre></td></tr></table></figure>
<p>在<strong>非聚簇索引中包含了age信息</strong>，那么直接返回12，不需要再到聚簇索引中查询。</p>
<h4 id="【重点】3-什么时候使用索引比较好？-什么时候不要使用索引？">【重点】3. **什么时候使用索引比较好？**什么时候不要使用索引？</h4>
<h5 id="3-1-什么时候用索引">3.1 什么时候用索引</h5>
<blockquote>
<p>特别的，主键自动建立唯一索引。</p>
</blockquote>
<ol>
<li>
<p><strong>频繁</strong>作为查询条件的字段应该创建索引 ；</p>
</li>
<li>
<p><strong>查询中与其他表关联的字段</strong>，外键关系建立索引；</p>
</li>
<li>
<p><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度（<strong>索引就是排序加快速查找</strong>）；</p>
</li>
<li>
<p><strong>查询中统计或者分组字段</strong>。</p>
</li>
</ol>
<h5 id="3-2-什么时候不用索引">3.2 什么时候不用索引</h5>
<ol>
<li>
<p><strong>经常增删改</strong>的列不要建立索引（因为每次更新不单单是更新记录，还会更新索引，保存索引文件）；</p>
</li>
<li>
<p><strong>表记录太少</strong>不要建立索引；</p>
</li>
<li>
<p>（被CSIG问过）**区分度低，**数据重复且分布平均的字段不适合做索引；</p>
<blockquote>
<p>例如性别字段，只有男女，不适合建立索引。</p>
<ul>
<li>因为从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO；</li>
<li>假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了；</li>
<li>但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要 <u>访问50万次索引，再访问50万次表</u>，加起来的开销并不会比直接对表进行一次完整扫描小。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>text，image</strong>等类型不应该建立索引，<strong>这些列的数据量大</strong>；</p>
</li>
<li>
<p><strong>多个单列索引并不是最佳选择</strong> MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引 ；</p>
</li>
<li>
<p><strong>参加运算 或 作为函数参值等字段</strong>，不要建立索引，这会使得索引失效而全表扫描 。</p>
</li>
</ol>
<h4 id="4-主键与唯一索引有什么区别？">4. <strong>主键与唯一索引有什么区别？</strong></h4>
<ul>
<li>
<p>主键一<strong>定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</strong></p>
</li>
<li>
<p>主键不允许为空值，唯一索引列允许空值；</p>
</li>
<li>
<p>一个表只能有一个主键，但是可以有多个唯一索引；</p>
</li>
<li>
<p>主键可以被<strong>其他表引用为外键，唯一索引列不可以；</strong></p>
</li>
<li>
<p>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质差别。</p>
</li>
</ul>
<h4 id="5-b-树和b树有什么区别？">5. <strong>b+树和b树有什么区别？</strong></h4>
<p>B树：</p>
<p><img src="https://i.loli.net/2021/04/21/YsAxSctJ1wKUm3g.png" alt="clip_image002"></p>
<ul>
<li>索引与数据存储在每个节点中（增加了IO次数）；</li>
<li>搜索过程有可能在非叶子节点结束（最好情况下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li>
</ul>
<p>B+树：</p>
<p><img src="https://i.loli.net/2021/04/21/ihT3SbqwodNUvPe.png" alt="clip_image039"></p>
<ul>
<li>所有数据<strong>按顺序</strong>存储在叶子节点中；</li>
<li>所有叶子节点被<strong>双向链连接</strong>；</li>
<li>搜索过程固定时间复杂度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>）；</li>
<li>（优点易忘）<u>适合范围查找，降低磁盘IO次数</u>。</li>
</ul>
<h4 id="6-为什么MySQL使用B-树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？">6. <strong>为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？</strong></h4>
<ul>
<li>
<p><strong>不用平衡二叉树或者红黑树：</strong> 树的查询时间和树的结构有关，B+树是一颗多路搜索数，可以降低树的高度提高查询速度。</p>
</li>
<li>
<p><strong>不用B树：</strong> （1）无法范围查询，而<strong>B+树所有叶子节点形成有序链表便于范围查询</strong>；（2）N阶B+数，B树，B+数可以存储n个关键字，而B树是n个。</p>
</li>
<li>
<p><strong>不用Hash：</strong> （1）B+树允许分配加载节点，如果内存数据太大B+树更好（2）B+树更适合范围查询</p>
<blockquote>
<p>用Hash需要把数据全部<strong>加载到内存中</strong>，如果数据量大，是一件很<strong>消耗内存</strong>的事，而采用B+树，是基于<strong>按照节点分段加载，由此减少内存消耗</strong>。</p>
</blockquote>
</li>
</ul>
<h5 id="6-1-无限增加树的路数是不是可以有最优的查找效率？">6.1 <strong>无限增加树的路数是不是可以有最优的查找效率？</strong></h5>
<ul>
<li>
<p>这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，<u>不一定能一次性加载到内存中</u>。</p>
</li>
<li>
<p><strong>有序数组没法一次性加载进内存</strong>，这时候B+树的多路存储威力就出来了，<strong>可以每次加载B+树的一个结点，然后一步步往下找</strong>。</p>
</li>
</ul>
<h4 id="7-B-树怎么进行分裂、合并的？知道具体步骤吗？">7. <strong>B+树怎么进行分裂、合并的？知道具体步骤吗？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.htm">https://www.cnblogs.com/nullzx/p/8729425.htm</a></p>
</blockquote>
<p><img src="https://i.loli.net/2021/04/21/aejwRD2WxNb7slY.png" alt="image-20210421124006795"></p>
<h4 id="8-MySQL聚簇索引和非聚簇索引的区别是什么？">8. <strong>MySQL聚簇索引和非聚簇索引的区别是什么？</strong></h4>
<ul>
<li>
<p><strong>主要区别</strong></p>
<ul>
<li>
<p><strong>聚簇索引</strong> ： 找到索引就找到了需要的数据，那么这个索引就是聚簇索引;</p>
<blockquote>
<p>所以Innodb主键就是<strong>聚簇索引</strong>，修改聚簇索引其实就是修改主键；但在<u>Myisam下主键索引是非聚集索引</u>。</p>
<p>InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引（但是这个主键如果更改代价较高，<u>故建表时要考虑自增ID不能频繁update</u>这点）。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/03/mzwGgCjxuIpaeA7.png" alt="img"></p>
</li>
<li>
<p><strong>非聚簇索引：<strong>索引的存储和数据的存储是分离的 , 找到了索引但没找到数据，需要根<u>据</strong>索引上的值(主键/地址)再次回表查询</strong></u>，<strong>也叫做辅助索引</strong>。</p>
<blockquote>
<p>MyISM使用的是非聚簇索引 ，下图叶节点的<strong>data域存放的是数据记录的地址</strong> 。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/03/A1X5aOY6qkuEol9.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p><strong>聚簇索引查找过程</strong></p>
<blockquote>
<p>首先澄清一个概念，聚簇索引和和辅助索引。</p>
<p>Innodb存储引擎的B+树分为，聚簇索引保存的是放着一整行的数据；辅助索引都引用<u>主键作为data域</u>。</p>
<p>例如，下图以Col3建立一个<strong>Innodb辅助索引</strong> ：</p>
<p><img src="https://i.loli.net/2021/05/03/l1IHbpgGAYr73sT.png" alt="img"></p>
<p>对于MyISAM，主索引和辅助索引（Secondary key）在结构上没有任何区别。<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。</p>
<p>例如，下图以Col2建立一个<strong>MyISAM的辅助索引</strong>：</p>
<p><img src="https://i.loli.net/2021/05/03/9jpKvRbIWFwucLT.png" alt="img"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * Where name=‘Alice’</span><br></pre></td></tr></table></figure>
<p>首先根据<u>辅助索引</u> ，在叶子节点找到**0X56对应主键值<code>18</code> ；**然后在<u>聚簇索引</u>，根据<code>18</code> 找到对应行数据。</p>
</li>
</ul>
<h5 id="8-1-看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B-树查找，这不是多此一举吗？聚簇索引的优势在哪？">8.1 <strong>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？</strong></h5>
<ul>
<li>
<p>**重复访问同一页更快：**由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，<strong>已经把页加载到了Buffer中</strong>，<strong>再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘；</p>
<blockquote>
<p>B+树的每个节点的数量都是一个mysql分区页的大小(阿里面试) 。</p>
</blockquote>
</li>
<li>
<p><strong>辅助索引使用主键值作为指针：</strong> 辅助索引使用主键作为&quot;指针&quot;而不是使用地址值作为指针（MyISAM） ，<strong>减少了当出现【行移动】或者数据页分裂时（<u>地址值变化</u>）辅助索引的维护工作</strong> 。</p>
</li>
</ul>
<h5 id="8-2-为什么name-age这些字段不适合做索引？">8.2 为什么name,age这些字段不适合做索引？</h5>
<p>在InnoDB中每一个表都会有聚集索引，如果表定义了主键，则（默认）主键就是聚簇索引。</p>
<p>一个表只有一个聚集索引，其余为普通索引。所以name，age就是普通索引，也就是作为辅助索引。</p>
<p>在使用普通索引name查询时，会先加载普通索引：</p>
<p>（1）通过普通索引查询到实际行的主键</p>
<p>（2）再使用主键通过聚集索引查询相应的行</p>
<p>（3）以此<strong>循环查询所有的行</strong><br>
若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。相比两种操作的总开销可能扫描全表效率更高。</p>
<h4 id="9-MySQL联合索引如何使用？-什么是最左匹配原则？">9. <strong>MySQL联合索引如何使用？</strong> <strong>什么是最左匹配原则？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Abysscarry/article/details/80792876">https://blog.csdn.net/Abysscarry/article/details/80792876</a></p>
</blockquote>
<p>对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(4) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` varchar(10) NOT NULL,</span><br><span class="line">  `b` varchar(10) NOT NULL,</span><br><span class="line">  `c` varchar(10) NOT NULL,</span><br><span class="line">  `d` varchar(10) NOT NULL,</span><br><span class="line">  `e` varchar(10) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  # 联合索引(a,b,c)</span><br><span class="line">  UNIQUE KEY `idx_a_b_c` (`a`,`b`,`c`) USING BTREE </span><br><span class="line">) ENGINE=I</span><br></pre></td></tr></table></figure>
<p>以联合索引(a,b,c)为例：</p>
<ul>
<li>
<p><strong>建立这样的索引相当于建立了索引a、ab、abc三个索引</strong>。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。</p>
<blockquote>
<p>**a,c **组合也可以但不是为他建立了索引，但实际上只用到了a的索引，c并没有用到！</p>
</blockquote>
</li>
<li>
<p><strong>最左匹配原则</strong></p>
<p>最左优先，在检索数据时从联合索引的最左边开始匹配，<strong>即是where条件必须有联合索引的第一个字段。</strong></p>
<ul>
<li>
<p>不包含第一个字段</p>
<p>不会走索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where  b = &#x27;333&#x27; and c = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>where和索引顺序不一样</p>
<p>会走索引，<u>和顺序无关</u>。</p>
<blockquote>
<p>where 后面列的顺序是被<strong>优化器</strong>优化了的，所以才会觉得无影响，你可以查看一下优化器优化后的语句，会帮你调整为满足最左前缀的顺序。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where c = &#x27;333&#x27; and b = &#x27;333&#x27; and a = &#x27;333&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="9-1-联合索引的好处？">9.1 联合索引的好处？</h5>
<h4 id="10-（还要补充）介绍一下索引失效的原因？">10. （还要补充）介绍一下索引失效的原因？</h4>
<blockquote>
<p>很不错的一篇文章：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1704743">索引失效原理，终于有人讲明白了</a></p>
<p>结合这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904073955639304">https://juejin.cn/post/6844904073955639304</a></p>
</blockquote>
<p>假设mysql 存在联合索引（a,b），显然也是一颗B+树:</p>
<p><img src="https://i.loli.net/2021/05/24/GlDckpZzWTnodIf.png" alt="image-20210524114029113"></p>
<ul>
<li>
<p><strong>不符合最左匹配失效</strong></p>
<ol>
<li>
<p>情况1 ：<code>select * from testTable where b=2</code></p>
<p>联合索引是通过第一个索引<code>a</code> 来构建B+树，进行定位二分查找的，不能直接通过<code>b</code> 来进行二分查找。</p>
</li>
<li>
<p>情况2：<code>like</code>查询失效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where name like &quot;a%&quot;  # 会有效，因为可以匹配到首字母</span><br><span class="line"></span><br><span class="line">where name like &quot;%a%&quot; # 首字母是任意匹配的，所以索引用不上</span><br><span class="line"></span><br><span class="line">where name like &quot;%a&quot; # 同上，不能根据尾字母来索引</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p><strong>范围查询失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from testTable where a&gt;1 and b=2</span><br></pre></td></tr></table></figure>
<p>首先<strong>a字段在B+树上是有序</strong>的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。</p>
<p><strong>b有序的前提是a是确定的值</strong>，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。</p>
<p>大于1的a那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。</p>
</li>
<li>
<p><strong>多个单列索引</strong></p>
<p>我们首先建立了三个单列索引：userid，mobile，billMonth。然后使用以下查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; AND mobile=&#x27;13281899972&#x27; AND billMonth=&#x27;2018-04&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>explain</code> 结果分析，最终只有<code>userid</code> 这<strong>一个索引有效</strong>。</p>
<blockquote>
<p>此处<code>userid 、mobile 、billMonth</code>这三个索引列都能用，只不过<strong>优化器判断使用<code>userid</code>这一个索引能最高效完成本次查询</strong>，故最终explain展示的key为userid。</p>
</blockquote>
</li>
</ul>
<p>特别的，如果改为 <code>or</code> 进行判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `t_mobilesms_11` WHERE  userid=&#x27;2222&#x27; OR mobile=&#x27;13281899972&#x27; </span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/24/UDQxsm7YIrglvu8.png" alt="这里写图片描述"></p>
<ul>
<li>
<p><strong>此时两个索引 userid &amp; mobile都用上了</strong>。</p>
<blockquote>
<p>mysql <u>5.0 版本之前</u> 使用or<strong>只会用到一个索引</strong>, 自从<u>5.0版本开始</u> ，引入了index_merge索引合并优化！也就是说，我们现在可以利用上多个索引去优化or查询了。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>或者索引加上了运算</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure>
<p>这种情况不会有效，应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure>
<p>又比如用了函数操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="11-【⚠️-新增】索引实战篇">11. 【⚠️ 新增】索引实战篇</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115778804">https://zhuanlan.zhihu.com/p/115778804</a></p>
</blockquote>
<ol>
<li>
<p><code>where a=xxx and b=xxx order by c</code>  ，如何建立索引？</p>
<p>建立联合索引<code>（a,b,c）</code> ，因为这样的话<strong>无需做一次额外的排序操作</strong>。</p>
<p>因为建立联合索引时，根据最左匹配原则，先按<code>a</code>排序，再按<code>b</code>排序，最后按<code>c</code> 排序。根据联合索引检索到，<code>a=xxx and b=xxx</code>条件时，再去检索<code>c</code>本身已排序的。那么不用 <code>order by c</code> ，不用进行文件排序。</p>
<ul>
<li>注意，建立联合索引 <code>（a,b）</code> , 则是走不到 sort的！</li>
</ul>
</li>
<li>
<p><code>where a=xxx  order by b,c</code>  ，如何建立索引？</p>
<p>道理同上，建立<code>（a,b,c）</code> 。</p>
</li>
<li>
<p><code>where a &gt; 1 ORDER BY b</code>，怎么建立索引？</p>
<p>建立索引（a）即可，因为a是范围查询：</p>
<ul>
<li>建立（a,b）的 话b也用不上，因为是a是范围查询；</li>
<li>建立（b,a）, <strong>b按索引排好序，a&gt;1可以用上？错误，因为先where筛选才会order by！</strong></li>
</ul>
</li>
<li>
<p><code>where a=1 and b=2 and c&gt;3 and d=4</code> ，如何建立索引？</p>
<p>建立联合索引，<code>(a,b,d,c)</code>  即可。</p>
<ul>
<li>但是对于建立<code>(a,b,c,d)</code> ，<strong>a,b,c三个字段能用到索引，而d就匹配不到</strong>，因为遇到了<strong>范围查询，在c&gt;3这个范围内，d不是有序的；但是c=3，这个范围内，d是有序的</strong>！</li>
</ul>
</li>
<li>
<p><code>where a &gt; 1 and b = 2 and c &gt; 3</code>，如何建立索引？</p>
<p>建立（b,c）或者（b,a）即可，但至少有一个索引要失效（遇上范围查询）。</p>
</li>
<li>
<p><code>WHERE a IN (1,2,3) and b &gt; 1</code>，怎么建立索引？</p>
<p>还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)！</p>
</li>
</ol>
<h4 id="12-order-by-怎么进行排序的？怎么优化？">12. order by 怎么进行排序的？怎么优化？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040357292">https://segmentfault.com/a/1190000040357292</a></p>
</blockquote>
<p>假设存在以下数据：</p>
<p><img src="https://i.loli.net/2021/09/04/cudfwqEHGmn3Ppt.png" alt="image-20210904013336980"></p>
<p>此时进行如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city, order_num, user_code from `order` where city=&#x27;广州&#x27; order by order_num limit 1000;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>建立索引(city)：order by过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `order` ADD INDEX city_index ( `city` );</span><br></pre></td></tr></table></figure>
<img src="D:/hwh/images/image-20210904013506155.png" alt="image-20210904013506155" style="zoom:80%;" />
<ul>
<li>
<p><strong>用 explain 看看执行情况</strong></p>
<p><img src="https://i.loli.net/2021/09/04/lv3uyaxWkKPtqjd.png" alt="img"></p>
<p>注意到最后一个 extra 字段的结果是：<strong>Using filesort</strong>，表示需要排序。<strong>其实 MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</strong>。</p>
</li>
<li>
<p><strong>完整执行过程</strong></p>
<img src="https://i.loli.net/2021/09/04/Pm7eJ1vQFg8l2xA.png" alt="image-20210904013732363" style="zoom:80%;" />
<ol>
<li>
<p>初始化 <strong>sort_buffer</strong>，放入 <code>city、order_num、user_code</code> 这三个字段；</p>
</li>
<li>
<p>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</p>
</li>
<li>
<p><strong>到主键 id 索引取出整行</strong>，取 city、order_num、user_code 三个字段的值，存入 sort_buffer 中；</p>
</li>
<li>
<p>从索引 city 取下一个记录的主键 id；</p>
</li>
<li>
<p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_X；</p>
</li>
<li>
<p>对 sort_buffer 中的数据按照字段 <strong>order_num 做快速排序</strong>；</p>
<blockquote>
<p>其中，<strong>按 order_num 排序</strong>这个步骤，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <strong>sort_buffer_size</strong>。</p>
</blockquote>
</li>
<li>
<p>按照排序结果取前 1000 行返回给客户端。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>优化1：使用rowid</strong></p>
<p>上面的全字段排序其实会有很大的问题，你可能发现了。<strong>我们需要查询的字段都要放到 sort_buffer 中，如果查询的字段多了起来，内存占用升高，就会很容易打满 sort_buffer</strong> 。</p>
<ul>
<li>
<p><strong>sort_buffer 只存 order_num 和 id 字段</strong>。</p>
<img src="https://i.loli.net/2021/09/04/PRwrO4ae3BJLciH.png" alt="img" style="zoom:80%;" />
<ol>
<li>初始化 sort_buffer，确定放入两个字段，即 order_num 和 id；</li>
<li>从索引 city 找到第一个满足 city=’ 广州’条件的主键 id，也就是图中的 ID_3；</li>
<li><strong>回表</strong>，取 order_num、id 这两个字段，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到不满足 city=’ 广州’条件为止，也就是图中的 ID_X；</li>
<li>对 sort_buffer 中的数据按照字段 order_num 进行排序；</li>
<li>遍历排序结果，取前 1000 行，再次回表取出 city、order_num 和 user_code 三个字段返回给客户端。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>优化2：建立联合索引</strong></p>
<p>参见索引部分解释，不再赘述。</p>
<img src="https://segmentfault.com/img/remote/1460000040357304" alt="img" style="zoom:80%;" />
<ol>
<li>
<p>从索引 (city,order_num) 找到第一个满足 city=’ 广州’条件的主键 id；</p>
</li>
<li>
<p>回表，取 city、order_num、user_code 三个字段的值，作为结果集的一部分直接返回；</p>
</li>
<li>
<p>从索引 (city,order_num) 取下一个记录主键 id；</p>
</li>
<li>
<p>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’ 广州’条件时循环结束。</p>
</li>
</ol>
</li>
</ol>
<h2 id="5-3-事务相关">5.3 事务相关</h2>
<h4 id="1-请介绍一下数据库事务？和-u-事务特性-u-（ACID）？">1. <strong>请介绍一下数据库事务？和<u>事务特性</u>（ACID）？</strong></h4>
<ul>
<li>
<p><strong>数据库事务：</strong> 数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败。</p>
<blockquote>
<p><em>e.g.</em>  假设一个网购付款的操作，用户付款后要涉及到订单状态更新、扣库存以及其他一系列动作，这就是一个事务，如果一切正常那就相安无事，一旦中间有某个环节异常，那整个事务就要回滚，总不能更新了订单状态但是不扣库存吧。</p>
</blockquote>
</li>
<li>
<p><strong>事务特性：</strong>（1） 原子性（Atomicity）：一个事务必须视为一个不可分割的最小工作单元，要么都成功要么都失败（2）一致性（Consistency）：数据库总能从一个<strong>一致性的状态转换到另一个一致性的状态</strong>（3）隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（4）持久性（Durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中</p>
</li>
</ul>
<h5 id="1-1-四大特性得不到保障会出现什么情况？">1.1 四大特性得不到保障会出现什么情况？</h5>
<blockquote>
<p>们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。</p>
</blockquote>
<ul>
<li>
<p><strong>原子性</strong> : 原子性是指一个事务是一个不可分割的工作单位，<strong>其中的操作要么都做，要么都不做</strong>。即要么转账成功，要么转账失败，是不存在中间的状态。</p>
<blockquote>
<p><strong>如果无法保证原子性会怎么样？</strong></p>
</blockquote>
<p>会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~</p>
</li>
<li>
<p><strong>一致性</strong> ：一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。<strong>满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。</strong></p>
<blockquote>
<p><strong>如果无法保证一致性会怎么样？</strong></p>
</blockquote>
<ul>
<li>
<p>例一: A账户有200元，转账300元出去，此时A账户余额为-100元。</p>
<p>你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>余额这列必须大于0</strong>。</p>
</li>
<li>
<p>例二：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。</p>
<p>你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，<strong>要求A+B的余额必须不变</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>隔离性</strong> ：隔离性是指<strong>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的</strong>，并发执行的各个事务之间不能互相干扰。</p>
<blockquote>
<p><strong>如果无法保证隔离性会怎么样</strong>？</p>
</blockquote>
<p>假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。</p>
<p>如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！</p>
</li>
<li>
<p><strong>持久性</strong> : 根据定义，<strong>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的</strong>。接下来的其他操作或故障不应该对其有任何影响。</p>
<blockquote>
<p><strong>如果无法保证持久性会怎么样？</strong></p>
</blockquote>
<p>在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。</p>
<p>设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是<strong>数据不一致</strong>的情形。</p>
</li>
</ul>
<h5 id="1-2-数据库如何保证四大特性？">1.2 数据库如何保证四大特性？</h5>
<ul>
<li>
<p><strong>保证原子性</strong> ：主要是利用 Innodb 的<strong>undo log</strong>。 <strong>undo log</strong>名为回滚日志，是实现原子性的关键，当<strong>事务回滚时能够撤销所有已经成功执行的 SQL语句</strong>，他需要记录你要回滚的相应日志信息 。</p>
<blockquote>
<ul>
<li>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>…</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>保证一致性：</strong> 分为以下两个方面阐述。</p>
<ul>
<li><strong>从数据库层面</strong>，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。<strong>数据库必须要实现AID三大特性，才有可能实现一致性</strong>；</li>
<li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</li>
</ul>
</li>
<li>
<p><strong>保证隔离性：</strong></p>
</li>
<li>
<p><strong>保证持久性：</strong> 主要是利用Innodb的<strong>redo log</strong>，重写日志。</p>
<blockquote>
<p>正如之前说的，MySQL是先把磁盘上的数据（加载一页16kb）加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？</p>
</blockquote>
<ul>
<li>
<p><strong>事务提交前直接写入磁盘不经过内存：</strong>  但是有以下缺点</p>
<ol>
<li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了；</li>
<li>一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li>
</ol>
</li>
<li>
<p><strong>采用redo log（推荐）：</strong>   当做数据修改的时候，不仅在内存中操作，还会在<strong>redo log</strong>中记录这次操作。</p>
<ol>
<li>当事务提交的时候，会将<strong>redo log</strong>日志进行<strong>刷盘</strong>(<strong>redo log</strong>一部分在内存中，一部分在磁盘上)；</li>
<li>当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据<strong>undo log</strong>和<strong>binlog</strong>内容决定回滚数据还是提交数据。</li>
</ol>
<p>redo log的优点：</p>
<ol>
<li>
<p><strong>redo log</strong>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快；</p>
</li>
<li>
<p><strong>redo log</strong>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="2-介绍一下（并发）事务不同隔离级别？-对应可能出现的问题？">2. <strong>介绍一下（并发）事务不同隔离级别？</strong> <strong>对应可能出现的问题？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shan-kylin/p/9543294.html">https://www.cnblogs.com/shan-kylin/p/9543294.html</a></p>
</blockquote>
<p>下面<strong>排它锁和共享锁</strong>都是<strong>行锁</strong>，锁住一行。</p>
<ul>
<li>
<p><strong>Read uncommitted：</strong> 顾名思义，就是一个事务可以读取另一个未提交事务的数据。但这种情况会出现<strong>脏读：</strong> 因为<strong>写</strong>数据的时候添加一个<strong>X锁（排他锁，拿到锁的事务可以写，其它事务只能等待阻塞）</strong>；但<strong>读</strong>不受限制，读不加锁。</p>
<blockquote>
<p>由于读不加锁，读的是可能是修改前（未提交）的数据，也就是<strong>脏读</strong>。</p>
</blockquote>
</li>
<li>
<p><strong>Read Committed ：写</strong>数据的时候加上<strong>X锁（排他锁）</strong>，<strong>读</strong>数据的时候添加<strong>S锁（共享锁，拿到锁的事务可以查看但无法修改和删除，其它事务【只能加S锁】【不能加其它锁】如X锁）</strong>。解决脏读，但会导致出现<strong>不可重复读</strong>的问题。</p>
<blockquote>
<ol>
<li>初始x=100,；</li>
<li>事务A<strong>读</strong>x，加上<strong>S锁</strong>，读到x=<strong>100</strong>，<strong>立即释放S锁且未提交</strong>；</li>
<li>事务B<strong>修改</strong>x，加上<strong>X锁</strong>，修改x=50，提交 ；</li>
<li>事务A再次<strong>读取x</strong>，加上<strong>S锁</strong>，读取x=<strong>50</strong>，发现和第一次读取不一致，提交事务。</li>
</ol>
<p>上述过程，事务A在提交前读取两次不一样的x值，为<strong>不可重复读</strong>。</p>
</blockquote>
</li>
<li>
<p><strong>Repeatable read</strong> ：<strong>MySQL 默认隔离界别</strong> , 开始<strong>读取</strong>数据（事务开启）时，<strong>【S】锁不再立即释放，其它事务就不能加上【X】锁修改数据</strong>。解决了脏读、不可重复读，但是可能会出现<strong>幻读：</strong>-</p>
<ul>
<li>Mysql官方给出的幻读解释是：<strong>只要在一个事务中，第二次select（读）多出了row就算幻读</strong>。</li>
</ul>
<blockquote>
<p>现在做如下修改：</p>
<ul>
<li>写：X锁保持不变</li>
<li>读：S锁，<strong>读完不再立即释放</strong>，而是<strong>在提交的时候再释放</strong>。</li>
</ul>
<p>这样的话，保证事务A在<u>提交前</u>，读取的x是一致的。解决了<strong>不可重复读</strong>，但依旧可能出现<strong>幻读</strong>。例如，<strong>X锁不能阻止（表中其它记录）插入操作，因为只锁住了当前记录，是行级锁</strong>。</p>
<ol>
<li>事务A加上X锁，更新了<strong>所有用户</strong>年龄从<code>20→18</code>；</li>
<li>过一会儿再读发现<strong>还有一个用户没修改</strong>，还是20岁？出现幻觉了吗？</li>
</ol>
<p>这是因为，其它事务B同时插入了一行新数据，年龄就是20岁。所以再读发现没修改。</p>
</blockquote>
</li>
<li>
<p><strong>Serializable ：</strong> 序列化，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。耗费性能，一般不用。</p>
</li>
</ul>
<h5 id="2-1【猿辅导】-怎么解决幻读？">2.1【猿辅导】 怎么解决幻读？</h5>
<p>解决幻读使用两种方式：</p>
<ol>
<li>
<p><strong>间隙锁</strong></p>
<ul>
<li>
<p><strong>间隙锁（Gap Lock）</strong>：<strong>当我们用【范围条件】而不是相等条件检索数据，并请求共享或排他锁时</strong>，InnoDB会给<strong>符合条件的已有数据记录的索引项加锁</strong>；对于键值在<strong>条件范围内但并不存在的记录，叫做“间隙（GAP)”</strong>，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁；</p>
</li>
<li>
<p><strong>举例：</strong> 假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">&gt;</span> <span class="number">99</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>
<p>是一个范围条件的检索，InnoDB不仅会对（1）<strong>符合条件的user_id值（100、101）的记录加锁</strong>，也会对（2）user_id大于101（这些<strong>记录并不存在）的“间隙”加锁</strong>。</p>
</li>
<li>
<p><strong>如何解决幻读？</strong> 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，导致下次读取产生幻读。如果锁住了间隙，自然也就没锁的问题了。</p>
</li>
</ul>
</li>
<li>
<p><strong>mvvc</strong></p>
<p>在RR（可重复读级别下）不会出现幻读。例如：</p>
<ol>
<li>
<p>开启事务1，获得事务ID为1。</p>
</li>
<li>
<p>事务1执行查询，得到readview。</p>
</li>
<li>
<p>开始事务2。</p>
</li>
<li>
<p>执行insert。</p>
</li>
<li>
<p>提交事务2。</p>
</li>
<li>
<p>执行事务1的第二次查询 (因为这里是RR级别，所以<strong>不会再去获得readview，<strong>还是使用第一次获得的readview，所以</strong>当前read view 事务的ID不会更新</strong>，即不会加入插入事务2)</p>
</li>
<li>
<p>最后得到的结果是，插入的数据不会被读取显示，因为<strong>插入的数据事务ID &gt; readview里的最大活跃事务ID</strong>。</p>
</li>
</ol>
</li>
</ol>
<h4 id="3-Mysql怎么保证事务的原子性？持久性？">3. Mysql怎么保证事务的原子性？持久性？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1600883">https://cloud.tencent.com/developer/article/1600883</a></p>
</blockquote>
<ul>
<li>
<p><strong>原子性</strong></p>
<p>是利用Innodb的<strong>undo log</strong>。</p>
<p>undo log名为回滚日志，是实现原子性的关键，当<strong>事务回滚时能够撤销所有已经成功执行的sql语句</strong>，他需要记录你要回滚的相应日志信息。</p>
<p>例如</p>
<ul>
<li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操</li>
</ul>
<p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
</li>
<li>
<p><strong>持久性</strong></p>
<p>利用Innodb的<strong>redo log</strong>，为什么要使用redo log，请看下面：</p>
<ul>
<li>正如之前说的，Mysql是把磁盘上的数据<strong>先加载到内存</strong>中，在内存中对数据进行修改，再刷回磁盘上。<strong>如果此时突然宕机，内存中的数据就会丢失；</strong></li>
<li><strong>如果事务提交前直接把数据写入磁盘，只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了</strong>。</li>
</ul>
<p><strong>redo log解决方案：</strong></p>
<ul>
<li>当做数据修改的时候，<strong>不仅在内存中操作，还会在redo log中记录这次操作</strong>；</li>
<li>当事务提交的时候，<strong>会将redo log日志进行刷盘</strong>(redo log一部分在内存中，一部分在磁盘上)；</li>
<li><strong>当数据库宕机重启</strong>的时候，会将redo log中的内容恢复到数据库中，<strong>再根据undo log和binlog内容决定回滚数据</strong>还是提交数据。</li>
</ul>
</li>
</ul>
<h2 id="5-4-MySQ优化">5.4 MySQ优化</h2>
<h4 id="0-分页查询慢的原因？如何优化？">0. 分页查询慢的原因？如何优化？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904141878214664">https://juejin.cn/post/6844904141878214664</a></p>
</blockquote>
<p>在偏移量非常大的时候，也就是翻页到很靠后的页面时，查询速度会变得越来越慢，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_order order by id limit 1000000000, 10;</span><br></pre></td></tr></table></figure>
<p>这是因为，需要查询 100000000010 (100000000000 + 10) 条记录，然后只返回最后 10 条，并将前面的 100000000000 条记录抛弃，这样当翻页越靠后时，代价就变得越来越高。</p>
<p><strong>优化方法：</strong></p>
<ol>
<li>
<p><strong>最大id法</strong></p>
<ul>
<li>
<p>举例：查询第一页的时候是limit 400000,10 查询到的最后一条id是4000000，那么下一页的查询只需要查询id大于400000的10条数据即可。</p>
</li>
<li>
<p>语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user where id &gt; 4000000  limit 10;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>BETWEEN … AND</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id BETWEEN 4000000 and 4000010</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>分表查询</strong></p>
<p>mysql推荐一张表的存储不要超过500w数据，查询400w不到1秒对于一般的查询来说已经可以了，如果还要更快的话，我建议使用分表存储，分表又分两种情况，水平分表于垂直分表。</p>
</li>
<li>
<p><strong>延迟关联（个人推荐）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table a,(select id from table limit 100000,20) b on a.id=b.id</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="1-SQL优化手段有哪些？">1. <strong>SQL优化手段有哪些？</strong></h4>
<ol>
<li>
<p>**查询语句中不要使用select ***</p>
</li>
<li>
<p><strong>尽量减少子查询，使用关联查询</strong>（left join,right join,inner join）替代</p>
</li>
<li>
<p><strong>减少使用IN或者NOT IN ,使用exists，not exists</strong>或者关联查询语句替代(在确认没有重复数据或者不用剔除重复数据时，union all会更好)</p>
</li>
<li>
<p><strong>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li>
<p><strong>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</strong>，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p>
</li>
</ol>
<h4 id="2-请问如何防止SQL被注入？">2. <strong>请问如何防止SQL被注入？</strong></h4>
<ul>
<li>
<p><strong>什么是SQL注入？</strong></p>
<p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p>
<ul>
<li>
<p>例如：用户登录，攻击者输入：<code>用户名 = liangzone</code>，<code>密码 = ‘ or ‘1’=’1</code>  ，那么拼接后的语句是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ </span><br></pre></td></tr></table></figure>
<p>攻击者就可以<strong>查询出所有的用户表信息</strong>！</p>
</li>
</ul>
</li>
<li>
<p><strong>如何防范SQL注入？</strong></p>
<ul>
<li>Web端：1）有效性检验； 2）限制字符串输入的长度</li>
<li>服务器端：1）不用拼接SQL字符串， 2）使用预编译的PrepareStatement， 3）有效性检验，4）<strong>过滤SQL需要的参数中的特殊字符，比如单引号、双引号</strong>。</li>
</ul>
</li>
</ul>
<h4 id="3-MySQL-如何做到高并发解决方案？">3. <strong>MySQL 如何做到高并发解决方案？</strong></h4>
<ol>
<li><strong>在web服务框架中加入缓存</strong>。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li><strong>增加数据库索引，进而提高查询速度</strong>。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li><strong>主从读写分离分库</strong>，让主服务器负责写，从服务器负责读。</li>
<li><strong>将数据库表进行拆分表</strong>，使得数据库的表尽可能小，提高查询的速度。</li>
<li><strong>使用分布式架构</strong>，分散计算压力。</li>
</ol>
<h4 id="4-大表如何进行优化？">4. 大表如何进行优化？</h4>
<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下。</p>
<ul>
<li>
<p><strong>限定数据的范围</strong>：务必禁⽌不带任何限制数据范围条件的查询语句。⽐如：我们当⽤户在查询订单历史的时候，我们可以控制在⼀个⽉的范围内；</p>
</li>
<li>
<p>**读/写分离：**经典的数据库拆分⽅案，主库负责写，从库负责读；</p>
</li>
<li>
<p>**垂直分区：**根据数据库⾥⾯数据表的相关性进行拆分。</p>
<blockquote>
<p>例如，⽤户表中既有⽤户的登录信息⼜有⽤户的基本信息，可以将⽤户表拆分成两个单独的表，甚⾄放到单独的库做分库。</p>
<ul>
<li>
<p>简单来说垂直拆分是指数据表列的拆分，把⼀张列⽐较多的表拆分为多张表。</p>
<p><img src="https://i.loli.net/2021/05/16/25HtBIuXygCUVrq.png" alt="image-20210516234359675"></p>
</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>水平分区 :</strong> 保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，<strong>达到了分布式的⽬的</strong>。 ⽔平拆分可以支撑⾮常大的数据量。</p>
</li>
</ul>
<p>其它数据库结构方面优化：</p>
<ul>
<li><strong>范式优化</strong>： 比如消除冗余（节省空间。。）</li>
<li><strong>反范式优化</strong>：比如适当加冗余等（减少join）</li>
</ul>
<h4 id="5-数据库如何去重？">5. 数据库如何去重？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002508404">MySQL数据库行去重复和列去重复</a></p>
</blockquote>
<h5 id="5-1-行去重">5.1 行去重</h5>
<blockquote>
<p>存在行重复，则无法建立 <u>唯一索引</u> 等。</p>
</blockquote>
<blockquote>
<p>用<code>distinct</code> 得到我们要保留的数据也是可以的。</p>
</blockquote>
<p>下面假设的是email字段重复。</p>
<ol>
<li>
<p>查看我们的分组后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,count(id) from demo_table group by email having count(id)&gt;1 order by id;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+------+--------------+-----------+</span><br><span class="line">| id | name | email        | count(id) |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">|  1 | u1   | u1@email.com |         4 |</span><br><span class="line">|  2 | u2   | u2@email.com |         4 |</span><br><span class="line">|  3 | u3   | u3@email.com |         3 |</span><br><span class="line">|  4 | u4   | u4@email.com |         2 |</span><br><span class="line">|  5 | u5   | u5@email.com |         2 |</span><br><span class="line">+----+------+--------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>保留每个分组<strong>最小的id</strong>，表中其余都删除</p>
<p>在表中删除不符合要求的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from demo_table where id not in (select min(id) from demo_table group by email);</span><br></pre></td></tr></table></figure>
<p>但是似乎有保护机制，无法直接删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;demo_table&#x27; for update in FROM clause</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建临时表再删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时表保存每个分组中最小的那个id</span><br><span class="line">create table tmp_table as select min(id) from demo_table group by email;</span><br><span class="line"></span><br><span class="line"># 删除表中数据</span><br><span class="line">delete from demo_table where id not in (select * from tmp_table);</span><br><span class="line"></span><br><span class="line"># 删除临时表</span><br><span class="line">drop table tmp_table;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="5-2-列重复">5.2 列重复</h5>
<ol>
<li>
<p>先找到重复字段的<strong>行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from demo_table as a, demo_table as b where a.id=b.id and a.name=b.email;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| id | name         | email        | id | name         | email        |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">| 31 | 31@email.com | 31@email.com | 31 | 31@email.com | 31@email.com |</span><br><span class="line">| 32 | 32@email.com | 32@email.com | 32 | 32@email.com | 32@email.com |</span><br><span class="line">| 33 | 33@email.com | 33@email.com | 33 | 33@email.com | 33@email.com |</span><br><span class="line">| 34 | 34@email.com | 34@email.com | 34 | 34@email.com | 34@email.com |</span><br><span class="line">| 35 | 35@email.com | 35@email.com | 35 | 35@email.com | 35@email.com |</span><br><span class="line">+----+--------------+--------------+----+--------------+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>重复记录的id都已经找出来了，删除就参考上述方式处理了。</p>
</li>
</ol>
<h4 id="6-select慢的原因？慢查询的优化策略？">6. select慢的原因？慢查询的优化策略？</h4>
<h5 id="6-1-select-很慢的原因">6.1 select 很慢的原因</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kubidemanong/p/10734045.html">腾讯面试：一条SQL语句执行得很慢的原因有哪些?</a></p>
</blockquote>
<ul>
<li>
<p><strong>如果是偶尔很慢</strong></p>
<p>针对这种情况，这条SQL语句的书写本身是没什么问题的。可能是其它原因导致：</p>
<ol>
<li><strong>被加锁。</strong> 要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了；或者，表没有加锁，但要使用到的某个一<strong>行</strong>被加锁了 。</li>
<li>数据库在刷新脏页 ？ 看链接，不太明白流程。</li>
</ol>
</li>
<li>
<p><strong>如果是经常很慢</strong></p>
<ol>
<li>
<p><strong>没用到索引</strong></p>
</li>
<li>
<p><strong>索引失效了</strong> ：</p>
<p>（1）联合索引不满足最左匹配（不包含第一个索引）；</p>
<p>（2）like语句不满足最左匹配（不包含第一个索引）</p>
<p>（3）或者索引加上了运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure>
<p>这种情况不会有效，应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure>
<p>（4）或者函数操作用上索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>数据库使用非聚簇索引</strong></p>
<p>我们在进行查询操作的时候，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure>
<p>此时使用的非聚簇索引（辅助索引），只是存储了<strong>主键的key</strong> ，还是要再次通过聚簇索引去查找。效率可能不必全表扫描高。</p>
</li>
</ol>
</li>
</ul>
<h4 id="7-select…for-update用法？">7. select…for update用法？</h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023045909">数据库-MySQL中for update的作用和用法</a></p>
</blockquote>
<p><code>for update</code>是一种<code>行级锁</code>，又叫<code>排它锁</code>。</p>
<p>一旦用户对某个行施加了行级加锁，则<strong>该用户可以查询也可以更新</strong>被加锁的数据行，<strong>其它用户只能查询</strong>但不能更新被加锁的数据行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">begin;</span><br><span class="line">SELECT * FROM user WHERE id=3 FOR UPDATE;</span><br><span class="line">SELECT * FROM user WHERE id=3 and name=&#x27;Tom&#x27; FOR UPDATE;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<h4 id="8-场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？">8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？</h4>
<ol>
<li><strong>设计良好的数据库结构</strong>，允许部分数据冗余，尽量避免join查询，提高效率；</li>
<li>选择合适的表字段数据类型和存储引擎，适当的<strong>添加索引</strong>；</li>
<li>MySQL库主从<strong>分库读写分离</strong>；</li>
<li>找规律<strong>分表</strong>，减少单表中的数据量提高查询速度；</li>
<li><strong>添加缓存机制</strong>，比如Memcached，Apc等；</li>
<li><strong>书写高效率的SQL</strong>。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li>
</ol>
<h1>六、Redis</h1>
<h2 id="6-1-Redis基本">6.1 Redis基本</h2>
<h4 id="1-什么是-Redis？">1. <strong>什么是</strong> <strong>Redis？</strong></h4>
<p>（🚩*1）Redis 是一个开源（BSD 许可）、基于<u>内存（读写快）</u>、支持多种数据结构的存储系统，可以作为<u>数据库、缓存和消息中间件</u>。</p>
<ul>
<li>支持的数据结构有<strong>5</strong>种：字符串（String）、哈希（hash）、列表（list）、集合（set）、有序集合（sorted set）。</li>
</ul>
<h5 id="1-1-有MySQL不就够用了吗？为什么要用Redis这种新的数据库？">1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</h5>
<p>主要是因为 Redis <strong>具备高性能和高并发</strong>两种特性。</p>
<ul>
<li><strong>高性能</strong>：除了第一次读取硬盘比较慢，后面加载到缓存，读取速度都相关快，性能高；</li>
<li><strong>高并发</strong>：直接<strong>操作缓存能够承受的并发请求是远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的<strong>部分热点数据</strong>转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li>
</ul>
<h5 id="1-2-C-JAVA-中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？">1.2 C++ / JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</h5>
<p>缓存分为本地缓存和分布式缓存 。</p>
<ul>
<li><strong>本地缓存不具一致性。<strong>以Java为例 ，使用自带的map或者guava实现的是本地缓存，最主要的特点是</strong>轻量以及快速</strong>，生命周期<strong>随着jvm的销毁而结束</strong>，并且在多实例的情况下，<strong>每个实例都需要各自保存一份缓存</strong>，缓存不具有一致性；</li>
<li><strong>Redis分布式缓存具有一致性。</strong> 使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性；</li>
<li><strong>Redis可以使用更大内存作为缓存。</strong> Redis可以使用几十G内存作为缓存，Map不行，比如JVM最多使用几个G ；</li>
<li><strong>Redis可以持久化。</strong> Redis可以实现持久化，而Map是内存对象，程序重启就没了；</li>
<li><strong>Redis可以处理百万级别并发；</strong></li>
<li><strong>Redis有丰富的API &amp; 缓存过期等机制。</strong></li>
</ul>
<h4 id="2-【重点】-redis的数据类型，以及每种数据类型的使用场景？">2. 【<strong>重点</strong>】**redis的数据类型，以及每种数据类型的使用场景？ **</h4>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">存储key-value键值对，注意redis中String可修改。统计在线人数；也可以存储<strong>视频、图片</strong>等</td>
</tr>
<tr>
<td style="text-align:center">hash（🚩*1）</td>
<td style="text-align:center">购物车：<code>hset [key] [field] [value]</code> 命令， 存放键值对，一般可以用来存某个对象的基本属性信息，例如，用户信息，商品信息等</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center">全局去重，JVM自带的set不适合分布式集群情况</td>
</tr>
<tr>
<td style="text-align:center">zset</td>
<td style="text-align:center">排行榜，比如微信运动排行榜</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">分页功能，lrange做基于redis的分页功能，性能很好；模仿一个消息队列</td>
</tr>
</tbody>
</table>
<h4 id="3-说一下-Redis-有什么优点和缺点-？">3. <strong>说一下</strong> <strong>Redis</strong> <strong>有什么优点和缺点</strong> ？</h4>
<table>
<thead>
<tr>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>速度快</strong>：因为在内存中</td>
<td style="text-align:center"><strong>存储有限</strong>：因为Redis是内存数据库，大小和机器本身内存有关</td>
</tr>
<tr>
<td style="text-align:center"><strong>支持多种数据结构：</strong> String，List，Set，Hash，Sorted Set等</td>
<td style="text-align:center">完成重同步耗费CPU资源和带宽</td>
</tr>
<tr>
<td style="text-align:center"><strong>持久化存储</strong>：RDB和AOF</td>
<td style="text-align:center"><strong>当Redis重启后</strong>通过把硬盘文件重新加载到内存，速度比较慢，这个时候redis做不了其它事。</td>
</tr>
<tr>
<td style="text-align:center"><strong>高可用</strong>：内置 <u>Redis Sentinel</u> （哨兵），实现主从故障自动转移。 内置 <u>Redis Cluster</u> ，提供集群方案。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>丰富特性</strong>：Key过期、计数、分布式锁</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="4-Redis的数据结构？key是怎么存储的？">4. Redis的数据结构？key是怎么存储的？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6862291064624152583">【大课堂】Redis底层数据存储原理</a></p>
</blockquote>
<ul>
<li>
<p><strong>概述</strong></p>
<p>Redis底层采用 <strong>数组</strong>， key就是对应数组的<strong>索引</strong> ，采用Hash(key)映射到数组上。解决冲突采用<strong>链地址法</strong>。</p>
<p>具体可看参考下文。</p>
</li>
<li>
<p><strong>底层存储原理</strong></p>
<p>redis 中以<code>redisDb</code>作为整个缓存存储的核心，保存着我们<strong>客户端需要的缓存</strong>数据。</p>
<p>其结构如下：</p>
<p><img src="https://i.loli.net/2021/05/26/tbGEW3eV986aRkj.png" alt="RedisDB主体数据结构"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>    </span><br><span class="line">       dict *dict;           <span class="comment">// 最重要--字典类型，保存数据库的键值对</span></span><br><span class="line">       dict *expires;        <span class="comment">// 重要--字典类型，保存过期的时间          </span></span><br><span class="line">       dict *blocking_keys;  <span class="comment">// 和ready_key 实现BLPOP等阻塞命令         </span></span><br><span class="line">       dict *ready_keys;     <span class="comment">// 同上      </span></span><br><span class="line">       dict *watched_keys;   <span class="comment">// 实现watch命令，记录正在被watch的key         </span></span><br><span class="line">       <span class="keyword">int</span> id;    <span class="comment">// 数据库id，默认16个，支持单个                      </span></span><br><span class="line">       <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;    <span class="comment">/* Average TTL, just for stats */</span>      </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>现在我们来查看，<strong>dict</strong> 的结构。</p>
<ul>
<li>
<p><strong>dict的结构</strong></p>
<p><img src="https://i.loli.net/2021/05/26/kV1JhcrUwFHLznG.png" alt="image-20210526111544663"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  字典 : 每个字典使用两个哈希表，用于实现渐进式 rehash */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>    </span><br><span class="line">       <span class="comment">// type存储了hash函数，key和value的复制函数等，比较以及销毁函数</span></span><br><span class="line">      dictType *type;   </span><br><span class="line">      <span class="comment">// privdata保存一些私有数据，决定了*type保存的函数，实现了【多态】</span></span><br><span class="line">      <span class="keyword">void</span> *privdata;     </span><br><span class="line">      dictht ht[<span class="number">2</span>];      <span class="comment">// 哈希表（2 个）,  正常使用ht[0],rehash就会扩容使用ht[1]</span></span><br><span class="line">      <span class="keyword">int</span> rehashidx;     <span class="comment">// 记录 rehash 进度的标志，值为 -1 表示 rehash 未进</span></span><br><span class="line">      <span class="keyword">int</span> iterators;    <span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">&#125; dict;  </span><br></pre></td></tr></table></figure>
<p>上述<code>dictht</code>就是个hash表，包含：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>    </span><br><span class="line">   <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）    </span></span><br><span class="line">   dictEntry **table;    </span><br><span class="line">   <span class="comment">// 指针数组的大小   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    </span><br><span class="line">   <span class="comment">// 指针数组的长度掩码，用于计算索引值，其实永远都是size-1    </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;   </span><br><span class="line">   <span class="comment">// 哈希表现有的节点数量   </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>**dictEntry 指针数组（table）。**key 的哈希值最终映射到这个数组的某个位置上（对应一个 bucket）。如果多个 key 映射到同一个位置，就发生了冲突，那么就拉出一个 dictEntry 链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点dictEntry</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>     </span><br><span class="line">    <span class="keyword">void</span> *key;    <span class="comment">// redis的键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>        </span><br><span class="line">    <span class="keyword">void</span> *val;    <span class="comment">// 存储了对应string/set/list/hash/zset的数据     </span></span><br><span class="line">    <span class="keyword">uint64_t</span> u64;        </span><br><span class="line">    <span class="keyword">int64_t</span> s64; </span><br><span class="line">    &#125; v;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表后续节点</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em><strong>size</strong></em>：标识 dictEntry 指针数组的长度。它总是 2 的指数次幂。</p>
</li>
</ul>
<p>上面<code>dictEntry</code> 的<strong>value</strong> 最终指向了<code>redisObject</code>对象，我们来观察下其结构。</p>
</li>
<li>
<p><strong>Redis Object</strong></p>
<p><img src="https://i.loli.net/2021/05/26/kvhZQdtOuJjE6gY.png" alt="image-20210526112251563"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    </span><br><span class="line">     <span class="keyword">unsigned</span> type:<span class="number">4</span>;     <span class="comment">// 类型 ，比如string，set等，才能确定是哪种数据结构使用什么API操作   </span></span><br><span class="line">     <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// encoding 表示 ptr 指向的具体数据结构,这个对象使用什么数据结构实现   </span></span><br><span class="line">     <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">// 对象最后一次被访问的时</span></span><br><span class="line">     <span class="keyword">int</span> refcount;    <span class="comment">// 引用计数         </span></span><br><span class="line">     <span class="keyword">void</span> *ptr;  <span class="comment">// 指向底层数据结构的指针 </span></span><br><span class="line"> robj;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-String、list、hash、set、zset的底层结构是什么？">4.1 String、list、hash、set、zset的底层结构是什么？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://i6448038.github.io/2019/12/01/redis-data-struct/">图解redis五种数据结构底层实现(动图哦)</a></p>
<p>版本：redis 3.0.6中版本各种数据结构的实现</p>
</blockquote>
<ol>
<li>
<p><strong>String</strong></p>
<ul>
<li>embstr和raw都是由SDS动态字符串构成的 ，底层结构应该都是<strong>char数组</strong>吧 ；</li>
<li>int ，就是指<strong>int类型</strong>。</li>
</ul>
<p><img src="https://i.loli.net/2021/05/26/h4mzJvU9I5BEj1o.png" alt="img"></p>
</li>
<li>
<p><strong>list</strong></p>
<p><img src="https://i.loli.net/2021/05/26/QSgDl39yIA5uXN2.png" alt="img"></p>
</li>
<li>
<p><strong>hash</strong></p>
<p><img src="https://i.loli.net/2021/05/26/9X8gPmG6MeDb4V3.png" alt="img"></p>
</li>
<li>
<p><strong>set</strong></p>
<p>intset是集合键的底层实现方式之一，是int类型数组。</p>
<p><img src="https://i.loli.net/2021/05/26/KXD9yHLewkIFGha.png" alt="img"></p>
<img src="https://i.loli.net/2021/05/26/rn3BfhLOT8dsRCH.png" alt="img" style="zoom:67%;" />
</li>
<li>
<p><strong>zest</strong></p>
<p><img src="https://i6448038.github.io/img/redis-data-struct/object_zset.png" alt="img"></p>
</li>
</ol>
<h5 id="4-2-讲讲redis的hash表扩容方式？">4.2 讲讲redis的hash表扩容方式？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://luoming1224.github.io/2018/11/12/%5Bredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Dredis%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%9C%BA%E5%88%B6/">[redis学习笔记]redis渐进式rehash机制</a></p>
</blockquote>
<ul>
<li>
<p><strong>扩容条件</strong></p>
<ul>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 （<strong>保存的key超过哈希表大小</strong>）；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li>
</ul>
</li>
<li>
<p><strong>渐进式rehash</strong></p>
<ol>
<li>
<p>新建一个哈希表大小，为<code>2^N</code> 次方，并分配内存，此时字典<strong>同时持有：ht[0] 和 ht[1] 两个哈希表</strong></p>
<blockquote>
<p>同hashmap：哈希表掩码sizemask为size-1，当size满足2的n次方时，计算每个key的索引值时只需要用key的hash值与掩码sizemask进行位与操作，替代求余操作，计算更快。</p>
</blockquote>
</li>
<li>
<p>哈希表赋值给字典的ht[1]，然后将rehashidx赋值为0，表示rehash工作开始</p>
<blockquote>
<p>rehashidx也标识了，当前rehash<strong>进行到了哪个槽</strong></p>
</blockquote>
</li>
<li>
<p>在 rehash 进行期间，：每次对字典执行<strong>添加、删除、查找或者更新操作</strong>时， 程序除了执行指定的操作以外， 还会顺带将 <strong>ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]</strong> 。</p>
<p>当 rehash 工作完成之后， 程序将 rehashidx 属性的值**+1**</p>
</li>
<li>
<p>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] 。此时<code>rehashidx=-1</code>，表示rehash完成。</p>
</li>
</ol>
<p>采取分而治之的方式， 将 rehash 键值对所需的计算工作<strong>均摊</strong>到对字典的每个添加、删除、查找和更新操作上， 从而<strong>避免了集中式 rehash 而带来的庞大计算量</strong>。</p>
</li>
<li>
<p><strong>渐进式rehas优缺点</strong></p>
<ul>
<li>优点：避免redis阻塞</li>
<li>缺点：rehash需要分配一个新的hash表，会使得<strong>内存爆增，使得大量key被驱逐</strong></li>
</ul>
</li>
</ul>
<h5 id="4-3-rehash过程中增删查改怎么操作呢？">4.3 rehash过程中增删查改怎么操作呢？</h5>
<ul>
<li>
<p><strong>增加：</strong> 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作</p>
</li>
<li>
<p><strong>删除（delete）、查找（find）、更新（update）等</strong>： 同时在ht[0] &amp; ht[1]两个表进行。</p>
<blockquote>
<p>比如：要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找。</p>
</blockquote>
</li>
</ul>
<h4 id="5-说说Redis有序集合zset的底层结构？">5. 说说Redis有序集合zset的底层结构？</h4>
<p>zset底层的存储结构包括<u>ziplist</u>或<u> skiplist &amp; dic</u> ，<strong>当满足以下两个条件的时候使用ziplist</strong>：</p>
<ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素的长度小于64字节</li>
</ul>
<p>其余情况用skiplist。</p>
<ul>
<li>
<p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/exceptioneye/p/7040815.html">什么是ziplist？</a></strong></p>
<p>ziplist是一个经过特殊编码的<u>双向链表</u>，以O(1)的时间复杂度在表的两端提供push和pop操作。</p>
<p>ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。</p>
<ul>
<li>
<p><strong>使用原因：<strong>一个普通的<u>双向链表</u>，链表中每一项都<u>占用独立的一块内存</u>，各项之间用地址指针（或引用）连接起来；这种方式会带来大量的</strong>内存碎片</strong>，而且<strong>地址指针也会占用额外的内存</strong>。</p>
</li>
<li>
<p><strong>具体结构</strong></p>
<p><img src="https://i.loli.net/2021/05/04/zYwG2PtCZq84hgV.jpg" alt="img"></p>
<ul>
<li>entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037473381"><strong>什么是skiplist ?</strong></a></p>
<p>跳表是在单链表上实现多级索引，<strong>可以实现 <u>二分查找</u> 的有序链表</strong>。</p>
<blockquote>
<p>跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)。</p>
</blockquote>
<ul>
<li>
<p>主要形式</p>
<p>在单链表上进行多级索引。</p>
<p><img src="https://i.loli.net/2021/05/28/Rc6tAuOmELHz5nN.png" alt="image-20210528143426041"></p>
</li>
<li>
<p>构建过程</p>
<blockquote>
<p>上面链表是如何构建的呢，请见下图。</p>
</blockquote>
<p>⚠️ skiplist为了避免上下两层出现<strong>严格1:2</strong>数量对应关系后，新插入节点会打乱这种关系，而需要<strong>把新插入节点后所以节点都进行调整</strong>。</p>
<p><strong>它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)</strong>。</p>
<img src="https://i.loli.net/2021/05/28/sEy7B6gUHuIfbd3.png" alt="preview" style="zoom: 67%;" />
</li>
<li>
<p>查找过程</p>
<blockquote>
<p>zset : <code>&lt;key&gt; &lt;score&gt; &lt;member&gt;</code></p>
</blockquote>
<p>在上图中，我们没有区分member和score，但是实际上链表是<strong>按score进行排序，查找也是在比较score</strong>。</p>
<blockquote>
<p>以查找 和 插入23为例。</p>
</blockquote>
<ol>
<li>从最高层（第4）层开始查找，因为<code>7&lt;23</code> ,本应该继续往后查找，但是后继节点为null，所以往下一层进行查找</li>
<li>此时第3层，满足<code>7&lt;23&lt;37</code> ，继续往下一层继续查找</li>
<li>此时第2层，<code>7&lt;23 &amp; 19&lt;23</code> ，往下第二层的下一个节点（19）查找；此时满足<code>19&lt;23&lt;37</code> ，继续往下一层</li>
<li>此时第1层，一直往后遍历到22，发现<code>22&lt;23&lt;26</code> ：
<ul>
<li>如果此时是<strong>查询23</strong>：返回null，不存在</li>
<li>此时是<strong>插入23</strong>：生成新节点 &amp; 随机生成层数，（1）将新节点各层指针指向对应层的<strong>下一个节点</strong>（不存在则指向null）（2）将新节点节点各层<strong>前一个节点</strong>对应层数的指针指向新节点</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="5-1-Redis为什么不用红黑树">5.1 Redis为什么不用红黑树</h5>
<blockquote>
<p>参考 ： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20202931">知乎回答</a></p>
</blockquote>
<p>虽然跳表操作<strong>时间复杂度和红黑树相同</strong> ，但是：</p>
<ol>
<li>
<p>**实现简单：**跳表代码实现更易读</p>
</li>
<li>
<p>**区间查找：**跳表区间查找效率更高</p>
</li>
</ol>
<h4 id="6-Redis-持久化方式有哪些？以及有什么区别？">6. <strong>Redis</strong> <strong>持久化方式有哪些？以及有什么区别？</strong></h4>
<p><code>Redis</code> 提供两种持久化机制 <code>RDB</code> 和 <code>AOF</code> 机制。</p>
<ul>
<li>
<p><strong>各自优点</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">RDB</th>
<th style="text-align:center">AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">【<strong>方便</strong>】只有一个文件 <code>dump.rdb</code> ，方便持久化</td>
<td style="text-align:center">【<strong>数据安全</strong>】 AOF 持久化有 <code>always</code>，每进行一次命令操作就记录到 AOF 文件中一次。</td>
</tr>
<tr>
<td style="text-align:center">【<strong>容灾性好</strong>】一个文件可以保存到安全的磁盘</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">【<strong>性能</strong>】最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">【<strong>启动效率高</strong>】相对于数据集大时，比 AOF 的<strong>启动效率</strong>更高</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>各自缺点</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">RDB</th>
<th style="text-align:center">AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">【<strong>安全性低</strong>】 <code>RDB</code> 是间隔一段时间进行持久化</td>
<td style="text-align:center">【<strong>启动效率低</strong>】数据集大的时候，比 RDB 启动效率低。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">【<strong>恢复慢</strong>】<code>AOF</code> 文件比 <code>RDB</code> 文件大，且恢复速度慢。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h5 id="6-1-AOF-重写了解吗？">6.1 AOF 重写了解吗？</h5>
<p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，<strong>但体积更小</strong>。</p>
<blockquote>
<p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的<strong>键值</strong>对来实现的，程序<strong>无须对现有AOF文件进行</strong>任伺读入、分析或者写入操作。</p>
</blockquote>
<p>具体过程如下：</p>
<ol>
<li>在执行 <code>BGREWRITEAOF</code> 命令，开始重写；</li>
<li>Redis 服务器会维护一个 AOF <strong>重写缓冲区</strong>，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令；</li>
<li>当子进程完成创建新AOF文件的工作之后，服务器会将重写<strong>缓冲区中的所有内容追加到新AOF文件的末尾</strong> ；</li>
<li>最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。</li>
</ol>
<h4 id="7-Redis持久化有两种，那应该怎么选择呢？">7. Redis持久化有两种，那应该怎么选择呢？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39412293">https://zhuanlan.zhihu.com/p/39412293</a></p>
</blockquote>
<ol>
<li><strong>如果Redis中的数据完全丢弃也没有关系</strong>（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化；</li>
<li><strong>单机环境：</strong> 如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF；</li>
<li><strong>主从架构：</strong>
<ul>
<li>**master：**完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好；</li>
<li><strong>slave</strong>：<strong>关闭RDB，开启AOF</strong>（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调bgrewriteaof。</li>
</ul>
</li>
</ol>
<h4 id="8-（-u-不太理解-u-）pipeline-有什么好处，为什么要用-pipeline？">8. （<u>不太理解</u>）<strong>pipeline</strong> <strong>有什么好处，为什么要用</strong> <strong>pipeline？</strong></h4>
<ul>
<li>
<p>使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系；</p>
</li>
<li>
<p>用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。</p>
</li>
</ul>
<h4 id="9-怎么使用-Redis-实现消息队列？-如何实现延时队列？">9. <strong>怎么使用</strong> <strong>Redis</strong> <strong>实现消息队列？ 如何实现延时队列？</strong></h4>
<ul>
<li>
<p>**消息队列：**一般使用 <code>list</code> 结构作为队列， <code>rpush</code> 生产消息， <code>lpop</code> 消费消息。当 <code>lpop</code> 没有消息的时候，要适当<code>sleep</code> 一会再重试；</p>
</li>
<li>
<p><strong>延时队列：</strong> ：使用<code>sortedset</code> ，拿<u>时间戳</u>作为 <code>score</code> ，消息内容作为 <code>key</code> 调用 <code>zadd</code> 来生产消息，消费者用<code>zrangebyscore</code> 指令获取符合条件的数据轮询进行处理。</p>
<blockquote>
<p>什么是延时队列？</p>
<p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理：</p>
<ul>
<li>如果需要就放入到延时队列中，由延时任务检测器进行检测和处理；</li>
<li>如果不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</li>
</ul>
<p>【举个例子】</p>
<ul>
<li>点外卖时，下单后不会立即安排配送，而是等待一段时间让商户接单才正式安排配送，否则超时取消</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6-2-Redis单线程模型">6.2 Redis单线程模型</h2>
<h4 id="1-（🚩-1）为什么-Redis-使用单线程模型？单线程模型效率也能那么高？">1. （🚩*1）<strong>为什么</strong> <strong>Redis 使用单线程模型？单线程模型效率也能那么高？</strong></h4>
<ol>
<li>
<p>采用单线程，避免了不要的上下文切换和竞争条件；</p>
</li>
<li>
<p><strong>其次 CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p>
</li>
</ol>
<p>【<strong>效率高的原因</strong>】</p>
<p>. 1. <strong>C语言</strong>实现，效率高</p>
<ol start="2">
<li>
<p>纯<strong>内存</strong>操作</p>
</li>
<li>
<p><strong>基于非阻塞的IO复用模型机制</strong>（可能会跟自己挖坑）</p>
</li>
<li>
<p>单线程的话就能避免多线程的频繁上下文切换问题（为什么单线程效率高）</p>
</li>
<li>
<p>丰富的数据结构（<u>全程采用hash结构，读取速度非常快</u>，对数据存储进行了一些优化，<u>比如zset压缩表，跳表等</u>）</p>
</li>
</ol>
<h4 id="2-（新，易忘）说说-Redis-的单线程模型-？">2. <strong>（新，易忘）说说 Redis 的单线程模型</strong> ？</h4>
<blockquote>
<p>这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑了。</p>
</blockquote>
<p>redis 内部使⽤⽂件事件处理器 file event handler ，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制一个线程同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。<br>
⽂件事件处理器的结构包含 4 个部分：</p>
<ol>
<li>多个 socket</li>
<li>IO 多路复⽤程序</li>
<li>⽂件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ol>
<p>（1） IO 多路复⽤程序会监听多个 socket，（2）会将 socket 产⽣的事件<strong>放⼊队列中排</strong>队，（3）事件分派器每次从队列中取出⼀个事件，（4）把该事件交给对应的事件处理器进⾏处理。</p>
<h4 id="3-你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？">3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？</h4>
<ul>
<li>
<p>Redis采用了<strong>IO多路复用机制</strong>，使其在网络IO操作中能并发处理大量的客户端请求。</p>
<blockquote>
<p>详见上一个问题。</p>
</blockquote>
</li>
<li>
<p>Redis可以采用<strong>主从架构</strong>，master负责写，slave负责读。</p>
</li>
</ul>
<h4 id="4-说说你对Redis事务的理解-？">4. <strong>说说你对Redis事务的理解</strong> ？</h4>
<p>Redis 中的事务是<strong>一组命令的集合</strong>，是 Redis 的最小执行单位。</p>
<blockquote>
<p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
</blockquote>
<ul>
<li>
<p><strong>需要注意的地方</strong></p>
<ol>
<li>
<p>**Redis 事务不支持回滚：**不像 MySQL 的事务一样，要么都执行要么都不执行；</p>
<blockquote>
<p>因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</p>
</blockquote>
</li>
<li>
<p>（🚩*1）Redis 服务端在执行事务的过程中，<u><strong>不会被其他客户端发送来的命令请求打断</strong></u>，直到事务命令全部执行完毕才会执行其他客户端的命令。</p>
</li>
</ol>
</li>
</ul>
<h4 id="5-为什么Redis的操作是原子性的，怎么保证原子性的？">5. <strong>为什么Redis的操作是原子性的，怎么保证原子性的？</strong></h4>
<ul>
<li><strong>原子性。</strong> 因为Redis是单线程的， Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</li>
<li><strong>事务性。</strong> Redis中的事务其实是要保证<u>批量操作</u>的原子性。</li>
</ul>
<h2 id="6-3-Redis缓存">6.3 Redis缓存</h2>
<h4 id="1-为什么要用缓存-？怎么提高缓存命中率？">1. <strong>为什么要用缓存</strong> ？<strong>怎么提高缓存命中率？</strong></h4>
<ul>
<li>
<p><strong>为什么用缓存？</strong></p>
<p>把热点数据存入内存中，提高读写性能。</p>
</li>
<li>
<p><strong>提高命中率？</strong></p>
<ol>
<li>增加缓存空间</li>
<li>（🚩*1）提升缓存更新频率</li>
<li>提前加载数据到缓存中</li>
</ol>
</li>
</ul>
<h4 id="2-缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？">2. <strong>缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904173725548557">https://juejin.cn/post/6844904173725548557</a></p>
</blockquote>
<ul>
<li>
<p><strong>缓存雪崩</strong></p>
<blockquote>
<p>简而言之：<strong>Redis 挂掉了</strong>，请求全部走数据库 。</p>
</blockquote>
<ul>
<li>
<p><strong>例如：</strong> 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库；</p>
<ul>
<li><strong>key过期解决：</strong> 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</li>
</ul>
<p>更通用情况的做法：</p>
<ul>
<li><strong>事发前：<strong>实现 Redis 的</strong>高可用 (主从架构 + Redis Cluster)</strong>，尽量避免 Redis 挂掉这种情况发生；</li>
<li><strong>事发中：<strong>万一 Redis 真的挂了，我们可以设置</strong>本地缓存 (ehcache)+ 限流 (hystrix)</strong>，尽量避免我们的数据库被干掉；</li>
<li><strong>事发后：<strong>redis <strong>持久化</strong>，重启后</strong>自动</strong>从磁盘上加载数据，<strong>快速恢复缓存数据</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>缓存穿透</strong></p>
<blockquote>
<p>查询一个一定<strong>不存在的数据</strong> ，导致<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义 。</p>
</blockquote>
<ul>
<li><strong>解决1：</strong> 使用布隆过滤器 (BloomFilter)  <strong>提前拦截</strong>，不合法就不让这个请求到数据库层；</li>
<li><strong>解决2：<strong>当我们从数据库找不到的时候，我们也将这个</strong>空对象设置到缓存里边去</strong>，下次再请求的时候，就可以从缓存里边获取了。</li>
</ul>
</li>
<li>
<p><strong>缓存击穿</strong></p>
<p>在平常高并发的系统中，大量的请求同时查询一个key时，此时这个<strong>高热key</strong>正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。</p>
<ul>
<li>
<p><strong>解决1：使用互斥锁(mutex key) 。</strong> 是只让一个线程构建缓存，<strong>其他线程等待构建缓存</strong>的线程执行完，重新从缓存获取数据就行。</p>
<blockquote>
<p>如果是单机，可以用synchronized或者lock来处理，如果是**【淘特】分布式环境可以用分布式锁**就可以了。</p>
<p><img src="https://i.loli.net/2021/05/06/4oRvz638eOiEFTf.png" alt="image-20210506115517283"></p>
</blockquote>
</li>
<li>
<p><strong>解决2：</strong> <strong>key永不过期。</strong> 把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建。</p>
<p><img src="https://i.loli.net/2021/05/06/jZ9v47kthTmADqg.png" alt="image-20210506115748032"></p>
</li>
</ul>
</li>
<li>
<p><strong>缓存预热</strong></p>
<blockquote>
<p>系统上线后，将相关的缓存数据直接加载到缓存系统。</p>
</blockquote>
<p>这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p>
</li>
<li>
<p><strong>缓存更新</strong></p>
<ul>
<li><code>LRU</code>(访问时间最旧淘汰)/<code>LFU</code>(把频次低的淘汰掉)</li>
<li>超时剔除：设置key过期时间</li>
<li>主动更新：开发设置生命周期</li>
</ul>
</li>
<li>
<p><strong>缓存降级</strong></p>
<p>降级的情况，<u>就是<strong>缓存失效或者缓存服务挂掉</strong>的情况下，我们也不去访问数据库</u>。我们<strong>直接访问内存部分数据缓存</strong>或者直接返回默认数据。</p>
<blockquote>
<p>对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对<strong>热点商品数据</strong>也存储到了<strong>内存</strong>中。同时内存中还保留了一些默认的商品信息。</p>
<p>如下图所示：</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/06/a1XZHWCterV3uR2.png" alt="image-20210506115200276"></p>
</li>
</ul>
<h4 id="3-Redis-设置key过期后如何处理？Redis-缓存刷新策略（内存淘汰机制）有哪些？">3. Redis 设置key过期后如何处理？<strong>Redis</strong> <strong>缓存刷新策略（内存淘汰机制）有哪些？</strong></h4>
<ul>
<li>
<p><strong>Redis 设置过期时间</strong></p>
<p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置⼀个过期时间。</p>
<ul>
<li>如我们⼀般项⽬中的 <strong>token</strong> 或者⼀些登录信息，尤其是短信验证码都是有时间限制的，过期后基本不会使用</li>
</ul>
</li>
<li>
<p><strong>过期后采用什么策略进行删除？</strong></p>
<ul>
<li><strong>定期删除：<strong>redis默认是</strong>每隔 100ms</strong> 就<strong>随机抽取</strong>⼀些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这⾥是随机抽取的。**为什么要随机呢？**你想⼀想假如 redis 存了⼏⼗万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
</ul>
</li>
<li>
<p><strong>惰性删除 ：</strong><u><strong>定期删除可能会导致很多过期 key 到了时间并没有被删除掉</strong></u>，所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存⾥，除⾮你的系统去查⼀下那个 key，才会被redis给删除掉。</p>
<ul>
<li><strong>内存淘汰策略</strong> ：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没⾛惰性删除，此时会怎么样？如果大量过期key堆积在内存⾥，导致redis内存块耗尽了。所以有内存淘汰策略。</li>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据中挑选最近最少使⽤的数据淘汰
<ul>
<li>
<p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选<strong>将要过期的数据</strong>淘汰</p>
</li>
<li>
<p><strong>volatile-random</strong>：从已设置过期时间的数据中任意选择数据淘汰</p>
</li>
<li>
<p><strong>allkeys-lru</strong>：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的key（这个是最常⽤的）</p>
</li>
<li>
<p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</p>
</li>
<li>
<p><strong>no-eviction</strong>：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-Redis-报内存不足怎么处理？">4. <strong>Redis</strong> <strong>报内存不足怎么处理？</strong></h4>
<ul>
<li>增加 Redis 可用内存：
<ol>
<li>修改件 <code>redis.conf</code> 的 <code>maxmemory</code> 参数；</li>
<li>使用分布式集群，提高存储量；</li>
</ol>
</li>
<li><strong>设置缓存淘汰策略</strong>：提高内存的使用效率；</li>
</ul>
<h4 id="5-【重点】缓存和数据库谁先更新呢？-（保持缓存和数据库一致性）">5. 【<strong>重点</strong>】<strong>缓存和数据库谁先更新呢？</strong>  <strong>（保持缓存和数据库一致性）</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://learnku.com/articles/22363">https://learnku.com/articles/22363</a></p>
</blockquote>
<ul>
<li>
<p><strong>对于读（查询）操作</strong></p>
<p>一般我们对<strong>读操作</strong>的时候有这么一个固定的套路：</p>
<ol>
<li>如果我们的数据在缓存里边有，那么就直接取缓存的；</li>
<li>如果缓存里没有我们想要的数据，我们会先去查询数据库，<u>然后将数据库查出来的数据写到缓存中</u>；</li>
<li>最后将数据返回给请求。</li>
</ol>
<p><strong>不用更新（写）数据库，只用更新（写）缓存</strong>。</p>
</li>
<li>
<p><strong>对于写操作导致双写问题</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/712285">如何保证缓存(redis)与数据库(MySQL)的一致性</a></p>
</blockquote>
<p>写操作会更新数据库，那么缓存也要进行更新，此时会发生数据库和缓存不一致的问题。</p>
<blockquote>
<p>**键的过期时间：**能保证缓存和数据库的数据最终是一致的。</p>
<p><u>因为只要缓存数据过期了，就会被删除</u>。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据<strong>重新写入到缓存</strong>中。<br>
除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。</p>
</blockquote>
<p>直接看结论：</p>
<blockquote>
<p>不考虑更新缓存而是<strong>直接删除缓存</strong>，因为更新逻辑较为复杂涉及到其它数据，更新cache消耗会比较大。</p>
</blockquote>
<ul>
<li><strong>先删除缓存，再更新数据库</strong>
<ul>
<li>在高并发下可能<strong>会导致数据长时间不一致</strong></li>
<li>采用<u>异步更新缓存</u>的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好**——保证了数据的一致性，适用于对一致性要求高的业务**</li>
</ul>
</li>
<li><strong>先更新数据库，再删除缓存</strong> (<strong>Cache Aside Pattern 设计模式</strong>)
<ul>
<li>在高并发下不会导致数据长时间不一致</li>
<li>在<strong>更新数据库期间，cache中的旧数据会被读取</strong>，可能会有一段时间的数据不一致，但读的效率很好。<strong>——保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>先删除缓存，再更新数据库</strong></p>
<blockquote>
<p>⚠️ <strong>只有读才会更新缓存！！</strong></p>
</blockquote>
<ul>
<li>
<p><u>正常情况</u></p>
<ol>
<li>A线程进行写操作，先淘汰缓存，再更新数据库</li>
<li>B线程进行读操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li>
</ol>
</li>
<li>
<p><u>高并发异常</u></p>
<ol>
<li>A线程进行<strong>写</strong>操作，先淘汰缓存，但由于<u>网络原因等未及时更新数据库</u></li>
<li>B线程<strong>读</strong>取缓存失败，去<u>读取数据库的是旧值</u> ，并将<u>旧数据放入缓存</u></li>
<li>A线程再更新数据库成功（<strong>同步情况下写操作不更新redis而读操作更新redis</strong>），<u>此时缓存（旧）和数据库（新）不一致</u></li>
</ol>
<p>而且没有设置键过期，会保持很长时间的数据不一致。</p>
</li>
<li>
<p>（🚩*1）<u>解决方案</u></p>
<ul>
<li><strong>异步更新缓存</strong> ：B线程读操作不更新缓存，而是由<u>A线程写操作更新数据库成功后，通过binlog异步更新缓存</u></li>
<li><strong>延时双删：</strong> A线程<u>休眠M秒（确保事务都已提交）</u>，再更新数据库成功后，<strong>再次删除缓存</strong>。其它线程进行<strong>读</strong>操作时，缓存中无数据，从数据库中读取的是更新后的新数据，<u>又再次一致了</u>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>先更新数据库，再删除缓存</strong></p>
<ul>
<li>
<p><u>正常情况</u></p>
<ol>
<li>A线程进行<strong>写</strong>操作，先更新数据库，再删除缓存</li>
<li>B线程进行<strong>读</strong>操作，发现缓存中没有想要的数据，从数据库中读取更新后的新数据 ，并更新缓存</li>
</ol>
</li>
<li>
<p><u>高并发异常</u></p>
<ol>
<li>
<p>A线程进行<strong>写</strong>操作，先更新数据库，<u>但未来得及删除缓存</u></p>
</li>
<li>
<p>B线程进行<strong>读</strong>操作，<u><strong>读取缓存的旧数据</strong>（背错一次），此时数据不一致</u></p>
</li>
<li>
<p>A线程再删缓存</p>
</li>
</ol>
<p>但其它线程进行读数据的时候更新缓存，更新缓存又一致了，<u>不一致的时间很短。</u></p>
<p>（🚩*1）但是还可能会考虑：<strong>3. A线程删除缓存失败</strong> ，此后读取的一直都是旧数据了。</p>
</li>
<li>
<p><u>解决方案</u></p>
<ul>
<li><strong>消息队列进行删除补偿</strong>。如果Redis删除发现报错，将Redis的key作为消息发送到消息队列中，系统收到消息队列再次对Redis进行删除操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-4-集群相关">6.4 集群相关</h2>
<h4 id="1-Redis-的同步机制了解是什么？">1. <strong>Redis</strong> <strong>的同步机制了解是什么？</strong></h4>
<p>Redis主从复制可以根据是否是全量分为：<u>全量同步</u>和<u>增量同步</u>。</p>
<blockquote>
<p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。</p>
</blockquote>
<ul>
<li>
<p><strong>全量同步</strong></p>
<p>Redis全量复制一般发生在Slave初始化阶段，这时<strong>Slave需要将Master上的所有数据都复制一份</strong>：</p>
<p>​       1）从服务器连接主服务器，发送<code>SYNC</code>命令；<br>
　　2）主服务器接收到SYNC命名后，开始执行<code>BGSAVE</code>命令（1）生成<u>RDB文件</u>  （2）并使用<u>缓冲区记录</u>此后执行的所有<strong>写</strong>命令；<br>
　　3）主服务器<code>BGSAVE</code>执行完后，向所有从服务器发送RDB快照文件，并在发送期间继续记录被执行的写命令；<br>
　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>
　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p>
</li>
<li>
<p>（🚩*1）<strong>增量同步</strong></p>
<p>Slave初始化后开始正常工作时：<strong>主服务器发生的写操作同步到从服务器的过程。</strong></p>
<ol>
<li>主服务器每执行一个<strong>写命令</strong>就会向从服务器发送相同的写命令；</li>
<li>从服务器接收并执行收到的写命令。</li>
</ol>
</li>
</ul>
<h4 id="2-【新补充】-Redis-集群架构模式有哪几种？-集群的原理是什么？">2.【新补充】 <strong>Redis</strong> <strong>集群架构模式有哪几种？</strong> <strong>集群的原理是什么？</strong></h4>
<blockquote>
<p>待补充：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzhongcy/article/details/108446687">Redis 架构模式详解（单机、主从、哨兵、集群模式）</a></p>
</blockquote>
<ul>
<li>
<p><strong>1. 单机模式</strong></p>
<blockquote>
<p>QPS（每秒查询速度）大约在几万左右。</p>
</blockquote>
<p>安装一个 Redis，启动起来，业务调用即可。</p>
<p><img src="https://i.loli.net/2021/05/25/m5euvrDF1UOtYbn.png" alt="image-20210525232444113"></p>
<ul>
<li><strong>优点：</strong> 部署简单；成本低；高性能</li>
<li><strong>缺点：</strong> 单节点宕机风险 ;  单机高性能受限于 CPU 的处理能力</li>
</ul>
</li>
<li>
<p><strong>2. 主从复制</strong></p>
<p><img src="https://i.loli.net/2021/05/25/tGy6WCzmKpS4Mfr.png" alt="image-20210525232806643"></p>
<p>Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。</p>
<ul>
<li>被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。</li>
</ul>
<p>主要优缺点：</p>
<ul>
<li><strong>优点：</strong> Master/Slave 角色方便水平扩展，降低 Master <strong>读</strong>压力，转交给 Slave 节点；</li>
<li><strong>缺点：</strong> 可靠性保证不是很好，主节点故障便无法提供写入服务；没有解决主节点<strong>写的压力</strong> ；主节点宕机，需要人为干预。</li>
</ul>
</li>
<li>
<p><strong>3. 哨兵模式</strong></p>
<blockquote>
<p>Redis 2.8版本后引入了哨兵的概念。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/01/81lKSUu7skhM2Yr.png" alt="img"></p>
<p>主从模式中，当主节点宕机之后，<strong>从节点是可以作为主节点顶上来继续提供服务</strong>，<u>但是需要修改应用方的主节点地址</u>，还需要命令所有从节点去复制新的主节点数据，整个过程需要<strong>人工干预</strong>。</p>
<p>为此，引入了哨兵（Sentinel）这个概念，在<strong>主从复制的基础</strong>上，哨兵实现了<strong>自动化故障恢复</strong>。哨兵模式由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li>
<p><strong>哨兵节点</strong>：哨兵节点是特殊的 Redis 节点，不存储数据；</p>
</li>
<li>
<p><strong>数据节点</strong>：主节点和从节点都是数据节点。</p>
</li>
</ul>
<p><strong>哨兵工作原理：</strong></p>
<ol>
<li>每个 Sentinel 以每秒一次的频率向它所知的 <strong>Master，Slave 以及其他 Sentinel</strong> 节点发送一个 <code>PING</code> 命令；</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间<strong>超过配置文件 <code>own-after-milliseconds</code> 选项所指定的值</strong>，则这个实例会被 Sentinel 标记为<strong>主观下线</strong>；</li>
<li>如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以<strong>每秒一次</strong>的频率确认 Master 是否真的进入主观下线状态；</li>
<li>当有<strong>足够数量的 Sentinel</strong>（大于等于配置文件指定的值）在<strong>指定的时间范围内确认</strong> Master 的确进入了主观下线状态，则 Master 会被标记为<strong>客观下线</strong>；</li>
<li>如果 Master 处于 <strong>ODOWN 状态</strong>，则投票自动选出新的主节点;将剩余的从节点指向新的主节点继续进行数据复制；</li>
<li>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。<u>若 Master 重新向 Sentinel 的 PING 命令返回有效回复</u>，Master 的主观下线状态就会被移除。</li>
</ol>
<p><u><strong>哨兵模式优缺点</strong></u>：</p>
<ul>
<li><strong>优点：</strong>（1）主从自动切换，更加健壮</li>
<li><strong>缺点：</strong> （1）主从切换需要时间还是会丢失数据；（2）没有解决主节点<strong>写</strong>压力 （3）动态扩容复杂</li>
</ul>
</li>
<li>
<p><strong>4. 集群模式</strong></p>
<blockquote>
<p>Redis 3.0 版本引入了Redis Cluster集群模式。</p>
</blockquote>
<img src="https://i.loli.net/2021/05/25/yfskJDK3vrzUoWp.png" alt="img" style="zoom:80%;" />
<ul>
<li>如上图所示：该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 <strong>Gossip</strong> 协议进行通信，交换维护节点元数据信息</li>
</ul>
<p>Redis Cluster 采用<strong>无中心</strong>结构，<strong>每个节点都可以保存数据</strong>和整个集群状态，每个节点<strong>都</strong>和其他所有节点<strong>连接</strong>。</p>
<ul>
<li>Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中3个为<strong>主</strong>节点，3个为<strong>从</strong>节点；</li>
</ul>
<p><strong>4.1 Redis 集群分片概念</strong></p>
<blockquote>
<p>单机、主从、哨兵的模式数据都是存储在<strong>一个master节点</strong>上，<strong>其他节点进行数据的复制</strong>。</p>
<p>集群模式就是把数据进行<strong>分片</strong>存储，当一个分片数据达到上限的时候，还可以分成多个分片。</p>
</blockquote>
<p>Redis Cluster 采用<strong>虚拟哈希槽分区</strong>，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：</p>
<ul>
<li><code>HASH_SLOT = CRC16(key) % 16384</code></li>
</ul>
<p><strong>每一个主</strong>节点负责维护一部分<strong>槽</strong>以<strong>及</strong>槽所<strong>映射的键值数据</strong>。</p>
<ul>
<li>
<p><strong>举例说明</strong>：</p>
<blockquote>
<p>有 3 个节点的集群环境如下</p>
<ul>
<li>节点 A 哈希槽范围为 0 ~ 5500；</li>
<li>节点 B 哈希槽范围为 5501 ~ 11000；</li>
<li>节点 C 哈希槽范围为 11001 ~ 16383。</li>
</ul>
</blockquote>
<p><strong>增加数据：</strong> （1）根据上述公式计算<strong>新增的key存储</strong> ，映射到相应节点（假设为B）</p>
<p><strong>增加节点：</strong> （1）从各个节点拿出一部分哈希槽分配到新增的D节点上即可</p>
<p><strong>删除节点：</strong> （1）删除A节点，只需将A节点的哈希槽移动到其它节点接口</p>
</li>
</ul>
<p><strong>4.2 Reids集群的主从模式</strong></p>
<p>Redis Cluster 为了保证数据的高可用性，加入了主从模式，<strong>一个主节点对应一个或多个从节点</strong>，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。</p>
<p><strong>4.3 优缺点总结</strong></p>
<ul>
<li><strong>优点：</strong> （1）无中心结构 ，<strong>多</strong>节点<strong>存储</strong>数据；（2）节点动态<strong>删除、移动</strong>数据分布方便；（3）<strong>部分节点不可用</strong>，集群依旧可用（哈希槽 + 从节点备份并故障晋升主节点）；</li>
<li><strong>缺点：</strong> （1）<strong>异步</strong>复制，<strong>无法保证数据一致性</strong>（2）集群搭建<strong>复杂</strong>（3） <strong><code>mget</code>,<code>pipeline</code><strong>等命令。它们需要把请求</strong>分散到多个节点执行</strong>、再聚合。节点越多，性能越低</li>
</ul>
</li>
</ul>
<h4 id="3-说说-Redis-哈希槽的概念？-什么情况下会导致整个集群不可用？">3. <strong>说说</strong> <strong>Redis</strong> <strong>哈希槽的概念？</strong> <strong>什么情况下会导致整个集群不可用？</strong></h4>
<blockquote>
<p>Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。</p>
</blockquote>
<p>假设集群中有 A、B、C 三个集群节点，<strong>不存在复制模式</strong>下，每个集群的节点包含的哈希槽如下：</p>
<ul>
<li>
<p>节点 A 包含从 0 到 5500 的哈希槽；</p>
</li>
<li>
<p>节点 B 包含从 5501 到 11000 的哈希槽；</p>
</li>
<li>
<p>节点 C 包含从 11001 到 16383 的哈希槽；</p>
</li>
</ul>
<p>这时，如果<strong>节点 B 出现故障</strong>，<u>整个集群就会出现缺少 5501 到 11000</u> 的哈希槽范围而不可用。</p>
<h4 id="4-Redis-常见性能问题和解决方案有哪些？">4. <strong>Redis 常见性能问题和解决方案有哪些？</strong></h4>
<p>Redis 常见性能问题和解决方案如下：</p>
<ul>
<li>**Master不做持久化，   Slave 做 AOF：**Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</li>
<li>**同局域网：**为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；</li>
<li>尽量避免在压力很大的主库上增加从库；</li>
<li><strong>主从复制不要用图状结构</strong>，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变</li>
</ul>
<h2 id="6-5-Redis-Key相关">6.5 Redis Key相关</h2>
<h4 id="1-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？">1. <strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某</strong>个固定的已知的前缀开头的，如果将它们全部找出来？</h4>
<p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p>
<ul>
<li>
<p><strong>keys命令</strong></p>
<p>虽然可以查询但不太推荐：</p>
<ul>
<li><strong>时间长且会导致线程阻塞：</strong> 时间长是因为O(N)遍历 ； 阻塞是因为Redis单线程，要等遍历完，这使得Redis要等keys执行完毕才能恢复生产（在生成环境中这是不被允许的）。</li>
<li><strong>没有分页功能：</strong> 一次查找所有的结果</li>
</ul>
</li>
<li>
<p><strong>scan命令</strong></p>
<p>推荐：</p>
<ul>
<li>
<p>不会阻塞，但查找出的元素可能重复，需要客户端去重下</p>
<blockquote>
<p><strong>为什么不会阻塞？</strong></p>
<p>因为 scan 是通过游标方式查询的 ，查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="2-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？">2. <strong>如果有大量的 key 需要设置同一时间过期，一般需要注意什</strong>么？</h4>
<p>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致<strong>缓存雪崩</strong>。</p>
<ul>
<li><strong>解决方案：</strong> 最好给数据的过期时间加一个<strong>随机值</strong>，让过期时间更加分散</li>
</ul>
<h4 id="3-什么是-bigkey？会存在什么影响？">3. <strong>什么是</strong> <strong>bigkey？会存在什么影响？</strong></h4>
<p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p>
<p><strong>bigkey 的主要影响有：</strong></p>
<ul>
<li>
<p><strong>网络阻塞</strong>：获取 bigkey 时，传输的数据量比较大，会增加带宽的压力；</p>
</li>
<li>
<p>超时阻塞：因为 bigkey 占用的空间比较大，所以<u>操作起来效率会比较低</u>，导致出现阻塞的可能性增加。</p>
</li>
</ul>
<h4 id="4-Redis-如何解决-key-冲突？">4. <strong>Redis</strong> <strong>如何解决</strong> <strong>key</strong> <strong>冲突？</strong></h4>
<blockquote>
<p>Redis 如果 key 相同，后一个 key 会覆盖前一个 key。</p>
</blockquote>
<p>如果要解决 key 冲突，最好给 <strong>key 取好名</strong>区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。</p>
<h4 id="5-如何解决Redis的并发竞争Key问题-？">5. 如何解决Redis的并发竞争Key问题 ？</h4>
<blockquote>
<p>多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同。</p>
</blockquote>
<ul>
<li>
<p>解决方案：<strong>分布式锁</strong>（zookeeper 和 Redis 都可以实现分布式锁）。</p>
<ul>
<li>
<p><strong>zookeeper分布式锁</strong>：（1）每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点；（2）判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个；（3）当释放锁的时候，只需将这个瞬时节点删除即可。</p>
<blockquote>
<p>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="6-Redis删除key的底层原理实现？">6. Redis删除key的底层原理实现？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.hoohack.me/2019/06/24/redis-expire-strategy">https://www.hoohack.me/2019/06/24/redis-expire-strategy</a></p>
</blockquote>
<p>Redis在启动的时候，会注册两种事件：</p>
<ol>
<li><strong>时间事件：</strong> Redis处理后台操作的一类事件，比如客户端超时、删除过期key</li>
<li><strong>文件事件：</strong> redis注册的回调函数是serverCron，在**定时任务（惰性删除）**回调函数中，通过调用databasesCron清理部分过期key</li>
</ol>
<p><strong>定时删除</strong></p>
<p>对于每一个设置了过期时间的key都会创建一个<strong>定时器</strong>，一旦到达过期时间就立即删除：</p>
<ul>
<li>缺点：占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。</li>
</ul>
<p><strong>惰性删除</strong></p>
<p><strong>每次访问key的时候</strong>，都会调用<code>expireIfNeeded</code>函数判断key是否过期，如果是，清理key：</p>
<ul>
<li>缺点：大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</li>
</ul>
<p><strong>定期删除</strong></p>
<p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key：</p>
<ul>
<li>缺点：折中方案</li>
</ul>
<p><strong>Redis单线程清理key的时机</strong></p>
<p>Redis是以**单线程运行的，在清理key是不能占用过多的时间和CPU，**需要在尽量不影响正常的服务情况下，进行过期key的清理。</p>
<ul>
<li>
<p><strong>以随机删除为例</strong></p>
<ol>
<li>
<p>server.hz配置了serverCron任务的执行周期，默认是10，<strong>即CPU空闲时每秒执行十次</strong>；</p>
</li>
<li>
<p><strong>每次清理过期key的时间不能超过CPU时间的25%</strong> ；</p>
</li>
<li>
<p>如果是快速清理模式（在beforeSleep函数调用），则一次清理的最大时间是1ms；</p>
</li>
<li>
<p>依次遍历所有的DB；</p>
</li>
<li>
<p>从db的过期列表中随机取20个key，判断是否过期，如果过期，则清理；</p>
</li>
<li>
<p>如果有5个以上的key过期，则重复步骤5，否则继续处理下一个db ；</p>
</li>
<li>
<p>在清理过程中，如果达到CPU的25%时间，退出清理过程。</p>
</li>
</ol>
</li>
<li>
<p><strong>Redis4.0使用BIO处理</strong></p>
<p>Redis4.0以前，删除指令是del，del会直接释放对象的内存，但是，如果删除的key是一个<strong>非常大的对象</strong>，那么删除操作就会导致单线程卡顿，Redis的响应就慢了。</p>
<ul>
<li>在Redis4.0版本引入了unlink指令，能对删除操作进行“懒”处理，<strong>将删除操作丢给后台线程，由后台线程BIO来异步回收内存</strong>。</li>
</ul>
</li>
</ul>
<p><strong>内存淘汰策略</strong></p>
<p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p>
<h1>七、数据结构和算法</h1>
<h4 id="1-如何对快排进行优化？">1. 如何对快排进行优化？</h4>
<p>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p>
<p><strong>1.三数取中法和随机交换法</strong></p>
<blockquote>
<p>快排将选取的基准点经过调整放到合适的位置，之后将这个基准点左右两边的区间分别递归的进行快排，如果基准点的数据比较小，将会导致调整后基准点处于靠近两侧的位置，那么两边的区间长度将会严重失去平衡.</p>
<p><strong>三数取中法：指的是选取基准点之前</strong>我们可以拿出数列中间位置元素的值，将它和首尾的元素进行比较，之后将这三个数中的<strong>中间数</strong>交换到<strong>数列首位</strong>的位置，之后将这个数作为基准点，<u>尽量减小之后的分区后左右两边的区间长度之差</u>。</p>
</blockquote>
<p>2.（🚩*1）分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p>
<blockquote>
<p><u><strong>3路法同样是针对含有大量【重复数列】的优化</strong></u>，不同于之前的快排方法，3路法的思想是将数列分成3个区间，分别是小于、等于和大于基准点的区间，那么分区之后，对于等于基准点的区间内的元素，我们就不需要对其做任何处理了，只需要递归的处理小于和大于基准点的元素即可。</p>
</blockquote>
<p>3.（🚩*1）递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p>
<blockquote>
<p>当待排序序列的长度分割到一定大小后，使用插入排序。</p>
<p>原因：<strong>对于很小和部分有序的数组，快排不如插排好</strong>。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p>
</blockquote>
<h4 id="2-快排和堆排的区别？-什么时候使用快排和堆排？">2. <strong>快排和堆排的区别？</strong> <strong>什么时候使用快排和堆排？</strong></h4>
<p>二者区别：</p>
<ul>
<li>
<p>**综合性能：**实际应用中，虽然（🚩）<u>堆排序的时间复杂度要比快速排序稳定</u>（快排最差退化成O(N^2)） ，但是统计意义上这种情况较少，所以综合性能还是快排更优；</p>
</li>
<li>
<p>（🚩*1）<strong>交换次数：</strong> 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序；</p>
</li>
<li>
<p><strong>访问友好：</strong> 堆排序数据访问的方式没有快速排序友好。</p>
<blockquote>
<p><strong>对于快速排序来说，数据是顺序访问的；而堆排序来说，数据是跳着访问的。<strong>比如，堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，会一次访问</strong>数组下标1，2，4，8</strong>的元素，而不是像快排那样，局部顺序访问，<u>所以对<strong>CPU缓存</strong>是不友好的</u>。</p>
</blockquote>
</li>
</ul>
<p>快排和堆排：</p>
<ul>
<li>
<p><strong>快排：</strong> 绝大多数场合</p>
</li>
<li>
<p><strong>堆排：</strong> topK问题、优先队列（需要在一组不停更新的数据中不停地找最大/小元素）</p>
<blockquote>
<p>在N个元素中找到top K，时间复杂度是O(N log K)，空间复杂的是O(K)，而快速排序的空间复杂度是O(N)，</p>
</blockquote>
</li>
</ul>
<h4 id="3-【面试重点】-有哪些排序算法，各算法的时间复杂度-哪些是稳定的？为什么是稳定的？">3. **【面试重点】**有哪些<a href="">排序</a><a href="">算法</a>，各<a href="">算法</a>的时间复杂度 ? 哪些是稳定的？为什么是稳定的？</h4>
<p><img src="https://i.loli.net/2021/05/01/K3s7DFEvyhHkwI9.png" alt="image-20210501224258097"></p>
<h5 id="3-1-如果数据大致有序的，用什么排序比较好？">3.1 如果数据大致有序的，用什么排序比较好？</h5>
<p>如果是<strong>大致有序</strong>，用 <u>插入排序</u> 比较好：</p>
<ul>
<li><u>直接插入排序</u>是将第i个元素插入到已经排序好的前i-1个元素中 ，当元素基本有序时。和前i-1个元素<strong>末尾比较一次</strong>就可以直接插入。</li>
</ul>
<p>在相比使用其它排序：</p>
<ul>
<li>
<p><u>归并排序：</u> 归并排序和数组是否有序无关，都是O(nlgn)。</p>
<blockquote>
<p>归并排序是把一个有n个记录的无序文件看成由<strong>n个长度为1</strong>的有序子文件组成的文件，然后进行两两归并，得到[n/2]个长度为2或1的有序文件，再两两归并 。</p>
</blockquote>
</li>
<li>
<p><u>快速排序：</u> 数组基本有序时，此时如果使用基点是最后一个元素，划分的两个子数组极为不平衡，每次划分比较次数都很多。所以不推荐。</p>
</li>
</ul>
<h4 id="4-二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）">4. <strong>二叉查找树，<a href="">红黑树</a>和<a href="">平衡二叉树</a>的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）</strong></h4>
<blockquote>
<p>总结来说：平衡树是为了解决二叉查找树退化为链表的情况；而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。</p>
</blockquote>
<ul>
<li>
<p><strong>二叉查找树退化成单链表</strong></p>
<p>正常使用二叉查找树是类似于<u>二分查找 O（logn）</u>，但是极端情况：</p>
<ul>
<li>
<p>构建的二叉树所有节点都只有右子树或左子树，此时时间复杂度退化成O(N)</p>
<p><img src="https://i.loli.net/2021/05/01/38TASb1DB7sYN5k.jpg" alt="preview"></p>
</li>
</ul>
</li>
<li>
<p><strong>平衡二叉树频繁左右旋</strong></p>
<p>平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点：</p>
<ol>
<li>
<p>具有二叉查找树的全部特性；</p>
</li>
<li>
<p><strong>每个节点的左子树和右子树的高度差至多等于1</strong>。</p>
</li>
</ol>
<p>避免了二叉查找树极端情况产生，但是：</p>
<ul>
<li>每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li>
</ul>
<p>平衡树性能大打折扣。</p>
</li>
<li>
<p><strong>红黑树规不需要频繁着调整</strong></p>
<p>红黑树具有如下特点：</p>
<blockquote>
<p>最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。</p>
<ul>
<li>与平衡树不同的是，红黑树在插入、删除等操作，（🚩*1）<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因；</li>
<li>但是，单单在查找方面的效率的话，平衡树比红黑树快。</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2021/05/01/sFSaG9POEi73hdo.jpg" alt="img"></p>
<ol>
<li>具有二叉查找树的特点；</li>
</ol>
</li>
</ul>
<ol start="2">
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；</li>
<li>（🚩*1）<strong>任何相邻的节点都不能同时为红色</strong>，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，<strong>从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点</strong>。</li>
</ol>
<h5 id="4-1-为什么红黑树不需要频繁调整？">4.1 为什么红黑树不需要频繁调整？</h5>
<blockquote>
<p>详细理解红黑树一篇不错的文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97523789">百图详解红黑树，想不理解都难</a></p>
</blockquote>
<p>平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间。</p>
<p>但是由于红黑树：</p>
<ul>
<li>具有二叉树所有特点。</li>
<li>每个节点只能是红色或者是黑色。</li>
<li><strong>根节点只能是黑色</strong>，且黑色根节点不存储数据。</li>
<li><strong>任何相邻的节点都不能同时为红色</strong>。</li>
<li>红色的节点，它的子节点只能是黑色。</li>
<li>从任一节点到其每个叶子的所有路径都包含<strong>相同数目的黑色节点</strong>。</li>
</ul>
<p><strong>不追求插入、删除等操作绝对平衡</strong>，只需满足上述条件即可。它的旋转次数少，<strong>插入最多两次旋转</strong>，<strong>删除最多三次旋转</strong>。</p>
<p>所以在搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。</p>
<h4 id="5-快速排序的过程-？">5. <strong>快速<a href="">排序</a>的过程 ？</strong></h4>
<ul>
<li>
<p>手撕一个<a href="">二分查找</a> 和快排？</p>
<ul>
<li>
<p><strong>二分查找</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid ;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right) <span class="comment">//*&lt;= 而不是&lt; </span></span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 如果数组存在待查找元素，按照逻辑一定会是mid</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(value &lt; arr[mid])</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// value &gt; arr[mid]</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quick_sort(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=left)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择基准：数组最右数字</span></span><br><span class="line">        <span class="comment">// *如果选择最左，思考交换过程</span></span><br><span class="line">        <span class="comment">// *partition 左侧始终是比pivot小的数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">        <span class="keyword">int</span> partition = left;</span><br><span class="line">        <span class="comment">// 遍历分区元素</span></span><br><span class="line">        <span class="comment">// 小于基准的放基准左边，大于的放基准右边</span></span><br><span class="line">        <span class="comment">// * 终止条件：i &lt; right 而非 right-1！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt; right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot) <span class="comment">// 实际只交换小于到左边即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr,i,partition);</span><br><span class="line">                partition++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// *基准插入位置partition位置</span></span><br><span class="line">        swap(arr,partition,right);</span><br><span class="line">        <span class="comment">//递归的排序</span></span><br><span class="line">        quick_sort(arr,left,partition-<span class="number">1</span>);</span><br><span class="line">        quick_sort(arr,partition+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="6-【重点】-红黑树结构？自旋过程？大致原理。">6.【重点】 红黑树结构？自旋过程？大致原理。</h4>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/efc3f84541cd50fc4988048d4c0f68b3.html">https://www.huaweicloud.com/articles/efc3f84541cd50fc4988048d4c0f68b3.html</a></p>
<p><img src="https://i.loli.net/2021/05/22/psc7jdzmoDbZgGv.png" alt="image-20210522100743169"></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/30/mysql-index.html">https://tech.meituan.com/2014/06/30/mysql-index.html</a>  <a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p>
<h4 id="7-布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？">7. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43263751">详解布隆过滤器的原理，使用场景和注意事项</a></p>
</blockquote>
<blockquote>
<p>“布隆说：<strong>不存在</strong>的那么<strong>一定不存在</strong>”</p>
<p>“布隆说：<strong>存在</strong>的那么<strong>只是可能存在</strong>”</p>
</blockquote>
<h5 id="7-1-从HashMap说起—当你判断某个元素时候你在想什么？">7.1 从HashMap说起—当你判断某个元素时候你在想什么？</h5>
<blockquote>
<p>通常我们怎么判断一个数组，是否存在某个元素呢？</p>
</blockquote>
<p>聪明的你一定想到HashMap：（1）HashMap将数组所有元素使用哈希函数，映射到HashMap上（HashMap本身也是一个数组）（2）然后就可以在O(1)级别判断某个元素是否存在。</p>
<p>但是这种做法通常会导致以下问题：</p>
<ol>
<li><strong>一旦数组很大</strong>，比如上亿，HashMap将会占据非常大的内存；</li>
<li>数组很大，不大可能一次性能在内存构建HashMap；</li>
<li>而且HashMap，通常存在负载因子，是不能充分利用内存的。</li>
</ol>
<p>为此，我们可以从以下方向优化：</p>
<ul>
<li>
<p><strong>只存储key。<strong>但是，因为我们</strong>只要判断某个元素（key）是否存在</strong>， 不需要取出对应key的value—也就是<strong>不需要存储value</strong>。</p>
</li>
<li>
<p><strong>key映射为bit数组索引。<strong>key映射为<code>bit</code>数组索引，即</strong>位图对应索引</strong>，  索引对应数值用 <code>0/1</code> 就可以标识为是否存在该key。</p>
</li>
</ul>
<p>为此，我们可以【第一阶段优化】如下：</p>
<p><img src="https://i.loli.net/2021/05/28/acoknPGdU3DVMEw.png" alt="img"></p>
<p>看样子似乎是满足我们要求了，但是依旧存在以下问题：</p>
<ol>
<li>只使用一个<code>hash</code>函数，<strong>空间利用率低</strong>。</li>
</ol>
<p>一个<code>hash</code>函数只能<strong>将key散列到一个位置</strong> ，虽然hash尽量优良映射均匀，但是空间利用率依然不算高。</p>
<p>因此，我们可以多个函数，将<strong>key同时映射到多个位置</strong>，即使发生哈希冲突，某个位置被覆盖，其它依旧存在，<strong>变相的降低了哈希冲突</strong>。</p>
<h5 id="7-2-数据结构及原理">7.2 数据结构及原理</h5>
<p>布隆过滤器，最终结构如下：一个<code>bit</code>数组，采用<strong>多个hash函数</strong>进行映射。</p>
<p><img src="https://i.loli.net/2021/05/28/zIxX9WcwUoT2lGK.png" alt="img"></p>
<h5 id="7-3-布隆函数优缺点">7.3 布隆函数优缺点</h5>
<ul>
<li><strong>优点</strong>
<ol>
<li><code>存储/插入/查询</code>时间复杂度，都是常数级别<code>O(1)</code></li>
<li><strong>保密性好</strong>，因为不需要存储数据本身</li>
<li><strong>存储数据大</strong>，可以存储非常大的数据本身</li>
</ol>
</li>
<li><strong>缺点</strong>
<ol>
<li>随着元素数量增加，<strong>误算率</strong>会增加</li>
<li><strong>不能删除</strong>元素，因为删除某个元素，要把其对应所有hash函数散列的位置如A,B，置为<code>0</code> 。其它元素的可能散列到位置A，再去判断这个元素是否存在就会出现<strong>误判</strong>。</li>
</ol>
</li>
</ul>
<h5 id="7-4-应用场景">7.4 应用场景</h5>
<ol>
<li>
<p><strong>解决缓存穿透</strong>，防止<strong>不存在</strong>的元素去查询数据库</p>
</li>
<li>
<p><strong>防止重复被攻击</strong>，用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率</p>
</li>
<li>
<p><strong>判断用户是否阅读过某视频或文章</strong>， 比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</p>
</li>
</ol>
<h1>八、场景题&amp;智力题</h1>
<h2 id="8-1-场景题">8.1 场景题</h2>
<h4 id="1-设计一个微信运动排行榜？（Redis）">1. <strong>设计一个微信运动排行榜？（Redis）</strong></h4>
<ul>
<li>
<p><strong>被CSIG伤过的的心还可以爱谁（第一次回答）</strong></p>
<blockquote>
<p>“可以使用mysql, 将用户的好友列表关联的运动记录查询出来，然后通过order by 来进行排序，就可以实现了。”</p>
</blockquote>
<p>一旦数据量大达到千万级别的时候，不可避免地会出现慢查询，效率就会降低。所以<u>这不是面试官想听到的回答！</u></p>
</li>
<li>
<p><strong>Redis–高效</strong></p>
<p>使用Redis的有序集合 zset（<strong>有序且不重复</strong>） 。因为 zset 排序的下标从0 开始，自带一个score 值，该值可以当作排行的标准 。</p>
<ul>
<li><strong>添加用户和步数：</strong> <code>zadd key score member</code></li>
<li><strong>查询指定排名范围内用户：</strong> （从小到大）<code>zrange key start stop withscores </code>or （从大到小）<code>zrevrange key start stop withscores</code></li>
</ul>
<p>根据上面，所以用户按score从小到大排序完毕了，如果还要获取排名也可以使用下面命令：</p>
<ul>
<li><strong>查询指定用户排名</strong> ： <code>zrank key member</code> or <code>zrevrank key member</code></li>
</ul>
<p>一个简单的排行榜就设计完成了。</p>
<blockquote>
<p>如果面试官进一步问：一周排行榜怎么设计？</p>
</blockquote>
<p>一周的数据其实就是7天数据的累加，累加完后再排序，一个月的数据原理也是一样。可以使用 ：</p>
<ul>
<li>
<p><code>ZINTERSTORE</code> ： 计算给定一个或多个有序集的交集并将结果放到一个新的有序集合destination中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure>
<p>默认情况使用的函数是求和。</p>
</li>
</ul>
<p>所以可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zunionstore last_seven_days 7 20210315  20210316 20210317 20210318 20210319 20210320 20210321</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-海量数据问题">2. <strong>海量数据问题</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/v_JULY_v/article/details/6279498">https://blog.csdn.net/v_JULY_v/article/details/6279498</a></p>
</blockquote>
<p>在海量数据中，针对top K类问题，通常比较好的方案是：</p>
<ul>
<li>
<p><strong>Top数问题：小根堆</strong></p>
<blockquote>
<p><strong>有1亿个浮点数，如何找出其最大的10000个？</strong></p>
</blockquote>
<p>直接进行排序，大约需要10^8*4字节 = 400M ，如果内存够可以直接进行排序；如果内存不够采用：</p>
<ol>
<li><strong>最小堆法</strong> ：（1）先读入10000个数来创建大小为10000的<strong>最小堆</strong>（假设这10000个数是最大的10000个，然后每次和这10000中最小的比较）（2）遍历后续数字，和堆顶最小数字比较：如果小于堆顶数字，继续；如果大于堆顶数字，则替换堆顶并重新调整为最小堆（3）整个过程直至1亿个数全部遍历完为止</li>
<li><strong>分治法。</strong> （1）1亿分为100份，每份100万个数据，找到每份的<strong>最大的1万</strong>个 （2）在剩下的100*1万个数据找到最大的1万个</li>
<li><strong>哈希法。</strong> <u>如果这1亿个书里面有很多重复的数</u>，先通过Hash法，把这1亿个数字去重复。 然后再采用方法 1 或 2 。</li>
</ol>
</li>
<li>
<p><strong>最多重复（频率最高）：Hash映射+HashMap频率计算</strong></p>
<blockquote>
<p><strong>【最多重复】海量日志数据，提取出某日访问百度次数最多的那个IP。</strong></p>
</blockquote>
<ul>
<li><strong>分治法（基于Hash）。</strong> （1）按照IP地址的<code>Hash(IP)%1024</code>值，把海量IP日志分别存储到1024个小文件中 （2）对于每一个小文件，可以构建一个IP为key，出现次数为value的<strong>Hash map</strong> （3）可以得到1024个小文件中的出现次数最多的IP ，再根据常规排序得到。</li>
</ul>
<p><u>⚠️ 使用Hash分散ip可以保证相同ip都在同一个文件夹</u>，如果只是简单均分是不行的。</p>
<blockquote>
<p><strong>【最多重复】有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</strong></p>
</blockquote>
<ul>
<li>同上，<strong>分治法（基于Hash）。</strong> 首先计算下：1G / 1M = 1000个小文件，为保险分为2000个（1）<code>Hash(词)%2000</code> 映射到2000个文件中（2）分别计算2000个文件频率最高的那个单词，然后常规排序即可（2000个单词占：2k*16B=32KB&lt;&lt;1M）</li>
</ul>
<blockquote>
<p><strong>【最多重复】有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</strong></p>
</blockquote>
<ul>
<li>同上，<strong>分治法（基于Hash）。</strong> 顺序读取10个文件，然后将query重新映射到若干个文件中，保证相同query都在同一个文件。其余同上。</li>
</ul>
</li>
<li>
<p><strong>不重复数：位图</strong></p>
<blockquote>
<p>【<strong>不重复</strong>】 <strong>在2.5亿个整数中找出不重复的整数。注，内存不足以容纳这2.5亿个整数。</strong></p>
</blockquote>
<ul>
<li>
<p><strong>采用2位图（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a>）</strong>。00表示不存在，01表示出现一次，10表示多次，11无意义，需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mi>b</mi><mo>=</mo><mn>2.5</mn><mo>∗</mo><mn>0.1</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>0.25</mn><mi>G</mi><mi>b</mi><mo>=</mo><mn>25</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2.5*10^8b = 2.5*0.1Gb=0.25Gb=25MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.1</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0.25</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">25</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>。但是我们<strong>需要把所有的整数都表示出来</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>1</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2*2^{32}bit=1GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>（1）扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变（2）查看bitmap，<u>把对应位是<strong>01</strong></u> 的整数输出即可。</p>
<p>注，int类型占32个字节，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 表示其能表示的整数个数。</p>
</li>
</ul>
<blockquote>
<p>【<strong>不重复·腾讯</strong>】<strong>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong></p>
</blockquote>
<ul>
<li><strong>采用2位图（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/11591979.html">BitMap</a>）</strong>。 需要40亿bit，大约500M，但实际是要表示所有整数，故还是1GB。其余同上。</li>
</ul>
</li>
<li>
<p><strong>共同数</strong></p>
<blockquote>
<p>【<strong>相同数</strong>】 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p>
</blockquote>
<ul>
<li><strong>分治法（基于Hash）。</strong> （1）分别将a，b两个大文件各自映射为10000个小文件，这样相同url会映射到a,b相同哈希值小文件中。（2）在a,b每一对小文件找到相同的url。</li>
</ul>
</li>
</ul>
<h4 id="3-分布式相关">3. <strong>分布式相关</strong></h4>
<blockquote>
<p><strong>谈一谈，分布式集群中如何保证线程安全？</strong></p>
</blockquote>
<ul>
<li>
<p>对于单一服务来说，只要保证一台机器上的对于共享资源的访问是同步进行的就能保证线程安全了；但是对于分布式系统而已，保证一台服务器的同步，并不能保证访问共享资源是同步的；</p>
</li>
<li>
<p>所以可以考虑使用<strong>分布式锁</strong>的方式来保证分布式中的线程的安全线，这样不同的服务不同的线程通过竞争分布式锁来获取共享资源的操作权限；</p>
</li>
<li>
<p>例如<u><strong>redis的分布式锁、zookeeper锁</strong></u>，都可以作为分布式线程安全的手段。</p>
</li>
</ul>
<blockquote>
<p><strong>在淘宝购物，这个场景下，你会怎样来设计消息队列？</strong></p>
</blockquote>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903817348136968">什么是消息队列？</a></p>
<p>消息队列（MQ）可以简单理解为：<strong>把要传输的数据放在队列中</strong>，一种先进先出的结构。</p>
</li>
<li>
<p><strong>怎么去设计淘宝消息队列？</strong></p>
<p>待补充。</p>
</li>
</ul>
<h4 id="4-微信抢红包">4. <strong>微信抢红包</strong></h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alimayun/p/12795698.html">例如一个人在群里发了100块钱的红包，群里有10个人一起来抢红包，每人抢到的金额随机分配。</a></p>
<ol>
<li>
<p>所有人抢到的金额之和要等于红包金额，不能多也不能少。</p>
</li>
<li>
<p>每个人至少抢到1分钱。</p>
</li>
<li>
<p>要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的情况。</p>
</li>
</ol>
</blockquote>
<p><strong>二倍均值法</strong>：假设剩余红包金额为m元，剩余人数为n，那么有如下公式：</p>
<ul>
<li>
<p><strong>每次抢到的金额 =  [0.01，m /n × 2 - 0.01]</strong></p>
</li>
<li>
<p>这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。</p>
</li>
</ul>
<p>举例说明：</p>
<ul>
<li>
<p>假设有5个人，红包总额100元。100÷5×2 = 40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在正常情况下，平均可以抢到20元。假设第1个人随机抢到了20元，那么剩余金额是80元。80÷4×2 = 40，所以第2个人抢到的金额的随机范围同样是[0.01，</p>
<p>39.99]元，在正常的情况下，还是平均可以抢到20元。假设第2个人随机抢到了20元，那么剩余金额是60元。60÷3×2 = 40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]元，平均可以抢到20元。以此类推，每一次抢到金额随机范围的均值是相等的。</p>
</li>
</ul>
<h2 id="8-2-智力题">8.2 智力题</h2>
<h4 id="1-厉害了我的杯">1. <strong>厉害了我的杯</strong></h4>
<blockquote>
<p>有一种玻璃杯质量确定但未知，需要检测。 有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。 现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？</p>
</blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497944">https://cloud.tencent.com/developer/article/1497944</a></p>
<h4 id="2-赛马问题">2. <strong>赛马问题</strong></h4>
<blockquote>
<p>64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马。</p>
<ul>
<li>Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形。</li>
</ul>
</blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/103572219">https://zhuanlan.zhihu.com/p/103572219</a></p>
<h1>九、框架相关</h1>
<h2 id="9-1-（要扩充）设计模式">9.1 （要扩充）设计模式</h2>
<blockquote>
<p>没有足够实际代码经验，只好先写这些应付下面试。</p>
</blockquote>
<h4 id="1-说说什么是单例模式-手写一个？">1. <strong>说说什么是单例模式 ?</strong> <strong>手写一个？</strong></h4>
<p>单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p>
<ul>
<li>
<p><strong>手写单例模式</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">https://www.runoob.com/design-pattern/singleton-pattern.html</a></p>
</blockquote>
<blockquote>
<p>记忆：“2private + 1public ”</p>
</blockquote>
<ol>
<li>
<p><strong>饿汉式</strong></p>
<p>线程安全 ， 但：类加载时就初始化，浪费内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// *让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>懒汉式（不加锁）</strong></p>
<p>只有真正调用获取实例对象时，才会创建一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用时才判断</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>懒汉式（加锁）</strong></p>
<p>线程安全，但加锁性能不够高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 就是多了个synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>双检锁式</strong></p>
<p>懒汉式（加锁）虽然可以保证只创建一个单例，但其性能不高，因为每次访问<strong>整个方法都加锁</strong>。</p>
<p>因此出现双检索式，在<code>instance=new DoubleCheckSingleton();</code> 进行加锁 ， <code>return instance;</code> <strong>不加锁</strong>！</p>
<blockquote>
<p><strong>为什么要进行两次检查instance==null？</strong></p>
<ol>
<li>
<p>第一层检查作用</p>
<p>主要为了提高性能。如果没有第一层，上来就要加锁比较耗费性能</p>
</li>
<li>
<p>第二层检查作用</p>
<p>解决多线程并发问题。假设是第一次开始执行<code>getInstance</code>方法：</p>
<ol>
<li>A，B两个线程，此时<code>instance==null</code> ，A，B都通过了第一层检查。</li>
<li>假设A先拿到锁，往下执行创建一个实例，然后释放了锁；</li>
<li>此时B也拿到了锁，<strong>如果没有第二层检查，B会进行重新new一个实例</strong>，违背单例模式！</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;      </span><br><span class="line">     <span class="comment">// volitale 关键字修饰，避免指令重排，因为初始化操作是不原子化的 ：</span></span><br><span class="line">    <span class="comment">//  (1) 给DoubleCheckSingleton类的实例instance分配内存</span></span><br><span class="line">    <span class="comment">//  (2) 调用实例instance的构造函数来初始化成员变量</span></span><br><span class="line">    <span class="comment">//  (3) 将instance指向分配的内存地址</span></span><br><span class="line">    <span class="comment">//  在多线程中，A可能是 1→3→2的顺序，执行到1→3，此时另外一个线程看到instance不为null（因为前面线程执行了3）就直接返回实例。而此时并没有被分配内存故可能出现问题。</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第一层检查，是否存在实例</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123; <span class="comment">//第二层检查，防止出现另外一个线程阻塞在synchronized，获得锁后重复创建实例</span></span><br><span class="line"></span><br><span class="line">                    instance=<span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="2-说说你对代理模式的理解？">2. <strong>说说你对代理模式的理解？</strong></h4>
<p>代理模式是给某一个对象提供一个代理，并由<strong>代理对象控制对原对象的引用</strong>。</p>
<ul>
<li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li>
<li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li>
</ul>
<h4 id="3-说说简单工厂模式？">3. <strong>说说简单工厂模式？</strong></h4>
<p>简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，<strong>对实现了同一接口的一些类进行实例的创建</strong>。</p>
<ul>
<li>
<p>比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可；</p>
</li>
<li>
<p>【<strong>优点</strong>】<strong>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例</strong>，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；</p>
</li>
<li>
<p>【<strong>缺点</strong>】 不易拓展，<u>一旦添加新的产品类型，就不得不修改工厂的创建逻辑</u>； 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</p>
</li>
</ul>
<h4 id="4-说说抽象工厂模式？">4. <strong>说说抽象工厂模式？</strong></h4>
<p>抽象工厂模式是在简单工厂的基础上将未来<strong>可能需要修改的代码抽象出来</strong>，通过继承的方式让子类去做决定。</p>
<ul>
<li>【<strong>简单工厂模式缺点</strong>】以上面的咖啡工厂为例，某天我的口味突然变了，<u>不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码</u>，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。</li>
<li>【<strong>抽象工厂</strong>】 <strong>抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现</strong>，这个时候再有新增品类的需求，只需要新创建代码即可。如，创建一个啤酒工厂而不是咖啡工厂。</li>
</ul>
<h4 id="5-装饰器模式是什么？">5. <strong>装饰器模式是什么？</strong></h4>
<blockquote>
<p>不够深入。</p>
</blockquote>
<p>装饰器模式是指<u>动态地给一个对象增加一些额外的功能</u>，同时<strong>又不改变其结构</strong>。</p>
<h2 id="9-2-分布式问题【校招必问】">9.2 分布式问题【校招必问】</h2>
<blockquote>
<p>非常系统的总结文档：<a target="_blank" rel="noopener" href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/03%20%20%E9%9D%A2%E8%AF%95%E5%AE%98%E5%A6%82%E4%BD%95%E8%80%83%E5%AF%9F%E4%B8%8E%20CAP%20%E6%9C%89%E5%85%B3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%EF%BC%9F.md">分布式相关：第一页</a></p>
</blockquote>
<p>CAP 理论指的是什么：C（Consistency）是数据一致性、A（Availability）是服务可用性、P（Partition tolerance）是分区容错性。</p>
<ul>
<li>
<p><strong>问题引入</strong></p>
<p>现在有一个分布式系统 A，它有一个副本 A1，在正常情况下，客户端 Client 写数据到系统 A，然后数据从 A 节点同步到 A1 节点，再返回给 Client 成功状态。</p>
<p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgqCHl_-eW2ALOs5AAFBvaYD4f8199.png" alt="6.png"></p>
<p>但由于网络是不可靠的，节点 A 和 A1 的网络随时会因为中断而出现分区。所谓网络分区就是由于网络不通导致节点 A 和 A1 被隔离在不同的网络子集中，此时节点 A 的数据就不能及时同步到节点 A1 中了。</p>
<p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/Ciqc1F_-eXaAcu6nAAE3Pk18sD8666.png" alt="7.png"></p>
</li>
</ul>
<h4 id="9-1-1-在CAP基础上讲讲BASE？举实例说说？">9.1.1 在CAP基础上讲讲BASE？举实例说说？</h4>
<p>BASE 理论，它是 CAP 理论的延伸。BASE 是 Basically Available（基本可用）、Soft State（软状态）和 Eventually Consistent（最终一致性）三个单词的简写，作用是保证系统的可用性，然后通过<strong>最终一致性来代替强一致性</strong>，它是目前分布式系统设计中最具指导意义的经验总结。</p>
<p>其实是做了“可用性”方面的妥协，比如：</p>
<ul>
<li>电商网站在双十一大促等访问压力较大的时候，关闭商品排行榜等次要功能的展示，从而保证商品交易主流程的可用性，这也是我们常说的<strong>服务降级；</strong></li>
<li>为了错开双十一高峰期，电商网站会将<strong>预售商品的支付时间</strong>延后十到二十分钟，这就是<strong>流量削峰</strong>；</li>
<li>在你抢购商品的时候，往往会在队列中等待处理，这也是常用的<strong>延迟队列</strong>。</li>
</ul>
<p>软状态和最终一致性指的是允许系统中的数据存在中间状态，这同样是<strong>为了系统可用性而牺牲一段时间窗内的数据一致性</strong>，从而保证最终的数据一致性的做法。</p>
<h4 id="9-1-2-亿级商品分布式存储问题？">9.1.2 亿级商品分布式存储问题？</h4>
<h5 id="1-如何设计一个支持海量商品存储的高扩展性架构？">1.如何设计一个支持海量商品存储的高扩展性架构？</h5>
<p><strong>从这一点出发会考察你Hash（哈希）分片的具体实现原理。</strong></p>
<ol>
<li>以商品 ID 作为关键字进行分片，系统会通过一个 Hash 函数计算商品 ID 的 Hash 值，然后取模，就能得到对应的分片；</li>
</ol>
<h5 id="2-在做分库分表时，基于-Hash-取模和一致性-Hash-的数据分片是如何实现的？">2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？</h5>
<ol>
<li><strong>解决 Hash 分片的缺点，既保证数据均匀分布，又保证扩展性</strong> ，最终采用一致性 Hash ：它是指将存储节点和数据都映射到一个首尾相连的哈希环上。</li>
<li>具体见前，一致性哈希相关算法描述</li>
</ol>
<h5 id="3-在电商大促时期，如何对热点商品数据做存储策略-？">3.在电商大促时期，如何对热点商品数据做存储策略 ？</h5>
<ul>
<li>
<p><strong>问题</strong></p>
<p>一致性 Hash 提升了稳定性，使节点的加入和退出不会造成大规模的数据迁移，但<strong>本质上 Hash 分片是一种静态的分片方式</strong>，必须要提前设定分片的最大规模，<strong>而且无法避免单一热点问题，</strong> 某一数据被海量并发请求后，不论如何进行 Hash，数据也只能存在一个节点上，这势必会带来热点请求问题。</p>
</li>
<li>
<p><strong>解决</strong></p>
<p><strong>做 Range（范围）分片</strong>。 与 Hash 分片不同的是，Range 分片能结合业务逻辑规则，例如，我们用 “Category（商品类目）” 作为关键字进行<strong>动态分片时</strong>，不是以统一的商品一级类目为标准，而是可以按照一、二、三级类目进行灵活分片。例如，对于京东强势的 3C 品类，可以按照 3C 的三级品类设置分片；对于弱势品类，可以先按照一级品类进行分片，这样会让分片间的数据更加平衡。</p>
<p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/assets/CgpVE1_-ed6AfUBMAAFtDc6PlH4881.png" alt="15.png"></p>
</li>
</ul>
<p><strong>4.强一致性和最终一致性的数据共识算法是如何实现的 ？</strong></p>
<h4 id="9-1-3-海量并发，分布式事务一致性问题？">9.1.3 海量并发，分布式事务一致性问题？</h4>
<ul>
<li>
<p><strong>什么是分布式事务问题？</strong></p>
<p>一次大的操作由多个小操作组成，这些<strong>小的操作分布在不同的服务器上</strong>，分布式事务需要<strong>保证这些小操作要么全部成功，要么全部失败</strong>。</p>
<p>举一个实例：</p>
<ul>
<li>京东旅行系统，拆分成多个子系统，如商品系统、促销系统、订单系统。用户下单时，<strong>订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券</strong>，<strong>只有当三个系统的事务都提交之后，才认为此次下单成功</strong>，否则失败。</li>
</ul>
</li>
<li>
<p><strong>解决方案</strong></p>
<p>有两阶段提交协议（Two-Phase Commit，2PC）、3PC 、TCC 和基于消息队列的实现方式。</p>
<ul>
<li>
<p><strong>错误回答</strong>：方案很多，可以选择 2PC ，2PC 实现的流程是…</p>
</li>
<li>
<p><strong>错误原因：</strong> 因为在实际工作中，<strong>很少采用前几种方案（互联网中落地方案代价大）</strong>，基本都是基于 MQ 的可靠消息投递的方式来实现。</p>
</li>
<li>
<p>**正确回答：**先介绍目前主流实现分布式系统事务一致性的方案（也就是基于 MQ 的可靠消息投递的机制）然后回答出可实现方案和关键知识点。另外，<strong>为了和面试官进一步交流，你可以提出 2PC 或 TCC</strong> （这是一种交流方案）。</p>
</li>
<li>
<p><strong>回答一、基于 MQ 的可靠消息投递方案</strong></p>
<ul>
<li>
<p><strong>什么是MQ</strong></p>
<p>核心的五个概念：</p>
<ol>
<li><strong>Queue</strong>: 真正存储数据的地方</li>
<li><strong>Exchange</strong>: 接收请求，转存数据</li>
<li><strong>Bind:</strong> 收到请求后存储到哪里</li>
<li><strong>消息生产者</strong>:发送数据的应用</li>
<li><strong>消息消费者</strong>: 取出数据处理的应用</li>
</ol>
</li>
<li>
<p><strong>场景实例</strong></p>
<blockquote>
<p><strong>订单系统（1）完成订单后，（2）购物车系统减购物车中的商品。</strong></p>
</blockquote>
<p><img src="https://i.loli.net/2021/09/05/B2uKDL8cyfhplis.png" alt="img"></p>
<ol>
<li>
<p>订单系统在<strong>消息队列上</strong>开启一个事务（没有创建订单）；</p>
</li>
<li>
<p>订单系统给消息服务器发送一个“半消息”；</p>
<blockquote>
<p>这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，<strong>在事务提交之前，对于消费者来说，这个消息是不可见的。</strong></p>
</blockquote>
</li>
<li>
<p>半消息发送成功后，<strong>订单系统就可以执行本地事务了</strong>，在订单库中创建一条订单记录，并提交订单库的数据库事务。</p>
</li>
<li>
<p>然后<strong>根据本地事务的执行结果决定提交或者回滚事务消息</strong>。</p>
<blockquote>
<p>如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</p>
</blockquote>
</li>
<li>
<p>购物系统消费这条拿到的订单系统消息（<strong>确认了订单系统事务执行完毕</strong>），这样就可以继续下一步购物操作</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-1-4-分布式锁问题">9.1.4 分布式锁问题</h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/06%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F.md">06 分布式系统中，如何回答锁的实现原理？</a></p>
</blockquote>
<p>分布式锁是解决协调分布式系统之间，同步访问共享资源的一种方式。详细来讲：在分布式环境下，<strong>多个系统在同时操作共享资源</strong>（如写数据）时，发起操作的系统通常会通过一种方式去协调其他系统，然后获取访问权限，得到访问权限后才可以写入数据，其他系统必须等待权限释放。</p>
<img src="https://i.loli.net/2021/09/05/f7Fh83wrnqvH6PK.png" alt="image-20210905232542573" style="zoom:80%;" />
<ul>
<li>
<p><strong>基于redis的分布式锁</strong></p>
<p><strong>使用setnx命令加锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步：加锁</span></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二步：设置过期时间</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>setnx命令，意思就是 set if not exist，<strong>如果lockKey不存在，把key存入Redis</strong>，保存成功后如果result返回1，表示设置成功，如果非1，表示失败，别的线程已经设置过了。</p>
</li>
<li>
<p>expire()，设置过期时间，防止死锁，假设，如果一个锁set后，一直不删掉，那这个锁相当于一直存在，产生死锁。</p>
</li>
</ul>
</li>
</ul>
<p><strong>解决setnx与expire不是一个原子操作</strong></p>
<ul>
<li>
<p>加锁总共分两步，第一步jedis.setnx，第二步jedis.expire设置过期时间，setnx与expire不是一个原子操作，如果程序执行完第一步后异常了，第二步jedis.expire(lockKey, expireTime)没有得到执行，<strong>相当于这个锁没有过期时间，有产生死锁的可能</strong>。</p>
</li>
<li>
<p>解决方案为：一步操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line"> 		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;   </span><br><span class="line">        <span class="comment">/**     </span></span><br><span class="line"><span class="comment">        * 获取分布式锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> jedis Redis客户端     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> lockKey 锁    </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> requestId 请求标识     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> expireTime 超期时间     </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 是否获取功     */</span>   </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">           <span class="comment">// 两步合二为一，一行代码加锁并设置 + 过期时间。       </span></span><br><span class="line">     <span class="keyword">if</span> (<span class="number">1</span> == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime))</span><br><span class="line">      &#123;           </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//加锁成功        </span></span><br><span class="line">      &#125;       </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//加锁失败   </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 解锁：对应del删除key即可</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;           </span><br><span class="line">      <span class="comment">// 第一步： 使用 requestId 判断加锁与解锁是不是同一个客户端    </span></span><br><span class="line">      <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) </span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="comment">// 第二步： 若在此时，这把锁突然不是这个客户端的，则会误解锁     </span></span><br><span class="line">          jedis.del(lockKey);    </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p><strong>基于Zoopkeeper的分布式锁</strong></p>
<blockquote>
<p>sync，lock也只能保证你当前机器线程安全，这样分布式访问还是有问题。</p>
<p>建议参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aobing/p/12650036.html">https://www.cnblogs.com/aobing/p/12650036.html</a></p>
</blockquote>
<p>一个机器接收到了请求之后，先获取 zookeeper 上的一把分布式锁（zk会创建一个 znode），执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等待，等第一个机器执行完了方可拿到锁。</p>
<p>下面是创建临时顺序节点的情况：</p>
<ol>
<li>
<p>客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。</p>
</li>
<li>
<p>客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。</p>
</li>
<li>
<p>客户端获取到所有子节点path之后，如果发现<strong>自己在步骤1中创建的节点是所有节点中序号最小</strong>的，就是看自己创建的序列号是否排第一，如果是第一，那么<strong>就认为这个客户端获得了锁</strong>，在它前面没有别的客户端拿到锁。</p>
</li>
<li>
<p>如果创建的节点不是所有节点中需要最小的，那么则<strong>监视比自己创建节点的序列号小的最大的节点，进入等待</strong>。直到下次监视的<strong>子节点变更的时候</strong>，再进行子节点的获取，判断是否获取锁。</p>
</li>
</ol>
</li>
<li>
<p><strong>基于关系型数据库 MySQL 实现分布式锁</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904137172189198">https://juejin.cn/post/6844904137172189198</a></p>
</blockquote>
<p>利用 Mysql 的锁表，创建一张表，设置一个 UNIQUE KEY（如，<strong>利用主键ID的唯一性</strong>） 这个 KEY 就是要锁的 KEY，所以同一个 KEY 在mysql表里只能插入一次了。</p>
<blockquote>
<p>这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p>
</blockquote>
<p>定义加锁、解锁代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock</span> ：  </span></span><br><span class="line"><span class="function">    <span class="title">exec</span> <span class="title">sql</span>:</span> ins	ert into lockedtable (xxx) values (xxx)    </span><br><span class="line">    <span class="keyword">if</span> result == true :       </span><br><span class="line">         <span class="keyword">return</span> true    </span><br><span class="line">    <span class="keyword">else</span> :        </span><br><span class="line">         <span class="keyword">return</span> falsedef </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">unlock</span> ：   # 解锁就是删除</span></span><br><span class="line"><span class="function"> 	<span class="title">exec</span> <span class="title">sql</span>:</span> delete <span class="keyword">from</span> lockedOrder where order_id=<span class="string">&#x27;order_id&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-3-其它问题">9.3 其它问题</h2>
<h4 id="1-【字节-懂车帝】什么是跨域？">1. 【字节-懂车帝】什么是跨域？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f049ac7e2220">https://www.jianshu.com/p/f049ac7e2220</a></p>
</blockquote>
<p>跨域，是指浏览器不能执行其他网站的脚本。它是由<strong>浏览器的同源策略</strong>造成的，是浏览器对JavaScript实施的安全限制。</p>
<p>同源策略限制了一下行为：</p>
<ol>
<li>
<p>Cookie、LocalStorage 和 IndexDB 无法读取</p>
</li>
<li>
<p>DOM 和 JS 对象无法获取</p>
</li>
<li>
<p>Ajax请求发送不出去</p>
</li>
</ol>
<p>具体的一些实例：</p>
<ol>
<li>
<p><strong>非跨域</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.yyy.cn/index.html 调用 http://www.xxxyyy.cn/server.php 非跨域</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>跨域：主域不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxxyyy.cn/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>跨域：子域名不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://abc.xxxyyy.cn/index.html 调用  http://def.xxx.cn/server.php</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>跨域：端口不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.cn:**8080**/index.html 调用  http://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>跨域：协议不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**https**://www.xxx.cn/index.html 调用  **http**://www.xxx.cn/server.php</span><br></pre></td></tr></table></figure>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">https://hwh.zone/2021/11/25/校招笔记（二）_计算机基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="/img/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/"><img class="prev-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">校招笔记（一）_JAVA</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89Numpy/"><img class="next-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深度学习基础（一）Numpy</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/25/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89_JAVA/" title="校招笔记（一）_JAVA"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">校招笔记（一）_JAVA</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">二、Linux &amp; Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Linux"><span class="toc-text">2.1 Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1.1 常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98"><span class="toc-text">2.1.2 其它问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E9%97%AE-proc-%E7%9B%AE%E5%BD%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">1. 请问&#x2F;proc 目录有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Linux%E7%9A%84%E8%BD%AF-%E7%A1%AC%E9%93%BE%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. Linux的软&#x2F;硬链接是什么？有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%9A%84top10-IP"><span class="toc-text">3. 查询日志的top10 IP?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Git"><span class="toc-text">2.2 Git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%B8%B8%E9%97%AE%E5%91%BD%E4%BB%A4"><span class="toc-text">2.2.1 常问命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFGit%EF%BC%9F-%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%EF%BC%9F"><span class="toc-text">1.什么是Git？ 是用什么语言编写的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%9C%A8Git%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E5%BA%93%EF%BC%9F"><span class="toc-text">2. 如何在Git中创建存储库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%97%E4%B8%BE%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AAgit%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-text">3. 列举工作中常用的几个git命令？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AE%B2%E8%AE%B2Git-commit-%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">4. 讲讲Git commit 基本参数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%A8Git%E4%B8%AD%EF%BC%8C%E4%BD%A0%E5%A6%82%E4%BD%95%E8%BF%98%E5%8E%9F%E5%B7%B2%E7%BB%8F-push-%E5%B9%B6%E5%85%AC%E5%BC%80%E7%9A%84%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-text">5. 在Git中，你如何还原已经 push 并公开的提交？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-git-pull-%E5%92%8C-git-fetch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. git pull 和 git fetch 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-git-stash-%E4%BD%A0%E4%B8%80%E8%88%AC%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-text">7. 什么是 git stash?你一般什么情况下会使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A6%82%E6%9E%9C%E6%9C%AC%E6%AC%A1%E6%8F%90%E4%BA%A4%E8%AF%AF%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80%EF%BC%9F"><span class="toc-text">8. 如果本次提交误操作，如何撤销？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BD%BF%E7%94%A8%E8%BF%87git-merge%E5%92%8Cgit-rebase%E5%90%97%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">9. 使用过git merge和git rebase吗？它们之间有什么区别？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">三、计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ISO-OSI%E6%A8%A1%E5%9E%8B-%E5%92%8C-TCP-IP-%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.1 ISO&#x2F;OSI模型  和 TCP&#x2F;IP 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP-IP-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE-%E5%92%8C-ISO-OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">1. 请你简要介绍一下TCP&#x2F;IP 五层协议 和 ISO&#x2F;OSI七层协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%A0%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%84%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">2. 请你简要介绍一下各层的协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-RARP-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">2.1 RARP 工作原理？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AB%AF%E5%8F%A3%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F%E6%9C%89%E6%95%88%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-text">3. 端口在哪一层？有效端口范围？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-text">3.2 运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-TCP%E6%8A%A5%E6%96%87%E5%A4%B4%EF%BC%9FUDP%E6%8A%A5%E6%96%87%E5%A4%B4%EF%BC%9F"><span class="toc-text">0. TCP报文头？UDP报文头？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%EF%BC%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%843%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%89%EF%BC%9F"><span class="toc-text">1. 请你说明一下，TCP协议的3次握手（进行连接）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-ISN-%EF%BC%88Initial-Sequence-Number%EF%BC%89%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">1.1 ISN （Initial Sequence Number）是固定的吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-text">2. 为什么要三次握手？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-text">2.1 三次握手可以携带数据吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%EF%BC%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%89%EF%BC%9F"><span class="toc-text">3. 请你说明一下，TCP协议的4次挥手（断开连接）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%A6%81%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%8F%8C%E5%B7%A5%EF%BC%8C%E4%B8%8D%E5%9F%BA%E4%BA%8E%E5%8D%8A%E5%8F%8C%E5%B7%A5%E5%91%A2%EF%BC%9F%E5%9F%BA%E4%BA%8E%E5%8D%8A%E5%8F%8C%E5%B7%A5%E5%8F%AF%E4%BB%A5%E6%94%B9%E4%B8%BA%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%97%EF%BC%9F"><span class="toc-text">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AD%89%E5%BE%85%E6%98%AF2MSL%EF%BC%9F"><span class="toc-text">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2MSL"><span class="toc-text">4.1 为什么是2MSL?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%AF%B7%E9%97%AETCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E5%8F%AF%E9%9D%A0%EF%BC%9F%E5%93%AA%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%BC%9A%E6%9C%89%E6%89%80%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-text">5. 【重点】请问TCP为什么要更可靠？哪种场景会有所应用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">5.1 超时重传机制原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BARQ%E5%8D%8F%E8%AE%AE-%EF%BC%9F"><span class="toc-text">5.2 介绍一下ARQ协议 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">5.3 介绍一下拥塞控制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">5.4 如何区分流量控制和拥塞控制？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B9%B6%E5%8F%91%E6%95%B0%EF%BC%9F"><span class="toc-text">6. 如何提高客户端并发数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B4%E8%AF%B4HTTP%E3%80%81TCP%E3%80%81Socket-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7. 说说HTTP、TCP、Socket 的关系是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%EF%BC%88DDos%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5-%EF%BC%9F"><span class="toc-text">8. 什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88DNS%EF%BC%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%EF%BC%89%E7%94%A8UDP%EF%BC%8C%E8%80%8C%E5%8C%BA%E5%9F%9F%E4%BC%A0%E9%80%81%E7%94%A8TCP"><span class="toc-text">9. 为什么DNS（域名解析）用UDP，而区域传送用TCP?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%AF%B4%E4%B8%80%E4%B8%8B-TCP-%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-text">10. 说一下 TCP 粘包是怎么产生的？怎么解决粘包？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-TCP-UDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">11. TCP, UDP的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">3.3 网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%8CARP%E5%8D%8F%E8%AE%AE%E5%92%8CARP%E6%94%BB%E5%87%BB"><span class="toc-text">1. 请简单解释一下，ARP协议和ARP攻击?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFICMP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2. 什么是ICMP协议，它的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3. 请你讲一下路由器和交换机的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E8%A7%A3%E9%87%8Aping%E5%91%BD%E4%BB%A4%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">4. 请解释ping命令过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%EF%BC%88%E8%A1%A5%E5%85%85%E4%BB%8B%E7%BB%8D%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIPV6%EF%BC%9F%E4%B8%80%E5%85%B1%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%9F"><span class="toc-text">5. （补充介绍）介绍一下IPV6？一共多少位？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%EF%BC%9FC%E7%B1%BB%E5%93%AA%E4%BA%9B%E6%98%AF%E4%BF%9D%E7%95%99%E5%9C%B0%E5%9D%80%EF%BC%9F%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%85%A8-0-%E5%85%A8-1-%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%85%A8-0-%E5%85%A81-%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">3.4 应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88DNS%E7%9A%84%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">1. 请你谈谈DNS的寻址过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%9613%E5%8F%B0%E6%A0%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F"><span class="toc-text">1.1 怎么获取13台根服务器？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BDNS%E5%8A%AB%E6%8C%81%E5%92%8CDNS%E6%B1%A1%E6%9F%93%EF%BC%9F"><span class="toc-text">1.2 解释一下DNS劫持和DNS污染？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Forward-%E5%92%8C-Redirect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. Forward 和 Redirect 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E3%80%81%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">3. 请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">3.1 请解释下负载均衡的相关算法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-DNS-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%98%AF%E4%BB%80%E4%B9%88%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">3.2 DNS 负载均衡是什么策略？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4. 请说明一下http和https的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E8%AE%B2%E4%B8%80%E8%AE%B2http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%EF%BC%9F%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">4.1 讲一讲http的请求报文和响应报文？协议？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E5%A4%9A%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E5%8F%91%E7%94%9F%E5%8F%AF%E4%BB%A5%E3%80%90%E5%90%8C%E6%97%B6%E3%80%91%E4%B8%80%E8%B5%B7%E5%8F%91%E7%94%9F%E5%90%97%EF%BC%9F"><span class="toc-text">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bhttp1-0-%E5%92%8Chttps1-1-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. 请说明一下http1.0 和https1.1 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bhttp1-0-%E5%92%8Chttps2-0-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. 请说明一下http1.0 和https2.0 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B7%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E6%8E%A5%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AAURL%EF%BC%8C%E5%88%B0%E6%9C%80%E5%90%8E%E5%B1%95%E7%A4%BA%E5%87%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">7. 请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BSSL%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%88Https%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%EF%BC%89%EF%BC%9F"><span class="toc-text">8. 请解释一下SSL工作过程（Https传输过程）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-%E5%85%AC%E9%92%A5%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9F%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%AF%81%E4%B9%A6%E3%80%82"><span class="toc-text">8.1 公钥如何保证不被篡改？说一说证书。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E8%AE%A1%E7%AE%97%E9%87%8F%E5%A4%AA%E5%A4%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E8%80%97%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-text">8.2 公钥加密计算量太大，如何减少耗用的时间？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E7%9A%84%E6%97%B6%E5%80%99%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B-SSL-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F-%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">9. **介绍一下常见的几种非对称加密算法？**优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E2%80%93%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86%E4%B8%8E%E5%85%AC%E9%92%A5%E8%A7%A3%E5%AF%86%E2%80%93%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">10. 公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-HTTPS-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81CA%E8%AF%81%E4%B9%A6%EF%BC%9F%E5%8F%AA%E6%9C%89%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%90%97%EF%BC%9FHTTPS-%E7%BB%9D%E5%AF%B9%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-text">11. HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-http%E5%BA%94%E7%AD%94%E7%A0%81%E4%B8%AD%E7%9A%84301-2-4%E3%80%81500%E3%80%81502%E3%80%81503%E3%80%81504%E7%8A%B6%E6%80%81%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%A7%A3%E9%87%8A%EF%BC%9F"><span class="toc-text">12. http应答码中的301&#x2F;2&#x2F;4、500、502、503、504状态码进行解释？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bhttp%E8%AF%B7%E6%B1%82get%E3%80%81post%E7%AD%89%EF%BC%9F"><span class="toc-text">13. 介绍一下http请求get、post等？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-Get%E6%96%B9%E6%B3%95%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-text">13.1 Get方法长度有限制是怎么回事？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-POST-%E6%96%B9%E6%B3%95%E7%9B%B8%E6%AF%94GET%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%9D%E5%AF%B9%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-text">13.2 POST 方法相比GET方法是绝对安全吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-text">14.  HTTP是不保存状态的协议,如何保存用户状态?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-cookie-%E3%80%81session%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15. cookie 、session的作用和区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-1-Session%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E5%A5%BD%E6%9C%AA%E6%9D%A5%E9%97%AE%E8%BF%87%EF%BC%89"><span class="toc-text">15.1 Session的共享方式？（好未来问过）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Cookie-%E5%92%8C-Session%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E8%81%94%EF%BC%9F%EF%BC%88%E9%97%AE%E8%BF%87%EF%BC%89token%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BC%98%E7%82%B9%EF%BC%8C%EF%BC%88JWT%EF%BC%89%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-1-session%E5%92%8Ccookie%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%8E%BB%E9%80%89%E6%8B%A9%EF%BC%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9F"><span class="toc-text">16.1 session和cookie应该如何去选择（适用场景）？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%AF%B4%E8%AF%B4HTTP%E3%80%81TCP%E3%80%81Socket-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17. 说说HTTP、TCP、Socket 的关系是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%85%B6%E5%AE%83"><span class="toc-text">3.5 其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCDN-%EF%BC%9F-CDN%E5%88%86%E5%8F%91%E8%8A%82%E7%82%B9%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%83%BD%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-text">1. 介绍一下CDN ？ CDN分发节点各个数据都一样吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFCDN%E4%B8%89%E7%BA%A7%E6%BA%AF%E6%BA%90%EF%BC%9F"><span class="toc-text">2.  什么是CDN三级溯源？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">四、操场系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-text">4.1 操作系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-text">0. （百度安全一面） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-text">1. 什么是操作系统？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%91%A2%EF%BC%9F-%E8%83%BD%E4%B8%8D%E8%83%BD%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E2%BC%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">2. 什么是系统调用呢？ 能不能详细介绍⼀下？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CentOS-%E5%92%8C-Linux%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">3. CentOS 和 Linux的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="toc-text">4. 什么是分布式，优缺点？集群？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%A8Linux-windows%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-text">5. 在Linux&#x2F;windows栈空间的大小？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ASCII%E3%80%81Unicode%E5%92%8CUTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. ASCII、Unicode和UTF-8编码的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">6.1 三者区别和联系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%9F"><span class="toc-text">7. 什么是并发和并行？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E4%BA%AB%EF%BC%9F"><span class="toc-text">8. 什么是共享？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.2 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E9%97%AE64%E4%BD%8D%E5%92%8C32%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. 请问64位和32位的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. 介绍一下线程和进程的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.1 线程和协程之间的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F"><span class="toc-text">2.2 一个进程可以创建多少个线程，和什么有关？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E5%8C%BA%E5%88%86%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">2.3 进程之间的同步方式？（区分通信方式）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E9%97%AE%E3%80%90%E8%BF%9B%E7%A8%8B%E3%80%91%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-text">3. 请问【进程】之间如何进行通信？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E9%97%AE%E3%80%90%E7%BA%BF%E7%A8%8B%E3%80%91%E9%97%B4%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%88%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9F"><span class="toc-text">4. 请问【线程】间同步方式（通信方式）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">5. 什么时候用多线程 &#x2F; 多进程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E3%80%90%E7%BA%BF%E7%A8%8B%E3%80%91%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">6. 【线程】调度算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E3%80%90%E8%BF%9B%E7%A8%8B%E3%80%91%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">7.【进程】调度算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%8F%91%E7%94%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-text">8. CPU上下文切换？有什么类型？线程发生在什么地方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E6%9D%80%E6%AD%BB%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">9. 如何杀死一个进程？ 进程终止的方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-%E7%BB%88%E7%AB%AF%E9%80%80%E5%87%BA%EF%BC%8C%E7%BB%88%E7%AB%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-text">9.1 终端退出，终端运行的进程会怎么样？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-%E6%80%8E%E4%B9%88%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%9F"><span class="toc-text">9.2 怎么让进程后台运行？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10. 外中断和异常的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%BC%9A%E8%AF%9D%EF%BC%9F"><span class="toc-text">11. 什么是父进程、子进程、进程组、作业和会话？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">12. 什么是守护进程、僵尸进程、孤儿进程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">11.1 如何避免僵尸进程？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-socket%E7%BC%96%E7%A8%8B"><span class="toc-text">4.3 socket编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">4.4 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%EF%BC%9F"><span class="toc-text">1. 介绍一下操作系统的堆和栈？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-text">1.1 什么时候会栈溢出？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">2. 介绍一下什么内存管理？常用的内存管理机制？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">2.1 介绍一下逻辑地址和物理地址？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.2 操作系统在内存管理需要做什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%9F"><span class="toc-text">3. 介绍一下快表和多级页表？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">快表介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">多级页表介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB-%EF%BC%9F"><span class="toc-text">4. 分页机制和分段机制的共同点和区别 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E3%80%90%E5%BE%85%E6%89%A9%E5%85%85%E3%80%91CPU-%E5%AF%BB%E5%9D%80%E4%BA%86%E8%A7%A3%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">5. 【待扩充】CPU 寻址了解吗?为什么需要虚拟地址空间?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86%EF%BC%9F"><span class="toc-text">6. 如果系统中具有快表后，那么地址的转换过程变成什么样了？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">7. 进程内存分配动态分区算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E8%A6%86%E7%9B%96%E5%92%8C%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%EF%BC%9F"><span class="toc-text">8. 什么是内存覆盖和内存交换？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">4.5 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF-%EF%BC%9F%E4%BB%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E4%B8%A4%E6%96%B9%E9%9D%A2%E6%9D%A5%E8%AF%B4%E3%80%82"><span class="toc-text">0. 什么是虚拟技术 ？从时间和空间两方面来说。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E5%90%A7%EF%BC%9F"><span class="toc-text">1. 介绍一下局部性原理吧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">2. 介绍一下，什么是虚拟内存？页式存储？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0-%EF%BC%9F"><span class="toc-text">3. 虚拟内存的技术实现 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">4. 请你介绍一下页面置换算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-text">5. 你怎么理解操作系统里的内存碎片，有什么解决办法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%EF%BC%9F"><span class="toc-text">6. 什么是内存抖动？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%B9%B6%E5%8F%91%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-text">4.6 并发和死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E4%BB%8B%E7%BB%8D%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">0. 介绍几种典型的锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1. 【重点】什么是线程死锁？什么情况下会发生死锁？解决死锁的策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%B3%BB%E7%BB%9FCPU%E6%AF%94%E8%BE%83%E9%AB%98%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">2. （待补充）请你解释一下，通常系统CPU比较高是什么原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8BNIO%EF%BC%8CBIO%EF%BC%8CAIO%E5%8C%BA%E5%88%AB"><span class="toc-text">3. 说一下NIO，BIO，AIO区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bselect%EF%BC%8Cpoll%EF%BC%8Cepoll-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">4. 【重点】介绍一下select，poll，epoll 原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%BB%8E%E9%98%BB%E5%A1%9EI-O-%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%E8%AF%B4%E8%B5%B7"><span class="toc-text">4.1 从阻塞I&#x2F;O &amp; 非阻塞I&#x2F;O说起</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-select%E5%8E%9F%E7%90%86"><span class="toc-text">4.2 select原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-poll%E5%8E%9F%E7%90%86"><span class="toc-text">4.3 poll原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-epoll%E5%8E%9F%E7%90%86"><span class="toc-text">4.3 epoll原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-select%EF%BC%8Cpoll%EF%BC%8Cepoll-%E5%90%84%E8%87%AA%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.4 select，poll，epoll 各自区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-ET-LT-%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D%EF%BC%9F%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">4.5 ET , LT 模式介绍？各自优缺点？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">5. 操作系统底层是怎么实现原子操作的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%85%B6%E5%AE%83"><span class="toc-text">4.7 其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">1. 常见的磁盘调度算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">2. 服务器高并发的解决方案你知道多少？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">五、MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-MySQL%E5%9F%BA%E6%9C%AC"><span class="toc-text">5.1 MySQL基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">0. 关系型数据库和非关系数据库的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F"><span class="toc-text">1. 介绍一下数据库三范式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2. MySQL数据库引擎有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-InnoDB%E3%80%81MyISAM%E3%80%81Memory-%E3%80%90%E7%B4%A2%E5%BC%95%E3%80%91%EF%BC%88%E6%8C%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%EF%BC%89"><span class="toc-text">2.1 InnoDB、MyISAM、Memory 【索引】（按数据结构分）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88Innodb%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-text">2.2 为什么Innodb使用自增id作为主键？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3. 说说InnoDB与MyISAM的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E8%AF%B4%E8%AF%B4InnoDB%E4%B8%8EMyISAM%E5%9C%A8B-%E6%95%B0%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.1 说说InnoDB与MyISAM在B+数索引方式区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E3%80%90%E7%99%BE%E5%BA%A6%E3%80%91%E8%AF%B4%E8%AF%B4InnoDB%E4%B8%8EMyISAM%E5%9C%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.2 【百度】说说InnoDB与MyISAM在适用场景上的区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88-SELECT-COUNT-FROM-table-%E5%9C%A8-InnoDB-%E6%AF%94MyISAM-%E6%85%A2%EF%BC%9F-3"><span class="toc-text">4. **为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？**3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E8%AF%B4drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. 简单说一说drop、delete与truncate的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%9F-%E6%B8%B8%E6%A0%87%EF%BC%9F"><span class="toc-text">6. 什么是视图？ 游标？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%81%94%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%81%94%E6%8E%A5%EF%BC%9F"><span class="toc-text">7. 什么是内联接、左外联接、右外联接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B4%E8%AF%B4%E5%9C%A8-MySQL-%E4%B8%AD%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2-SQL-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">8. 说说在 MySQL 中一条查询 SQL 是如何执行的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-MySQL-%E4%B8%AD-varchar-%E4%B8%8E-char-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-int-3-%E5%91%A2%EF%BC%9F"><span class="toc-text">9. MySQL 中 varchar 与 char 的区别？ int(3) 呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%B6%85%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10. 超键、主键、候选键和外键有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%A7%A3%E9%87%8A%E2%BC%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%A0%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%82%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">11.  解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98%E8%80%8C%E6%98%AF%E5%9C%A8%E5%86%85%E5%AD%98%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Mysql%E4%B8%8D%E4%BD%BF%E7%94%A8hash%EF%BC%9F"><span class="toc-text">12. 如果数据不存储在磁盘而是在内存，用什么数据结构？为什么Mysql不使用hash？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E3%80%90%E5%AD%97%E8%8A%82%E3%80%91Mysql-Join%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">13.【字节】Mysql Join的原理？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">5.2 分布式数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E3%80%90%E5%AD%97%E8%8A%82%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">0. 【字节】分布式数据库锁如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E8%AF%B4%E8%AF%B4-MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">1. 请说说 MySQL 数据库的锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E5%8F%91%E7%94%9F%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9F"><span class="toc-text">2. 说说什么是锁升级？什么情况发生锁升级？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4innoDB-%E5%BC%95%E6%93%8E%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98-%EF%BC%9F"><span class="toc-text">2.1 为什么说innoDB 引擎不存在锁升级的问题 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E7%BA%A7%E9%94%81%EF%BC%9F"><span class="toc-text">2.2 什么时候触发行锁和表级锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E8%A1%8C%E9%94%81%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">2.3 行锁适合的场景？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%8E%E6%A0%B7%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E5%87%BA%E7%8E%B0%EF%BC%9F"><span class="toc-text">3. 怎样尽量避免死锁的出现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-text">4. 解释一下悲观锁和乐观锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A8%E5%B1%80ID%E5%94%AF%E4%B8%80%E4%B8%94%E8%87%AA%E5%A2%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%EF%BC%9F-%EF%BC%88%E6%88%96%E8%80%85%E9%97%AE%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F%EF%BC%89"><span class="toc-text">5. 介绍一下分布式数据库全局ID唯一且自增，如何生成？ （或者问分库分表之后，id 主键如何处理？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">8. 介绍一下哈希算法？和一致性哈希算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%EF%BC%88%E5%86%8D%E7%90%86%E8%A7%A3%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BMVVC%EF%BC%9F"><span class="toc-text">9. （再理解）介绍一下MVVC？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-MVCC-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-%EF%BC%9F"><span class="toc-text">9.1 MVCC 如何实现 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-MVCC-%E7%89%88%E6%9C%AC%E5%8F%B7%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84%EF%BC%9F%E3%80%90%E5%B9%BB%E8%AF%BB%E3%80%91%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">9.2 MVCC 版本号如何变化的？更新的数据如何确定版本的？【幻读】又是怎么解决的呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-mvvc-%E5%92%8C-for-update%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9.3 mvvc 和 for update的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-4-%EF%BC%88%E5%BF%AB%E6%89%8B%EF%BC%89MVCC%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0RC%EF%BC%8CRR"><span class="toc-text">9.4 （快手）MVCC作用，如何实现RC，RR?</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3"><span class="toc-text">5.3 索引相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">0. MySQL索引原理及慢查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95"><span class="toc-text">0.1 为什么要需要索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-2-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%88%E7%A3%81%E7%9B%98IO%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96%E5%A4%A7%E5%B0%8F%EF%BC%89"><span class="toc-text">0.2 局部性原理（磁盘IO一次读取大小）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-3-%E7%B4%A2%E5%BC%95%E2%86%92B-%E6%A0%91"><span class="toc-text">0.3 索引→B+树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-4-%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">0.4 慢查询优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MySQ%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">1. MySQ索引的原理和数据结构能介绍一下吗？ 索引的缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MySQL-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2. MySQL 索引类型有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">2.1 什么是覆盖索引？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E3%80%913-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%AF%94%E8%BE%83%E5%A5%BD%EF%BC%9F-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">【重点】3. **什么时候使用索引比较好？**什么时候不要使用索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">3.1 什么时候用索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">3.2 什么时候不用索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BB%E9%94%AE%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4. 主键与唯一索引有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-b-%E6%A0%91%E5%92%8Cb%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5. b+树和b树有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F%E8%80%8C%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81%E6%88%96%E8%80%85Hash%EF%BC%9F"><span class="toc-text">6. 为什么MySQL使用B+树作为索引？而不是平衡二叉树、红黑树、B树、或者Hash？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9C%80%E4%BC%98%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-text">6.1 无限增加树的路数是不是可以有最优的查找效率？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-B-%E6%A0%91%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A3%82%E3%80%81%E5%90%88%E5%B9%B6%E7%9A%84%EF%BC%9F%E7%9F%A5%E9%81%93%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E5%90%97%EF%BC%9F"><span class="toc-text">7. B+树怎么进行分裂、合并的？知道具体步骤吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-MySQL%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8. MySQL聚簇索引和非聚簇索引的区别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-%E7%9C%8B%E4%B8%8A%E5%8E%BB%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%88%E7%8E%87%E6%98%8E%E6%98%BE%E8%A6%81%E4%BD%8E%E4%BA%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%AF%8F%E6%AC%A1%E4%BD%BF%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%A3%80%E7%B4%A2%E9%83%BD%E8%A6%81%E7%BB%8F%E8%BF%87%E4%B8%A4%E6%AC%A1B-%E6%A0%91%E6%9F%A5%E6%89%BE%EF%BC%8C%E8%BF%99%E4%B8%8D%E6%98%AF%E5%A4%9A%E6%AD%A4%E4%B8%80%E4%B8%BE%E5%90%97%EF%BC%9F%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">8.1 看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-%E4%B8%BA%E4%BB%80%E4%B9%88name-age%E8%BF%99%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">8.2 为什么name,age这些字段不适合做索引？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-MySQL%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">9. MySQL联合索引如何使用？ 什么是最左匹配原则？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">9.1 联合索引的好处？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%EF%BC%88%E8%BF%98%E8%A6%81%E8%A1%A5%E5%85%85%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">10. （还要补充）介绍一下索引失效的原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E3%80%90%E2%9A%A0%EF%B8%8F-%E6%96%B0%E5%A2%9E%E3%80%91%E7%B4%A2%E5%BC%95%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-text">11. 【⚠️ 新增】索引实战篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-order-by-%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">12. order by 怎么进行排序的？怎么优化？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-text">5.3 事务相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F%E5%92%8C-u-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7-u-%EF%BC%88ACID%EF%BC%89%EF%BC%9F"><span class="toc-text">1. 请介绍一下数据库事务？和事务特性（ACID）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E5%BE%97%E4%B8%8D%E5%88%B0%E4%BF%9D%E9%9A%9C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">1.1 四大特性得不到保障会出现什么情况？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">1.2 数据库如何保证四大特性？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%88%E5%B9%B6%E5%8F%91%EF%BC%89%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F-%E5%AF%B9%E5%BA%94%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">2. 介绍一下（并发）事务不同隔离级别？ 对应可能出现的问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%90%E7%8C%BF%E8%BE%85%E5%AF%BC%E3%80%91-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-text">2.1【猿辅导】 怎么解决幻读？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Mysql%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-text">3. Mysql怎么保证事务的原子性？持久性？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-MySQ%E4%BC%98%E5%8C%96"><span class="toc-text">5.4 MySQ优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">0. 分页查询慢的原因？如何优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-SQL%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1. SQL优化手段有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2SQL%E8%A2%AB%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-text">2. 请问如何防止SQL被注入？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MySQL-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">3. MySQL 如何做到高并发解决方案？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">4. 大表如何进行优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-text">5. 数据库如何去重？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E8%A1%8C%E5%8E%BB%E9%87%8D"><span class="toc-text">5.1 行去重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E5%88%97%E9%87%8D%E5%A4%8D"><span class="toc-text">5.2 列重复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-select%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">6. select慢的原因？慢查询的优化策略？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-select-%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">6.1 select 很慢的原因</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-select%E2%80%A6for-update%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">7. select…for update用法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A%E5%81%87%E5%A6%82%E9%80%89%E6%8B%A9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B8%80%E5%A4%A9%E4%BA%94%E4%B8%87%E6%9D%A1%E5%A2%9E%E9%87%8F%EF%BC%8C%E8%BF%90%E7%BB%B4%E4%B8%89%E5%B9%B4%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-text">8. 场景题：假如选择MySQL数据库，一天五万条增量，运维三年，有哪些优化手段？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">六、Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Redis%E5%9F%BA%E6%9C%AC"><span class="toc-text">6.1 Redis基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9F"><span class="toc-text">1. 什么是 Redis？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E6%9C%89MySQL%E4%B8%8D%E5%B0%B1%E5%A4%9F%E7%94%A8%E4%BA%86%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Redis%E8%BF%99%E7%A7%8D%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-text">1.1 有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-C-JAVA-%E4%B8%AD%E7%9A%84Map%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%93%E5%AD%98%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Map%EF%BC%8C%E8%80%8C%E9%80%89%E6%8B%A9Redis%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">1.2 C++ &#x2F; JAVA 中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%8F%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">2. 【重点】**redis的数据类型，以及每种数据类型的使用场景？ **</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8B-Redis-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9-%EF%BC%9F"><span class="toc-text">3. 说一下 Redis 有什么优点和缺点 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Fkey%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">4. Redis的数据结构？key是怎么存储的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-String%E3%80%81list%E3%80%81hash%E3%80%81set%E3%80%81zset%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4.1 String、list、hash、set、zset的底层结构是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E8%AE%B2%E8%AE%B2redis%E7%9A%84hash%E8%A1%A8%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">4.2 讲讲redis的hash表扩容方式？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-rehash%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="toc-text">4.3 rehash过程中增删查改怎么操作呢？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">5. 说说Redis有序集合zset的底层结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">5.1 Redis为什么不用红黑树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%A5%E5%8F%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6. Redis 持久化方式有哪些？以及有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-AOF-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">6.1 AOF 重写了解吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%8C%E9%82%A3%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%91%A2%EF%BC%9F"><span class="toc-text">7. Redis持久化有两种，那应该怎么选择呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%EF%BC%88-u-%E4%B8%8D%E5%A4%AA%E7%90%86%E8%A7%A3-u-%EF%BC%89pipeline-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-pipeline%EF%BC%9F"><span class="toc-text">8. （不太理解）pipeline 有什么好处，为什么要用 pipeline？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">9. 怎么使用 Redis 实现消息队列？ 如何实现延时队列？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.2 Redis单线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EF%BC%88%F0%9F%9A%A9-1%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%95%88%E7%8E%87%E4%B9%9F%E8%83%BD%E9%82%A3%E4%B9%88%E9%AB%98%EF%BC%9F"><span class="toc-text">1. （🚩*1）为什么 Redis 使用单线程模型？单线程模型效率也能那么高？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%EF%BC%88%E6%96%B0%EF%BC%8C%E6%98%93%E5%BF%98%EF%BC%89%E8%AF%B4%E8%AF%B4-Redis-%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%EF%BC%9F"><span class="toc-text">2. （新，易忘）说说 Redis 的单线程模型 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%A0%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E9%82%A3%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F%E6%AF%94%E5%A6%821000%E4%B8%AA%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E5%90%8C%E6%97%B6%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-text">3. 你说Redis是单线程的，那如何处理高并发？比如1000个并发请求同时发生？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3-%EF%BC%9F"><span class="toc-text">4. 说说你对Redis事务的理解 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">5. 为什么Redis的操作是原子性的，怎么保证原子性的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Redis%E7%BC%93%E5%AD%98"><span class="toc-text">6.3 Redis缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98-%EF%BC%9F%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%EF%BC%9F"><span class="toc-text">1. 为什么要用缓存 ？怎么提高缓存命中率？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%E7%AD%89%EF%BC%9F"><span class="toc-text">2. 缓存雪崩、缓存穿透、缓存击透、缓存预热、缓存更新、缓存降级等？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Redis-%E8%AE%BE%E7%BD%AEkey%E8%BF%87%E6%9C%9F%E5%90%8E%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9FRedis-%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0%E7%AD%96%E7%95%A5%EF%BC%88%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3. Redis 设置key过期后如何处理？Redis 缓存刷新策略（内存淘汰机制）有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis-%E6%8A%A5%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">4. Redis 报内存不足怎么处理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%81%E5%85%88%E6%9B%B4%E6%96%B0%E5%91%A2%EF%BC%9F-%EF%BC%88%E4%BF%9D%E6%8C%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="toc-text">5. 【重点】缓存和数据库谁先更新呢？  （保持缓存和数据库一致性）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3"><span class="toc-text">6.4 集群相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Redis-%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. Redis 的同步机制了解是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E3%80%90%E6%96%B0%E8%A1%A5%E5%85%85%E3%80%91-Redis-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.【新补充】 Redis 集群架构模式有哪几种？ 集群的原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4-Redis-%E5%93%88%E5%B8%8C%E6%A7%BD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AA%E9%9B%86%E7%BE%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-text">3. 说说 Redis 哈希槽的概念？ 什么情况下会导致整个集群不可用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis-%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">4. Redis 常见性能问题和解决方案有哪些？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-Redis-Key%E7%9B%B8%E5%85%B3"><span class="toc-text">6.5 Redis Key相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%81%87%E5%A6%82-Redis-%E9%87%8C%E9%9D%A2%E6%9C%89-1-%E4%BA%BF%E4%B8%AA-key%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89-10w-%E4%B8%AA-key-%E6%98%AF%E4%BB%A5%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5%EF%BC%9F"><span class="toc-text">1. 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84-key-%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF-bigkey%EF%BC%9F%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">3. 什么是 bigkey？会存在什么影响？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Redis-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-key-%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-text">4. Redis 如何解决 key 冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89Key%E9%97%AE%E9%A2%98-%EF%BC%9F"><span class="toc-text">5. 如何解决Redis的并发竞争Key问题 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Redis%E5%88%A0%E9%99%A4key%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">6. Redis删除key的底层原理实现？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">七、数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BF%AB%E6%8E%92%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">1. 如何对快排进行优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BF%AB%E6%8E%92%E5%92%8C%E5%A0%86%E6%8E%92%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8E%92%E5%92%8C%E5%A0%86%E6%8E%92%EF%BC%9F"><span class="toc-text">2. 快排和堆排的区别？ 什么时候使用快排和堆排？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E3%80%90%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E3%80%91-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%8C%E5%90%84%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%93%AA%E4%BA%9B%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">3. **【面试重点】**有哪些排序算法，各算法的时间复杂度 ? 哪些是稳定的？为什么是稳定的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E5%A4%A7%E8%87%B4%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E5%A5%BD%EF%BC%9F"><span class="toc-text">3.1 如果数据大致有序的，用什么排序比较好？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E6%9C%89%E4%BA%86%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E3%80%81%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88AVL%EF%BC%89%E4%B8%BA%E5%95%A5%E8%BF%98%E9%9C%80%E8%A6%81%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%EF%BC%89"><span class="toc-text">4. 二叉查找树，红黑树和平衡二叉树的区别？（有了二叉查找树、平衡树（AVL）为啥还需要红黑树？）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E9%9C%80%E8%A6%81%E9%A2%91%E7%B9%81%E8%B0%83%E6%95%B4%EF%BC%9F"><span class="toc-text">4.1 为什么红黑树不需要频繁调整？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B-%EF%BC%9F"><span class="toc-text">5. 快速排序的过程 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84%EF%BC%9F%E8%87%AA%E6%97%8B%E8%BF%87%E7%A8%8B%EF%BC%9F%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-text">6.【重点】 红黑树结构？自旋过程？大致原理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%EF%BC%9F%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-text">7. 布隆过滤器原理？为什么使用多个哈希函数？其它相关应用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-%E4%BB%8EHashMap%E8%AF%B4%E8%B5%B7%E2%80%94%E5%BD%93%E4%BD%A0%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%97%B6%E5%80%99%E4%BD%A0%E5%9C%A8%E6%83%B3%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7.1 从HashMap说起—当你判断某个元素时候你在想什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-text">7.2 数据结构及原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-%E5%B8%83%E9%9A%86%E5%87%BD%E6%95%B0%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">7.3 布隆函数优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">7.4 应用场景</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">八、场景题&amp;智力题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">8.1 场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%EF%BC%9F%EF%BC%88Redis%EF%BC%89"><span class="toc-text">1. 设计一个微信运动排行榜？（Redis）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98"><span class="toc-text">2. 海量数据问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3"><span class="toc-text">3. 分布式相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85"><span class="toc-text">4. 微信抢红包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="toc-text">8.2 智力题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%89%E5%AE%B3%E4%BA%86%E6%88%91%E7%9A%84%E6%9D%AF"><span class="toc-text">1. 厉害了我的杯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98"><span class="toc-text">2. 赛马问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">九、框架相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%EF%BC%88%E8%A6%81%E6%89%A9%E5%85%85%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.1 （要扩充）设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%EF%BC%9F"><span class="toc-text">1. 说说什么是单例模式 ? 手写一个？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">2. 说说你对代理模式的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">3. 说说简单工厂模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">4. 说说抽象工厂模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5. 装饰器模式是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E3%80%90%E6%A0%A1%E6%8B%9B%E5%BF%85%E9%97%AE%E3%80%91"><span class="toc-text">9.2 分布式问题【校招必问】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E5%9C%A8CAP%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%AE%B2%E8%AE%B2BASE%EF%BC%9F%E4%B8%BE%E5%AE%9E%E4%BE%8B%E8%AF%B4%E8%AF%B4%EF%BC%9F"><span class="toc-text">9.1.1 在CAP基础上讲讲BASE？举实例说说？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E4%BA%BF%E7%BA%A7%E5%95%86%E5%93%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">9.1.2 亿级商品分布式存储问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E6%B5%B7%E9%87%8F%E5%95%86%E5%93%81%E5%AD%98%E5%82%A8%E7%9A%84%E9%AB%98%E6%89%A9%E5%B1%95%E6%80%A7%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-text">1.如何设计一个支持海量商品存储的高扩展性架构？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%97%B6%EF%BC%8C%E5%9F%BA%E4%BA%8E-Hash-%E5%8F%96%E6%A8%A1%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7-Hash-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">2.在做分库分表时，基于 Hash 取模和一致性 Hash 的数据分片是如何实现的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%A8%E7%94%B5%E5%95%86%E5%A4%A7%E4%BF%83%E6%97%B6%E6%9C%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AF%B9%E7%83%AD%E7%82%B9%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E5%81%9A%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5-%EF%BC%9F"><span class="toc-text">3.在电商大促时期，如何对热点商品数据做存储策略 ？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E6%B5%B7%E9%87%8F%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">9.1.3 海量并发，分布式事务一致性问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">9.1.4 分布式锁问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98"><span class="toc-text">9.3 其它问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E3%80%90%E5%AD%97%E8%8A%82-%E6%87%82%E8%BD%A6%E5%B8%9D%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">1. 【字节-懂车帝】什么是跨域？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" title="前端基础（一）JavaScript基础笔记(上)">前端基础（一）JavaScript基础笔记(上)</a><time datetime="2021-11-25T12:37:58.119Z" title="发表于 2021-11-25 20:37:58">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89/" title="前端基础（一）JavaScript基础笔记(中)">前端基础（一）JavaScript基础笔记(中)</a><time datetime="2021-11-25T12:36:37.921Z" title="发表于 2021-11-25 20:36:37">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0/" title="前端基础（二）CSS基础笔记">前端基础（二）CSS基础笔记</a><time datetime="2021-11-25T10:45:45.161Z" title="发表于 2021-11-25 18:45:45">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/" title="前端基础（一）JavaScript基础笔记（下）">前端基础（一）JavaScript基础笔记（下）</a><time datetime="2021-11-25T10:44:17.432Z" title="发表于 2021-11-25 18:44:17">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Python 基础笔记">Python 基础笔记</a><time datetime="2021-11-25T10:40:15.008Z" title="发表于 2021-11-25 18:40:15">2021-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Tencent Cloud</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'Wanghui-Huang/gittalk')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>