<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深度学习基础（三）OpenCV | royhuang's blog</title><meta name="keywords" content="OpenCV"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OpenCV一、初识OpenCV使用以下命令可以一键安装 OpenCV ： 1conda install -c menpo opencv  1.1 环境搭建 简单测试是否搭建成功OpenCV： 1234567891011import cv2 as cv# 1.测试打开图片src &#x3D; cv.imread(&quot;C:&#x2F;Users&#x2F;86151&#x2F;Pictures&#x2F;1571142354306.png&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="深度学习基础（三）OpenCV">
<meta property="og:url" content="http://example.com/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89OpenCV/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="OpenCV一、初识OpenCV使用以下命令可以一键安装 OpenCV ： 1conda install -c menpo opencv  1.1 环境搭建 简单测试是否搭建成功OpenCV： 1234567891011import cv2 as cv# 1.测试打开图片src &#x3D; cv.imread(&quot;C:&#x2F;Users&#x2F;86151&#x2F;Pictures&#x2F;1571142354306.png&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/about-bg.jpg">
<meta property="article:published_time" content="2021-11-25T09:08:54.544Z">
<meta property="article:modified_time" content="2021-11-25T10:49:36.380Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="OpenCV">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/about-bg.jpg"><link rel="shortcut icon" href="/img/cat.jpg"><link rel="canonical" href="http://example.com/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89OpenCV/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深度学习基础（三）OpenCV',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-25 18:49:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/about-bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深度学习基础（三）OpenCV</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T09:08:54.544Z" title="发表于 2021-11-25 17:08:54">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-25T10:49:36.380Z" title="更新于 2021-11-25 18:49:36">2021-11-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/OpenCV/">OpenCV</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深度学习基础（三）OpenCV"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="一、初识OpenCV"><a href="#一、初识OpenCV" class="headerlink" title="一、初识OpenCV"></a>一、初识OpenCV</h2><p>使用以下命令可以一键安装 <em>OpenCV</em> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c menpo opencv</span><br></pre></td></tr></table></figure>

<h3 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h3><p><img src="https://i.loli.net/2021/11/25/bIr8YQXkGJ6gVqD.png" alt="1574252314095"></p>
<p>简单测试是否搭建成功OpenCV：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.测试打开图片</span></span><br><span class="line">src = cv.imread(<span class="string">&quot;C:/Users/86151/Pictures/1571142354306.png&quot;</span>)</span><br><span class="line"><span class="comment"># 打开一个名为“test”的窗口（不知道有什么用？）</span></span><br><span class="line">cv.namedWindow(<span class="string">&quot;test&quot;</span>,cv.WINDOW_AUTOSIZE) </span><br><span class="line"><span class="comment"># 打开指定路径图片</span></span><br><span class="line">cv.imshow(<span class="string">&quot;111&quot;</span>,src)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)    <span class="comment"># 等待用户输入关闭图片，这里好像任意键关闭</span></span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello opencv!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-图像加载和保存"><a href="#1-2-图像加载和保存" class="headerlink" title="1.2 图像加载和保存"></a>1.2 图像加载和保存</h3><h4 id="1-2-1-图片：读取-基本属性"><a href="#1-2-1-图片：读取-基本属性" class="headerlink" title="1.2.1 图片：读取+基本属性"></a>1.2.1 图片：读取+基本属性</h4><blockquote>
<p>显示图片同时打印一些基本信息。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.读取图片：中文路径好像会报错</span></span><br><span class="line"></span><br><span class="line">imageSrc = <span class="string">r&quot;C:/Users/86151/Pictures/1571142354306.png&quot;</span></span><br><span class="line">image = cv.imread(imageSrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图片和基本信息</span></span><br><span class="line">cv.imshow(<span class="string">&quot;hwh&quot;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(image))      <span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(image.shape)      <span class="comment"># (278, 1068, 3),依次对应：宽、高、通道数</span></span><br><span class="line"><span class="built_in">print</span>(image.size)       <span class="comment"># 890712 = 278*1068*3</span></span><br><span class="line"><span class="built_in">print</span>(image.dtype)      <span class="comment"># uint8,每个像素基本单元？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">cv.imwrite(<span class="string">&quot;D:/result.png&quot;</span>,image)</span><br></pre></td></tr></table></figure>

<p>图片使用 <code>cv.imread</code> 读取后三位 <code>numpy</code> 数组，例如 <em>image[0,0,0]</em>  索引第一个像素值。</p>
<blockquote>
<p>栗子1：将图片RGB三通道进行拆分、合并分别展示。</p>
</blockquote>
<p>首先我们可以利用 <code>cv.split()</code> 将图片进行分隔：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># cv.split：将图片分割为BGR三通道</span></span><br><span class="line">b,g,r = cv.split(image)</span><br><span class="line">cv.imshow(<span class="string">&#x27;r&#x27;</span>,r)</span><br><span class="line">cv.imshow(<span class="string">&#x27;g&#x27;</span>,g)</span><br><span class="line">cv.imshow(<span class="string">&#x27;b&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv.merge：合并成RGB（不是BGR）图像</span></span><br><span class="line">rgb = cv.merge([r,g,b])</span><br><span class="line">cv.imshow(<span class="string">&#x27;rgb&#x27;</span>,rgb)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/25/V71ksgqUWHA9Cez.png" alt="1574600332445"></p>
<h5 id="其它：numpy创建图片"><a href="#其它：numpy创建图片" class="headerlink" title="其它：numpy创建图片"></a>其它：numpy创建图片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一张三通道黑色图片：255*255*3</span></span><br><span class="line"></span><br><span class="line">image = np.zeros((<span class="number">255</span>,<span class="number">255</span>,<span class="number">3</span>),np.uint8)  <span class="comment"># 每个像素值都占一个字节（0-255）</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;black&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/25/d8hWpZBnLGDTJmz.png" alt="1574604545562"></p>
<h4 id="1-2-2-视频：读取"><a href="#1-2-2-视频：读取" class="headerlink" title="1.2.2 视频：读取"></a>1.2.2 视频：读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.视频</span></span><br><span class="line"><span class="comment"># VideoCapture：指定视频路径，不指定（参数=0）则是打开自带摄像头</span></span><br><span class="line">capture = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    ret,frame = capture.read()</span><br><span class="line">    <span class="comment"># cv.flip: 使图像镜像颠倒，恢复正常</span></span><br><span class="line">    frame = cv.flip(frame,<span class="number">1</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;video&quot;</span>,frame)</span><br><span class="line">    <span class="comment"># cv.waitKey:每处理一帧都等待50ms，同时当按下ESC(ASCII=27)退出</span></span><br><span class="line">    c = cv.waitKey(<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">if</span> c==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-色彩空间"><a href="#1-3-色彩空间" class="headerlink" title="1.3 色彩空间"></a>1.3 色彩空间</h3><blockquote>
<p>该部分主要参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/renhaofan/article/details/82632132">图像色彩空间总结</a></p>
</blockquote>
<h4 id="1-3-1-色彩空间初识"><a href="#1-3-1-色彩空间初识" class="headerlink" title="1.3.1 色彩空间初识"></a>1.3.1 色彩空间初识</h4><ul>
<li><p>图像通道</p>
<p>从数学方式理解，一张图片是一个数值矩阵。如果有<code>n</code> 个通道，则指按*<u>不同方式</u>* 可分解成 <code>n</code> 个同大小、不同数值矩阵之和。</p>
<p>如下三通道<code>RGB</code> ，可将原始彩色图片 —&gt; 分解成 <code>RGB</code> 三通道：</p>
<p><img src="https://i.loli.net/2021/11/25/GUk5yzM9HCjRTJw.jpg" alt="è¿éåå¾çæè¿°"></p>
<ul>
<li><code>RGB</code> 三个分量 R、G、B取值大小在 <code>[0,255]</code> 之间。</li>
</ul>
</li>
</ul>
<p>常用色彩空间有：BGR、RGB、GRAY、RGB、HSV、YUV 等</p>
<h4 id="1-3-2-色彩空间转换"><a href="#1-3-2-色彩空间转换" class="headerlink" title="1.3.2 色彩空间转换"></a>1.3.2 色彩空间转换</h4><p>简单使用如下代码可以进行不同色彩空间的转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4.色彩空间转换</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&quot;standingCat&quot;</span>,image)</span><br><span class="line"><span class="comment"># 转换为GRAY</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&quot;gray&quot;</span>,gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为RGB</span></span><br><span class="line">RGB = cv.cvtColor(image,cv.COLOR_BGR2RGB)</span><br><span class="line">cv.imshow(<span class="string">&quot;RGB&quot;</span>,RGB)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="HSV空间颜色三通道范围"><a href="#HSV空间颜色三通道范围" class="headerlink" title="HSV空间颜色三通道范围"></a>HSV空间颜色三通道范围</h5><p><img src="https://i.loli.net/2021/11/25/SBized3gEqH15Db.png" alt="1574652309707"></p>
<blockquote>
<p>栗子 1：将视频中红色转换为 –&gt;白色突出显示，其余颜色都是黑色便于跟踪。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/nP6tOK9l5bpaXWu.png" alt="1574652931443"></p>
<ul>
<li>在图像处理中，通常不会直接对<code>RGB</code>图像做处理，因为<code>RGB</code>和人类视觉相差较远。故下面代码将每一帧都转换到 <code>HSV</code> 色彩空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.视频色彩空间转换</span></span><br><span class="line">capture = cv.VideoCapture(<span class="string">&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = capture.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">False</span>:    <span class="comment"># 判断视频流是否读取完毕</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换到hsv色彩空间，返回hsv帧</span></span><br><span class="line">    hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># 设置黑色像素三通道值阀值范围</span></span><br><span class="line">    <span class="comment"># 将hsv帧转换为二值化mask帧</span></span><br><span class="line">    lower_hsv = np.array([<span class="number">0</span>,<span class="number">43</span> ,<span class="number">46</span>])     <span class="comment"># 设置红色最低三通道值（在hsv色彩空间）</span></span><br><span class="line">    upper_hsv = np.array([<span class="number">10</span>,<span class="number">255</span>,<span class="number">255</span>])   <span class="comment"># 设置红色最高三通道值（在hsv色彩空间）</span></span><br><span class="line">    mask = cv.inRange(hsv,lowerb=lower_hsv,upperb=upper_hsv)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示原始视频</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">0</span>)        <span class="comment"># 第二参数不明</span></span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">900</span>,<span class="number">600</span>) <span class="comment"># 设置窗口大小</span></span><br><span class="line">    cv.imshow(<span class="string">&quot;testVideo&quot;</span>,frame)         <span class="comment"># 显示当前读取的帧</span></span><br><span class="line">    <span class="comment"># 显示mask二值化视频</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">900</span>, <span class="number">600</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;mask&quot;</span>,mask)</span><br><span class="line">    c = cv.waitKey(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-像素运算"><a href="#1-4-像素运算" class="headerlink" title="1.4 像素运算"></a>1.4 像素运算</h3><h4 id="1-4-1-基本加减乘除"><a href="#1-4-1-基本加减乘除" class="headerlink" title="1.4.1 基本加减乘除"></a>1.4.1 基本加减乘除</h4><blockquote>
<p>试分析，下面两张图片进行加减乘除得到的结果。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/s5NJvd7C2w1XPUS.png" alt="1574602887982"></p>
<p>定义基本代码：</p>
<p><img src="https://i.loli.net/2021/11/25/fksyc5Xj7ziu6qt.png" alt="1574603004141"></p>
<p><em><u>加减操作：</u></em></p>
<p><img src="https://i.loli.net/2021/11/25/9Z5643YokhaizDt.png" alt="1574603303238"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片相加</span></span><br><span class="line">add_image = cv.add(src1,src2);</span><br><span class="line"><span class="comment"># 图片相减</span></span><br><span class="line">substract_image = cv.substract(src1,src2);</span><br></pre></td></tr></table></figure>

<ul>
<li>图片相加：黑色=0，白色=255。所以src1黑色背景相加对src2没影响，而src1白色字体和src2相加会超过255被截断依旧显示Linux白色字体。</li>
<li>图片相减：背景是黑色？因为src1背景黑色-src2 &lt; 0，依旧取0故结果为黑色 ； 字体五颜六色？因为src中Linux字体是白色=255，减去src2值，变成其它颜色了。</li>
</ul>
<p><em><u>乘法操作：</u></em></p>
<p><img src="https://i.loli.net/2021/11/25/346tJMNpdylF2QB.png" alt="1574603542400"></p>
<ul>
<li>图片相乘：背景黑色？因为src1黑色=0 * 第二张图对应部分 == 0 ，还是显示黑色 ； <em><u>字体是白色周围又五颜六色？</u></em> 这是因为 src1中Linux字体周围有反锯齿，周围边缘有平滑有模糊，它周围像素值并不为0，和src2相乘后，所以最终像素值并不为0而相乘值变大了就容易显示出其它颜色。</li>
</ul>
<h4 id="14-2-MASK（掩膜）"><a href="#14-2-MASK（掩膜）" class="headerlink" title="14.2 MASK（掩膜）"></a>14.2 MASK（掩膜）</h4><blockquote>
<p>MASK掩膜，即图和掩膜按位与进行运算，筛选出感兴趣的区域。</p>
</blockquote>
<p>由于mask和原图像素值 $∈[0,255]$ ，所以定义逻辑与如下：</p>
<ul>
<li>mask和原图对应点像素值都 $&gt;0$ ，则为真，输出*<u>原图像素像素值</u>* </li>
<li>其中一个等于0，则为假，输出对于*<u>点像素值为0</u>* </li>
</ul>
<p>这样定义mask意义在于：</p>
<ul>
<li>对于自己敢兴趣的区域，mask=0，则按位与必为0（显示为黑色）</li>
<li>自己不感兴趣的区域设置 mask&gt;0 ,则依旧输出为原图像素像素值</li>
</ul>
<p>举个简单的例子：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yl_best/article/details/87877110">更多参考</a></p>
<p><img src="https://i.loli.net/2021/11/25/xZTi2sFX4A5K6rN.png" alt="1574654724727"></p>
<ul>
<li>mask只能是二维矩阵，与原图 <code>shape[:2]</code> 相同（<code>shape[:2]</code> 是 <code>1*3</code> 矩阵，当其是一维矩阵 <code>[:2]</code> 索引的是前两个数字，而非前两行！）</li>
</ul>
<h4 id="1-4-3-逻辑操作"><a href="#1-4-3-逻辑操作" class="headerlink" title="1.4.3 逻辑操作"></a>1.4.3 逻辑操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image1 = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\test1.jpg&quot;</span>)</span><br><span class="line">image2 = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\test2.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 逻辑与</span></span><br><span class="line">dst1 = cv.bitwise_and(image1,image2)</span><br><span class="line"><span class="comment"># 逻辑或</span></span><br><span class="line">dst2 = cv.bitwise_or(image1,image2)</span><br><span class="line"><span class="comment"># 取反 </span></span><br><span class="line">dst3 = cv.bitwise_not(image1)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/25/2TZqbKBXRCP1jn5.png" alt="1574651721471"></p>
<ul>
<li>上图是逻辑与结果</li>
</ul>
<h5 id="栗子1：inRang-mask"><a href="#栗子1：inRang-mask" class="headerlink" title="栗子1：inRang+mask"></a>栗子1：inRang+mask</h5><blockquote>
<p>实例：结合上节利用将图像掩膜mask，突出显示某些指定颜色变化为白色（其余为黑色）。</p>
<p>我们可以通过 <code>bitwise_and</code> ，使得突出显示的颜色为原来颜色，而非白色。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/czTDhy1HxiSaGMr.png" alt="1574653487779"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">capture = cv.VideoCapture(<span class="string">&quot;D:/hwh/uploadToGit/code/python/5_learn_pytorch/src/video1.mp4&quot;</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = capture.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">False</span>:    <span class="comment"># 视频流读取完毕</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    hsv = cv.cvtColor(frame,cv.COLOR_BGR2HSV)</span><br><span class="line">    lower_hsv = np.array([<span class="number">0</span>,<span class="number">43</span> ,<span class="number">46</span>])</span><br><span class="line">    upper_hsv = np.array([<span class="number">10</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># 在这里mask∈&#123;0,255&#125;，只有两个数字</span></span><br><span class="line">    mask =  </span><br><span class="line">    <span class="comment"># 前面两个参数原图进行相加（逻辑与不变？），然后通过掩膜mask按位与实现输出原图像素值？</span></span><br><span class="line">    dst = cv.bitwise_and(frame,frame,mask=mask)</span><br><span class="line">    <span class="comment"># 显示原始视频1</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;testVideo&quot;</span>,<span class="number">600</span>,<span class="number">400</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;testVideo&quot;</span>,frame)</span><br><span class="line">    <span class="comment"># 显示mask二值化视频2</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;mask&quot;</span>, <span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;mask&quot;</span>,mask)</span><br><span class="line">    <span class="comment"># 显示逻辑与操作视频3</span></span><br><span class="line">    cv.namedWindow(<span class="string">&quot;dst&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    cv.resizeWindow(<span class="string">&quot;dst&quot;</span>, <span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;dst&quot;</span>,dst)</span><br><span class="line">    c = cv.waitKey(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>实际上<code>原图 &amp; mask</code>输出非黑部分和 原图区别还是挺大的啊？</em></li>
</ul>
<h4 id="1-4-4-其它：对比度addWeight等"><a href="#1-4-4-其它：对比度addWeight等" class="headerlink" title="1.4.4 其它：对比度addWeight等"></a>1.4.4 其它：对比度addWeight等</h4><blockquote>
<p>有点类是<code>add</code>，也是进行图像叠加不过会设置各种权重和参数。按下公式计算结果图：</p>
<p><img src="https://i.loli.net/2021/11/25/uElpqnDHbCGT8gS.png" alt="1574668213000"></p>
<ul>
<li><em>alpha</em> ： <em>src1</em> 矩阵元素权重 ； <em>beta</em> ： <em>src2</em> 矩阵权重；<em>gamma</em> 最后各元素再相加值。</li>
</ul>
</blockquote>
<blockquote>
<p> 举例：可通过 <em>addWeighted</em> 调整图片的亮度、对比度等</p>
</blockquote>
<ul>
<li>生成一张纯0矩阵 <em>blank</em> ，那<em>beta</em>有什么用？乘上一个零矩阵不变？</li>
<li>此时 <em>alpha</em> 即可是认为是对比度（等比增大元素像素值，黑色还是黑，别的会等比变大），<em>gamma</em> 可调节亮度（值越大越白–&gt;越亮）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7.addWeight 调整对比度</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\Users\86151\Pictures\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 创建一张和原图等大纯黑图</span></span><br><span class="line">h,w,c = image.shape</span><br><span class="line">blank = np.zeros([h,w,c],dtype=image.dtype)</span><br><span class="line"><span class="comment"># 增加对比度</span></span><br><span class="line">dst = cv.addWeighted(image,<span class="number">1.2</span>,blank,<span class="number">1</span>-<span class="number">1.2</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;image&#x27;</span>,image)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/25/uOjUs86MFy1wbYl.png" alt="1574668803789"></p>
<blockquote>
<p>其它操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出图片三个通道像素均值</span></span><br><span class="line">m1 = cv.mean(src1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出图片三个通道像素均值和方差</span></span><br><span class="line">m1,dev1 = cv.meanStdDev(m1)</span><br></pre></td></tr></table></figure>

<h3 id="1-5-绘图与鼠标事件"><a href="#1-5-绘图与鼠标事件" class="headerlink" title="1.5 绘图与鼠标事件"></a>1.5 绘图与鼠标事件</h3><blockquote>
<p>该部分主要参照于：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/aollo/aolloopencv/260982">openCV-Python 中文教程</a></p>
</blockquote>
<h4 id="1-5-1-绘图"><a href="#1-5-1-绘图" class="headerlink" title="1.5.1 绘图"></a>1.5.1 绘图</h4><blockquote>
<p>以下为简单实例，绘制矩形、多边形、圆、椭圆、添加文字等</p>
</blockquote>
<img src="https://i.loli.net/2021/11/25/9KDmslWZe3uNRBt.png" width = "450" height = "250" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 1.画线</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，起始点坐标，终点坐标，线颜色，线厚度</span></span><br><span class="line">cv.line(image,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.画矩形</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，左上角坐标，右下角坐标，边颜色，边厚度</span></span><br><span class="line">cv.rectangle(image,(<span class="number">50</span>,<span class="number">50</span>),(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.画圆</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，圆心坐标，半径，边颜色，边厚度</span></span><br><span class="line"><span class="comment"># 指定边厚度=-1，则圆会向内填充</span></span><br><span class="line">cv.circle(image,(<span class="number">250</span>,<span class="number">250</span>),<span class="number">20</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.画椭圆</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，圆心坐标，(长轴，短轴)，旋转角度，椭圆弧起始角，椭圆弧终止角，颜色</span></span><br><span class="line">cv.ellipse(image,(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">30</span>,<span class="number">70</span>,<span class="number">360</span>,<span class="number">255</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.画多边形</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，多边形各点坐标，是否闭合，边颜色</span></span><br><span class="line"><span class="comment"># 指定多边形各点左边，[必须是int32]</span></span><br><span class="line">pts=np.array([[<span class="number">100</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">300</span>],[<span class="number">400</span>,<span class="number">200</span>],[<span class="number">500</span>,<span class="number">100</span>]],np.int32)</span><br><span class="line">cv.polylines(image,[pts],<span class="literal">True</span>,(<span class="number">46.46</span>,<span class="number">46</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.添加文字</span></span><br><span class="line"><span class="comment"># 参数依次意义：原图，绘制位置，字体类型，大小，颜色，粗细，类型</span></span><br><span class="line">font = cv.FONT_HERSHEY_SCRIPT_SIMPLEX</span><br><span class="line">cv.putText(image,<span class="string">&#x27;HELLO OPENCV!&#x27;</span>,(<span class="number">100</span>,<span class="number">200</span>),font,<span class="number">2</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),cv.LINE_4)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;result&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-鼠标事件"><a href="#1-5-2-鼠标事件" class="headerlink" title="1.5.2 鼠标事件"></a>1.5.2 鼠标事件</h4><blockquote>
<p>利用鼠标事件，实现对图片指定区域裁剪。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/4dDLKWimfpQekrc.png" alt="1574739798120"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9.鼠标事件</span></span><br><span class="line"><span class="comment"># 1.创建回调函数：draw_circle(event,x,y,flags,param)</span></span><br><span class="line"><span class="comment"># 2.绑定回调函数&amp;窗口：setMouseCallback(&#x27;window&#x27;,draw_circle)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span></span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line">    <span class="comment"># 触发左键按下事件：EVENT_LBUTTONDOWN</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        ix,iy = x,y      <span class="comment"># 获取左键按下初始坐标</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        cv.rectangle(image,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;crop&#x27;</span>,image[iy:y,ix:x])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 未解决：用鼠标移动+拖拽事件来判断，会每次移动画一个矩形，最后出现很多矩形</span></span><br><span class="line">    <span class="comment"># 已画的矩形又无法清除</span></span><br><span class="line">    <span class="comment"># 触发鼠标移动 &amp; 左键拖拽事件</span></span><br><span class="line">    <span class="comment"># elif event==cv.EVENT_MOUSEMOVE and flags==cv.EVENT_FLAG_LBUTTON:</span></span><br><span class="line">        <span class="comment"># if drawing == True:</span></span><br><span class="line">    <span class="comment"># elif event==cv.EVENT_LBUTTONUP:</span></span><br><span class="line">        <span class="comment"># drawing = False</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;img&#x27;</span>,draw_circle)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 放在循环里，一直显示？</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;img&#x27;</span>, image)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h2 id="二、进击！openCV！"><a href="#二、进击！openCV！" class="headerlink" title="二、进击！openCV！"></a>二、进击！openCV！</h2><h3 id="2-1-ROI与泛洪填充"><a href="#2-1-ROI与泛洪填充" class="headerlink" title="2.1 ROI与泛洪填充"></a>2.1 ROI与泛洪填充</h3><p>简单来说：获取感兴趣区域ROI对它进行指定方式填充。</p>
<blockquote>
<p>例子：截取指定区域，转换为GRAY图像并覆盖原图相同区域</p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/eMsYPv3uXV5mK7a.png' width='20%' hight='20%'/>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ROI与填充</span></span><br><span class="line"><span class="comment"># 该例子分为三个部分：</span></span><br><span class="line"><span class="comment"># 1.实现指定图片对其进行部分截图</span></span><br><span class="line"><span class="comment"># 2.将截图部分转换为灰色，并覆盖原图相同区域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop_trans_Img</span>(<span class="params">event,x,y,flags,param</span>):</span></span><br><span class="line">    <span class="keyword">global</span> x0,y0,x1,y1</span><br><span class="line">    <span class="comment"># 触发左键按下事件：EVENT_LBUTTONDOWN</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        x0,y0 = x,y      <span class="comment"># 获取左键按下时初始坐标</span></span><br><span class="line">    <span class="comment"># 触发左键抬起事件：EVENT_LBUTTONUP，裁剪指定区域图片并转换为灰度图</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        x1,y1 = x, y</span><br><span class="line">        <span class="comment"># 指定裁剪区域</span></span><br><span class="line">        cv.rectangle(image,(x0,y0),(x1,y1),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 获取裁决区域图</span></span><br><span class="line">        crop = image[y0:y1,x0:x1]</span><br><span class="line">        <span class="comment"># 裁剪区域转换为灰度图Gray</span></span><br><span class="line">        gray_crop = cv.cvtColor(crop,cv.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 将[灰度图--&gt; BGR图] --&gt; 覆盖原图指定区域 </span></span><br><span class="line">        image[y0:y1, x0:x1] = cv.cvtColor(gray_crop,cv.COLOR_GRAY2BGR)</span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;img&#x27;</span>,crop_trans_Img)  <span class="comment"># img窗口绑定回调函数</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;img&#x27;</span>, image)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-FloodFill：泛洪填充"><a href="#2-1-1-FloodFill：泛洪填充" class="headerlink" title="2.1.1 FloodFill：泛洪填充"></a>2.1.1 FloodFill：泛洪填充</h4><p>定义，<code>floodFill(image,mask,seePoint,newVal,rect,loDiff,upDiff,scalar,flags)</code> :</p>
<p><img src="https://i.loli.net/2021/11/25/uitUnyW7P4TkvcV.png" alt="1574757962010"></p>
<ul>
<li><p>mask：必须宽高比原图大2像素；对不想填充区域设置为<em><strong>非零值</strong></em>，则不被填充（为原像素值）</p>
<ul>
<li>即mask &gt; 0 区域依旧表现为原图像素值；mask = 0 ，则会被指定填充（前面讲mask=0，值=0，即黑色，和这有点不同的）</li>
</ul>
</li>
<li><p>loDiff、upDiff：定义指定视为连通可被填充像素值范围（彩色还要设置三通道这种低、高Diff）</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574758099832.png" alt="1574758099832"></p>
</li>
<li><p>flags：填充方法选择，一般彩色图片选择<code>cv.FLOODFILL_FIXED_RANGE</code> ；还有可以选择<code>cv.FLOODFILL_FIXED_MASK_ONLY</code> 好像是只填充mask=0区域？？？？ </p>
</li>
</ul>
<blockquote>
<p>利用mask，实现对指定区域进行泛洪填充。</p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/se3S61jqwY4OkrB.png' width='30%' hight='30%'/>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">copyImg = image.copy()</span><br><span class="line">h,w = copyImg.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 设置mask，对于想感兴趣的区域设置0</span></span><br><span class="line">mask = np.ones([h+<span class="number">2</span>,w+<span class="number">2</span>],np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">800</span>,<span class="number">200</span>:<span class="number">700</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># 进行泛洪填充</span></span><br><span class="line">cv.floodFill(copyImg,mask,(<span class="number">250</span>,<span class="number">250</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>),cv.FLOODFILL_FIXED_RANGE)</span><br><span class="line">cv.imshow(<span class="string">&#x27;flood&#x27;</span>,copyImg)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-2-模糊操作"><a href="#2-2-模糊操作" class="headerlink" title="2.2 模糊操作"></a>2.2 模糊操作</h3><h4 id="2-2-1-均值模糊、中值模糊"><a href="#2-2-1-均值模糊、中值模糊" class="headerlink" title="2.2.1 均值模糊、中值模糊"></a>2.2.1 均值模糊、中值模糊</h4><ul>
<li><p>均值模糊</p>
<ul>
<li><p>作用：对随机噪声有很好去噪效果</p>
</li>
<li><p>实现：通过指定$size=(h,w)$的全<code>1</code>卷积核，计算新像素值 = $\frac{(h,w)范围像素线性加权}{h*w}$</p>
</li>
<li><p><em>API</em>：<code>blur(src,dst,ksize,anchor=Point(-1,-1), borderType=BORDER_DEFAULT )</code> </p>
<p><img src="https://i.loli.net/2021/11/25/RymJiOhBEF4GVnS.png" alt="1574773303111"></p>
</li>
</ul>
</li>
<li><p>中值模糊</p>
<ul>
<li><p>作用：对椒盐噪声有很好去噪效果</p>
</li>
<li><p>实现：指定长宽相同$size=(h,h)$卷积核， 在对图像进行卷积过程中，将卷积核区域内像素值从小–&gt;大排序，取中值像素作为整个区域像素值。</p>
</li>
<li><p><em>API</em> : <code>medianBlur( src,dst,ksize )</code></p>
<p><img src="https://i.loli.net/2021/11/25/pkAMODVd8UByPI9.png" alt="1574773609673"></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例1：调用openCV的API来实现均值模糊，中值模糊。</p>
</blockquote>
<p><u><em>注：实际上好像下面都没有指定参数 <code>dst</code> 啊？</em></u></p>
<p><img src="https://i.loli.net/2021/11/25/qv3oRngJF16sK7k.png" alt="1574773707893"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;orign&#x27;</span>,image)</span><br><span class="line"><span class="comment"># 均值模糊</span></span><br><span class="line">avgBlurImg = cv.blur(image,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">cv.imshow(<span class="string">&#x27;avgBlur&#x27;</span>,avgBlurImg)</span><br><span class="line"><span class="comment"># 中值模糊</span></span><br><span class="line">medianBlurImg = cv.medianBlur(image,<span class="number">5</span>)  <span class="comment"># 必须是方阵，只指定一个数字即可</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;medianBlur&#x27;</span>,medianBlurImg)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例2：自定义卷积核实现均值滤波。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义卷积核实现均值滤波</span></span><br><span class="line">kernel = np.ones([<span class="number">5</span>,<span class="number">5</span>],np.float32)/<span class="number">25</span></span><br><span class="line">autoAvgImg = cv.filter2D(image,-<span class="number">1</span>,kernel=kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;aotuAvgImg&#x27;</span>,autoAvgImg)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>效果和调用<em>API</em> 一样。</p>
<h4 id="2-2-2-高斯模糊"><a href="#2-2-2-高斯模糊" class="headerlink" title="2.2.2 高斯模糊"></a>2.2.2 高斯模糊</h4><blockquote>
<p>和前均值模糊一样，也是进行卷积。只不过高斯模糊的卷积核附和高斯分布而已。</p>
</blockquote>
<p>高斯分布（又为正态分布）：</p>
<p><img src="https://i.loli.net/2021/11/25/46ptzCUW2AfDGhN.png" alt="1574775578169"></p>
<p>高斯模糊</p>
<ul>
<li><p>作用：对高斯噪声有较好处理效果</p>
</li>
<li><p><em>API</em> :  <code>GaussianBlur(src,ksize,sigmaX,dst,sigmaY,borderType: Any = None)</code> </p>
<p><img src="https://i.loli.net/2021/11/25/mWeGU7pEQR4Zwj6.png" alt="1574777588431"></p>
</li>
</ul>
<blockquote>
<p>实例1：简单调用接口实现对图片的高斯模糊。</p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/bxfuykT3GnI95Jv.png' width='40%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 13.高斯模糊</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"><span class="comment"># GaussianBlur:调用高斯模糊</span></span><br><span class="line"><span class="comment"># x标准差=sigmax=15，卷积核大小设置为0则会根据sigmax自动计算</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">0</span>,<span class="number">0</span>),<span class="number">15</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;guassian image&#x27;</span>,GaussianImg)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例2：利用高斯模糊对高斯噪声进行处理。</p>
</blockquote>
<p>可发现高斯噪声对高斯模糊产生结果没什么影响。</p>
<img src='https://i.loli.net/2021/11/25/wdhTGjnM1vgut3K.png' width='60%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 14.高斯模糊对高斯噪声进行处理</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给图片加上高斯噪声</span></span><br><span class="line">h,w,c = image.shape</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="comment"># 生成高斯随机噪声像素值</span></span><br><span class="line">        <span class="comment"># loc:概率分布的均值；scale：概率分布标准差；size：输出的shape，默认输出一个</span></span><br><span class="line">        <span class="comment"># 例如正态分布（μ=0,σ=1 ） == random.normal(loc=0, scale=1, size)</span></span><br><span class="line">        s = np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">20</span>,size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取BGR三个通道对应像素值</span></span><br><span class="line">        b = image[row,col,<span class="number">0</span>]</span><br><span class="line">        g = image[row,col,<span class="number">1</span>]</span><br><span class="line">        r = image[row,col,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给每个像素点加上高斯噪声生成的像素值</span></span><br><span class="line">        image[row, col, <span class="number">0</span>] = (b + s[<span class="number">0</span>]) % <span class="number">255</span></span><br><span class="line">        image[row, col, <span class="number">1</span>] = (g + s[<span class="number">1</span>]) % <span class="number">255</span></span><br><span class="line">        image[row, col, <span class="number">2</span>] = (r + s[<span class="number">2</span>]) % <span class="number">255</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;Guassian noise&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯模糊对高斯噪声图片进行处理</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">0</span>,<span class="number">0</span>),<span class="number">15</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;GaussianImg&#x27;</span>,GaussianImg)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-EPF模糊：高斯双边、均值偏移"><a href="#2-2-3-EPF模糊：高斯双边、均值偏移" class="headerlink" title="2.2.3  EPF模糊：高斯双边、均值偏移"></a>2.2.3  EPF模糊：高斯双边、均值偏移</h4><blockquote>
<p>EPF，即边缘保留滤波。常用有基于高斯双边和均值偏移。</p>
</blockquote>
<p>我们知道，在前 <em><u>高斯模糊</u></em>  只考虑了空间分布，而没有像素之间差异问题：</p>
<ul>
<li>如果像素差异很大，说明实现显著特征，我们应该将它进行平滑吗？</li>
</ul>
<p>显然是不应该的，而且往往在 <em><u>图像边缘</u></em> 出现像素差异变大。在openCV中提供了：*<u>高斯双边、均值漂移</u>*  来实现边缘保留。</p>
<h5 id="高斯双边模糊"><a href="#高斯双边模糊" class="headerlink" title="高斯双边模糊"></a>高斯双边模糊</h5><blockquote>
<p>高斯双边美颜效果杠杠的。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/25/B3WngPioprZ9cTz.png" alt="1574824190173"></p>
<ul>
<li><p>上述是高斯双边模糊原理图（没太明白）</p>
</li>
<li><p><em>API</em> : <code>cv.bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]])</code></p>
<p><img src="https://i.loli.net/2021/11/25/jJrgBbRcvCSFeK3.png" alt="1574824773446"></p>
<ul>
<li><code>d</code> : 滤波器大小，$d&gt;5$ 执行效率低，一般取$d=5$； $d≤0$ 时由 <em>sigmaSpace</em>确定且成正比</li>
<li><code>sigmaColor</code> ：值越大，交界处即边缘越模糊</li>
<li><code>sigmaSpace</code> ：值越大，即颜色平均的地方越模糊</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个简单测试：利用高斯双边模糊把刘欣变得更美美的。</p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/XDPjQeN7c2UTEfg.png' width = '30%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 15.高斯双边模糊</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># d=0,由sigamColor确定；sigamColor=100 ；sigamSpace=15</span></span><br><span class="line"><span class="comment"># 好像又略过了dst参数啊？？</span></span><br><span class="line">lx_beautiful = cv.bilateralFilter(image,<span class="number">0</span>,<span class="number">100</span>,<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;lx_beautiful&quot;</span>,lx_beautiful)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="均值飘移模糊"><a href="#均值飘移模糊" class="headerlink" title="均值飘移模糊"></a>均值飘移模糊</h5><blockquote>
<p>也能保留边缘，但是更类似于卡通效果。</p>
</blockquote>
<p>均值飘移模糊：</p>
<ul>
<li><p>原理：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dcrmg/article/details/52705087"><em><u>又是什么色彩聚类平滑滤波，结合泛洪填充可以进行图像分割？</u></em> </a></p>
<img src='https://i.loli.net/2021/11/25/sLeAD95YmkgiIBp.png' width='30%'></li>
<li><p><em>API</em> : <code>pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]])</code> </p>
<p><img src="https://i.loli.net/2021/11/25/BJUCYFaMWoPH6ke.png" alt="1574825777384"></p>
<ul>
<li><code>sp、sr</code> ： 值越大，则图像色彩平滑效果越好，但耗时也越多。</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单测试：均值漂移把刘欣变得..</p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/84XkwohlKcdUWFt.png' width = '30%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 15.均值漂移模糊</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">lx_beautiful = cv.pyrMeanShiftFiltering(image,<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;lx_beautiful&quot;</span>,lx_beautiful)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-3-图像直方图"><a href="#2-3-图像直方图" class="headerlink" title="2.3 图像直方图"></a>2.3 图像直方图</h3><p>图像直方图：</p>
<ul>
<li><p>意义：直方图是图像 <em><u>像素强度</u></em> 分布的图形表达方式，统计每一个强度值所具有的像素个数。</p>
<p>例如下列灰度直方图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14312364-74ec7304573d1830.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p>
<ul>
<li>$x$ 轴代表灰度值（0-255） ； $y$ 轴代表同一个灰度值点的数目。</li>
<li><em><strong><u>彩色图像如何设置直方图？</u></strong></em> 三个通道值还是$∈[0,255]$ ,那么分别统计各个不同通道相同像素值就好了。</li>
</ul>
</li>
</ul>
<p>常用一些术语：</p>
<ul>
<li><p><em>range</em>：每个特征空间的取值范围，例如 range=[0,255]</p>
</li>
<li><p><em>bin</em>：直条或组距，表示每个特征子空间的段的数目</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/11/25/AxFj3eKaPo4hYNV.png" alt="1574826886242"></p>
<ul>
<li><p><em><strong>下面图像14位是什么意思，为什么会有 $2^{14}$ 不同像素值，不是只会 $∈[0,255]$  ?</strong></em> </p>
<p>这里指得应该是图像大小=14，然后灰度图会有 $14*14$ 个像素点。</p>
</li>
</ul>
<h4 id="2-3-1-实例：直方图初应用"><a href="#2-3-1-实例：直方图初应用" class="headerlink" title="2.3.1 实例：直方图初应用"></a>2.3.1 实例：直方图初应用</h4><p>下面我们分别介绍两个<em>API</em> 来计算图像 <em>直方图</em> 和 <em>直方折线图</em> ：</p>
<ul>
<li><p><code>matplotlib::plt.hist()</code> 计算直方图</p>
<p><img src="https://i.loli.net/2021/11/25/Ll3TWOYoNtjP9Ap.png" alt="1574857367339"></p>
<ul>
<li><code>x </code> ：数组，必须是(n,)数组，<u><em>所以图像要用 <code>image.ravel()</code> 函数进行降维</em></u></li>
<li><code>bins</code> ：指定bin个数</li>
<li><code>range</code> ： 显示的区间</li>
</ul>
</li>
<li><p><code>cv.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]])</code> </p>
<p>返回的是一个数组(<em>histSize</em>,1)，统计了指定 <em>histSize</em> 的像素强度统计个数。</p>
<p><img src="https://i.loli.net/2021/11/25/rRIDA8Cq3jkWHM9.png" alt="1574859087175"></p>
</li>
</ul>
<blockquote>
<p>实例1：利用<code>matplotlib::plt.hist()</code>绘制出图像不同像素强度统计数直方图 </p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/wkhRQfCK8WI3oGX.png' width='50%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 16.直方图</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line"><span class="comment"># image.ravel()将原图640*640*3维度降为一维 2288000=640*640*3</span></span><br><span class="line"><span class="comment"># 注意这里是256不是255</span></span><br><span class="line">plt.hist(image.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例2：利用 <em>cv.calcHist()</em> 统计指定图像和通道的各个像素强度个数。</p>
</blockquote>
<img src='https://i.loli.net/2021/11/25/xfe927VqhmoylNO.png' width='50%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 17.绘制直方折线图？</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">color = (<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;red&#x27;</span>)  <span class="comment"># 三个通道各个像素统计折线不同颜色</span></span><br><span class="line"><span class="keyword">for</span> i,color <span class="keyword">in</span> <span class="built_in">enumerate</span>(color):</span><br><span class="line">    hist =cv.calcHist([image],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(hist,color=color)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-直方图应用"><a href="#2-3-3-直方图应用" class="headerlink" title="2.3.3 直方图应用"></a>2.3.3 直方图应用</h4><h5 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h5><blockquote>
<p>直方图均衡化：利用图像直方图 <em><u>对比度进行调整</u></em> 的方法。可参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/my-love-is-python/p/10405811.html">这篇文章</a></p>
</blockquote>
<ul>
<li><p>原理：待补充</p>
</li>
<li><p><em>API ：</em></p>
<p><em><u>直方图均衡化 ：</u></em> <em>cv.equalizeHist(src[, dst])</em> </p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574862327976.png" alt="1574862327976"></p>
<p><em><u>局部直方图均衡化：</u></em>  <em>cv2.createCLAHA(clipLimit=8.0, titleGridSize=(8, 8))</em>  </p>
<ul>
<li><em>clipLimit</em> ：颜色对比度的阈值</li>
<li><em>titleGridSize</em> ：进行像素均衡化的网格大小，即在多少网格下进行直方图的均衡化操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例1：通过直方图均衡化提升图像质量。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574862416340.png' width='50%'>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 18.直方图均衡化</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原图转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin_gay&#x27;</span>,gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图均衡化只能是灰度图，如果是彩色图？不能？</span></span><br><span class="line">dst = cv.equalizeHist(gray)</span><br><span class="line">cv.imshow(<span class="string">&#x27;equalHistImg&#x27;</span>,dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例2：局部图直方图均衡化，解决全局的均衡化整体亮度提升使得局部图像的细节变得模糊。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574863177058.png' width='50%'>

<ul>
<li><p>好像这张图不能体现局部直方图均衡化可以保留更多细节？下面这张图最右侧局部均衡化显然保存的人脸更多细节：</p>
<img src='https://img2018.cnblogs.com/blog/1396837/201902/1396837-20190220120341669-1864417603.png' width='80%'></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 19.局部直方图均衡化</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原图转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 显示全局均衡化图像</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;hist&#x27;</span>,cv.equalizeHist(gray))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化自适应直方图均衡化系数</span></span><br><span class="line">clahe = cv.createCLAHE(<span class="number">5.0</span>,(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">dst = clahe.apply(gray)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;clahe&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h5 id="直方图比较"><a href="#直方图比较" class="headerlink" title="直方图比较"></a>直方图比较</h5><blockquote>
<p>手动创建图像直方图方法 <code>create_rgb_hist</code> 没有太明白？</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574865114095.png" alt="1574865114095"></p>
<h5 id="直方图反向投影"><a href="#直方图反向投影" class="headerlink" title="直方图反向投影"></a>直方图反向投影</h5><blockquote>
<p>该小节例子使用的范围归一化到[0,255]，而不是一值归一化。可查看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37764129/article/details/82313507">OpenCV中矩阵的归一化</a></p>
</blockquote>
<ul>
<li><p>作用：用于图像分割或查找图像中感兴趣的对象</p>
</li>
<li><p>归一化:<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574910939514.png" alt="1574910939514"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574910983214.png" alt="1574910983214"></p>
</li>
<li><p>计算反向直方图：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574911073204.png" alt="1574911073204"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574911113101.png" alt="1574911113101"></p>
</li>
</ul>
<blockquote>
<p>实例1：计算二维直方图并显示。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574913199543.png' width='30%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 20.显示hsv二维直方图</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"><span class="comment"># 计算直方图反向投影先转换到hsv色彩空间(?)</span></span><br><span class="line">hsv = cv.cvtColor(image,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># hsv，因为亮度(v)很容易受到外界影响，所以我们认为颜色本质是hsv，h∈[0,180],v∈[0,256]</span></span><br><span class="line">hist = cv.calcHist([hsv],[<span class="number">0</span>,<span class="number">1</span>],<span class="literal">None</span>,[<span class="number">180</span>,<span class="number">256</span>],[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">cv.imshow(<span class="string">&#x27;hist2D&#x27;</span>,hist)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例2：提取刘欣头发为感兴趣区域，进行反向直方图投影。</p>
</blockquote>
<p>:warning: 经过测试感兴趣区域应该是一类颜色，而不应该是整个脸什么的？</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574912802828.png' width='50%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 21.直方图反向投影</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取roi图像并转换到hsv色彩空间</span></span><br><span class="line">roi = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx_roi2.jpg&quot;</span>)</span><br><span class="line">roi_hsv = cv.cvtColor(roi,cv.COLOR_BGR2HSV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;roi&#x27;</span>,roi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取目标图像并转换到hsv色彩空间</span></span><br><span class="line">target = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\testlx.jpg&quot;</span>)</span><br><span class="line">target_hsv = cv.cvtColor(target,cv.COLOR_BGR2HSV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;target&#x27;</span>,target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算roi图像直方图并[范围]归一化到[0,255]</span></span><br><span class="line"><span class="comment"># roi_hist.shape=(180,256)</span></span><br><span class="line"><span class="comment"># 如果想效果更好，可以把bin不那么细化，即bin数目调整少点：[180,256] --&gt; [32,64]</span></span><br><span class="line">roi_hist = cv.calcHist([roi_hsv],[<span class="number">0</span>,<span class="number">1</span>],<span class="literal">None</span>,[<span class="number">180</span>,<span class="number">256</span>],[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>]) </span><br><span class="line"><span class="comment"># 归一化范围至0-256，cv.NORM_MINMAX常用的线性平移缩放归一化</span></span><br><span class="line">cv.normalize(roi_hist,roi_hist,<span class="number">0</span>,<span class="number">256</span>,cv.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算反向直方图投影</span></span><br><span class="line">dst = cv.calcBackProject([target_hsv],[<span class="number">0</span>,<span class="number">1</span>],roi_hist,[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>],<span class="number">1</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-4-模板匹配"><a href="#2-4-模板匹配" class="headerlink" title="2.4 模板匹配"></a>2.4 模板匹配</h3><p>模板匹配即给定模板（<em>template</em>）在目标（<em>target</em>）中进行搜索匹配，画出锚框。</p>
<h4 id="匹配：matchTemplate"><a href="#匹配：matchTemplate" class="headerlink" title="匹配：matchTemplate"></a>匹配：matchTemplate</h4><ul>
<li><p>原理：利用模板在目标图像匹配（卷积），返回所有匹配结果矩阵<strong>A</strong></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574925776285.png" alt="1574925776285"></p>
<ul>
<li>对于<a target="_blank" rel="noopener" href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#gga3a7850640f1fe1f58fe91a2d7583695dab65c042ed62c9e9e095a1e7e41fe2773">TM_SQDIFF</a> 方法，结果矩阵<strong>A</strong> 中*<u>最小值位置</u>* 对应最佳匹配时模板图像*<u>左上角</u>* 位置</li>
<li>对于<a target="_blank" rel="noopener" href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#gga3a7850640f1fe1f58fe91a2d7583695da5be00b45a4d99b5e42625b4400bfde65">TM_CCORR</a> or <a target="_blank" rel="noopener" href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#gga3a7850640f1fe1f58fe91a2d7583695dac5babb7dfda59544e3e31ea928f8cb16">TM_CCOEFF</a> 方法，<strong>A</strong> 中*<u>最大值位置</u>* 对应最佳匹配模板图像*<u>左上角</u>* 位置</li>
</ul>
</li>
<li><p>原型：<em>cv.matchTemplate(image, templ, method[, result[, mask]])</em> </p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574925200085.png" alt="1574925200085"></p>
</li>
</ul>
<blockquote>
<p>例1：给定模板图像猫脸，在目标图像猫中画出对应模板图像位置红框。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574926159367.png' width='60%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 22.模板匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取模板图像（猫脸）</span></span><br><span class="line">template = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat_roi.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;template&#x27;</span>,template)</span><br><span class="line">th,tw = template.shape[:<span class="number">2</span>]   <span class="comment"># shape=(h,w,c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取目标图像（猫）</span></span><br><span class="line">target = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板匹配的三种方法</span></span><br><span class="line">methods = [cv.TM_SQDIFF_NORMED,cv.TM_CCOEFF_NORMED,cv.TM_CCORR_NORMED]</span><br><span class="line"></span><br><span class="line">tl = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> md <span class="keyword">in</span> methods:</span><br><span class="line">    <span class="comment"># 采用指定方法md,进行模板匹配</span></span><br><span class="line">    result = cv.matchTemplate(target,template,md)</span><br><span class="line">    <span class="comment"># minMaxLoc：返回矩阵中最小值、最大值、最小值位置，最大值位置</span></span><br><span class="line">    minVal,maxVal,minLoc,maxLoc = cv.minMaxLoc(result)</span><br><span class="line">    <span class="keyword">if</span> md == cv.TM_SQDIFF_NORMED:</span><br><span class="line">        tl = minLoc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tl = maxLoc</span><br><span class="line">    <span class="comment"># 注意右下角 = （左上角x+宽，左上角y+高）</span></span><br><span class="line">    cv.rectangle(target,tl,(tl[<span class="number">0</span>]+tw,tl[<span class="number">1</span>]+th),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">    cv.imshow(<span class="built_in">str</span>(md),target)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-图像二值化"><a href="#2-5-图像二值化" class="headerlink" title="2.5 图像二值化"></a>2.5 图像二值化</h3><blockquote>
<p>什么是图像的二值化？该部分主要参考 : <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37385726/article/details/82015545">图像二值化</a></p>
</blockquote>
<p> 一幅图像包括目标物体、背景还有噪声，要想*<u>从多值的数字图像中直接提取出目标物体</u>*，通过设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。</p>
<p>例如：将图像上的像素点的灰度值设置为0或255，整个图像呈现出明显的只有黑和白的视觉效果。</p>
<h4 id="1-hsv二值化：-inRange"><a href="#1-hsv二值化：-inRange" class="headerlink" title="1 hsv二值化： inRange"></a>1 hsv二值化： <em>inRange</em></h4><p>在之前我们还接触过 <em>inRange</em> 将图像进行二值化 ：</p>
<ul>
<li>在 <em>hsv</em> 色彩空间中，对于指定 $h_{min}-h_{max} 、s_{min}-s_{max} 、v_{min}-v_{max} $ 范围内像素值设置为白色其余为黑色。</li>
</ul>
<p>这是针对在 <em>hsv</em> 色彩空间，而下面 <em>threshold</em> 是指对 <em><u>单通道灰度图</u></em> 进行二值化。</p>
<h4 id="2-gray二值化：threshold"><a href="#2-gray二值化：threshold" class="headerlink" title="2 gray二值化：threshold"></a>2 gray二值化：<em>threshold</em></h4><p><em><u>相关API</u></em> :</p>
<ul>
<li><em>cv2.threshold(img, threshold, maxval,type)</em><ul>
<li><em>threshold</em> : 是设定的阈值</li>
<li><em>maxval</em>: 当灰度值大于（或小于）阈值时将该灰度值赋成的值</li>
<li><em>type</em> : 当前二值化的方式（<em><strong>保持原样指的是保持原图像像素值</strong></em>）</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>threshold</em> 方法针对 <em><u>单通道灰度图</u></em> ，彩色图要先转换为灰度图。</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574929809949.png" alt="1574929809949"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 23.图像二值化：threshold</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin_gray&#x27;</span>,image_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行二值化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_BINARY: 大于阈值=127，被置为255，小于阈值=127，被置为0</span></span><br><span class="line"><span class="comment"># 这里maxVal=255，是大于阈值被设置的值，而不是默认就设置为255！</span></span><br><span class="line">ret1,binary1 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">255</span>,<span class="built_in">type</span>=cv.THRESH_BINARY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_BINARY&#x27;</span>,binary1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_BINARY_INV: 和THRESH_BINARY设置相反</span></span><br><span class="line">ret2,binary2 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">255</span>,<span class="built_in">type</span>=cv.THRESH_BINARY_INV)</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_BINARY_INV&#x27;</span>,binary2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_TRUNC：大于阈值部分被置为threshold，小于部分保持原样（原图像素值）</span></span><br><span class="line"><span class="comment"># 这里及下面maxVal（0）设置不起作用，大于阈值为原图像值</span></span><br><span class="line">ret3,binary3 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">0</span>,<span class="built_in">type</span>=cv.THRESH_TRUNC )</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_TRUNC&#x27;</span>,binary3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_TOZERO：小于阈值部分被置为0，大于部分保持不变（原图像素值）</span></span><br><span class="line">ret4,binary4 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">0</span>,<span class="built_in">type</span>=cv.THRESH_TOZERO )</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_TOZERO&#x27;</span>,binary4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># THRESH_TOZERO_INV ：大于阈值部分被置为0，小于部分保持不变 （原图像素值）</span></span><br><span class="line">ret5,binary5 = cv.threshold(image_gray,<span class="number">127</span>,<span class="number">0</span>,<span class="built_in">type</span>=cv.THRESH_TOZERO_INV )</span><br><span class="line">cv.imshow(<span class="string">&#x27;THRESH_TOZERO_INV&#x27;</span>,binary5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [重要] cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分</span></span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3-gray二值化：adaptiveThreshold"><a href="#3-gray二值化：adaptiveThreshold" class="headerlink" title="3 gray二值化：adaptiveThreshold"></a>3 gray二值化：<em>adaptiveThreshold</em></h4><blockquote>
<p>该部分主要参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/GaloisY/p/11037350.html">自适应化阈值操作</a></p>
</blockquote>
<p>自适应阈值，则是根据像素的 <em><u>邻域块的像素值分布来确定该像素位置上的二值化阈值</u></em>  ：</p>
<ul>
<li>每个像素位置处的二值化阈值不是固定不变的，而是由其周围邻域像素的分布来决定的</li>
<li>亮度较高图像区域二值化阈值通常较高，而亮度低的图像区域的二值化阈值则会相适应变小</li>
<li>不同亮度、对比度、纹理的局部图像区域将会拥有相对应的局部二值化阈值</li>
</ul>
<p><em>每一个像素计算阈值过程：</em> </p>
<ul>
<li>首先该像素点周围 B*B 区域内像素加权平均（对应方法有平均值法、高斯平均两种方法）</li>
<li>最后减去一个常数C，得到该像素点的阈值</li>
</ul>
<p><em><u>相关API</u></em> :</p>
<ul>
<li><p><em>cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])</em> </p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574930068730.png" alt="1574930068730"></p>
<ul>
<li><p><em>maxValue</em> ：阈值？</p>
</li>
<li><p><em>adaptiveType</em> : 指自适应的阈值 <em>求平均值方法</em>，同上有两种可选</p>
<ul>
<li>ADAPTIVE_THRESH_MEAN_C ：先求出领域块中的均值，再减去常数C</li>
<li>ADAPTIVE_THRESH_GAUSSIAN_C：局部邻域块的高斯加权和，最后减去常数C</li>
</ul>
</li>
<li><p><em>thresholdType</em> ：阈值类型，有两种可选：THRESH_BINARY 或THRESH_BINARY_INV <em><strong>？</strong></em></p>
<p>同前，THRESH_BINARY 大于阈值置为阈值，小于阈值置为0；THRESH_BINARY_INV 相反。</p>
</li>
<li><p><em>blockSize</em>： 指定的领域块区域大小，通常为3、5、7</p>
</li>
<li><p><em>C</em> : 上面说的常数C</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例：可以看到自适应阈值化很好的保留了 <em><u>边缘信息</u></em> 。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574931630972.png' width='50%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24.自适应阈值：adaptiveThreshold</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">image_gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin_gray&#x27;</span>,image_gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自适应阈值</span></span><br><span class="line"><span class="comment"># 不知道为什么设置C=10,blockSize=5(区域大小为5*5=25)</span></span><br><span class="line">adaptive_binary = cv.adaptiveThreshold(image_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">25</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;adaptive_binary&#x27;</span>,adaptive_binary)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h4 id="4-超大图像二值化"><a href="#4-超大图像二值化" class="headerlink" title="4 超大图像二值化"></a>4 超大图像二值化</h4><blockquote>
<p>该部分主要参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ssyfj/p/9273116.html">超大图像二值化和空白过滤</a></p>
</blockquote>
<p>处理超大图像的思路其实就是分块思想：</p>
<ul>
<li>将图像分成一个个小块</li>
<li>对每个小块进行 <em>threshold</em> 、<em>adaptiveThreshold</em> 二值化操作，获取二值化图像</li>
<li>将原图（灰度图像）对应区域覆盖为上述的二值化图像</li>
</ul>
<blockquote>
<p>分别使用全局阈值/局部阈值对分块图像进行处理比较。</p>
</blockquote>
<p><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574943278597.png' width='50%'><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574943355871.png' width='50%'></p>
<ul>
<li>左侧全局阈值处理，导致每个分块之间的图像差距较大，*<u>出现分块边界</u>* 现象。</li>
<li>右侧局部阈值处理，就没有明显的分块现象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 25.超大图像二值化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">big_image_binary</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(image.shape)  <span class="comment">#(4208, 2368, 3)　　</span></span><br><span class="line">    cw,ch = <span class="number">256</span>,<span class="number">256</span></span><br><span class="line">    h,w = image.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment">#要二值化图像，要先进行灰度化处理</span></span><br><span class="line">    gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY)   </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,h,ch):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,w,cw):</span><br><span class="line">            roi = gray[row:row+ch,col:col+cw]           <span class="comment">#获取分块</span></span><br><span class="line">        <span class="comment"># 全局阈值</span></span><br><span class="line">        <span class="comment"># ret,binary = cv.threshold(roi,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU)</span></span><br><span class="line">        <span class="comment"># 局部阈值</span></span><br><span class="line">           binary = cv.adaptiveThreshold(roi,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">127</span>,<span class="number">20</span>)　　</span><br><span class="line">            gray[row:row + ch, col:col + cw] = binary　　<span class="comment">#分块覆盖</span></span><br><span class="line">            <span class="built_in">print</span>(np.std(binary),np.mean(binary))</span><br><span class="line"></span><br><span class="line">    cv.imwrite(<span class="string">&quot;binary2.jpg&quot;</span>,gray)</span><br></pre></td></tr></table></figure>

<h5 id="空白区域过滤"><a href="#空白区域过滤" class="headerlink" title="空白区域过滤"></a>空白区域过滤</h5><blockquote>
<p>简单来说就是我们认为该区域是空白图像，不进行二值化（但可全变为黑或者白）。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574943661293.png' width='40%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空白区域过滤</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">big_image_binary</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(image.shape)  <span class="comment">#(4208, 2368, 3)</span></span><br><span class="line">    cw,ch = <span class="number">128</span>,<span class="number">128</span></span><br><span class="line">    h,w = image.shape[:<span class="number">2</span>]</span><br><span class="line">    gray = cv.cvtColor(image,cv.COLOR_RGB2GRAY)   <span class="comment"># 要二值化图像，要先进行灰度化处理</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,h,ch):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,w,cw):</span><br><span class="line">            roi = gray[row:row+ch,col:col+cw]     <span class="comment"># 获取分块</span></span><br><span class="line">            <span class="comment"># 通过获取分块区域的方差和平均值来判断是否是空白区域</span></span><br><span class="line">            dev = np.std(roi)</span><br><span class="line">            avg = np.mean(roi)</span><br><span class="line">            <span class="keyword">if</span> dev &lt; <span class="number">15</span> <span class="keyword">and</span> avg &gt; <span class="number">200</span>:　　<span class="comment"># 满足条件，接近空白区域，让他变黑</span></span><br><span class="line">                gray[row:row + ch, col:col + cw] = <span class="number">0</span>    <span class="comment">#全部都赋值为0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret,binary = cv.threshold(roi,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY|cv.THRESH_OTSU)</span><br><span class="line">                gray[row:row + ch, col:col + cw] = binary</span><br><span class="line">                <span class="built_in">print</span>(np.std(binary), np.mean(binary))</span><br><span class="line"></span><br><span class="line">    cv.imwrite(<span class="string">&quot;binary.jpg&quot;</span>,gray</span><br></pre></td></tr></table></figure>



<h3 id="2-6-图像缩放"><a href="#2-6-图像缩放" class="headerlink" title="2.6 图像缩放"></a>2.6 图像缩放</h3><p>如果要进行对图像进行 <em><u>放大或缩小</u></em> 通常有以下几种方法（在openCV中提供）：</p>
<p>:warning: 以下方法都可以进行 <em><u>放大或缩小</u></em> （具体怎么实现<em><strong>缩小图像</strong></em>，还待理解）</p>
<ul>
<li>INTER_NEAREST ：最近邻插值法</li>
<li>INTER_LINEAR ： 双线性插值法（默认）</li>
<li>INTER_AREA ： 基于局部像素的重采样，*<u>缩小图像通常选择</u>* </li>
<li>INTER_CUBIC ： 基于4x4像素邻域的3次插值法</li>
<li>INTER_LANCZOS4 ： 基于8x8像素邻域的Lanczos插值</li>
</ul>
<p>在 <em>openCV</em> 中可使用以下API实现对图像缩放：</p>
<ul>
<li>简单粗暴的 <em><u>resize</u></em> 函数 ：实现效率最高</li>
<li><em>cv::pyrUP</em>  、<em>cv::pyrDown</em> ：对图像进行上采样、下采样，常用于图像金字塔中，下详</li>
</ul>
<h4 id="2-6-1-缩放：resize"><a href="#2-6-1-缩放：resize" class="headerlink" title="2.6.1  缩放：resize"></a>2.6.1  缩放：<em>resize</em></h4><p><em><u>函数原型：</u></em></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574994926873.png" alt="1574994926873"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574994942895.png" alt="1574994942895"></p>
<blockquote>
<p>实例：演示如何使用 <em>resize</em> 函数对图像进行缩放。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574995365395.png' width='50%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 26.resize</span></span><br><span class="line"><span class="comment"># image.shape = (640, 640, 3)</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(image.shape)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># resize到 512*512,采用双线性插值</span></span><br><span class="line"><span class="comment"># 彩色图虽然有三通道，但是只需指定长、宽就行</span></span><br><span class="line">resize_image = cv.resize(image,(<span class="number">512</span>,<span class="number">512</span>),interpolation=cv.INTER_LINEAR)</span><br><span class="line">cv.imshow(<span class="string">&#x27;resize_image&#x27;</span>,resize_image)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-6-2-图像金字塔：pyrUP-、pyrDown"><a href="#2-6-2-图像金字塔：pyrUP-、pyrDown" class="headerlink" title="2.6.2 图像金字塔：pyrUP  、pyrDown"></a>2.6.2 图像金字塔：<em>pyrUP</em>  、<em>pyrDown</em></h4><p>图像金字塔是一系列图像的集合，所有图像来源于同一张原始图像，通过梯次向下采样获得。</p>
<p>通常有两种类型的图像金字塔 ：</p>
<ul>
<li>高斯金字塔(<em>Gaussian pyramid</em>)：用来向下采样 </li>
<li>拉普拉斯金字塔(<em>Laplacian pyramid</em>)：用来从金字塔底层图像重建上层未采样图像，可以对图像进行最大程度的还原. </li>
</ul>
<h5 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h5><img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996706325.png' width='30%'>

<p>高斯金字塔用于下采样过程可描述如下：</p>
<ul>
<li><p>对图像进行高斯内核卷积，其中高斯内核= <img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996318946.png' width='15%'></p>
<p>:grey_question:<em>​ 这一步卷积不会缩小图像尺寸吗？</em></p>
</li>
<li><p>将所有偶数行、列去除，这样得到的图形长、宽是原图$\frac{1}{2}$ 。</p>
</li>
</ul>
<p>在openCV中提供了<em>pyrDown</em> 函数来实现下采样：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996533783.png" alt="1574996533783"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574996587500.png" alt="1574996587500"></p>
<blockquote>
<p>实例：使用高斯金字塔来缩放图像。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574997397753.png' width='40%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 27.高斯金字塔</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># resize到 512*512</span></span><br><span class="line">image = cv.resize(image,(<span class="number">512</span>,<span class="number">512</span>),interpolation=cv.INTER_AREA)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">level = <span class="number">3</span></span><br><span class="line">pyramid_imgs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level):</span><br><span class="line">    dst = cv.pyrDown(image)</span><br><span class="line">    pyramid_imgs.append(dst)</span><br><span class="line">    image = dst</span><br><span class="line">    cv.imshow(<span class="string">&#x27;L&#x27;</span>+<span class="built_in">str</span>(i),dst)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h5><p>拉普拉斯金字塔中使用了上采样，其上采样过程如下：</p>
<ul>
<li><p>将图像在每个方向上扩大为原来的两倍，新增的行和列以0填充 </p>
</li>
<li><p>使用先前同样的内核(<em><u>乘以4</u></em>)与放大后的图像卷积，或得”新增像素”的近似值 </p>
<p>:warning: 同上疑问，卷积这一步不会改变图像大小吗？那就不是放大2倍了？</p>
</li>
</ul>
<p>在openCV中提供了<em>pyrUp</em> 函数来实现上采样：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574997773700.png" alt="1574997773700"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1574997844806.png" alt="1574997844806"></p>
<p>拉普拉斯金字塔图像可不仅仅通过对图像向上采样就得到，具体操作如下：</p>
<ol>
<li><p>通过高斯金字塔得到一系列不同层级(0-L)图像G</p>
</li>
<li><p>先对最高层级图像G[L]  –&gt; 上采样(<em>pyrUp</em>)得到EP[L-1] –&gt;  G[L-1] - EP[L-1] == 拉普拉斯图L[L-1]</p>
</li>
<li><p>对次高层图像G[L-1]  –&gt; 上采样(<em>pyrUp</em>)得到EP[L-2] –&gt;  G[L-2] - EP[L-2] == 拉普拉斯图像L[L-2]</p>
</li>
<li><p>重复步骤 2-3 ，直至高斯金字塔最低层（原图第一次下采样图）</p>
</li>
</ol>
<p>显然，根据上述步骤，拉普拉斯金字塔是通过 <em><strong>源图下采样对应层级 - 上采样相应层级</strong></em> 获取。保留的残差，为图像还原做准备（:slightly_smiling_face: 此处复原不是很清楚 ）。</p>
<blockquote>
<p>实例：获取拉普拉斯金字塔图像。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575000194347.png' width='100%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 28.拉普拉斯金字塔</span></span><br><span class="line"><span class="comment"># 下面 pyramid_imgs 表示高斯金字塔下采样获得图像集合</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># 左闭右开从[2,-1)，递减选择步伐=-1</span></span><br><span class="line">    <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">        expand = cv.pyrUp(pyramid_imgs[i], dstsize=pyramid_imgs[i - <span class="number">1</span>].shape[:<span class="number">2</span>])</span><br><span class="line">        lpls = cv.subtract(pyramid_imgs[i - <span class="number">1</span>], expand)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 此时已经放大至原图大小</span></span><br><span class="line">        expand = cv.pyrUp(pyramid_imgs[i], dstsize=image.shape[:<span class="number">2</span>])</span><br><span class="line">        lpls = cv.subtract(image, expand)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&#x27;lpls&#x27;</span>+<span class="built_in">str</span>(i),lpls)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-7-图像梯度"><a href="#2-7-图像梯度" class="headerlink" title="2.7 图像梯度"></a>2.7 图像梯度</h3><blockquote>
<p>该部分主要参考清晰易懂的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/saltriver/article/details/78987096">图像梯度的基本原理</a></p>
</blockquote>
<p>我们知道用 <em>均值滤波器</em> 等 ，可以降低图像噪声，但是会使得图像变得<em><strong>模糊</strong></em>  。</p>
<p><em>Q1 : 那么模糊图像和清晰图像又是怎么区分定义的呢？</em>  </p>
<ul>
<li>图像模糊：因为图像轮廓不明显，换言之，<em>轮廓边缘灰度变化不强烈</em>   ，层次感不强。</li>
</ul>
<p>自然我们可以通过使得  <em>轮廓灰度变得强烈</em>   —&gt; 联系到 <em>图像梯度</em>  。</p>
<blockquote>
<p>那么梯度又是如何增强图像清晰度呢？</p>
</blockquote>
<p>首先我们了解下如何计算图像的梯度。</p>
<p>我们知道图像是一个离散二维函数，那么其 $x、y$ 方向梯度可定义如下：</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575017585561.png' width='70%'>

<ul>
<li>显然这就相当于 <u><em>梯度 = 2个相邻像素之间差值</em></u></li>
</ul>
<p>考虑下面这张图：左部分是图像某个X方向像素变化值，右侧部分是该像素X方向梯度值。</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575017975805.png' width='50%'>

<p>将 $ 原图X方向像素值 + 该X方向梯度 = 新图X方向像素值 $ 。</p>
<p>这样：<u>将有梯度值的相邻像素的灰度值变大了；而没有灰度值变换的像素值不变</u>。</p>
<p>特别的，我们还可以将 $x和y$方向结合来计算新图像素值。计算公式如下：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575018332263.png" alt="1575018332263"></p>
<p>一般使用拟合公式，简化计算：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575018360804.png" alt="1575018360804"></p>
<ul>
<li>$M(x,y)$ 即认为是梯度变化值，原图像像素加上该值便可获得最终新图像素值。</li>
</ul>
<h4 id="2-7-1-图像求导：Sobel、Scharr、Lapacian"><a href="#2-7-1-图像求导：Sobel、Scharr、Lapacian" class="headerlink" title="2.7.1 图像求导：Sobel、Scharr、Lapacian"></a>2.7.1 图像求导：<em>Sobel、Scharr、Lapacian</em></h4><p>OpenCV提供三种不同梯度滤波器（高通滤波器）：<em>Sobel，Scharr和 Lapacian</em> ：</p>
<ul>
<li><em>Sobel、Scharr</em> ：用于求图像一阶导或二阶导</li>
<li><em>Lapacian</em> ：求图像二阶导，对 <em>Sobel</em> 的部分优化</li>
</ul>
<h5 id="Sobel-amp-Scharr"><a href="#Sobel-amp-Scharr" class="headerlink" title="Sobel &amp; Scharr"></a><em>Sobel &amp; Scharr</em></h5><blockquote>
<p>感觉就是定义卷积核，然后进行卷积。但是不知道为什么这样可以求导。</p>
</blockquote>
<ul>
<li><p><em>Sobel</em> 算子 ：高斯平滑和微分操作的结合体，因此抗噪声能力很好</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020343752.png" alt="1575020343752"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020360960.png" alt="1575020360960"></p>
<ul>
<li><p>ddepth：指图像深度，目标图像深度必须 &gt;= 原图像深度。<code>-1</code> 表示和原图像深度一致。</p>
</li>
<li><p>dx、dy：表示求导的方向，<code>0</code> 表示这个方向不进行求导，<code>1</code> 表示有。</p>
</li>
<li><p>ksize：卷积核大小，当 <code>ksize=-1</code> ，会使用 <code>3*3</code> Scharr卷积核。它的效果比Sobel好</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020943308.png" alt="1575020943308"></p>
</li>
</ul>
</li>
<li><p><em>Scharr</em> 算子：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020830027.png" alt="1575020830027"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575020845833.png" alt="1575020845833"></p>
</li>
</ul>
<blockquote>
<p>以<em>Scharr</em> 算子为例：实现计算图像指定方向的梯度。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021141489.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 29.图像求导：Sobel、Scharr、Lapacian</span></span><br><span class="line"><span class="comment"># 演示Scharr算子求导梯度，Sobel同理</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Scharr算子对图像求导</span></span><br><span class="line"><span class="comment"># 为什么使用CV_32F？</span></span><br><span class="line"><span class="comment"># 因为Scharr算子求导后会有负值&amp;大于255值。而原图是unit8位，即8位无符号数。</span></span><br><span class="line"><span class="comment"># 所以scharr建立图像位置不够，需要使用32F有符号数据类型。</span></span><br><span class="line">grad_x = cv.Scharr(image,cv.CV_32F,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">grad_y = cv.Scharr(image,cv.CV_32F,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 经过处理后，别用convertScaleAbs()函数将其转回原来的uint8形式。</span></span><br><span class="line"><span class="comment"># 否则将无法显示图像，而只是一副灰色的窗口。</span></span><br><span class="line"><span class="comment"># dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])</span></span><br><span class="line"><span class="comment"># 可选参数alpha是伸缩系数，beta是加到结果上的一个值。结果返回uint8类型的图片</span></span><br><span class="line"></span><br><span class="line">grad_x = cv.convertScaleAbs(grad_x)</span><br><span class="line">grad_y = cv.convertScaleAbs(grad_y)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;gradx&#x27;</span>,grad_x)</span><br><span class="line">cv.imshow(<span class="string">&#x27;grady&#x27;</span>,grad_y)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>:warning: 上面图不适合演示增加图像清晰度，可看下面这张图：</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575022308411.png' width='60%'>

<ul>
<li>梯度图是$x、y$ 方向分别计算然后绝对值相加：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575022388588.png" alt="1575022388588"></li>
</ul>
<h5 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a><em>Laplacian</em> 算子</h5><ul>
<li><p>作用</p>
<p>对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用边检测。一般用来检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。</p>
</li>
<li><p>原理</p>
<p>图像中的边缘区域，像素值会发生“跳跃”，对这些像素求导，在其*<u>一阶导数极值处就是边缘</u>* 。</p>
</li>
<li><p>API</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021975153.png" alt="1575021975153"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021992549.png" alt="1575021992549"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575022025704.png" alt="1575022025704"></p>
</li>
</ul>
<blockquote>
<p>实例：利用 <em>Laplacian</em> 检测图像的边。 </p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575021699095.png' width='60%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lapacian</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">dst = cv.Laplacian(image,cv.CV_32F,ksize=<span class="number">3</span>)</span><br><span class="line">dst = cv.convertScaleAbs(dst)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;Lapacian&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-7-2-Canny边缘提取"><a href="#2-7-2-Canny边缘提取" class="headerlink" title="2.7.2 Canny边缘提取"></a>2.7.2 Canny边缘提取</h4><blockquote>
<p>该部分主要参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/techyan1990/p/7291771.html">边缘检测之Canny</a></p>
</blockquote>
<ul>
<li><p>作用：提取图像边缘</p>
</li>
<li><p>流程：详细流程算法实现参考上述文章链接</p>
<ul>
<li>使用高斯滤波器，以平滑图像，滤除噪声</li>
<li>计算图像中每个像素点的梯度强度和方向</li>
<li>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应</li>
<li>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘</li>
<li>通过抑制孤立的弱边缘最终完成边缘检测</li>
</ul>
</li>
<li><p>API </p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024048101.png" alt="1575024048101"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024063583.png" alt="1575024063583"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024028630.png" alt="1575024028630"></p>
<ul>
<li><p>threshold1、threshold2即对应阈值$T_低、T_高$：</p>
<ul>
<li>$像素值&gt;T_高$ : 被认为是边缘像素，保留</li>
<li>$ T_低&lt;像素值&lt;T_高$ :  当该像素和高于上限的像素点连接才保留</li>
<li>$像素值&lt;T_低$ : 不认为是边缘像素，舍弃</li>
</ul>
<p>一般设置 $T_高/T_低 = 3:1$  或者 $T_高/T_低 = 2:1$ </p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例：利用Canny函数进行边缘检测。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575024808495.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 30.canny边缘检测</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\standingCat.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># canny边缘检测，可以使用这种不用提供gradx、grady的API</span></span><br><span class="line">edge_detect = cv.Canny(image,<span class="number">50</span>,<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;edge detect&#x27;</span>,edge_detect)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-8-直线、圆、轮廓检测"><a href="#2-8-直线、圆、轮廓检测" class="headerlink" title="2.8 直线、圆、轮廓检测"></a>2.8 直线、圆、轮廓检测</h3><h4 id="2-8-1-直线检测：霍夫变换"><a href="#2-8-1-直线检测：霍夫变换" class="headerlink" title="2.8.1 直线检测：霍夫变换"></a>2.8.1 直线检测：霍夫变换</h4><blockquote>
<p>给定一副图像（一般是二值图像，像素值对检测直线没有作用）如何检测是否存在直线？</p>
</blockquote>
<p>一种很直观的想法：任选一对点，决定一条线，然后测试所有其他点是否接近这条线，从而得出接近这条特殊线的所有点的子集。</p>
<p>但是这种方法比较复杂，我们通常使用的 <em>霍夫变换</em> 。</p>
<p>在了解霍夫变换，我们先来了解什么是 <em><u>对偶性</u></em> 。</p>
<h5 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h5><blockquote>
<p>我所理解的对偶性：将直角坐标系的 <em><strong>点</strong></em>  对应 参数空间的 <em><strong>直线</strong></em>。</p>
</blockquote>
<p>在直角空间$x-y$，过点$A(x_0,y_0)$ 所有直线确定一簇直线，都满足方程：$y_0=k*x_0+b$ 。</p>
<p>如果转换参数空间 $k-b$ ，那么过点$A(x_0,y_0)$  <em><u>所有</u></em> 直线就可以描述为 <u><em>一条</em></u> 直线：$b=-kx_0+y_0$:</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575081721956.png' width='80%'>

<ul>
<li>在参数空间$k-b$ ，斜率是点 $A$ 横坐标 $-x_0$ , 截距是点$A$ 纵坐标 $y_0$ </li>
</ul>
<p>那么如果在直角坐标系存在多个点在同一直线$l_1(斜率=k_1,截距=b_1)$上，也就是说：它们在参数空间$k-b$ 必然会交于一点 $(k_1,b_1)$ 。</p>
<p>如果有n个点在一条直线上，那么在参数空间就会存在对应交于n个点，<em><strong>那么在参数空间相交直线最多的点$(k,b)$ , 就是我们在 $x-y$ 直角坐标对应直线斜率和截距的解 。</strong></em></p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575083039858.png' width='50%'>

<h5 id="霍夫变化-amp-参数空间选择"><a href="#霍夫变化-amp-参数空间选择" class="headerlink" title="霍夫变化&amp;参数空间选择"></a>霍夫变化&amp;参数空间选择</h5><p>上述参数空间是选择直角坐标系空间 $k-b$ , 但是这样会带来一个问题：*<u>无法检测垂直直线</u>*</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575083182037.png' width='50%'>

<p>因此我们考虑将参数空间转换到极坐标系 $r-\theta$ :</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575083284237.png' width='60%'>

<ul>
<li><p> :warning:  <em>为什么映射到极坐标是曲线？</em> 为什么给定恒等式 $xcos\theta+ysin\theta=p$ 进行变换？</p>
</li>
<li><p> 同前，在极坐标系相交最多的点$(\theta，p)$ ，便可转换到直角坐标系求解对应斜率和截距。</p>
</li>
</ul>
<p>理论上，一个点会对应无数条直线，在参数空间 $p-\theta$ 自然也是连续的。但事实上，我们会规定直线的数量，将 $\theta$ 离散化为等间距离散值，相应$p$ 也离散为等间距离散值。</p>
<p>这样，参数空间就是一个等大小*<u>网格</u>* 。当参数空间有直线相交于这个点，则网格累加器+1：</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575084392206.png' width='60%'>

<h5 id="HoughLines"><a href="#HoughLines" class="headerlink" title="HoughLines()"></a>HoughLines()</h5><p>霍夫变换，利用openCV检测图像具体流程可总结如下：</p>
<ol>
<li><p>彩色图像-&gt;灰度图</p>
</li>
<li><p>去噪（高斯核）</p>
</li>
<li><p>边缘提取（canny、sobel）</p>
<p>:warning: <u><em>Canny方法中包含计算梯度，非最大信号抑制和双阈值输出</em></u></p>
</li>
<li><p>二值化（判断此处是否为边缘点，就看灰度值==255）</p>
</li>
<li><p>映射到霍夫空间</p>
</li>
<li><p>取局部极大值，设定阈值，过滤干扰直线</p>
</li>
<li><p>绘制直线、标定角点</p>
</li>
</ol>
<p><em><u>下面代码没有进行第三步二值化，是因为 canny自带二值化吗？</u></em> <em><strong>对的</strong></em></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085636139.png" alt="1575085636139"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085651422.png" alt="1575085651422"></p>
<ul>
<li>rho：生成极坐标像素扫描步长（离散化）</li>
<li>theta：生成极坐标时扫描角度步长（离散化）</li>
<li>threshold：只有足够交点的极坐标才被认为是直线</li>
</ul>
<blockquote>
<p>实例：利用openCV &amp; 霍夫变换来检测图像直线。</p>
</blockquote>
<p><em><u>为什么检测直线图像上面总是出现这些不正常直线？</u></em></p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575087049506.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 31.霍夫变换</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\building.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 0.高斯滤波（效果也不好，最好取消这步了）</span></span><br><span class="line"><span class="comment"># image = cv.GaussianBlur(image,(3,3),0)</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.边缘检测canny</span></span><br><span class="line"><span class="comment"># 分别设定阈值像素为50、150，sobel算子大小=3</span></span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.霍夫变换</span></span><br><span class="line"><span class="comment"># 生成极坐标扫描步长=1，角度=1°，至少有200个交点才认为是直线</span></span><br><span class="line">lines = cv.HoughLines(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.画出直线</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    r,theta = line[<span class="number">0</span>]  <span class="comment"># 极坐标p、θ</span></span><br><span class="line">    <span class="comment"># 计算直线两端点</span></span><br><span class="line">    <span class="comment"># 为什么是这么计算也不清楚？</span></span><br><span class="line">    cos = np.cos(theta)</span><br><span class="line">    sin = np.sin(theta)</span><br><span class="line">    x0 = r*cos</span><br><span class="line">    y0 = r*sin</span><br><span class="line">    <span class="comment"># 计算直线最大点(x1,y1)</span></span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-sin))</span><br><span class="line">    y1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (cos))</span><br><span class="line">    <span class="comment"># 计算直线最小点(x2,y2)</span></span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-sin))</span><br><span class="line">    y2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (cos))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出直线</span></span><br><span class="line">    cv.line(image,(x1,y1),(x2,y2),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect line&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h5 id="HoughLinesP"><a href="#HoughLinesP" class="headerlink" title="HoughLinesP()"></a>HoughLinesP()</h5><p>霍夫概率变换是霍夫变换的加强版：</p>
<ul>
<li><p>原理：暂略，待补</p>
</li>
<li><p>API：*<u>效果和API接口都比霍夫变换要好很多</u>* </p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085213285.png" alt="1575085213285"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575085268979.png" alt="1575085268979"></p>
</li>
</ul>
<blockquote>
<p>实例：利用openCV &amp; 霍夫变换来检测图像直线。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575120384392.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32.霍夫概率变换</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\building.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.进行高斯模糊（实测效果变好）</span></span><br><span class="line"><span class="comment"># ksize和sigma可以互相计算，故指定sigmaX=0</span></span><br><span class="line">image = cv.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 2.边缘检测canny</span></span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 3.霍夫概率变换</span></span><br><span class="line">lines = cv.HoughLinesP(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">200</span>,minLineLength=<span class="number">50</span>,maxLineGap=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1,y1,x2,y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv.line(image, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect line&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-8-2-圆检测：霍夫变换"><a href="#2-8-2-圆检测：霍夫变换" class="headerlink" title="2.8.2 圆检测：霍夫变换"></a>2.8.2 圆检测：霍夫变换</h4><p>在前，若干点在同一直线上，则它们必有一条直线$y=k x+b$ 经过它们。为了解算出$k、b$ 我们将这 <em><u>若干点</u></em> 变换到极坐标参数空间$k-b$ 得到对应 <em><u>若干曲线</u></em> , 这些曲线若存在交点$A(k_a,b_a)$ 则说明存在一条直线 $y=k_a x+b_a$ 使得它们在同一直线上。</p>
<p><em><u>那如何确定几个点是在同一圆上？</u></em></p>
<p>在 $x-y$ 坐标系，圆表达式可写作：$(x-a)^2+(y-b)^2 = r$ 。</p>
<p>同样将其映射到参数空间 $r-a-b$ 中。</p>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575122053546.png' width='80%'>

<p>:warning: 上有三个参数$rab$，在OpenCV中可通过设定$r$ 范围，循环遍历$r$ 值，则只在二维空间$a-b$ 寻找圆心$(a,b)$ 即可。</p>
<p>那么，在二维空间$a-b$ , 圆$(x-a)^2+(y-b)^2 = r$ 被映射成什么样子？</p>
<p>显然也是个圆，此时圆心是 $(x,y)$ , $r$ 已知 ：$(a-x)^2+(b-y)^2 = r$ 。</p>
<ul>
<li>假设在 $x-y$ 坐标系存在三个点 $a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)$ 。显然它们任意一个点，由于圆心$(a,b)$ 不确定，在$x-y$ 坐标系可以画出无数个圆。</li>
<li>三个点映射到 $a-b$ 二维空间，则为确定的一个圆，圆心分别为$a(x_1,y_1)、b(x_2,y_2)、a(x_2,y_2)$ </li>
<li>如果它们在同一个圆上，那么必然存在一个圆，圆心为$(a_1,b_1)$ 半径为$r$ ，都经过这三个点。换言之，在参数空间这三个点对应的圆必然会交于一个点$(a_1,b_1)$ 。由于在假设半径$r$ 值情况遍历搜寻，那么此时半径已知。至此，圆就被确定下来了。</li>
</ul>
<p>当然，上述过程三个点在参数空间对应的圆交于一个点，就确定一个点还是太少了。实际可以指定更多点交于一个点才认为确实存在圆。</p>
<h5 id="HoughCircles"><a href="#HoughCircles" class="headerlink" title="HoughCircles()"></a><em>HoughCircles()</em></h5><p>下面是基本API用法。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575124326462.png" alt="1575124326462"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575124353453.png" alt="1575124353453"></p>
<ul>
<li><em>method</em> : 检测圆方法，例如霍夫梯度法：CV_HOUGH_GRADIENT</li>
<li><em>dp</em>：检测圆心的累加器图像的分辨率于输入图像之比的倒数。dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度</li>
<li><em>minDist</em>：圆的圆心之间的最小距离。参数如果太小，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，参数设置太大的话，某些圆就不能被检测出来了。</li>
<li><em>param1</em>：默认值100。是第三个参数method设置的检测方法的对应的参数，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，低阈值为高阈值的一半。</li>
<li><em>param2</em>：默认值100。同上，对于霍夫梯度法CV_HOUGH_GRADIENT，它表示检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。</li>
<li><em>minRadius、maxRadius</em> ： 表示设置圆半径的最小值和最大值。</li>
</ul>
<blockquote>
<p>实例：使用<em>HoughCircles()</em> 检测图像中存在的圆形。</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575125468745.png' width='50%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 33.霍夫变换圆检测</span></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 霍夫变换易受噪声影响，先进行均值漂移滤波减少噪声</span></span><br><span class="line">dst = cv.pyrMeanShiftFiltering(image,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 转换为灰度图</span></span><br><span class="line">gray = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 霍夫变换圆检测</span></span><br><span class="line"><span class="comment"># param1、param2调参很重要。最开始param1=50，效果很差，canny的高阈值设置太低</span></span><br><span class="line">circles = cv.HoughCircles(gray,cv.HOUGH_GRADIENT,<span class="number">1</span>,<span class="number">20</span>,param1=<span class="number">100</span>,param2=<span class="number">30</span>,minRadius=<span class="number">0</span>,maxRadius=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画圆[注意维度问题]</span></span><br><span class="line"><span class="comment"># circles.shape=（1,3,3）,第一个维度不明。第二个维度是圆个数，第三个维度对应圆三个参数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>,:]:</span><br><span class="line">    cv.circle(image,(i[<span class="number">0</span>],i[<span class="number">1</span>]),i[<span class="number">2</span>],(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;circles&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-8-3-轮廓检测"><a href="#2-8-3-轮廓检测" class="headerlink" title="2.8.3 轮廓检测"></a>2.8.3 轮廓检测</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>待补充</p>
<h5 id="findContours"><a href="#findContours" class="headerlink" title="findContours"></a><em>findContours</em></h5><blockquote>
<p>原理不懂，API看得也稀里糊涂的。参数意义可以参考 ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ssyfj/p/9276443.html">轮廓发现</a></p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575171018417.png" alt="1575171018417"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575172245949.png" alt="1575172245949"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575175255172.png" alt="1575175255172"></p>
<p>整个API操作步骤可以总结如下：</p>
<ul>
<li><p>对图像进行高斯滤波，减少噪声</p>
</li>
<li><p>转换为二值图像：<em>threshold</em> 或者 <em>canny</em> 边缘提取都可</p>
</li>
<li><p>通过二值图像寻找轮廓：<em>findContours</em></p>
</li>
<li><p>描绘轮廓：<em>drawContours</em></p>
</li>
</ul>
<blockquote>
<p>实例1：寻找图像轮廓（通过threshold获取二值图像）</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575174791805.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 34.轮廓发现（通过threshold获取二值图像）</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.高斯滤波图像减少噪声</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图像</span></span><br><span class="line">grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.threshold 获取二值图像</span></span><br><span class="line"><span class="comment"># 如果选择二值方式是 cv.THRESH_BINARY，由于原图像素&gt;0,结果就是二值化图全白色</span></span><br><span class="line"><span class="comment"># cv.THRESH_OTSU：是最大间差法，按图像灰度特性将图像分为前景和背景两部分</span></span><br><span class="line">ret,binaryImg = cv.threshold(grayImg,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY|cv.THRESH_OTSU)</span><br><span class="line">cv.imshow(<span class="string">&#x27;binaryImg&#x27;</span>,binaryImg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.findContours 轮廓提取</span></span><br><span class="line"><span class="comment"># cv.RETR_EXTERNAL 获取外部轮廓 ； cv.CHAIN_APPROX_SIMPLE </span></span><br><span class="line">cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. drawContours 绘出轮廓</span></span><br><span class="line"><span class="keyword">for</span> i,contour <span class="keyword">in</span> <span class="built_in">enumerate</span>(contours):</span><br><span class="line">    <span class="comment"># 注意第二个参数是传递所有轮廓！</span></span><br><span class="line">    cv.drawContours(image,contours,i,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect contours&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例2：寻找图像轮廓（通过canny获取二值图像）</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575175031143.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 35.轮廓发现（通过canny获取二值图像）</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.高斯滤波图像减少噪声</span></span><br><span class="line">GaussianImg = cv.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图像</span></span><br><span class="line">grayImg = cv.cvtColor(GaussianImg,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.canny 获取二值图像</span></span><br><span class="line">binaryImg = cv.Canny(grayImg,<span class="number">50</span>,<span class="number">150</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;binaryImg&#x27;</span>,binaryImg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.findContours 轮廓提取</span></span><br><span class="line">cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. drawContours 绘出轮廓</span></span><br><span class="line"><span class="keyword">for</span> i,contour <span class="keyword">in</span> <span class="built_in">enumerate</span>(contours):</span><br><span class="line">    cv.drawContours(image,contours,i,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;detect contours&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-9-对象测量"><a href="#2-9-对象测量" class="headerlink" title="2.9 对象测量"></a>2.9 对象测量</h3><p>这部分对象测量主要包含两个部分：</p>
<ul>
<li>基于前<strong>2.8</strong> 节 <em><u>发现轮廓</u></em>  后对轮廓进行 <em><u>计算弧长和面积</u></em> </li>
<li>对发现的轮廓进行多边形拟合</li>
</ul>
<h4 id="2-9-1-面积-amp-多边形拟合"><a href="#2-9-1-面积-amp-多边形拟合" class="headerlink" title="2.9.1 面积&amp;多边形拟合.."></a>2.9.1 面积&amp;多边形拟合..</h4><ul>
<li><p>原理</p>
<p>待补充</p>
</li>
<li><p>API</p>
<ul>
<li><em>cv.contourArea(contour)</em>       ：获取每个轮廓面积</li>
<li><em>cv.boundingRect(contour)</em>     ：获取轮廓的外接矩形</li>
<li><em>cv.moments(contour)</em>             ：求取轮廓的几何距</li>
<li><em>cv.arcLength(contour,True)</em>　：求取轮廓的周长，指定闭合</li>
<li><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575211802166.png" alt="1575211802166"></li>
</ul>
</li>
<li><p>过程总结</p>
<ul>
<li>获取灰度图像：<em>cvtColor</em></li>
<li>二值化图像：<em>threshold</em> 或 <em>canny</em></li>
<li>发现轮廓：<em>findContours</em></li>
<li>计算面积 / 周长/多边形拟合 等</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例：获取图像面积、绘出外接矩形框、根据几何距计算轮廓中心（不明白原理）</p>
</blockquote>
<img src='https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1575211694175.png' width='80%'>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36.对象测量</span></span><br><span class="line"><span class="comment"># 计算面积、绘出外接矩形、根据几何距计算轮廓中心（不明白）</span></span><br><span class="line"></span><br><span class="line">image = cv.imread(<span class="string">r&quot;C:\\Users\\86151\\Pictures\\circles.jpg&quot;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;origin&#x27;</span>,image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.转换为灰度图像</span></span><br><span class="line">grayImg = cv.cvtColor(image,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.threshold 获取二值图像</span></span><br><span class="line">ret,binaryImg = cv.threshold(grayImg,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_OTSU)</span><br><span class="line">cv.imshow(<span class="string">&#x27;binaryImg&#x27;</span>,binaryImg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.发现轮廓</span></span><br><span class="line">cloneImage,contours,heriachy= cv.findContours(binaryImg,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.计算轮廓面积、外接矩形、求中心点</span></span><br><span class="line"><span class="comment"># debug：在二值图像化没反应？</span></span><br><span class="line"><span class="keyword">for</span> i,contour <span class="keyword">in</span> <span class="built_in">enumerate</span>(contours):</span><br><span class="line">    <span class="comment"># 计算轮廓面积</span></span><br><span class="line">    area = cv.contourArea(contour)</span><br><span class="line">    <span class="comment"># print(area)</span></span><br><span class="line">    <span class="comment"># 绘制外接矩形</span></span><br><span class="line">    x,y,w,h = cv.boundingRect(contour)</span><br><span class="line">    cv.rectangle(image,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 根据几何距获取中心点并绘制</span></span><br><span class="line">    m = cv.moments(contour)       <span class="comment"># 获取几何距</span></span><br><span class="line">    <span class="keyword">if</span> m[<span class="string">&#x27;m00&#x27;</span>] == <span class="number">0</span>:             <span class="comment"># 有可能出现 m[&#x27;m00&#x27;] == 0</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cx = m[<span class="string">&#x27;m10&#x27;</span>] / m[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># 中心x</span></span><br><span class="line">        cy = m[<span class="string">&#x27;m01&#x27;</span>] / m[<span class="string">&#x27;m00&#x27;</span>]  <span class="comment"># 中心y</span></span><br><span class="line">    cv.circle(image,(np.<span class="built_in">int</span>(cx),np.<span class="built_in">int</span>(cy)),<span class="number">1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 拟合多边形</span></span><br><span class="line">    <span class="comment"># 4是与阈值的间隔大小，越小越易找出，True是是否找闭合图像</span></span><br><span class="line">    <span class="comment"># 返回拟合曲线</span></span><br><span class="line">    approxCurve = cv.approxPolyDP(contour, <span class="number">4</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 如果拟合曲线的边数大于4则绘出（三角形、四边形等&lt;=4就不会绘出）</span></span><br><span class="line">    <span class="keyword">if</span> approxCurve.shape[<span class="number">0</span>] &gt; <span class="number">4</span>:</span><br><span class="line">        cv.drawContours(image, contours, i, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">cv.imshow(<span class="string">&#x27;draw&#x27;</span>,image)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-10-图像形态学"><a href="#2-10-图像形态学" class="headerlink" title="2.10 图像形态学"></a>2.10 图像形态学</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89OpenCV/">http://example.com/2021/11/25/深度学习基础（三）OpenCV/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OpenCV/">OpenCV</a></div><div class="post_share"><div class="social-share" data-image="/img/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89Pytorch/"><img class="prev-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深度学习基础（二）Pytorch</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/25/Git%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git基础笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenCV"><span class="toc-text">OpenCV</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86OpenCV"><span class="toc-text">一、初识OpenCV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1.1 环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98"><span class="toc-text">1.2 图像加载和保存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%9B%BE%E7%89%87%EF%BC%9A%E8%AF%BB%E5%8F%96-%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-text">1.2.1 图片：读取+基本属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%EF%BC%9Anumpy%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%89%87"><span class="toc-text">其它：numpy创建图片</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%A7%86%E9%A2%91%EF%BC%9A%E8%AF%BB%E5%8F%96"><span class="toc-text">1.2.2 视频：读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"><span class="toc-text">1.3 色彩空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E5%88%9D%E8%AF%86"><span class="toc-text">1.3.1 色彩空间初识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.3.2 色彩空间转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HSV%E7%A9%BA%E9%97%B4%E9%A2%9C%E8%89%B2%E4%B8%89%E9%80%9A%E9%81%93%E8%8C%83%E5%9B%B4"><span class="toc-text">HSV空间颜色三通道范围</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%83%8F%E7%B4%A0%E8%BF%90%E7%AE%97"><span class="toc-text">1.4 像素运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E5%9F%BA%E6%9C%AC%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-text">1.4.1 基本加减乘除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-MASK%EF%BC%88%E6%8E%A9%E8%86%9C%EF%BC%89"><span class="toc-text">14.2 MASK（掩膜）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="toc-text">1.4.3 逻辑操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%97%E5%AD%901%EF%BC%9AinRang-mask"><span class="toc-text">栗子1：inRang+mask</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%85%B6%E5%AE%83%EF%BC%9A%E5%AF%B9%E6%AF%94%E5%BA%A6addWeight%E7%AD%89"><span class="toc-text">1.4.4 其它：对比度addWeight等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BB%98%E5%9B%BE%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">1.5 绘图与鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E7%BB%98%E5%9B%BE"><span class="toc-text">1.5.1 绘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">1.5.2 鼠标事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E5%87%BB%EF%BC%81openCV%EF%BC%81"><span class="toc-text">二、进击！openCV！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-ROI%E4%B8%8E%E6%B3%9B%E6%B4%AA%E5%A1%AB%E5%85%85"><span class="toc-text">2.1 ROI与泛洪填充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-FloodFill%EF%BC%9A%E6%B3%9B%E6%B4%AA%E5%A1%AB%E5%85%85"><span class="toc-text">2.1.1 FloodFill：泛洪填充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A8%A1%E7%B3%8A%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2 模糊操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%9D%87%E5%80%BC%E6%A8%A1%E7%B3%8A%E3%80%81%E4%B8%AD%E5%80%BC%E6%A8%A1%E7%B3%8A"><span class="toc-text">2.2.1 均值模糊、中值模糊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="toc-text">2.2.2 高斯模糊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-EPF%E6%A8%A1%E7%B3%8A%EF%BC%9A%E9%AB%98%E6%96%AF%E5%8F%8C%E8%BE%B9%E3%80%81%E5%9D%87%E5%80%BC%E5%81%8F%E7%A7%BB"><span class="toc-text">2.2.3  EPF模糊：高斯双边、均值偏移</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%8F%8C%E8%BE%B9%E6%A8%A1%E7%B3%8A"><span class="toc-text">高斯双边模糊</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%87%E5%80%BC%E9%A3%98%E7%A7%BB%E6%A8%A1%E7%B3%8A"><span class="toc-text">均值飘移模糊</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-text">2.3 图像直方图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%AE%9E%E4%BE%8B%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%88%9D%E5%BA%94%E7%94%A8"><span class="toc-text">2.3.1 实例：直方图初应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%BA%94%E7%94%A8"><span class="toc-text">2.3.3 直方图应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96"><span class="toc-text">直方图均衡化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%AF%94%E8%BE%83"><span class="toc-text">直方图比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%8F%8D%E5%90%91%E6%8A%95%E5%BD%B1"><span class="toc-text">直方图反向投影</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="toc-text">2.4 模板匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%EF%BC%9AmatchTemplate"><span class="toc-text">匹配：matchTemplate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="toc-text">2.5 图像二值化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-hsv%E4%BA%8C%E5%80%BC%E5%8C%96%EF%BC%9A-inRange"><span class="toc-text">1 hsv二值化： inRange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-gray%E4%BA%8C%E5%80%BC%E5%8C%96%EF%BC%9Athreshold"><span class="toc-text">2 gray二值化：threshold</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-gray%E4%BA%8C%E5%80%BC%E5%8C%96%EF%BC%9AadaptiveThreshold"><span class="toc-text">3 gray二值化：adaptiveThreshold</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%B6%85%E5%A4%A7%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="toc-text">4 超大图像二值化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E8%BF%87%E6%BB%A4"><span class="toc-text">空白区域过滤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE"><span class="toc-text">2.6 图像缩放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E7%BC%A9%E6%94%BE%EF%BC%9Aresize"><span class="toc-text">2.6.1  缩放：resize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94%EF%BC%9ApyrUP-%E3%80%81pyrDown"><span class="toc-text">2.6.2 图像金字塔：pyrUP  、pyrDown</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-text">高斯金字塔</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-text">拉普拉斯金字塔</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6"><span class="toc-text">2.7 图像梯度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E5%9B%BE%E5%83%8F%E6%B1%82%E5%AF%BC%EF%BC%9ASobel%E3%80%81Scharr%E3%80%81Lapacian"><span class="toc-text">2.7.1 图像求导：Sobel、Scharr、Lapacian</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Sobel-amp-Scharr"><span class="toc-text">Sobel &amp; Scharr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Laplacian-%E7%AE%97%E5%AD%90"><span class="toc-text">Laplacian 算子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-Canny%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96"><span class="toc-text">2.7.2 Canny边缘提取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E7%9B%B4%E7%BA%BF%E3%80%81%E5%9C%86%E3%80%81%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B"><span class="toc-text">2.8 直线、圆、轮廓检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E7%9B%B4%E7%BA%BF%E6%A3%80%E6%B5%8B%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="toc-text">2.8.1 直线检测：霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%81%B6%E6%80%A7"><span class="toc-text">对偶性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E5%8F%98%E5%8C%96-amp-%E5%8F%82%E6%95%B0%E7%A9%BA%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-text">霍夫变化&amp;参数空间选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HoughLines"><span class="toc-text">HoughLines()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HoughLinesP"><span class="toc-text">HoughLinesP()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E5%9C%86%E6%A3%80%E6%B5%8B%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="toc-text">2.8.2 圆检测：霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HoughCircles"><span class="toc-text">HoughCircles()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-3-%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B"><span class="toc-text">2.8.3 轮廓检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#findContours"><span class="toc-text">findContours</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%AF%B9%E8%B1%A1%E6%B5%8B%E9%87%8F"><span class="toc-text">2.9 对象测量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-1-%E9%9D%A2%E7%A7%AF-amp-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%8B%9F%E5%90%88"><span class="toc-text">2.9.1 面积&amp;多边形拟合..</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6"><span class="toc-text">2.10 图像形态学</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" title="前端基础（一）JavaScript基础笔记(上)">前端基础（一）JavaScript基础笔记(上)</a><time datetime="2021-11-25T12:37:58.119Z" title="发表于 2021-11-25 20:37:58">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89/" title="前端基础（一）JavaScript基础笔记(中)">前端基础（一）JavaScript基础笔记(中)</a><time datetime="2021-11-25T12:36:37.921Z" title="发表于 2021-11-25 20:36:37">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89CSS%E7%AC%94%E8%AE%B0/" title="前端基础（二）CSS基础笔记">前端基础（二）CSS基础笔记</a><time datetime="2021-11-25T10:45:45.161Z" title="发表于 2021-11-25 18:45:45">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/" title="前端基础（一）JavaScript基础笔记（下）">前端基础（一）JavaScript基础笔记（下）</a><time datetime="2021-11-25T10:44:17.432Z" title="发表于 2021-11-25 18:44:17">2021-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/25/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Python 基础笔记">Python 基础笔记</a><time datetime="2021-11-25T10:40:15.008Z" title="发表于 2021-11-25 18:40:15">2021-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Tencent Cloud</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'Wanghui-Huang/gittalk')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>