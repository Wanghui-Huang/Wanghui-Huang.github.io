<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端基础（一）JavaScript基础笔记(中) | royhuang's blog</title><meta name="keywords" content="JavaScript"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第三章：标准对象 3.1 小城少年对象与坑 typeof 在 JavaScript 的世界里，一切都是对象，你喜欢但不喜欢你的姑娘也是。 typeof 操作符获取对象的类型，它总是返回一个 字符串。 1234567891011121314151617&#x2F;&#x2F; 1.字符串、数值、布尔基本类型typeof 123;      &#x2F;&#x2F; &amp;#x27;number&amp;#x27;typeof true;     &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础（一）JavaScript基础笔记(中)">
<meta property="og:url" content="https://hwh.zone/p/20680/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="第三章：标准对象 3.1 小城少年对象与坑 typeof 在 JavaScript 的世界里，一切都是对象，你喜欢但不喜欢你的姑娘也是。 typeof 操作符获取对象的类型，它总是返回一个 字符串。 1234567891011121314151617&#x2F;&#x2F; 1.字符串、数值、布尔基本类型typeof 123;      &#x2F;&#x2F; &amp;#x27;number&amp;#x27;typeof true;     &#x2F;&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2021-11-25T12:36:37.921Z">
<meta property="article:modified_time" content="2021-12-03T03:41:02.913Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/20680/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"XVCM04DNZ4","apiKey":"137b0bbc59574cb11c2e8fed36fb30fb","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端基础（一）JavaScript基础笔记(中)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:41:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">前端基础（一）JavaScript基础笔记(中)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T12:36:37.921Z" title="发表于 2021-11-25 20:36:37">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:41:02.913Z" title="更新于 2021-12-03 11:41:02">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端基础（一）JavaScript基础笔记(中)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>第三章：标准对象</h1>
<h2 id="3-1-小城少年对象与坑">3.1 小城少年对象与坑</h2>
<h3 id="typeof"><em>typeof</em></h3>
<p>在 <em>JavaScript</em> 的世界里，一切都是对象，你喜欢但不喜欢你的姑娘也是。</p>
<p><em>typeof</em> 操作符获取对象的类型，它总是返回一个 <u>字符串</u>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.字符串、数值、布尔基本类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>;      <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;     <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>;    <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs;  <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.预设特殊值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>;       <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;      <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.[] &#123;&#125; ?</span></span><br><span class="line"><span class="keyword">typeof</span> [];        <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;        <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>
<p>根据利用 <em>tepeof</em> 来判断一些变量。比如：</p>
<blockquote>
<p>判读全局变量、局部变量是否存在。</p>
</blockquote>
<ul>
<li>判断全局变量是否存在：<code>typeof window.myVar === 'undefined'</code></li>
<li>判断局部变量是否存在：<code>typeof myVar === 'undefined'</code> 。</li>
</ul>
<blockquote>
<p>判断是否 <em>null</em>、<em>Array</em> 。</p>
</blockquote>
<p>我们从上也知道，<em>typeof</em> 无法判断出是否 <em>null</em>、<em>Array</em> (它们和 <strong>[]、 {}</strong> 都是 <em>object</em>类型)，但可以：</p>
<ul>
<li>判断 <em>null</em> ： <code>变量 === null；</code></li>
<li>判断 <em>Array</em>：<code>Array.isArray(arr);</code></li>
</ul>
<h3 id="包装对象">包装对象</h3>
<p>和 <em>java</em> 类似，<em>JavaScript</em> 还提供了包装对象，比如 <em>int</em> 可封装转换为 <em>integer</em> 类型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装返回的是一个对象</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) ;     <span class="built_in">console</span>.log(n);  <span class="comment">// 输出：[Number: 123]</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);    <span class="built_in">console</span>.log(b);  <span class="comment">// 输出：[Boolean: true]</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>);    <span class="built_in">console</span>.log(s);  <span class="comment">// 输出：[String: &#x27;str&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>但是注意：包装对象看上去值和原来一样但是已经是 <em>object</em> 类型！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);   <span class="comment">// 输出：object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);   <span class="comment">// 输出：object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// 输出：object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和此前不同！</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>);    <span class="comment">// 输出：number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);   <span class="comment">// 输出：boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);  <span class="comment">// 输出：string</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-Date">3.2 <em>Date</em></h2>
<p><code>Date</code>对象用来表示日期和时间，有以下三种创建其对象方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.默认构造函数</span></span><br><span class="line"><span class="comment">// 用now对象获取的时间始终是[当前最新]时间</span></span><br><span class="line"><span class="comment">// 输出的是UTC时间，与本地时间相差8个小时</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line"><span class="built_in">console</span>.log(now);          <span class="comment">// 输出：2019-07-23T08:25:35.884Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.指定日期和时间构建</span></span><br><span class="line"><span class="comment">// 默认参数 = 0</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">6</span>,<span class="number">23</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date);         <span class="comment">// 输出：2019-07-23T16:20:30.123Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.指定时间戳创建</span></span><br><span class="line"><span class="comment">// 先将符合[ISO 8601格式]字符串---&gt;时间戳</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2019-07-23T16:20:30.123&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(timeStamp);     <span class="comment">// 输出：1563870030123，这是一个时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为Date对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line"><span class="built_in">console</span>.log(date);          <span class="comment">// 输出：2019-07-23T16:20:30.123Z</span></span><br></pre></td></tr></table></figure>
<p>常用的获取时间各种信息对象方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now;                       <span class="comment">// 2019-07-23T08:47:48.033Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line">now.getFullYear();         <span class="comment">// 2019, 年份</span></span><br><span class="line">now.getMonth();            <span class="comment">// 6, 月份，注意月份范围是0~11，6表示7月</span></span><br><span class="line">now.getDate();             <span class="comment">// 23, 24号</span></span><br><span class="line">now.getDay();              <span class="comment">// 2, 星期二</span></span><br><span class="line">now.getHours();            <span class="comment">// 16, 24小时制</span></span><br><span class="line">now.getMinutes();          <span class="comment">// 47, 分钟</span></span><br><span class="line">now.getSeconds();          <span class="comment">// 48, 秒</span></span><br><span class="line">now.getMilliseconds();     <span class="comment">// 033, 毫秒数</span></span><br><span class="line">now.getTime();             <span class="comment">// 1563871956469, 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());   <span class="comment">// 输出：1563871956469</span></span><br></pre></td></tr></table></figure>
<h3 id="时区问题">时区问题</h3>
<p>我们看到上面输出的时间，并不是我们本地时间，而是UTC时间和本地相差8个小时，我们可以输出本地时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.直接将当前时间转为本地时间</span></span><br><span class="line"><span class="built_in">console</span>.log(now.toLocaleString());   <span class="comment">// 输出：2019-7-23 5:10:21 PM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取时间戳，然后进行时区转换</span></span><br><span class="line"><span class="comment">// 静态OR动态方法获取时间戳</span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.now();          <span class="comment">// 或者 var timeStamp = new Date().getTime();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接用时间戳构建对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp);</span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleString());  <span class="comment">// 输出：2019-7-23 5:10:21 PM</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-RegExp（待）">3.3 <em>RegExp</em>（待）</h2>
<p><em>RegExp</em> 是专门用于正则解析的类，首先我们要对正则表达式熟悉。</p>
<h3 id="正则表达式">正则表达式</h3>
<h2 id="3-4-JSON">3.4 <em>JSON</em></h2>
<p><em>JSON</em> 是 <em>JavaScript Object Notation</em> 的缩写，它是一种数据交换格式，实际上也是 <em>JavaScript</em> 的一个子集。</p>
<p>其支持的数据类型有：</p>
<ul>
<li><em>object</em>：即<em>JavaScript</em> 的<code>&#123; ... &#125;</code>表示方式 (可嵌套)</li>
<li><em>number</em>、<em>boolean</em>、 <em>string</em>、<em>null</em>、<em>array</em>：和 <em>JavaScript</em> 中对应类型完全一致</li>
</ul>
<p><em>json</em> 数据可以是上面支持数据类型 <u>任意一个或多个组合</u> ，而不是只能在<em>object</em> <strong>{…}</strong> 包含键值对形式 。</p>
<blockquote>
<p>观察下面 <em>json</em> 格式数据{…}和 <em>js</em> 对象{…}有什么不同？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合成json格式数据</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line"> <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;3C&quot;</span>,</span><br><span class="line">  <span class="string">&quot;python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;2j&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要是字符串，如键值必须用双引号 <strong>‘’ ‘’</strong></li>
</ul>
<p>而且 <em>json</em> 还规定字符集必须是 UTF-8，这样可以支持多语言了。</p>
<p><em><u>json</u></em> 和 <em>js</em> <u>对象/数组/字符串（<em>json</em>支持）等</u> 可以互相转换，这又称为序列化和反序列化。</p>
<h3 id="序列化">序列化</h3>
<p>将<em>JavaScript</em> 数据类型转换为 <em>json</em> 称之为序列化。如下面是一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">skills</span>: [<span class="string">&#x27;3C&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;2j&#x27;</span>],</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <em>JavaScript</em> 内置了 <em>json  API</em>，我们可以直接调用 <code>JSON.stringify()</code>来转换为 <em>json</em> 格式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @value：传递一个对象或者数组(?)</span></span><br><span class="line"><span class="comment">// @replacer: 传递一个方法用来改变结果显示，或者传递数组筛选指定键值</span></span><br><span class="line"><span class="comment">// @space : 传递空白字符等用来格式化结果，使得结果更易读</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(hwh,<span class="literal">null</span>,<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>尝试输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(hwh,<span class="literal">null</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);   <span class="comment">// 输出：string，说明转换后json格式数据是字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化结果</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line"> <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;3C&quot;</span>,</span><br><span class="line">  <span class="string">&quot;python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;2j&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别的，允许的数据类型如果不属于<em>json</em> 支持类型，序列化时不会显示该类型，如 <u>函数<em>age</em>键值对</u> 没有显示。</p>
<p>当然，我们也可以转换其它<em>json</em> 支持的数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="string">&#x27;str&#x27;</span>));  <span class="comment">// 输出：&quot;str&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="number">123</span>));    <span class="comment">// 输出：123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="literal">true</span>));   <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>
<h4 id="进一步处理：传递函数">进一步处理：传递函数</h4>
<p>在前介绍，我们还可以通过第二个参数 <em>@replacer</em> 对键值对进行筛选、指定处理方法等。</p>
<blockquote>
<p>筛选出<em>JavaScript</em>对象指定键值：<em>birth、gender、school</em>  对应键值对。</p>
</blockquote>
<p>我们可以通过传递一个数组包含我们希望留下的键值，来达到目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(hwh,[<span class="string">&#x27;birth&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;school&#x27;</span>],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化结果</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;chongqingU&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组好像不行？？</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify([<span class="string">&#x27;hwh&#x27;</span>,<span class="string">&#x27;lt&#x27;</span>],[<span class="number">0</span>],<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化结果</span></span><br><span class="line">[</span><br><span class="line"> <span class="string">&quot;hwh&quot;</span>,</span><br><span class="line"> <span class="string">&quot;lt&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将所有键值转换为大写。（为什么不能对键值 <em>key</em> 大写？只能修改属性？）</p>
</blockquote>
<p>需要对键值对进行处理，可以传递一个函数，它会对所有键值对进行操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">// 必须判断是否是 string类型，因为如birth属性就是Number</span></span><br><span class="line"><span class="comment">// 注意：typeof返回String类型字符串！</span></span><br><span class="line"><span class="comment">// 为什么不能转换键值key为大写？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  valueToUpper = <span class="function">(<span class="params">key,value</span>) =&gt;</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span> ? value.toUpperCase():value;</span><br></pre></td></tr></table></figure>
<p>⚠️ 传递的函数任何情况要有返回值！比如上面不打算对属性<em>value</em> 进行修改也要 <code>return value</code> 。</p>
<p>我们尝试输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(hwh,valueToUpper,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;birth&quot;</span>: <span class="number">1996</span>,</span><br><span class="line"> <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line"> <span class="string">&quot;school&quot;</span>: <span class="string">&quot;CHONGQINGU&quot;</span>,</span><br><span class="line"> <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;3C&quot;</span>,</span><br><span class="line">  <span class="string">&quot;PYTHON&quot;</span>,</span><br><span class="line">  <span class="string">&quot;2J&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反序列化">反序列化</h3>
<p>我们也可以利用 <code>JSON.parse()</code> 将 <em>json</em> 格式字符串解析转换为 <em>javaScript</em>对象 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.反序列化对象 </span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;</span>);  <span class="comment">// Object &#123;name: &#x27;hwh&#x27;, age: 23&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.反序列化数组</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>);             <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.反序列化其它基本类型</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>);                     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>);                   <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p>⚠️ 要解析的 <em>json</em> 数据一定要是字符串！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.尝试解析对象？</span></span><br><span class="line"><span class="keyword">var</span> hwh = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;hwh&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;;  <span class="comment">// 这既不是对象（键值有&quot;&quot;），也不是字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(hwh));        <span class="comment">// 解析错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.尝试解析数组？</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(arr));        <span class="comment">// 解析错误</span></span><br></pre></td></tr></table></figure>
<h4 id="进一步处理：传递函数-2">进一步处理：传递函数</h4>
<p>事实上<code>JSON.parse()</code> 有两个参数，还可传第二个函数参数 <em>@reviver</em> 对<em>json</em> 字符串进行处理：</p>
<blockquote>
<p>把传递进来的<em>json</em> 字符串，键值<em>name</em>对应属性后加上“同学”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化：json字符串转换为对象</span></span><br><span class="line"><span class="comment">// JSON.parse(@text,@reviver)</span></span><br><span class="line"><span class="comment">// @text：传递合法json字符串</span></span><br><span class="line"><span class="comment">// @reviver：传递一个函数改变输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json_hwh = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;hwh&quot;, &quot;age&quot;:23&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> addSome = <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key === <span class="string">&quot;name&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;  <span class="comment">// 对value进行修改</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> value;          <span class="comment">// 易错：其它情况也一定要有返回值！否则最后解析为undefined的！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json_hwh,addSome);</span><br></pre></td></tr></table></figure>
<p>尝试输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;hwh同学&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure>
<h1>第四章：面对对象编程</h1>
<h2 id="4-1-在-JS-世界面对对象">4.1 在 <em>JS</em> 世界面对对象</h2>
<p><em>JavaScript</em> 所有数据都可以看成对象，比如我们之前使用：<em>Number</em>、<em>Array</em>、<em>string</em> &amp; 基本的**{…} **定义的对象。</p>
<p>但这并没有真正发挥面对对象编程威力。</p>
<p>熟悉 <em>java、C#</em> 的你一定知道：类 &amp;  实例之间区别，就是模板与创建的实例对象。<em>BUT</em> ，在<em>JavaScript</em> 中并没有类和实例概念，在<em>JavaScript</em> 世界里是通过 <u><em>原型（prototype）</em></u> 等方式实现的。</p>
<h3 id="1-创建对象">1.创建对象</h3>
<p>闲的蛋疼的你想创建一个<em>hwh</em>对象，他会唱 、跳、rap、喜欢打篮球，又懒得9点钟都不一定起床的你恰好看到你之前创建的一个<em>student</em>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line">    <span class="attr">sing</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am sing..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是<em>hwh</em> 不叫小明，也不是18岁啊！更重要的小明他居然不会跳、rap、🏀！</p>
<p>熟悉原型链的你微微一笑，不慌不忙的创建了一个<em>hwh</em> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;huangwanghui&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="comment">// 对象增加额外方法</span></span><br><span class="line">    <span class="attr">jump</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am jump..&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rap</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am rap..&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">play_basketball</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am playing basketball ..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把<em>hwh._<em>proto</em>_</em> 属性指向<em>student</em>，看上去好像继承了<em>student</em>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hwh.__proto__ = student; <span class="comment">// 注意：proto左右各有两个_，不是一个！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;大家好，我是渣渣辉 :&quot;</span> + hwh.name);</span><br><span class="line">hwh.sing();                <span class="comment">// 唱：i am sing..</span></span><br><span class="line">hwh.jump();                <span class="comment">// 跳：i am jump..</span></span><br><span class="line">hwh.rap();                 <span class="comment">// rap：i am rap..</span></span><br><span class="line">hwh.play_basketball();     <span class="comment">// 打篮球：i am playing basketball ..</span></span><br></pre></td></tr></table></figure>
<p>通过同名键值可以覆盖student原有键值，通过创建新键值对可以使得<em>hwh</em> 可以跳、<em>rap</em>、打篮球。</p>
<h4 id="扩展了解">扩展了解</h4>
<blockquote>
<p>为什么这种方式看上去好像 “继承”了 <em>student</em> 属性？</p>
</blockquote>
<p>因为在<em>JavaScript</em> 中，实例对象<em>hwh</em>如果没有找到属性、方法它会自动在其 <em>hwh._<em>proto</em>_</em> 对象属性中查找（<em>_<em>proto</em>_</em> 是一个对象）。这个时候把对象<em>student</em> 赋值 <em>hwh._<em>proto</em>_</em> ，那么就会自动查找对象 <em>student</em> 属性。</p>
<p>⚠️ <em>_<em>proto</em>_</em> 是每一个对象或函数都有的属性（<u>默认指向 <em>Object.prototype</em></u>），但是函数还有 <em>prototype</em> 属性。</p>
<p>所以<em>hwh._<em>proto</em>_</em> （也就是对象<em>student</em> ）中也有这个属性：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564110563722.png" alt="1564110563722"></p>
<p>此时查找的原型链为：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564110665280.png" alt="1564110665280"></p>
<p>如果是用后面介绍 <u>构造函数创建<em>hwh</em>对象方式</u> ，其查找原型链为：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p>
<h4 id="Object-create-创建对象"><code>Object.create()</code>创建对象</h4>
<p>通常在写 <em>JavaScript</em> 代码，<u>不推荐</u> 使用 <code>对象名.__proto__</code> 方式改变对象原型。</p>
<p>我们应该用 <code>Object.create(对象o)</code> 创建一个基于<code>对象o</code> 原型新对象：</p>
<blockquote>
<p>用<code>Object.create()</code> 方式创建基于原型<em>student</em> 的对象<em>hwh</em> ，相当 <u>复制</u> 了<em>student</em>对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于原型student创建对象hwh</span></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="built_in">Object</span>.create(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象修改属性</span></span><br><span class="line">hwh.name = <span class="string">&#x27;huangwanghui&#x27;</span>;</span><br><span class="line">hwh.age = <span class="number">23</span>;</span><br><span class="line"><span class="comment">// 对象增加方法</span></span><br><span class="line">hwh.jump = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am jump..&quot;</span>);</span><br><span class="line">hwh.rap = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am rap..&quot;</span>);</span><br><span class="line">hwh.play_basketball = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am playing basketball ..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试调用</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.name);  <span class="comment">// 输出：huangwanghui</span></span><br><span class="line">hwh.jump();             <span class="comment">// 输出：i am jump..</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数创建对象">构造函数创建对象</h4>
<p>前面我们介绍了两种基于student原型创建<em>hwh</em> 对象方式：其中 <code>hwh.__proto___ = student</code>  这种创建对象方式，我们不推荐修改实例<em>hwh</em> 的*_<em>proto</em>__* 属性。</p>
<p>而且我们知道，此前<em>student</em> 都是对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象student</span></span><br><span class="line"><span class="keyword">var</span> student = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line">    <span class="attr">sing</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am sing..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把<em>student</em> 改写成一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数Student</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,school</span>)  // 构造函数首字母建议大写</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name =  name;</span><br><span class="line">    <span class="built_in">this</span>.age = age,</span><br><span class="line">    <span class="built_in">this</span>.school = school,</span><br><span class="line">    <span class="built_in">this</span>.sing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)   // 必须全部用<span class="title">this</span>引用函数内部变量</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am sing..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内部看起来很像对象键值对形式只不过 <code>键值:属性</code> 变为：<code>this.键值:属性</code>，特别的</p>
<ul>
<li>函数所有变量（“键值”）必须用<em>this</em> 引用 ，在函数内部（非<em>strict</em> 模式）<em>this</em> 指向全局对象<em>window</em> ；<em>new</em> 创建新对象后，会自动将 <em>this</em> 指向到新创建的对象。</li>
</ul>
<p>这也就是构造函数，使用 <em>new</em> 它会返回一个实例对象：</p>
<ul>
<li>实例对象 <u>继承构造函数所有属性</u></li>
<li>实例对象 <em>_<em>proto</em>_</em> 属性自动绑定为构造函数原型<em>prototype</em> 属性。</li>
</ul>
<p>同样，自然我们也可以对对象进行增改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new返回一个对象</span></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student(<span class="string">&quot;hwh&quot;</span>,<span class="number">23</span>,<span class="string">&quot;chongqingU&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象增加额外方法</span></span><br><span class="line">hwh.jump = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am jump..&quot;</span>);</span><br><span class="line">hwh.rap = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am rap..&quot;</span>);</span><br><span class="line">hwh.play_basketball = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am playing basketball ..&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试输出</span></span><br><span class="line">hwh.sing();   <span class="comment">// 输出：i am sing..</span></span><br><span class="line">hwh.jump();   <span class="comment">// 输出：i am jump..</span></span><br></pre></td></tr></table></figure>
<p>同前，此时原型链查找顺序为：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p>
<ol>
<li>
<p>对象<em>student</em> 原型对象<em>prototype</em> 会自动赋值给 <em>hwh._<em>proto</em>_</em> （<em>student.prototype</em> 属性也是一个对象）</p>
</li>
<li>
<p>如果没有在实例<em>hwh</em> 中找到属性、方法就会自动在<em>hwh._<em>proto</em>_</em> 中查找，等价于在 <em>student.prototype</em> 查找</p>
</li>
<li>
<p>对象<em>student.prototype</em> 又有个对象属性 <em>student.prototype._<em>proto</em>_</em> 它被赋值为<em>Object</em> 原型<em>Object.prototype</em></p>
</li>
<li>
<p>如果<em>student.prototype</em> 没有找到属性，就会接着在 <em>student.prototype._<em>proto</em>_</em> 中查找（等价在原型<em>Object.prototype</em> 中查找）</p>
</li>
<li>
<p>最后还有还找到返回null</p>
</li>
</ol>
<h3 id="2-初识原型链">2. 初识原型链</h3>
<p>当我们用<code>对象名.xxx</code>访问一个对象属性时，<em>JavaScript</em> 引擎查找顺序如下：</p>
<ol>
<li>先在当前对象上查找该属性，如果没有找到；</li>
<li>在其原型对象上找，如果还没有找到；</li>
<li>一直上溯到 <em>Object.prototype</em> --&gt; <em>null</em>  ；</li>
<li>上溯到<em>null</em> 说明未找到，返回 <em>undefined</em> 。</li>
</ol>
<blockquote>
<p>等等，这里原型链是什么？</p>
</blockquote>
<p>当我们创建一个 <em>Array</em> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>数组 <em>arr</em> 它的原型链是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr ----&gt; <span class="built_in">Array</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>由于 <em>Array.prototype</em> 定义了 <em>indexof()</em> 、<em>shift()</em> 等方法，所以我们可以直接使用。</p>
<p>同理，创建一个函数 <em>fun()</em> 其原型链为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么前面以构造函数创建的hwh对象原型链是？（参考 <u>1.创建对象 — 构造函数创建对象</u> 一节）</p>
</blockquote>
<p><code>构造函数</code> 创建的<em>hwh</em>对象其原型链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ----&gt; Student.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>或者用图表达：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p>
<p>⚠️ 这里 <em>Array、Function、Student</em> 都是构造函数，因此有<em>prototype</em> 属性 即<u>函数原型</u>（见下详述）。</p>
<p>​      注：每一个对象或函数都有*_<em>proto</em>_*属性（<u>默认指向 <em>Object.prototype</em></u>），但只有函数才有 <em>prototype</em> 属性。</p>
<h4 id="使用原型链基本原则">使用原型链基本原则</h4>
<p>基本使用原型链原则：</p>
<ul>
<li>
<p>原型链不应该过长，这会在查找对象属性花费过多时间。</p>
</li>
<li>
<p>构造函数名首字母应该为大写（像约定类名首字母大写）。</p>
</li>
</ul>
<h3 id="3-深入理解原型链">3.深入理解原型链</h3>
<h4 id="prototype-proto"><em>prototype</em> &amp; <em>_<em>proto</em>_</em></h4>
<p>在前我们知道构造函数也是可以拥有属性的，<em>prototype</em> 是只有函数才拥有的共有属性。属性<em>prototype</em> 又称为 <u>函数原型</u>，它是一个对象。</p>
<p><em>_<em>proto</em>_</em>  是所有对象、函数都有属性，它也是一个对象，指向生成它的构造函数原型<em>prototype</em> 属性。因为所有对象都派生自 <em>Object</em> 构造函数，所以默认指向原型<em>object.prototype</em> 属性。如果是通过构造函数创建的实例对象，则指向生成它的构造函数原型<em>prototype</em> 。</p>
<p>（而<em>prototype</em> 也是一个对象，所以不难理解它也有*_<em>proto</em>_*属性 ：<em>prototype._<em>proto</em>_</em>）</p>
<p><u>在函数原型上定义的方法、属性会被所有实例“继承”</u>，（<strong>准确来说，构造函数<em>new</em> 出的实例才会继承构造函数所有属性，函数原型上定义的方法、属性只是可以通过原型链查找而被使用，看上去好像“继承”了</strong>）。</p>
<p>函数原型对象<em>prototype</em>主要包含的属性方法如下（<em>prototype</em> 是一个对象所以也有很多键值对属性）：</p>
<ul>
<li>
<p>原型本身定义的 <strong>原型</strong> 属性、方法（只有通过 <code>函数名.prototype.属性名 = 方法/属性</code> 定义的才是原型方法、属性 ）</p>
</li>
<li>
<p><em>constructor</em> 属性：指向构造函数本身</p>
</li>
<li>
<p><em>_<em>proto</em>_</em> 属性：和原型链上级构造函数原型<em>prototype</em>属性等价</p>
</li>
</ul>
<blockquote>
<p>进一步理解函数原型对象？</p>
</blockquote>
<p>我们创建一个空构造函数 <em>Student()</em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)  // 构造函数首字母建议大写</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;hwh&quot;</span>;  <span class="comment">// [注1]</span></span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.shcool = <span class="string">&quot;chongqingU&quot;</span>;   <span class="comment">// 给Student函数增加属性，这样可以增加到原型对象上</span></span><br><span class="line">Student.age = <span class="number">23</span>;       <span class="comment">// [注2]</span></span><br></pre></td></tr></table></figure>
<p>试想一下，如果我们之前用对象来作为原型创建实例， 把函数<em>Student()<em>改为对象</em>Student</em>应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [注1] 添加的属性name不属于函数原型方法属性，但可被创建的实例继承，是实例属性</span></span><br><span class="line"><span class="comment">// [注2] 添加的属性age，既不属于函数原型方法属性，也不会被实例继承，只能自娱自乐</span></span><br><span class="line"></span><br><span class="line">Student     </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们便有了函数原型 <em>Student.prototype</em> 的一个初步雏形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype   </span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，实际的 <em>Student.prototype</em> 属性不会这么简单：它还拥有<em>constructor</em>属性指向构造函数本身 ；<em>_<em>proto</em>_</em> 属性指向上一级构造函数原型<em>prototype</em> 。</p>
<p>我们尝试打印会出来类似下面结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Student.prototype);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">shcool</span>:<span class="string">&quot;chongqingU&quot;</span>               <span class="comment">// 1.函数原型增加的原型属性：shcool</span></span><br><span class="line">    <span class="attr">constructor</span>: ƒ doSomething(),     <span class="comment">// 2.constructor：指向Student本身</span></span><br><span class="line">    <span class="attr">__proto__</span>: &#123;                      <span class="comment">// 3.__proto__：== object.prototype</span></span><br><span class="line">        <span class="attr">constructor</span>: ƒ <span class="built_in">Object</span>(),</span><br><span class="line">        <span class="attr">hasOwnProperty</span>: ƒ hasOwnProperty(),</span><br><span class="line">        <span class="attr">isPrototypeOf</span>: ƒ isPrototypeOf(),</span><br><span class="line">        <span class="attr">propertyIsEnumerable</span>: ƒ propertyIsEnumerable(),</span><br><span class="line">        <span class="attr">toLocaleString</span>: ƒ toLocaleString(),</span><br><span class="line">        <span class="attr">toString</span>: ƒ toString(),</span><br><span class="line">        <span class="attr">valueOf</span>: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到构造函数<em>Student.prototype._<em>proto</em>_</em> 属性指向—&gt;上一级构造函数<em>object.prototype</em> 属性。</p>
<p>(<em>_<em>proto</em>_</em> 属性默认指向<em>Object</em> 原型)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.__proto__ === object.prototype;   <span class="comment">// ture</span></span><br></pre></td></tr></table></figure>
<p>t由上介绍我们也知道，用构造函数创建的实例*_<em>proto</em>_* 属性，会指向生成它的构造函数原型 <em>prototype</em> 属性。</p>
<blockquote>
<p>利用构造函数<em>Student</em> 创建实例<em>hwh</em> 对象，打印出它的 <em>_<em>proto</em>_</em> 属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(hwh.__proto__);</span><br></pre></td></tr></table></figure>
<p>下面打印出的实际就是原型 <em>Student.prototype</em> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">shcool</span>:<span class="string">&quot;chongqingU&quot;</span>               <span class="comment">// 1.原型本身拥有的属性：shcool</span></span><br><span class="line">    <span class="attr">constructor</span>: ƒ doSomething(),     <span class="comment">// 2.constructor：指向Student本身</span></span><br><span class="line">    <span class="attr">__proto__</span>: &#123;                      <span class="comment">// 3.__proto__：== object.prototype</span></span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，函数原型可看作是 <u>构造函数的一个&quot;实例&quot;</u> ，但是：</p>
<ul>
<li>只有 <code>函数名.prototype.属性</code> OR  <code>函数名.prototype.方法</code> 声明的属性/方法才是原型属性/方法</li>
<li>&quot;实例&quot;还自动拥有 <em>constructor</em> &amp; <em>_<em>proto</em>_</em> 属性分别指向函数本身和下一级构造函数原型</li>
</ul>
<h4 id="原型链查找">原型链查找</h4>
<p>好的聪明的你肯定想起来，我们前面写出的 <em>Student</em> 构造函数创建的 <em>hwh</em> 对象原型链：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564109191794.png" alt="1564109191794"></p>
<p>和我们此前说过的原型链查找某属性规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前对象查找属性 ---&gt; 上一级原型查找 ---&gt; .... ---&gt; object原型查找 ---&gt; 还没找到则为<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>用一张图概况整个过程应该是：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564027583727.png" alt="1564027583727"></p>
<ul>
<li>在对象 <em>hwh</em> 本身实例属性查找，未找到则在 <em>hwh._<em>proto</em>_</em> 查找</li>
<li><em>hwh._proto__</em> 实际 ===上级原型<em>Student.prototype</em> ，在该原型中查找定义的原型属性、方法</li>
<li>未找到则在<em>hwh._<em>proto</em>_.prototype._<em>proto</em>_</em> === <em>Student.prototype._<em>proto</em>_</em> ===上级原型 <em>Object.prototype</em>，查找该原型中定义的属性、方法</li>
<li>还未找到则返回null</li>
</ul>
<p>如果我们把构造函数<em>Student</em> 原型指向另外一个实例，那么原型链查找顺序如何变化？</p>
<blockquote>
<p>创建实例lt，它有属性<code>name = “liuting”</code> 。把<em>Student.prototype</em>指向lt后，分析原型链查找<em>name</em>过程。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lt = <span class="keyword">new</span> Student();  </span><br><span class="line">lt.name = <span class="string">&quot;liuting&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>此时我们还可以看到：<code>lt.__proto__ === Student.prototype</code> 为<em>ture</em> ，指向生成它的构造函数原型。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564044783639.png" alt="1564044783639"></p>
<p>而当把<em>Student</em> 原型指向<em>lt</em> 后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = lt;   <span class="comment">// Student原型指向lt</span></span><br></pre></td></tr></table></figure>
<p><code>lt.__proto__ === Student.prototype</code> 为 <em>false</em>， <em><em><em>lt._<em>proto</em>_</em> 还是保存原来未修改前的</em>Student</em> 函数原型**。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564046067250.png" alt="1564046067250"></p>
<p>再用构造函<em>Student</em>数创建新对象hwh：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.__proto__ === Student.prototype === lt;   <span class="comment">// ture</span></span><br></pre></td></tr></table></figure>
<p>用一张图概括原型链变化应该是：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564049416082.png" alt="1564049416082"></p>
<p>我们尝试输出 <code>hwh.name</code>，显然可以在原型链 <code>实例lt</code> 的 <code>lt属性方法</code> 找到 <code>name</code> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.name);     <span class="comment">// 输出:liuting</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-构造函数继承">4.2 构造函数继承</h2>
<p>我们定义一个构造函数 <em>Student()</em>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>其原型链为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>现在我们又定义了个构造函数 <em>People()</em> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望<em>Student</em> 能继承  <em>People</em> ,从而可以使用 <em>People</em> 的 <em>eat()</em> 方法，并且把原型链修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype ---&gt; People.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>那么该怎么办呢？</p>
<h3 id="1-构造函数绑定">1. 构造函数绑定</h3>
<p>前面我们讲过<em>apply</em>方法：<code>函数名.apply(对象名,[])</code> 。</p>
<p>可以将函数所有 <u>绑定到this的属性</u> 转而—&gt; <u>绑定到指定对象</u> 上。（注：非严格模式下函数<em>this</em> 指向 <em>undefined</em>）</p>
<p>因此，我们可以将构造函数<em>People</em> <u>绑定到this的属性</u> —&gt; 绑定到构造函数<em>Student</em> 生成的对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// this指向Student构造函数创建的对象</span></span><br><span class="line">    <span class="comment">// 将构造函数People绑定到this的属性(不是People所有属性) ---&gt; 绑定到Student对象上</span></span><br><span class="line">    People.apply(<span class="built_in">this</span>,[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();   <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure>
<p>这样只是继承了<em>Student</em> 所有的属性，但是其原型链没有改变，还是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>之所以<em>hwh</em> 能调用 <em>eat()</em> 方法，是因为该方法已经绑定到 <em>hwh</em> 对象上。</p>
<h3 id="2-prototype-模式">2. <em>prototype</em> 模式</h3>
<p>如果我们把 <em>Student</em> 原型指向 —&gt;一个 <em>People</em> 的实例，那么所有<em>Student</em> 实例都能“继承”<em>People</em> 属性、方法（准确来说，是通过原型链使得<em>Student</em> 实例对象<em>hwh</em> 可以使用构造函数<em>People</em> 的属性、方法）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 良好习惯：修改了prototype要设置回prototype.constructor</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();    <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure>
<p>此时原型继承链为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh --&gt;Student.prototype == <span class="keyword">new</span> People() --&gt;People.prototype --&gt;<span class="built_in">Object</span>.prototype --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>用一张图表示为：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564115792502.png" alt="1564115792502"></p>
<h4 id="为什么有“良好习惯”？">为什么有“良好习惯”？</h4>
<p>在上面我们修改了 <em>Student.prototype</em> 指向，立马有重新设置了 <em>Student.prototype.constructor</em> 指回<em>Student</em> 。</p>
<p>如果不这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();   <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure>
<p>不影响通过原型链使用<em>People.eat()</em> 方法，但我们尝试输出：<em>hwh.constructor</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cosole.log(hwh.constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现构造函数<em>Student</em> 生成的对象<em>hwh.constructor</em> 属性是指向构造函数<em>People</em> ！</p>
<p>首先，我们要知道<em>hwh</em> 本身是没有<em>constructor</em>这个属性的。它是通过原型链查找到构造函数 <em>People.prototype.constructor</em> 属性的，自然它是指向构造函数 <em>People</em> 了：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564133255074.png" alt="1564133255074"></p>
<p>但是对象<em>hwh</em>，是由构造函数<em>Student()</em> 生成的，我们在应该让<em>hwh.constructor</em>  指向生成它的构造函数<em>Student()</em>！</p>
<p>所以就有了上面的 <strong>“良好习惯</strong>”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，你可能会担心，<u>这样<em>People.prototype.constructor</em> 不就被修改了吗</u>？</p>
</blockquote>
<p>实际上，这样做只会在<em>Student.prototype</em> 也就是匿名对象 <em>new People()</em> +键值对：<code>constructor : f Student()</code></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564133877508.png" alt="1564133877508"></p>
<p>看上去好像基本解决了原型链继承问题？但是由于要创建实例对象，开销较大。</p>
<h3 id="3-直接继承-prototype">3. 直接继承 <em>prototype</em></h3>
<p>通过直接把<em>Student.prototype</em> 原型属性直接指向 <em>People.prototype</em> 原型属性，来达到继承<em>People</em> 属性、方法。</p>
<p>通过这种方式，需要把<em>People</em> 的属性、方法绑定到原型对象<em>People.prototype</em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>好了，我们开始 “ 继承 ” <em>People.prototype</em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = People.prototype;</span><br><span class="line"><span class="comment">// 良好的习惯：每次修改函数原型，都应该设置回constructor</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();      <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure>
<p>看起来天衣无缝，而且这比第 <strong>2</strong> 种方法效率更高：不用创建 <em>People</em> 实例。</p>
<p>但这种方式的原型链为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype == People.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564129946659.png" alt="1564129946659"></p>
<p>它没有体现  <em>Student</em> 和<em>People</em>之间原型继承关系，而且也隐藏了一个缺点。</p>
<h4 id="继承-prototype-方式缺点">继承 <em>prototype</em> 方式缺点</h4>
<p>这种方式， <em>Student.prototype</em> 和 <em>People.prototype</em> 现在指向了 <u>同一个对象</u> ，任何对 <em>Student.prototype</em> 修改都将反应在<em>People.prototype</em> 上。</p>
<p>我们在第二行修改了：<code>Student.prototype.constructor = Student;</code> ，会导致<em>People.prototype.constructor</em> 也被指向为构造函数 <em>Student</em> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">People.prototype.constructor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="我的疑问？">我的疑问？</h4>
<blockquote>
<p>为什么不可以直接设置 <em>Student.prototype._<em>proto</em>_</em> 指向 <em>People.prototype</em>  ？？？</p>
</blockquote>
<p>这种方式被很多博文都指出不应该提倡，原因影响性能？<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">MDN-不推荐使用<em>Object.prototype._<em>proto</em>_</em></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.__proto__ = People.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();      <span class="comment">// 可以输出：i am eating</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实现了原型链继承关系</li>
<li>同时因为没有修改<em>Student.prototype</em> ，不用设置 <code>Student.prototype.constructor = Student</code></li>
</ul>
<h3 id="4-利用空对象作为中介">4. 利用空对象作为中介</h3>
<blockquote>
<p>一种基本完美的方法：既可体现原型链 <em>Student</em> 和<em>People</em> 继承关系，也不会导致<em>constructor</em> 之类问题。</p>
</blockquote>
<p>由于第3种办法，会出现指向同一对象导致<em>constructor</em> 意料之外被修改问题，我们可以借用一个空函数作为中介。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空函数F作为媒介</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F原型指向People原型</span></span><br><span class="line">F.prototype = People.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时Student.prototype原型指向空函数F实例对象</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 良好习惯：每次修改函数原型，都应该设置回constructor</span></span><br><span class="line"><span class="comment">// 由于此时Student.prototype 和 People.prototype不再指向同一对象</span></span><br><span class="line"><span class="comment">// 此时修改constructor不会导致 People.prototype.constructor 被同步修改</span></span><br><span class="line">Student.prototype.constructor = Student; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();    <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure>
<p>噢，我的天！这是再变魔术吗？到底怎么一回事呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwh ---&gt; Student.prototype == <span class="keyword">new</span> F() ---&gt; F.prototype = People.prototype --&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564128658845.png" alt="1564128658845"></p>
<h3 id="5-拷贝继承">5. 拷贝继承</h3>
<p>这种方式比较暴力…</p>
<p>首先，把<em>People</em> 的属性、方法绑定到原型对象<em>People.prototype</em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.eat = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;i am eating&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>接着实现将<em>People</em> 原型属性全部拷贝到 <em>Student</em> 原型属性上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象只需普通for循环</span></span><br><span class="line"><span class="comment">// 遍历循环只能用&lt;对象名[&#x27;key&#x27;]&gt;方式，其中&#x27;&#x27;在[i]不用加，i已经是字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> People.prototype)</span><br><span class="line">&#123;</span><br><span class="line">    Student.prototype[i] = People.prototype[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student();</span><br><span class="line">hwh.eat();        <span class="comment">// 输出：i am eating</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<u>通过原型链</u> 实例对象<em>hwh</em> 可以访问到构造函数<em>Student.prototype.eat</em> 属性方法。</p>
<h2 id="4-3-class-继承">4.3 <em>class</em> 继承</h2>
<blockquote>
<p>写的比较简单，需要时再补充。</p>
</blockquote>
<h3 id="初识-class">初识 <em>class</em></h3>
<p>在ES6标准引入了 <em>class</em> 关键字，比原先<em>JavaScript</em> 基于原型链的对象模型更加简单。</p>
<p>现在有一个构造函数 <em>Student</em> 可用来<em>new</em> 出实例对象，它像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; </span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.learn =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;i am learning..&quot;</span>); &#125;;</span><br></pre></td></tr></table></figure>
<p>把它改写成<em>class</em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// new生成实例对象时自动调用该方法，为所有类实例对象生成下列实例属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// learn方法</span></span><br><span class="line">    <span class="function"><span class="title">learn</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;i am learning..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用</span></span><br><span class="line"><span class="keyword">var</span> hwh = <span class="keyword">new</span> Student(<span class="string">&#x27;hwh&#x27;</span>,<span class="number">23</span>);</span><br><span class="line">hwh.learn();   <span class="comment">// 输出：i am learning..</span></span><br></pre></td></tr></table></figure>
<p>看起来比此前写法简单多了，但其实在<em>JavaScript</em> 类 <em>class</em> 本质还是函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Student;  <span class="comment">//  function</span></span><br></pre></td></tr></table></figure>
<p>另一方面，函数自然一定有原型属性<em>prototype</em>  ：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1564147389409.png" alt="1564147389409"></p>
<p>当然，这个’'函数&quot;有点特殊，所有直接在类中定义的属性、方法会被直接绑定到函数原型上。</p>
<p>所以上面 <em>class Student</em> 等价这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.learn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;i am learning..&quot;</span>); &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用-class-实现继承">使用 <em>class</em> 实现继承</h3>
<p>使用<em>class</em> 可以方便的实现继承，我想刚刚学完原型继承的你不会忘记被它支配的恐惧。</p>
<p>现在这有一个类 <em>Girl_Student</em> 继承 <em>Student</em> ，你可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl_Student</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,grade</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ES6规定必须调用父类构造函数一次</span></span><br><span class="line">        <span class="built_in">super</span>(name,age);</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I am at grade: &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gs = <span class="keyword">new</span> Girl_Student(<span class="string">&#x27;lt&#x27;</span>,<span class="number">23</span>,<span class="number">395</span>);</span><br><span class="line">gs.myGrade();  <span class="comment">// 调用自身方法：I am at grade 395</span></span><br><span class="line">gs.learn();    <span class="comment">// 调用父类方法：i am learning..</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/20680/">https://hwh.zone/p/20680/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/30504/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端基础（二）CSS基础笔记</div></div></a></div><div class="next-post pull-right"><a href="/p/41171/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端基础（一）JavaScript基础笔记(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/41171/" title="前端基础（一）JavaScript基础笔记(上)"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">前端基础（一）JavaScript基础笔记(上)</div></div></a></div><div><a href="/p/11812/" title="前端基础（一）JavaScript基础笔记（下）"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">前端基础（一）JavaScript基础笔记（下）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第三章：标准对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%B0%8F%E5%9F%8E%E5%B0%91%E5%B9%B4%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9D%91"><span class="toc-text">3.1 小城少年对象与坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="toc-text">包装对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Date"><span class="toc-text">3.2 Date</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="toc-text">时区问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-RegExp%EF%BC%88%E5%BE%85%EF%BC%89"><span class="toc-text">3.3 RegExp（待）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-JSON"><span class="toc-text">3.4 JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-text">进一步处理：传递函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0-2"><span class="toc-text">进一步处理：传递函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第四章：面对对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%9C%A8-JS-%E4%B8%96%E7%95%8C%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.1 在 JS 世界面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E4%BA%86%E8%A7%A3"><span class="toc-text">扩展了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-create-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">Object.create()创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">构造函数创建对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E8%AF%86%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">2. 初识原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-text">使用原型链基本原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">3.深入理解原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prototype-proto"><span class="toc-text">prototype &amp; _proto_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%9F%A5%E6%89%BE"><span class="toc-text">原型链查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">4.2 构造函数继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-text">1. 构造函数绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-prototype-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. prototype 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E2%80%9C%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E2%80%9D%EF%BC%9F"><span class="toc-text">为什么有“良好习惯”？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF-prototype"><span class="toc-text">3. 直接继承 prototype</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-prototype-%E6%96%B9%E5%BC%8F%E7%BC%BA%E7%82%B9"><span class="toc-text">继承 prototype 方式缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E7%96%91%E9%97%AE%EF%BC%9F"><span class="toc-text">我的疑问？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A9%E7%94%A8%E7%A9%BA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E4%B8%AD%E4%BB%8B"><span class="toc-text">4. 利用空对象作为中介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8B%B7%E8%B4%9D%E7%BB%A7%E6%89%BF"><span class="toc-text">5. 拷贝继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-class-%E7%BB%A7%E6%89%BF"><span class="toc-text">4.3 class 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-class"><span class="toc-text">初识 class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-class-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">使用 class 实现继承</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/52463/" title="C++从零开始（二）：基础语法（上）之快速入门">C++从零开始（二）：基础语法（上）之快速入门</a><time datetime="2021-12-09T05:31:37.851Z" title="发表于 2021-12-09 13:31:37">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a><time datetime="2021-12-05T08:28:39.054Z" title="发表于 2021-12-05 16:28:39">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a><time datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/62712/" title="C++从零开始（零）">C++从零开始（零）</a><time datetime="2021-12-05T08:22:28.029Z" title="发表于 2021-12-05 16:22:28">2021-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/52463/" title="C++从零开始（二）：基础语法（上）之快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：基础语法（上）之快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）之VSCode远程开发</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记"><i class="post-icon gg-file-document"></i>Git基础笔记</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Python/">
          Python
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7160/" title="Python 基础笔记"><i class="post-icon gg-file-document"></i>Python 基础笔记</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">
          前端
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">
          JavaScript
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/41171/" title="前端基础（一）JavaScript基础笔记(上)"><i class="post-icon gg-file-document"></i>前端基础（一）JavaScript基础笔记(上)</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/20680/" title="前端基础（一）JavaScript基础笔记(中)"><i class="post-icon gg-file-document"></i>前端基础（一）JavaScript基础笔记(中)</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/11812/" title="前端基础（一）JavaScript基础笔记（下）"><i class="post-icon gg-file-document"></i>前端基础（一）JavaScript基础笔记（下）</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">
          CSS
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/30504/" title="前端基础（二）CSS基础笔记"><i class="post-icon gg-file-document"></i>前端基础（二）CSS基础笔记</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Java/">
          Java
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Java/Java%E5%9F%BA%E7%A1%80/">
          Java基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44149/" title="Java基础笔记"><i class="post-icon gg-file-document"></i>Java基础笔记</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
          数据库
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
          Redis
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/9336/" title="数据库（二）Redis基础"><i class="post-icon gg-file-document"></i>数据库（二）Redis基础</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
          MySQL
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/39784/" title="数据库（一）MySQL基础笔记"><i class="post-icon gg-file-document"></i>数据库（一）MySQL基础笔记</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">
          深度学习
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Numpy/">
          Numpy
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/64865/" title="深度学习基础（一）Numpy"><i class="post-icon gg-file-document"></i>深度学习基础（一）Numpy</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/OpenCV/">
          OpenCV
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61137/" title="深度学习基础（三）OpenCV"><i class="post-icon gg-file-document"></i>深度学习基础（三）OpenCV</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/">
          Pytorch
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/33170/" title="深度学习基础（二）Pytorch"><i class="post-icon gg-file-document"></i>深度学习基础（二）Pytorch</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>