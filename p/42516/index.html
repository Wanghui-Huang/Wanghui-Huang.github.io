<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（一）_Java_JVM | royhuang's blog</title><meta name="keywords" content="JAVA,校招"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（一）_Java_JVM">
<meta property="og:url" content="https://hwh.zone/p/42516/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2021-11-26T12:06:06.920Z">
<meta property="article:modified_time" content="2021-12-03T03:56:42.625Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="校招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/42516/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（一）_Java_JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:56:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">校招笔记（一）_Java_JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-26T12:06:06.920Z" title="发表于 2021-11-26 20:06:06">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:56:42.625Z" title="更新于 2021-12-03 11:56:42">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（一）_Java_JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我的校招记录：<a target="_blank" rel="noopener" href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>算法能力（“刷题”）</strong></td>
<td style="text-align:center">这部分就是耗时间多练习，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td>
<td style="text-align:center">补充练习：<a target="_blank" rel="noopener" href="https://codetop.cc/">codeTop</a></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td>
<td style="text-align:center">C++后端后续更新</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>项目&amp;实习</strong></td>
<td style="text-align:center">主要是怎么准备项目，后续更新</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="1-6-JVM相关">1.6 JVM相关</h2>
<h3 id="1-6-1-常问问题">1.6.1 常问问题</h3>
<h4 id="1-（被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）">1. （被问过）<strong>JVM启动的基本配置参数有哪些</strong>？（或者说调优参数）</h4>
<p><strong>「堆栈内存相关」</strong></p>
<ul>
<li>
<p>-Xms： 设置初始堆的大小</p>
</li>
<li>
<p>-Xmx： 设置最大堆的大小</p>
</li>
<li>
<p>-Xmn ：设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</p>
</li>
<li>
<p>-Xss： 每个线程的堆栈大小</p>
</li>
<li>
<p>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</p>
</li>
<li>
<p>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</p>
</li>
<li>
<p>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</p>
</li>
<li>
<p>-XX:SurvivorRatio Eden区与Survivor区的的比值</p>
</li>
<li>
<p>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</p>
</li>
<li>
<p>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</p>
</li>
</ul>
<p><strong>「垃圾收集器相关」</strong></p>
<p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</p>
<ul>
<li>
<p>-XX:ParallelGCThreads=20：配置并行收集器的线程数</p>
</li>
<li>
<p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</p>
</li>
<li>
<p>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</p>
</li>
<li>
<p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
</li>
</ul>
<p><strong>「辅助信息相关」</strong></p>
<ul>
<li>
<p>-XX:+PrintGCDetails 打印GC详细信息</p>
</li>
<li>
<p>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用</p>
</li>
<li>
<p>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.</p>
</li>
<li>
<p>-XX:+PrintTLAB 查看TLAB空间的使用情况</p>
</li>
</ul>
<h4 id="2-说说堆和栈的区别？">2.<strong>说说堆和栈的区别</strong>？</h4>
<ol>
<li>
<p><strong>功能不同</strong>：栈内存用来存储<u>局部变量和方法调用</u>，而堆内存用<u>来存储Java中的对象</u>；</p>
<blockquote>
<p>注：无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>
</blockquote>
</li>
<li>
<p><strong>共享性不同</strong>：栈内存是线程私有的； 堆内存是所有线程共有的；</p>
</li>
<li>
<p><strong>异常错误不同</strong>：如果栈内存或者堆内存不足，都会抛出异常但不同；</p>
<blockquote>
<p>栈空间不足：<code>java.lang.StackOverFlowError</code>。 堆空间不足：<code>java.lang.OutOfMemoryError</code>；</p>
</blockquote>
</li>
<li>
<p><strong>空间大小</strong>：栈的空间大小远远小于堆的。</p>
</li>
</ol>
<h4 id="3-【重点】请问JVM运行时内存布局分布？-哪些是线程共享的？">3.<strong>【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的</strong>？</h4>
<p>从概念上大致分为 6 个（逻辑）区域，参考下图。注：Method Area 中还有一个常量池区，图中未明确标出。</p>
<ul>
<li>总的来看，JVM 把内存划分为<u>“栈(stack)”与“堆(heap)”</u>两大类</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/dd/a9/dd614bf56417939aa0e0694fedf2caa9.png" alt="img"></p>
<p><u>线程私有的：</u></p>
<ul>
<li>
<p><strong>程序计数器</strong>：当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，<u>每个线程就需要一个属于自己的计数器来记录下一条要运行的指令</u>；</p>
</li>
<li>
<p><strong>虚拟机栈</strong>： <u>每个java方法执行时都会创建一个<strong>桢栈</strong></u>来存储方法的：</p>
<ul>
<li>
<p>变量表、操作数栈、动态链接方法、返回值、返回地址等信息；</p>
</li>
<li>
<p>栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法），“<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">栈帧参考</a>” ；</p>
</li>
</ul>
</li>
<li>
<p><strong>本地方法栈</strong>： 与虚拟机栈作用相似。但它不是为Java方法服务的，而是调用操作系统原生本地方法时，所需要的内存区域。</p>
<ul>
<li>本地方法被执行的时候，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li>
</ul>
</li>
</ul>
<p><u>线程共享的：</u></p>
<ul>
<li>
<p><strong>堆</strong>：GC 垃圾回收的主站场，用于<u>存放类的实例对象及 数组实例</u>等；</p>
<p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p>
</li>
<li>
<p><strong>方法区</strong>： 线程共享的，用于存放被虚拟机加载的<strong>类的元数据信息</strong>：</p>
<ul>
<li>如 <u><strong>常量</strong>、<strong>静态变量</strong></u>和 <u> 即时<strong>编译器编译后的代码</strong></u><strong>；</strong></li>
<li><strong>运行时常量池：字符串</strong>，int -128~127 范围的值等，它是 <u>方法区</u> 中的一部分。</li>
</ul>
</li>
</ul>
<h5 id="3-1-JVM-堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？">3.1 JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111809384">https://zhuanlan.zhihu.com/p/111809384</a></p>
</blockquote>
<ul>
<li>
<p><strong>堆划分</strong>：堆又被划分为，新生代，老年代。新生代又被划分为eden和survivor区。</p>
</li>
<li>
<p><strong>为什么划分新生代、老年代</strong>？</p>
<p>因为有的对象寿命长，有的对象寿命短。<strong>应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率</strong>。</p>
</li>
<li>
<p><strong>代替</strong>： 在java7版本前，堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。<strong>但在物理上来说，它们又是连续的一块内存</strong>。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224656302.png" alt="image-20210906224656302" style="zoom:50%;" />
<p><strong>也就是说，方法区和前面讲到的Eden和老年代是连续的</strong>。</p>
<p><strong>永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集</strong>。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224744446.png" alt="image-20210906224744446" style="zoom:50%;" />
<p>在Java8中，元空间(Metaspace)登上舞台，<strong>方法区存在于元空间(Metaspace)</strong>。同时，元空间不再与堆连续，<strong>而且是存在于本地内存（Native memory）。本地内存（Native memory），也称为C-Heap</strong>，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210906224848120.png" alt="image-20210906224848120" style="zoom:50%;" />
<p><strong>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了</strong>。</p>
</li>
</ul>
<h5 id="3-2-程序计数器存哪些东西？能为空吗？">3.2 <strong>程序计数器存哪些东西？能为空吗</strong>？</h5>
<p>程序计数器是用于存放下一条指令所在单元的地址的地方。</p>
<p>如果正在执行的是Native方法，这个计数器值为空（Ubdifined）。</p>
<h4 id="4-（新）说一下Java创建对象的过程？">4. （新）说一下Java创建对象的过程？</h4>
<p><img src="https://i.loli.net/2021/05/16/EBIujUDhkF9VRtg.png" alt="image-20210516205754856"></p>
<ol>
<li>
<p><strong>类加载检查</strong>： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在<strong>常量池中定位到这个类的符号引用</strong>，并且检查这个符号引用代表的<strong>类是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li>
<p><strong>分配内存</strong>： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定大小的内存从 <u>Java 堆中划分出来</u>。</p>
<blockquote>
<p><strong>（重要）分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整⼜由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="https://i.loli.net/2021/05/16/S27KdREVrpGqt5I.png" alt="image-20210516210222497"></p>
</blockquote>
</li>
<li>
<p><strong>初始化对象字段零值</strong>。 内存分配完成后，进行对象初始化操作。</p>
<blockquote>
<p>例如给<strong>对象中（区分类加载过程，初始化类变量</strong>）所有的基本数据变量赋上初始化值， 当我们没有对它们进行赋值操作时就可以使用对象了。</p>
</blockquote>
</li>
<li>
<p><strong>设置对象头</strong>： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是<u>哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息</u>。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用<u>偏向锁</u>等，对象头会有不同的设置方式。</p>
</li>
<li>
<p><strong>执行init() &amp; 构造函数</strong>。然后执行对象内部生成的init方法，然后执行构造器方法（程序员设置的）。</p>
</li>
<li>
<p><strong>内存地址赋给引用</strong>： 在虚拟机会将刚创建好对象的内存地址赋给引用对象。完成此操作后，便可以在程序中通过引用访问对象的实例数据。</p>
</li>
</ol>
<h5 id="4-1-什么是指针碰撞？空闲列表？TLAB">4.1 什么是指针碰撞？空闲列表？TLAB?</h5>
<p>三种虚拟机<strong>划分堆内存</strong>区域的方法，TLAB也可用来给堆内存分配空间。</p>
<ul>
<li>
<p><strong>指针碰撞</strong></p>
<p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。</p>
<ul>
<li>如果Java堆中内存是绝对规整的，所有被<strong>使用过的的内存都被放到一边，空闲的内存放到另外一边</strong>，中间放着一个<strong>指针作为分界点</strong>的指示器，<u>所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例</u>，这种分配方式就是指针碰撞。</li>
</ul>
</li>
<li>
<p><strong>空闲列表</strong></p>
<p><u>如果Java堆内存中的内存并不是规整的</u>，已被使用的内存和空闲的内存相互交错在一起，<u>不可以进行指针碰撞</u>。</p>
<ul>
<li>虚拟机必须维护一个列表，<strong>记录哪些内存是可用的</strong>，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li>
</ul>
</li>
<li>
<p><strong>TLAB</strong></p>
<p>TLAB 是虚拟机在内存的<u><strong>eden 区</strong>划分出来的一块专用空间，是线程专属的</u>。 在启用TLAB 的情况下，当线程被创建时，虚拟机会为每个线程分配一块TLAB 空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提高分配效率。</p>
<blockquote>
<p>虚拟机通过 -XX:UseTLAB 设定它的。</p>
</blockquote>
</li>
</ul>
<h5 id="4-2-JVM如何保证对象分配的线程安全问题？">4.2 JVM如何保证对象分配的线程安全问题？</h5>
<p>因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>TLAB</strong>： 为<strong>每⼀个线程预先在Eden区分配⼀块⼉内存TLAB</strong>，JVM在<strong>给线程中的对象分配内存时，⾸先在TLAB分配</strong>，当<u>对象大于TLAB中的剩余内存或TLAB的内存已用尽时</u>，再采用的CAS进行内存分配。</li>
<li><strong>CAS+失败重试</strong>： CAS 是乐观锁的⼀种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为⽌。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
</ul>
<h4 id="5-描述一下对象分配【原则】？（区分前面new对象【过程】）">5.<strong>描述一下对象分配【原则】？（区分前面new对象【过程】</strong>）</h4>
<p>JVM 中的堆可划分为两大部分，<u>新生代和老年代</u>，大小比例为1:2：</p>
<ul>
<li>新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to 区</li>
</ul>
<p><img src="https://i.loli.net/2021/05/05/6Ri9BzxGtLpFemP.png" alt="img"></p>
<p>具体回收过程：</p>
<p><img src="https://i.loli.net/2021/04/19/p2LqRv6krQnbga4.png" alt="image-20210419224230046"></p>
<p>对象的正常流程：<em>Eden 区 -&gt; Survivor 区 -&gt; 老年代</em>。</p>
<ol>
<li>新的对象<strong>优先在 Eden 区分配</strong>（<em>大对象直接进入老年区，避免在Eden区及两个Survivor区之间发生大量的内存复制</em>） ,<strong>当 Eden 区没有足够空间时</strong>，会发起一次<em><strong>Minor GC</strong></em>；</li>
<li><em><strong>Minor GC</strong></em>采用<strong>复制回收算法</strong>的改进版本回收Eden中对象：
<ul>
<li>先将Eden存活对象迁移到 to 区，然后清空Eden</li>
<li>最后交换to和from区域<strong>标签</strong></li>
</ul>
</li>
<li>每经过一次<em><strong>Minor GC</strong></em>  （在交换区）后对象年龄加1，对象年龄达到<em><strong>15次</strong></em>后将会晋升到老年代；</li>
<li>对象提前晋升到老年代，动态年龄判定：如果在 Survivor 区中相<u>同年龄所有对象大小总和大于 Survivor 区大小的一半</u>， 年龄大于或等于该年龄的对象就可以直接进入老年代；</li>
<li>老年代空间不够时进行<em><strong>Full GC</strong></em>。</li>
</ol>
<h5 id="5-1-对象一定分配到堆上吗？">5.1 对象一定分配到堆上吗？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&amp;mid=2650500024&amp;idx=1&amp;sn=0997c486387bf56bbe8ca909d55a7edf&amp;chksm=83c88c44b4bf05521d66f6a396550cd9c8379c3fdddee1ee198968f6a9ddd172550d3329a94d&amp;scene=21#wechat_redirect">面试官：是不是所有的对象和数组都会在堆内存分配空间</a></p>
</blockquote>
<blockquote>
<p>小伙，来给我讲一下是不是<strong>所有的对象和数组</strong>都会在堆内存分配空间？</p>
</blockquote>
<p>并不是，这涉及到<strong>对象逃逸</strong>。请看下面的代码：</p>
<p>StringBuffer对象，最终会被return，也就是<strong>会被该方法之外的给利用</strong>。 发生了对象逃逸。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/640" alt="图片"></p>
<p><strong>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识</strong>。 但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一<strong>个对象并没有逃逸出方法的话</strong>，那么就可能被<strong>优化成栈上分配</strong>。</p>
<h4 id="6-对象的访问定位有哪两种方式">6.<strong>对象的访问定位有哪两种方式</strong>?</h4>
<p>建⽴对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，⽬前主流的访问方式有：<strong>①使用句柄和 ②直接指针两种</strong>。</p>
<ol>
<li>
<p><strong>句柄</strong>： 如果使用句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据（存放在方法区</strong>）各⾃的具体地址信息；</p>
<blockquote>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/16/4XShu2w1nRbZl5x.png" alt="image-20210516211902118"></p>
</li>
<li>
<p><strong>直接指针</strong>： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，<strong>而reference 中存储的直接就是对象的地址</strong>。</p>
<blockquote>
<p>使用直接指针访问方式最大的好处就是速度快，它节省了⼀次指针定位的时间开销。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/16/lTvrqnOFu5X9VJk.png" alt="image-20210516212141885"></p>
</li>
</ol>
<h4 id="7-如何判断对象是否需要回收（死亡）？">7.<strong>如何判断对象是否需要回收（死亡</strong>）？</h4>
<ul>
<li><strong>可达性分析</strong>：根据引用的关系构造引用链（有向图），在图中不可达的对象就是要被回收的；</li>
<li><strong>引用计数</strong>：有地方引用该对象，计数器++，引用失效，计数器–，有循环引用的问题。</li>
</ul>
<h4 id="8-如何判断一个常量是废弃变量？如何判断一个类是无用类？">8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</h4>
<ul>
<li>
<p><strong>判断常量是废弃变量</strong></p>
<p>运行时常量池主要回收的是废弃的常量。</p>
<p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量&quot;abc&quot; 就是废弃常量，如果这时发⽣内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。</p>
</li>
<li>
<p><strong>判断类是无用类</strong>？</p>
<p>虚拟机可以对满足下面3个条件的无用类进行回收，这⾥说的仅仅是“可以”，而并不是和对象⼀样不使用了就会必然被回收。</p>
<ul>
<li>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</p>
</li>
<li>
<p>加载该类的 ClassLoader 已经被回收；</p>
</li>
<li>
<p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-6-1-GC相关">1.6.1 GC相关</h3>
<blockquote>
<p>不错的GC介绍文章：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">一文看懂 JVM 内存布局及 GC 原理</a></p>
</blockquote>
<h4 id="1-请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？">1.<strong>请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收</strong>？</h4>
<p>当程序员创建对象时，GC就开始监控这个对象的<u>地址、大小</u>及<u>使用情况</u> ，当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间 ：</p>
<ul>
<li><strong>基本原理</strong>： GC采用<u><strong>有向图</strong></u>的方式记录和管理<strong>堆(heap)<strong>中的所有对象 ，并确定对象</strong>是否“可达”</strong></li>
<li><strong>GC优点</strong>：（1）使得程序员不用考虑内存管理 （2）Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot; （3）有效防止内存泄漏</li>
<li><strong>马上回收</strong>： 程序员<strong>不能实时</strong>的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</li>
<li><strong>主动回收</strong>： 手动执行<code>System.gc()</code> ，但是Java语言规范 <u>并不保证</u> GC一定会执行。</li>
</ul>
<h5 id="1-1-本地java程序默认启动的是什么垃圾回收器？">1.1 本地java程序默认启动的是什么垃圾回收器？</h5>
<p>cmd执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>
<p>输出：<a target="_blank" rel="noopener" href="http://codewenda.com/xx%EF%BC%9Auseparallelgc%E5%92%8C-xx%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-useparnewgc/">-XX：UseParallelGC</a>。</p>
<h4 id="2-什么是GC-Root？可以作为GC-Root的对象？">2.<strong>什么是GC Root？可以作为GC Root的对象</strong>？</h4>
<ul>
<li>
<p><strong>GC Root <strong>：  判断对象是通过可达性分析，所以所有的可达性算法</strong>都会有起点</strong> ，这就是 GC Root。</p>
<ul>
<li><strong>特点</strong>：当前时刻存活的对象！</li>
</ul>
<p>通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p>
<p><img src="https://pic1.zhimg.com/80/v2-38552a00d9bfb53f0c780e26a0d4b078_720w.jpg" alt="img"></p>
</li>
<li>
<p><strong>GC Root对象</strong>： （1）虚拟机栈中<strong>引用</strong>的<strong>对象</strong>；（2）方法区中的<strong>静态</strong>变量、<strong>常量</strong>对象；（3）本地方法<strong>引用</strong>的<strong>对象</strong>；（4）被<code>synchronized</code>修饰的对象等。</p>
</li>
</ul>
<h4 id="3-哪些内存区域需要GC">3.<strong>哪些内存区域需要GC?</strong></h4>
<ul>
<li>
<p><strong>（无需）线程独享区域</strong>：<code>PC Regiester、JVM Stack、Native Method Stack</code>，其生命周期都与线程相同（即：与线程共生死），所以无需 GC;</p>
</li>
<li>
<p><strong>（需）线程共享</strong>的 Heap 区、Method Area 则是 GC 关注的重点对象。</p>
</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/e3/71/e36c624e8b4300775123f95a34b86571.png" alt="img"></p>
<h4 id="4-什么时候会触发Full-GC？">4.<strong>什么时候会触发Full GC？</strong></h4>
<ol>
<li>
<p><strong>调用 System.gc()</strong> ；</p>
</li>
<li>
<p><strong>老年代空间不足</strong>；</p>
</li>
<li>
<p><strong>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</strong>；</p>
<blockquote>
<p>如果发现<strong>统计之前Minor GC的平均晋升大小比目前old gen剩余的空间大</strong>，则不会触发Minor GC而是转为触发full GC。</p>
</blockquote>
</li>
<li>
<p><strong>方法区空间不足</strong>。</p>
<blockquote>
<p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些<u><strong>class的信息、常量、静态变量等数据</strong></u>，当系统中<strong>要加载的类、反射的类和调用的方法较多</strong>时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code> 。<br>
为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
</blockquote>
</li>
</ol>
<h4 id="5-什么时候触发-Minor-GC-什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？">5.<strong>什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢</strong>？</h4>
<ul>
<li>
<p><strong>什么时候触发Minor GC ?</strong></p>
<p><strong>当Eden区不足时</strong>就会触发 Minor GC 。</p>
</li>
<li>
<p><strong>minor gc运行频繁</strong></p>
</li>
</ul>
<ol>
<li>
<p>产生了太多朝生夕灭的对象导致需要频繁minor gc</p>
</li>
<li>
<p>新生代空间设置太小</p>
</li>
</ol>
<ul>
<li>
<p><strong>minor gc运行很慢</strong></p>
<ol>
<li><u>新生代空间设置过大</u>；</li>
<li><u>对象引用链较长</u>，进行可达性分析时间较长；</li>
<li><u>新生代survivor区设置的比较小</u>，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销；</li>
<li><u>内存分配担保失败</u>，由minor gc转化为full gc；</li>
<li><u>采用的垃圾收集器效率较低</u>，比如新生代使用serial收集器。</li>
</ol>
</li>
</ul>
<h4 id="6-描述一下GC算法？">6.<strong>描述一下GC算法</strong>？</h4>
<p>GC算法包含：引用计数法，标记清除，标记复制，标记压缩。</p>
<ul>
<li><strong>引用计数</strong>：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用；</li>
<li><strong>标记清除</strong>： 垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象；然后，在清除阶段，<u>清除所有未被标记的对象，<strong>但会产生很多垃圾碎片</strong></u> ；</li>
<li><strong>标记复制</strong>： 将内存对半分，总是<strong>保留一块空着</strong>（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧。<strong>避免了内存碎片问题，但是内存浪费很严重</strong>，<u>相当于只能使用 50%的内存</u>；</li>
<li><strong>标记压缩（标记整理</strong>）：标记过程仍然与<u>“标记-清除”</u>算法一样，但后续步骤<strong>不是直接对可回收对象进行清理</strong>，而是让<strong>所有存活的对象都向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>（类似于 windows 的磁盘碎片整理），避免垃圾碎片。</li>
</ul>
<h5 id="6-1-新生代和老年代用哪些算法？stw问题会发生在新生代吗">6.1 <strong>新生代和老年代用哪些算法？stw问题会发生在新生代吗?</strong></h5>
<ul>
<li>
<p><strong>针对新生代，采用标记复制算法</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p>
</blockquote>
<p>大多数对象在新生代中被创建，其中很多对象的生命周期很短。<strong>每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活</strong>，所以选用复制算法，只需要<strong>少量的复制成本</strong>就可以完成回收。</p>
<p>HotSpot实现的<strong>复制算法流程</strong>如下:</p>
<ol>
<li>当Eden区满的时候,<strong>会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区</strong>；当Eden区<strong>再次触发Minor gc</strong>的时候,会扫描Eden区和From区域，<strong>对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域</strong>,并将Eden和From区域清空。</li>
<li>当后续Eden又发生Minor gc的时候,会对<strong>Eden和To区域进行垃圾回收</strong>,存活的对象复制到From区域,并将Eden和To区域清空。</li>
<li>部分对象会在From和To区域中复制来复制去，<strong>如此交换15次</strong>(由JVM参数MaxTenuringThreshold决定,这个参数默认是15)，最终如果还是存活,就存入到老年代。</li>
</ol>
</li>
<li>
<p><strong>针对老年代对象存活率高的特点</strong></p>
<p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，<strong>该区域中对象存活率高</strong>。</p>
<p>老年代的垃圾回收（又称Major GC）通常使用<strong>标记-清理或标记-整理算法。整堆包括新生代和老年代的垃圾回收称为Full GC</strong>（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</p>
</li>
</ul>
<h4 id="7-什么是Stop-The-World-什么是安全点？安全区域？">7.<strong>什么是Stop The World ?</strong> 什么是安全点？安全区域？</h4>
<ul>
<li>
<p><strong>Stop The World</strong></p>
<p>进行<strong>垃圾回收</strong>的过程中，<u>会<strong>涉及对象的移动。为了保证对象引用更新的正确性</strong>，必须暂停所有的用户线程</u>，像这样的停顿，虚拟机设计者形象描述为「Stop The World」。也简称为STW。JVM在暂停的时候，需要选准一个时机。</p>
<p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了<strong>安全点</strong>的概念。</p>
</li>
<li>
<p><strong>安全点</strong></p>
<blockquote>
<p>安全点，即程序（非GC先）执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p>
</blockquote>
<p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，<strong>Java虚拟机的堆栈不会发生变化</strong>。这么一来，<strong>垃圾回收器便能够“安全”地执行可达性分析</strong>。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>
</li>
<li>
<p><strong>如何保证中断时所有线程都在安全点</strong></p>
<ul>
<li>
<p><strong>抢先式中断（Preemptive Suspension）</strong><br>
抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，<strong>如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上</strong>。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p>
</li>
<li>
<p><strong>主动式中断（Voluntary Suspension）</strong><br>
主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外再加上创建对象需要分配内存的地方。</p>
</li>
</ul>
</li>
</ul>
<h4 id="8-常见的垃圾回收器有哪些（比如G1）？">8. 常见的垃圾回收器有哪些（比如G1）？</h4>
<p><img src="https://i.loli.net/2021/05/16/ypmn6LRB5trC3Dl.png" alt="image-20210516215006746"></p>
<ul>
<li>
<p><strong>Serial收集器</strong>。 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是⼀个单线程收集器了。它的<strong>单线程</strong> 的意义不仅仅意味着它只会使用⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进行垃圾收集⼯作的时候必须<strong>暂停其他所有的⼯作线程（ “Stop The World”</strong>），直到它收集结束。</p>
</li>
<li>
<p><strong>ParNew收集器</strong>。 ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。</p>
<ul>
<li>新⽣代采用<u><strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li>
</ul>
</li>
<li>
<p><strong>Parallel Scavenge收集器</strong>。 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。</p>
<blockquote>
<p>如果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀个不错的选择。-</p>
</blockquote>
<ul>
<li><u>新⽣代采用<strong>标记-复制</strong>算法，⽼年代采用<strong>标记-整理</strong>算法</u>。</li>
</ul>
</li>
<li>
<p><strong>（重点）CMS收集器。<strong>CMS（Concurrent Mark Sweep）收集器是一种以</strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以<code>并发</code>执行，以此来达到降低收集停顿时间的目的。</p>
<ul>
<li>CMS收集器仅作用于<strong>老年代</strong>的收集，基于 <u>“<strong>标记-清除</strong>”</u> 。</li>
<li><strong>优点</strong>： 并发收集、低停顿。</li>
<li><strong>缺点（快手</strong>）： CMS收集器<strong>对CPU资源非常敏感</strong>；CMS收集器<strong>无法处理浮动垃圾</strong>（Floating Garbage）。</li>
</ul>
</li>
<li>
<p><strong>（重点）G1收集器</strong>。 G1重新定义了堆空间，<strong>打破了原有的分代模型，将堆划分为一个个区域</strong>。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利⽤CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核⼼）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与CMS的<u>“标记–清除”</u>算法不同，G1从整体来看是基于<strong>标记-整理</strong>算法实现的收集器；从局部上来看是<strong>基于<u>标记-复制</u>算法</strong>实现的。</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另⼀个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使用者明确指定在⼀个⻓度为M毫秒的时间片段内。</li>
</ul>
</li>
</ul>
<h5 id="8-1-介绍一下CMS-和-G1-垃圾回收器原理？">8.1 介绍一下CMS 和 G1 垃圾回收器原理？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/heyonggang/p/11718170.html">弄明白CMS和G1，就靠这一篇了</a></p>
</blockquote>
<ul>
<li>
<p><strong>CMS收集器</strong></p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p>
<p>CMS收集器仅作用于老年代的收集，是基于<u>标记-清除</u>算法的，它的运作过程分为4个步骤：</p>
<ol>
<li><strong>初始标记（CMS initial mark） :</strong> 需要<strong>STW</strong>，标记一下GC Roots能<strong>直接</strong>关联到的对象 ；</li>
<li><strong>并发标记（CMS concurrent mark）</strong>：从GC Roots开始堆中对象进<strong>行可达性分析</strong>，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li>
<li><strong>重新标记（CMS remark）</strong>：需要<strong>STW</strong> ，<strong>修正并发标记期间</strong>因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分对象的标记记录 ；</li>
<li><strong>并发清除（CMS concurrent sweep）</strong>： 清除对象。</li>
</ol>
</li>
<li>
<p><strong>G1收集器</strong></p>
<p>在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多<strong>相同大小</strong>的区域单元，每个单元称为<strong>Region</strong>。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p>
<blockquote>
<p>区域划分的好处就是带来了<strong>停顿时间可预测的收集模型</strong>：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
</blockquote>
<p>和CMS挺像的。</p>
<ol>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能<strong>直接关联</strong>到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li>并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行<strong>可达性分</strong>析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：首先<strong>对各个Region的回收价值和成本进行排序</strong>，根据用户<strong>所期望的GC停顿时间来制定回收计划</strong>。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ol>
</li>
</ul>
<h5 id="8-2-为什么CMS不用标记-压缩算法？">8.2 为什么CMS不用标记-压缩算法？</h5>
<p>CMS主要关注<strong>低延迟</strong>，因而采用并发方式。</p>
<p>在<strong>并发清理垃圾</strong>时，如果采用压缩算法，这<strong>涉及到移动存活的对象。如果不进行停顿会很难处理</strong>，违背了CMS初衷，所以采用<strong>标记-清除</strong>算法。</p>
<h4 id="9-什么是内存泄漏？">9.<strong>什么是内存泄漏</strong>？</h4>
<p>广义并通俗的说，就是：<u>不再会被使用的<strong>对象</strong>的内存不能被回收</u>，就是内存泄漏。</p>
<p><strong>内存泄漏场景</strong>：</p>
<ul>
<li>
<p>静态集合类、数组<strong>添加对象以后遗漏了对于他们的处理</strong>，例如HashMap和Vector；</p>
</li>
<li>
<p>各种连接，如数据库连接、网络连接、IO连接；</p>
</li>
<li>
<p>单例模式；</p>
</li>
<li>
<p>变量不合理的作用域。</p>
</li>
</ul>
<h3 id="1-6-2-类加载">1.6.2 类加载</h3>
<h4 id="1-介绍一下类文件结构？">1. 介绍一下类文件结构？</h4>
<p>Class⽂件字节码结构组织示意图 。</p>
<p><img src="https://i.loli.net/2021/05/16/VkMjgwfFb9NGr2L.png" alt="image-20210516220600929"></p>
<ol>
<li><strong>魔数:</strong> 确定这个⽂件是否为⼀个能被虚拟机接收的 Class ⽂件。</li>
<li><strong>Class ⽂件版本</strong>：Class ⽂件的版本号，保证编译正常执行。</li>
<li><strong>常量池</strong> ：常量池主要存放两大常量：字面量和符号引用。</li>
<li><strong>访问标志</strong>：标志用于识别⼀些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</li>
<li><strong>当前类索引,⽗类索引</strong> ：类索引用于确定这个类的全限定名，⽗类索引用于确定这个类的⽗类的全限定名，由于 Java 语⾔的单继承，所以⽗类索引只有⼀个，除了 java.lang.Object 之外，所有的 java 类都有⽗类，因此除了 java.lang.Object 外，所有 Java 类的⽗类索引<br>
都不为 0。</li>
<li><strong>接口索引集合</strong>：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents (如果这个类本身是接口的话则是 extends ) 后的接口顺序从左到右排列在接口索引集合中。</li>
<li><strong>字段表集合</strong>：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li>
<li><strong>方法表集合</strong> ：类中的方法。</li>
<li><strong>属性表集合</strong>： 在 Class ⽂件，字段表，方法表中都可以携带⾃⼰的属性表集合。</li>
</ol>
<h4 id="2-什么是类加载器？请你解释一下java程序运行的过程？">2. 什么是类加载器？请你解释一下java程序运行的过程？</h4>
<blockquote>
<p>参考 ： <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1350078">一个简单java程序的运行全过程</a></p>
</blockquote>
<p><u>类加载器是一个用来加载类文件的<strong>类</strong></u> 。</p>
<p>我们所说的类加载过程即是指<strong>JVM虚拟机把.class文件中类信息加载</strong>进内存。主要分为以下3大步、5小步：</p>
<p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p>
<ol>
<li>
<p><strong>编译</strong>。 将编译的<code>.java</code> 文件编译为<code>.class</code>字节码文件，然后交给JVM运行；</p>
</li>
<li>
<p><strong>加载</strong> ：class字节码文件从各个来源通过<strong>类加载器</strong>装载入<u>内存</u>中 。</p>
<blockquote>
<ul>
<li><strong>来源</strong>：包本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong> ：一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>系统类加载器</strong>，以及用户的<u><strong>自定义类加载器</strong> （代码加密防止反编译）</u>。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>链接</strong>： 分为，验证、准备、解析（”正-中-准-心“）三阶段</p>
<ul>
<li>
<p><strong>验证</strong>： 保证加载进来的<u>字节流符合虚拟机规范</u>；</p>
<blockquote>
<p><strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
<p><strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
<p><strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证<u>类型转换的合理性</u>。</p>
<p><strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
</blockquote>
</li>
<li>
<p><strong>准备</strong>：类变量（<strong>注意，不是实例变量</strong> ）分配内存，并且赋予<strong>初值</strong>（虚拟机根据不同类型设定的初始值）；</p>
<blockquote>
<p>这些变量所使用的内存都将在<strong>方法区</strong>中进行分配 ，进行<strong>零初始化</strong>：</p>
<ul>
<li>即数字类型初始化为 0 ，boolean 初始化为 false，引用类型初始化为 null 等</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>解析</strong>：将常量池内的 <u>符号引用</u> 替换为 <u>直接引用</u> 的过程。</p>
<blockquote>
<p><u>符号引用：</u>即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br>
<u>直接引用：</u>可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p>
<p>🌾 实例： 调用方法hello()，方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>初始化</strong>。 初始化就是执行类的<code> cinit</code>()的过程。</p>
<blockquote>
<p>❔ 和准备阶段那个初始化看得我有点迷糊？</p>
<ul>
<li><strong>在编译阶段</strong>，编译器收集所有的<strong>静态字段的赋值语句及静态代码块</strong>，并按 <u>语句出现的顺序</u> 拼接出一个类初始化方法 <code>&lt;clinit&gt;()</code>。此时，执行引擎会调用这个方法对静态字段进行代码中编写的初始化操作。</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="3-知道类的生命周期吗？">3.<strong>知道类的生命周期吗</strong>？</h4>
<p><strong>在类加载的过程</strong>再加上：</p>
<ol start="4">
<li><strong>使用</strong>。new出对象程序中使用</li>
<li><strong>卸载</strong>。执行垃圾回收</li>
</ol>
<h4 id="4-请你介绍一下类加载器？">4.<strong>请你介绍一下类加载器</strong>？</h4>
<img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" />
<p>JVM预定义的三种类型类加载器：</p>
<ul>
<li><strong>启动类加载器（BootstrapClassLoader）</strong>：是一般用本地代码实现，负责将 <code>&lt;Java_Runtime_Home&gt;/lib</code>下面的类库加载到内存中；</li>
<li><strong>标准扩展类加载器（ExtensionClassLoader）</strong>：<code>&lt; Java_Runtime_Home &gt;/lib/ext</code>或者由系统变量 <code>java.ext.dir</code>指定位置中的类库加载到内存中；</li>
<li><strong>系统类加载器（AppClassLoader）</strong>：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从<u>环境变量或者系统属性<code>java.class.path</code></u>所指定的目录中加载类，是<strong>用户自定义加载器的默认父加载器</strong>。</li>
</ul>
<h4 id="5-请你介绍一下双亲委派机制？为什么要这么做？">5.<strong>请你介绍一下双亲委派机制？为什么要这么做</strong>？</h4>
<ul>
<li>
<p><strong>双亲委派机制</strong>。某个特定的类加载器在接到加载类的请求时，首先将加载任务<strong>委托给父类加载器</strong>，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；<strong>只有父类加载器无法完成此加载任务时，才自己去加载</strong>；</p>
</li>
<li>
<p><strong>为什么要这么做？防止内存中出现多份同样的字节码</strong> 。</p>
<blockquote>
<p>比如两个类A和类B都要加载System类：</p>
<ul>
<li>如果不用委托：而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，<strong>这样内存中就出现了两份System字节码</strong>。</li>
<li>如果使用委托机制：会递归的向父类查找，也就是<strong>首选用Bootstrap尝试加载</strong>，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时<strong>Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载</strong>，这样内存中就只有一份System的字节码了。</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="5-1-如何自定义类加载器-，如何打破双亲委派机制-？">5.1 如何自定义类加载器 ，如何打破双亲委派机制 ？</h5>
<ul>
<li>
<p><strong>自定义类加载器 &amp; 打破双亲委派机制</strong></p>
<p>在实现自己的ClassLoader之前，我们先看一下JDK中的ClassLoader是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line"> <span class="number">2</span>     <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line"> <span class="number">3</span>     &#123;</span><br><span class="line"> <span class="number">4</span>     <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line"> <span class="number">5</span>     Class c = findLoadedClass(name);</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">9</span>             c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line"><span class="number">10</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">11</span>             c = findBootstrapClass0(name);</span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="number">14</span>             <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line"><span class="number">15</span>             <span class="comment">// to find the class.</span></span><br><span class="line"><span class="number">16</span>             c = findClass(name);</span><br><span class="line"><span class="number">17</span>         &#125;</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line"><span class="number">20</span>         resolveClass(c);</span><br><span class="line"><span class="number">21</span>     &#125;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> c;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>1、<strong>如果不想打破双亲委派模型，那么只需要重写findClass方法即可</strong></p>
<p><strong>（1）继承ClassLoader</strong></p>
<p><strong>（2）重写findClass()方法</strong></p>
<p>2、<strong>如果想打破双亲委派模型，那么就重写整个loadClass方法</strong></p>
<p><strong>（1）继承ClassLoader</strong></p>
<p><strong>（2）重写findClass()方法</strong>6</p>
<p><strong>（3）调用defineClass()方法</strong></p>
</li>
<li>
<p><strong>tomcat 为什么要违背双亲委托机制</strong>？</p>
<ol>
<li>双亲委托机制不能满足tomcat的业务需求；</li>
<li>Webapp类加载器需要独立加载自身的class以及依赖的jar；</li>
<li>例如，<strong>webapp1</strong>依赖的spring版本为4.x，另一个<strong>webapp2</strong>依赖的spring版本为5.x. 如果使用双亲委托，那么spring的版本只能存在一个，没法满足这个需求。</li>
</ol>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/42516/">https://hwh.zone/p/42516/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/45493/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">校招笔记（一）_Java_锁</div></div></a></div><div class="next-post pull-right"><a href="/p/44980/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（二）_计算机基础_Linux&amp;Git</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/51787/" title="校招笔记（一）_Java_Java入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_Java入门</div></div></a></div><div><a href="/p/8959/" title="校招笔记（一）_Java_多线程"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_多线程</div></div></a></div><div><a href="/p/7257/" title="校招笔记（一）_Java_面对对象"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_面对对象</div></div></a></div><div><a href="/p/45493/" title="校招笔记（一）_Java_锁"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_锁</div></div></a></div><div><a href="/p/21069/" title="校招笔记（一）_Java_集合"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_集合</div></div></a></div><div><a href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（七）_计算机基础_数据结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-JVM%E7%9B%B8%E5%85%B3"><span class="toc-text">1.6 JVM相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98"><span class="toc-text">1.6.1 常问问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EF%BC%88%E8%A2%AB%E9%97%AE%E8%BF%87%EF%BC%89JVM%E5%90%AF%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E6%88%96%E8%80%85%E8%AF%B4%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-text">1. （被问过）JVM启动的基本配置参数有哪些？（或者说调优参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.说说堆和栈的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%AF%B7%E9%97%AEJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%88%86%E5%B8%83%EF%BC%9F-%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%EF%BC%9F"><span class="toc-text">3.【重点】请问JVM运行时内存布局分布？ 哪些是线程共享的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-JVM-%E5%A0%86%E4%B8%AD%E5%8F%88%E6%80%8E%E4%B9%88%E5%88%86%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%88%92%E5%88%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%96%E6%B6%88%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%94%A8%E5%85%83%E7%A9%BA%E9%97%B4%E4%BB%A3%E6%9B%BF%EF%BC%9F"><span class="toc-text">3.1 JVM 堆中又怎么分的？为什么要这么划分？为什么要取消永久代用元空间代替？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AD%98%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%EF%BC%9F%E8%83%BD%E4%B8%BA%E7%A9%BA%E5%90%97%EF%BC%9F"><span class="toc-text">3.2 程序计数器存哪些东西？能为空吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%EF%BC%88%E6%96%B0%EF%BC%89%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">4. （新）说一下Java创建对象的过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%9F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%EF%BC%9FTLAB"><span class="toc-text">4.1 什么是指针碰撞？空闲列表？TLAB?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-JVM%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">4.2 JVM如何保证对象分配的线程安全问题？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E3%80%90%E5%8E%9F%E5%88%99%E3%80%91%EF%BC%9F%EF%BC%88%E5%8C%BA%E5%88%86%E5%89%8D%E9%9D%A2new%E5%AF%B9%E8%B1%A1%E3%80%90%E8%BF%87%E7%A8%8B%E3%80%91%EF%BC%89"><span class="toc-text">5.描述一下对象分配【原则】？（区分前面new对象【过程】）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E5%88%86%E9%85%8D%E5%88%B0%E5%A0%86%E4%B8%8A%E5%90%97%EF%BC%9F"><span class="toc-text">5.1 对象一定分配到堆上吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">6.对象的访问定位有哪两种方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%EF%BC%88%E6%AD%BB%E4%BA%A1%EF%BC%89%EF%BC%9F"><span class="toc-text">7.如何判断对象是否需要回收（死亡）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%8F%98%E9%87%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%B1%BB%EF%BC%9F"><span class="toc-text">8. 如何判断一个常量是废弃变量？如何判断一个类是无用类？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-GC%E7%9B%B8%E5%85%B3"><span class="toc-text">1.6.1 GC相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BB%8B%E7%BB%8DGC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9FGC%E5%8F%AF%E4%BB%A5%E9%A9%AC%E4%B8%8A%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%B8%BB%E5%8A%A8%E8%AE%A9%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-text">1.请介绍GC基本原理？有什么优点？GC可以马上回收内存吗？如何主动让虚拟机回收？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E6%9C%AC%E5%9C%B0java%E7%A8%8B%E5%BA%8F%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-text">1.1 本地java程序默认启动的是什么垃圾回收器？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFGC-Root%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Root%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">2.什么是GC Root？可以作为GC Root的对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E9%9C%80%E8%A6%81GC"><span class="toc-text">3.哪些内存区域需要GC?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC%EF%BC%9F"><span class="toc-text">4.什么时候会触发Full GC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91-Minor-GC-%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E4%BC%9A%E5%AF%BC%E8%87%B4minor-gc%E8%BF%90%E8%A1%8C%E9%A2%91%E7%B9%81%EF%BC%9F%E5%90%8C%E6%A0%B7%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%8F%88%E4%BC%9A%E5%AF%BC%E8%87%B4minor-gc%E8%BF%90%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%9F"><span class="toc-text">5.什么时候触发 Minor GC ? 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BGC%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">6.描述一下GC算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%94%A8%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%9Fstw%E9%97%AE%E9%A2%98%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9C%A8%E6%96%B0%E7%94%9F%E4%BB%A3%E5%90%97"><span class="toc-text">6.1 新生代和老年代用哪些算法？stw问题会发生在新生代吗?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AFStop-The-World-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%9F%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-text">7.什么是Stop The World ? 什么是安全点？安全区域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E6%AF%94%E5%A6%82G1%EF%BC%89%EF%BC%9F"><span class="toc-text">8. 常见的垃圾回收器有哪些（比如G1）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCMS-%E5%92%8C-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">8.1 介绍一下CMS 和 G1 垃圾回收器原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-%E4%B8%BA%E4%BB%80%E4%B9%88CMS%E4%B8%8D%E7%94%A8%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">8.2 为什么CMS不用标记-压缩算法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">9.什么是内存泄漏？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">1.6.2 类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">1. 介绍一下类文件结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bjava%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">2. 什么是类加载器？请你解释一下java程序运行的过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%9F%A5%E9%81%93%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">3.知道类的生命周期吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-text">4.请你介绍一下类加载器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">5.请你介绍一下双亲委派机制？为什么要这么做？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-%EF%BC%9F"><span class="toc-text">5.1 如何自定义类加载器 ，如何打破双亲委派机制 ？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a><time datetime="2021-12-05T08:28:39.054Z" title="发表于 2021-12-05 16:28:39">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）CMake使用指南">C++从零开始（一）：环境搭建（下）CMake使用指南</a><time datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/62712/" title="C++从零开始（零）">C++从零开始（零）</a><time datetime="2021-12-05T08:22:28.029Z" title="发表于 2021-12-05 16:22:28">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56326/" title="Hexo快速打造属于自己的网站">Hexo快速打造属于自己的网站</a><time datetime="2021-11-29T12:10:54.202Z" title="发表于 2021-11-29 20:10:54">2021-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&amp;智力题">校招笔记（八）_计算机基础_场景&amp;智力题</a><time datetime="2021-11-26T13:37:19.761Z" title="发表于 2021-11-26 21:37:19">2021-11-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>