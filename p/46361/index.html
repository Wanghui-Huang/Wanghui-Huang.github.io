<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（三）_计算机基础_计算机网络 | royhuang's blog</title><meta name="keywords" content="校招,计算机基础,计算机网络"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（三）_计算机基础_计算机网络">
<meta property="og:url" content="https://hwh.zone/p/46361/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2021-11-26T12:53:16.543Z">
<meta property="article:modified_time" content="2021-12-03T03:55:53.544Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="校招">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="/img/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/46361/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（三）_计算机基础_计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:55:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">校招笔记（三）_计算机基础_计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-26T12:53:16.543Z" title="发表于 2021-11-26 20:53:16">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:55:53.544Z" title="更新于 2021-12-03 11:55:53">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（三）_计算机基础_计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我的校招记录：<a target="_blank" rel="noopener" href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>算法能力（“刷题”）</strong></td>
<td style="text-align:center">这部分就是耗时间多练习，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td>
<td style="text-align:center">补充练习：<a target="_blank" rel="noopener" href="https://codetop.cc/">codeTop</a></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td>
<td style="text-align:center">C++后端后续更新</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>项目&amp;实习</strong></td>
<td style="text-align:center">主要是怎么准备项目，后续更新</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1>三、计算机网络</h1>
<h2 id="3-1-ISO-OSI模型-和-TCP-IP-模型">3.1 ISO/OSI模型  和 TCP/IP 模型</h2>
<h4 id="1-请你简要介绍一下TCP-IP-五层协议-和-ISO-OSI七层协议？">1.<strong>请你简要介绍一下TCP/IP 五层协议 和 ISO/OSI七层协议？</strong></h4>
<p><img src="https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="img"></p>
<ul>
<li>
<p><strong>应用层</strong>：为用户的<strong>应用程序</strong>（如：电子邮件、文件传输和仿真终端）<u><strong>*提供网络服务</strong></u>；</p>
</li>
<li>
<p><strong>表示层</strong>： 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取；</p>
</li>
<li>
<p><strong>会话层</strong>：  通过运输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求；</p>
</li>
<li>
<p><strong>运输层:</strong> 任务是为两台主机中<strong>进程之间的通信</strong>提供通用的<u><strong>*数据传输服务</strong></u>，传输的是<strong>报文段（tcp）/用户数据报（udp）</strong>；</p>
<blockquote>
<p>复用：多个应用层进程可同时使用下面运输层的服务。<br>
分用：运输层把收到的信息分别交付上面应用层中的相应进程。</p>
</blockquote>
</li>
<li>
<p><strong>网络层</strong>： 为主机间<u><strong>*提供通信服务</strong></u>。在发送数据时，网络层把运输层的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为<strong>数据报</strong></p>
</li>
<li>
<p><strong>数据链路层（忘</strong>）： 两台主机通信，总是在<strong>一段一段的链路</strong>上传送的，这就需要需要专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的<u><strong>*IP数据报组装成帧</strong></u>，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息。</p>
</li>
<li>
<p><strong>物理层</strong>：主要作用是<u>传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0）</u>，定义物理设备标准（例如网线的接口类型、光线的接口类型、各种传输介质的传输速率）。</p>
</li>
</ul>
<h4 id="2-请你简要介绍一下各层的协议？">2.<strong>请你简要介绍一下各层的协议？</strong></h4>
<ul>
<li>
<p><strong>物理层</strong>：暂无</p>
</li>
<li>
<p><strong>（<u>快手</u>）数据链路层</strong>：数据链路层主要是负责传输数据，</p>
<ul>
<li>
<p><strong>PPP（点到点协议</strong>）：在<strong>点对点</strong>连接上传输多协议数据包提供了一个标准方法，PPP 最初设计是为<strong>两个对等节点</strong>之间的 IP <strong>流量传输</strong>提供一种封装协议。这种链路提供<strong>全双工</strong>操作，并按照顺序传递数据包。</p>
<blockquote>
<p>设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p>
</blockquote>
</li>
<li>
<p><strong>以太网（Ethernet)</strong>：</p>
</li>
<li>
<p><strong>CSMA/CD 协议</strong>： 冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p>
<blockquote>
<p>许多计算机以<strong>多点接入</strong>的方式连接<strong>在一根总线</strong>上，每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</p>
<p>若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>网络层</strong>： <a target="_blank" rel="noopener" href="https://www.hhcycj.com/post/item/491.html">可参考</a></p>
<p><strong>IP</strong>：网络协议，非常重要的中间层协议，TCP和UDP必须基于IP工作</p>
<p><strong>ICMP</strong>：非常重要的中间层协议，用于在 <u>IP主机、路由器</u> 之间传递控制消息</p>
<p><strong>IGMP</strong>：网络组消息协议，用来在<u>IP主机</u>和与其<strong>直接相邻的<u>组播路由器</u>之间</strong>建立、维护组播组成员</p>
<p><strong>ARP</strong>：地址解析协议，建立<code>IP→MAC</code>地址映射表</p>
<p><strong>RARP</strong>：反向地址解析协议，某个网络设备的MAC物理地址转换为IP地址</p>
</li>
<li>
<p><strong>运输层:TCP(Transmission Control Protocol)</strong> 面向连接的，数据传输的单位是<u><strong>报文段</strong></u>，能够提供可靠的交付。</p>
<p><strong>UDP(User Datagram Protocol)</strong> ：无连接的，数据传输的单位<strong>是<u>用户数据报</u>，不保证提供可靠的交付</strong>，只能提供“尽最大努力交付”</p>
</li>
<li>
<p><strong>应用层</strong>：如支持万维网应用的<strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议，DNS，POP3，SNMP，Telnet等等。</p>
</li>
</ul>
<h5 id="2-1-RARP-工作原理？">2.1 RARP 工作原理？</h5>
<p>RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p>
<blockquote>
<p>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。</p>
</blockquote>
<ol>
<li>主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包；</li>
<li><strong>RARP服务器</strong>收到了<strong>RARP请求数据包</strong>，<strong>为其分配IP地址</strong>，并将<strong>RARP回应发送</strong>给主机；</li>
<li>主机收到RARP回应后，就使用得到的IP地址进行通讯。</li>
</ol>
<h4 id="3-端口在哪一层？有效端口范围？">3. 端口在哪一层？有效端口范围？</h4>
<p>端口在<strong>传输层</strong>。传输层以下的包封装过程：</p>
<ul>
<li>数据报在传输层：加源端口号和目的端口号；</li>
<li>在网络层加上：源ip和目的ip ；</li>
<li>在数据链路层转化成：数据桢进行校验；</li>
<li>在物理层变成信号（电、光、等信号）发送出去。</li>
</ul>
<p>UDP和TCP报头使用<strong>两个字节存放端口号</strong>，端口一共有一共有<strong>65535</strong>个。</p>
<ul>
<li>知名端口号从0~1023，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口） ；</li>
<li>动态端口的范围是从1024~65535。</li>
</ul>
<h2 id="3-2-运输层">3.2 运输层</h2>
<h4 id="0-TCP报文头？UDP报文头？">0. TCP报文头？UDP报文头？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="http://st233.com/blog.php?id=30">IP、TCP、UDP报文头说明</a></p>
</blockquote>
<ul>
<li>
<p><strong>TCP报文头</strong></p>
<p><img src="https://i.loli.net/2021/06/11/RtnwTmysWBvVlPD.png" alt="img"></p>
<ul>
<li>
<p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p>
</li>
<li>
<p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p>
<blockquote>
<p>从这也可以看书，端口占16bit，故范围是0~65535。</p>
</blockquote>
</li>
<li>
<p><strong>顺序号：数据包编号</strong>， 表明发送的数据包的顺序 。其值通常应该为<code>上次发送包中的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个包(SYN包) 则该值随意(通常随机)</p>
</li>
<li>
<p><strong>确认号</strong>：通常该值是<code>接受到的顺序号+1</code> ，若该数据包是整个TCP连接中的第一个数据包(SYN包) 则该值随意(通常为0)</p>
</li>
<li>
<p><strong>首部长度</strong>：TCP头长度 。表明包好多少个32Bit 包括可选头(如果有) 值为TCP头大小除以4 ：</p>
<ul>
<li>如：没有可选头TCP头为20字节 则该值为5</li>
</ul>
</li>
<li>
<p><strong>标志位</strong>：</p>
</li>
<li>
<ul>
<li>紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理</li>
<li>确认标志位(ACK)：开启时表明确认号有效 否则忽略确认号</li>
<li>推送标志位(PSH)：开启时表明应该尽快交付给应用进程 而不必等到缓存区填满才推送</li>
<li>复位标志位(RST)：开启时表明TCP连接出现连接出现错误 数据包非法拒绝连接</li>
<li>同步标志位(SYN)：开启时表明一个连接的请求或者接受报文</li>
<li>终止标志位(FIN)：开启时表明释放一个连接</li>
</ul>
</li>
<li>
<p><strong>窗口大小</strong>：表示期望接受到的每个数据包字节数</p>
</li>
<li>
<p><strong>校验和</strong>：该值为TCP报文头括数据部分中每16Bit的二进制反码求和</p>
</li>
<li>
<p><strong>紧急指针</strong>：若指定该值 他应该是一个偏移量 该值加上顺序号表示紧急数据最后一个字节的顺序号</p>
</li>
<li>
<p><strong>可选字段</strong>：包含最大载荷与窗口比例等信息 注：若使用该字段则长度必须为32Bit的倍数 不足则填充0</p>
</li>
</ul>
</li>
<li>
<p><strong>UDP报文</strong></p>
<p><img src="https://i.loli.net/2021/06/11/Bfh3THSLgzZCUAu.png" alt="img"></p>
<ul>
<li>
<p><strong>来源端口</strong>：向目标主机指明接入他的主机所使用的端口号 用于目标主机回应</p>
</li>
<li>
<p><strong>目标端口</strong>：指明要连接的目标主机的端口号</p>
</li>
<li>
<p><strong>数据包长度</strong>：UDP头和数据总长度字节数</p>
</li>
<li>
<p><strong>检验和</strong>：该值为UDP报文头括数据部分中每16Bit的二进制反码求和</p>
</li>
<li>
<ul>
<li><strong>注：UDP检验和不是必须的</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-请你说明一下，TCP协议的3次握手（进行连接）？">1. 请你说明一下，TCP协议的3次握手（进行连接）？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903834708344840">三次握手与四次挥手面试官想考我们什么？</a></p>
</blockquote>
<blockquote>
<p>TCP中，对<strong>确认ACK报文是不需要发送确认</strong>的 。</p>
</blockquote>
<ul>
<li>
<p><strong>简略过程</strong></p>
<blockquote>
<p>⚠️ SYN 和ACK报文是一起发的！！</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/27203200-7e3630b0fe1442898e6824ac061d475e.x-png" alt="TCP三次握手原理- asfion - 博客园"></p>
<p><strong>1、第一次握手</strong>：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN©</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p>
<p><strong>2、第二次握手</strong>：（⚠️ <strong>SYN+ACK是在一个包里发的！（字节一面</strong>） ）服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 <strong>ISN(s)</strong>，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>
<p><strong>3、第三次握手</strong>：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>
<p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p>
</li>
</ul>
<h5 id="1-1-ISN-（Initial-Sequence-Number）是固定的吗？">1.1 ISN （Initial Sequence Number）是固定的吗？</h5>
<ul>
<li>
<p><strong>ISN作用</strong></p>
<p>三次握手，其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道<strong>接下来接收数据的时候如何按序列号组装数据</strong>。</p>
</li>
<li>
<p><strong>ISN为什么不固定</strong>（还是不太理解）</p>
<blockquote>
<p>ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个<strong>32比特</strong>的计数器，<strong>每4ms加1</strong> 。</p>
</blockquote>
<ul>
<li><strong>防止在网络中被延迟的分组在以后被重复传输</strong>，而导致某个连接的一端对它作错误的判断；</li>
<li>如果 ISN 是固定的，攻击者很<strong>容易猜出后续的确认号</strong>，因此 ISN 是动态生成的。</li>
</ul>
</li>
</ul>
<h4 id="2-为什么要三次握手？">2.<strong>为什么要三次握手</strong>？</h4>
<p>1.<strong>用来确定服务端和客户端的发送能力是否正常；</strong></p>
<ul>
<li><strong>第一次握手</strong>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：<u>客户端的发送能力、服务端的接收能力是正常的。</u></li>
<li><strong>第二次握手</strong>：服务端发包，客户端收到了。这样客户端就能得出结论：<u>服务端的接收、发送能力，客户端的接收、发送能力是正常的</u>。<strong>不过此时服务器并不能确认客户端的接收能力是否正常</strong>。</li>
<li><strong>第三次握手</strong>：客户端发包，服务端收到了。这样服务端就能得出结论：<u>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</u></li>
</ul>
<p>2.<strong>指定自己的初始化序列号，为后面的可靠传送做准备；</strong></p>
<ul>
<li>如果只有两次握手，那么客户端的起始序列号可以确认，<u>服务端的起始序列号</u>将得不到确认。</li>
</ul>
<ol start="3">
<li><strong>如果是 https 协议的话，三次握手这个过程，还会进行数字<u>证书的验证以及加密密钥</u>的生成</strong>。</li>
</ol>
<h5 id="2-1-三次握手可以携带数据吗？">2.1 三次握手可以携带数据吗？</h5>
<p><strong>第一次、第二次握手不可以携带数据 ，</strong> 第三次可以携带数据：</p>
<ul>
<li><strong>对于第一次握手</strong>，不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。
<ul>
<li>如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，<strong>消耗服务器空间来接收数据</strong>；</li>
</ul>
</li>
<li><strong>对于第三次握手</strong>，客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，<strong>已经知道服务器的接收、发送能力正常</strong>，所以能携带数据。</li>
</ul>
<h4 id="3-请你说明一下，TCP协议的4次挥手（断开连接）？">3.<strong>请你说明一下，TCP协议的4次挥手（断开连接）</strong>？</h4>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/63264012">为什么不像三次握手一样执行三次即可？</a></p>
<p>因为第二次和第三次对于被动方来说，意义是不一样的。<br>
第二次是为了让主动方闭嘴（不再发挥手请求），自己该干嘛还是干嘛（但是自己可能还有数据美处理完）。<br>
第三次是为了表示“我的活儿干完了，可以结束了”。<br>
通常server接收到挥手的时候，手里还有活儿没做完。</p>
</blockquote>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</p>
<p><u>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据</u>。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211127191012778.png" alt="image-20211127191012778"></p>
<p>（1）客户端A发送一个FIN，<u>报文中会指定一个序列号</u>M，用来关闭客户A到服务器B的数据传送，此时客户端处于<strong>FIN_WAIT1</strong>状态；</p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，<u>确认序号为收到的序号M+1</u>。和SYN一样，一个FIN将占用一个序号，此时服务端处于 <strong>CLOSE_WAIT</strong>状态；</p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A和序列号N，此时服务端处于 <strong>LAST_ACK</strong> 的状态；</p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序N+1，此时客户端处于 <strong>TIME_WAIT</strong> 状态，需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <strong>CLOSED</strong> 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。</p>
<h5 id="3-1-为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</h5>
<blockquote>
<p>半双工：同时只能有一端发送消息 ； 全双工：两端都可以随机接受/发送。</p>
</blockquote>
<p>在四次挥手过程中，似乎C/S两端都是等待对方发送FIN/ACK，才会发送对应的ACK/FIN版本。同一时刻只有一方在发送消息，满足半双工。</p>
<p>但是，半双工模式效率会更低：比如C端（客户端）发送FIN报文请求关闭，但是S端（<strong>服务端</strong>）依旧<strong>可以同时发生数据</strong> ，这个时候效率更高。</p>
<h5 id="3-2（重点）-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h5>
<p>close_wait状态是在，TCP四次挥手的时候<strong>服务器收到FIN，但是没有发送自己的FIN时出现的</strong>。服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li><strong>服务器内部业务处理占用了过多时间</strong>，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候<strong>子进程处理但父进程没有处理该信号</strong>，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug</li>
</ul>
<h4 id="4-为什么要有TIME-WAIT-状态？为什么等待是2MSL？">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</h4>
<ul>
<li>
<p><strong>要确保服务器是否已经收到了客户端最后的ACK 报文</strong>，如果没有收到的话，<u>服务器会重新发 FIN + ACK报文给客户端</u>，客户端再次收到 FIN + ACK 报文之后，就知道之前的 ACK 报文丢失了，然后<u>再次发送 ACK 报文。</u></p>
</li>
<li>
<p><strong>确保之前连接的一些数据不在滞留在网络中</strong>：确保已经失效连接请求报文段不会再出现在本连接中，<strong>客户端发完最后一个ACK报文段后</strong>，再经过<strong>2MSL</strong>可以使得本连接中所有的报文段都从网络中消失。客户端就可以放心地<strong>释放</strong>TCP占用的资源、端口号，连接任何服务器。</p>
<blockquote>
<p>如果<strong>客户端</strong>直接CLOSED，然后又再次向服务器<strong>发起一个新连接</strong>，有可能<strong>新、老连接的端口号一样</strong>的。假设新、老连接端口号一致，若老连接的一些数据仍滞留在网络中，这些滞留数据在新连接建立后才到达服务器，鉴于前后端口号一致，TCP协议就默认这些数据属于新连接，于是数据就这样乱成一锅粥了。</p>
</blockquote>
</li>
</ul>
<h5 id="4-1-为什么是2MSL">4.1 为什么是2MSL?</h5>
<p>MSL是报文在网络中最长生存时间，这是一个工程值(经验值)，不同的系统中可能不同 。</p>
<p>考虑最坏 情况，客户端A最后一次挥手发送给服务端B的ACK报文丢失了：</p>
<ol>
<li>ACK从最多经过1MSL会到达服务端，<strong>超过1MSL服务端会重发FIN</strong></li>
<li>服务端重发的FIN最多经过1MSL到达A</li>
</ol>
<p>所以为了确保，客户端能<strong>接收到服务端重发的FIN报文</strong>。</p>
<h4 id="5-【重点】请问TCP为什么要更可靠？哪种场景会有所应用？">5. 【重点】<strong>请问TCP为什么要更可靠？哪种场景会有所应用？</strong></h4>
<ol>
<li>
<p><strong>超时重传</strong>：当 TCP 发出⼀个报文段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段；</p>
</li>
<li>
<p><strong>数据排序</strong>：TCP有专门的序列号<strong>ISN字段</strong>，可提供数据re-order；</p>
</li>
<li>
<p><strong>流量控制</strong>：滑动窗口和计时器的使用。TCP窗口中会指明双方能够<u>发送接收的最大数据量；</u></p>
<blockquote>
<p><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认。在收到确认后再发下⼀个分组。</p>
</blockquote>
</li>
<li>
<p><strong>拥塞控制</strong>：TCP的拥塞控制由4个核心算法组成。“慢启动”（Slow Start）、<u>“拥塞避免”</u>（Congestion avoidance）、“快重传 ”（Fast Retransmit）、“快恢复”（Fast Recovery）；</p>
</li>
<li>
<p><strong>校验和</strong>： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将<strong>丢弃这个报⽂段和不确认收到此报⽂段</strong>。</p>
</li>
</ol>
<p>【<strong>应用场景</strong>】</p>
<p><u>当对网络通讯质量有要求的时候，</u>比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用</p>
<ul>
<li>比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</li>
</ul>
<h5 id="5-1-超时重传机制原理？">5.1 超时重传机制原理？</h5>
<p>基本原理：在发送一个数据之后，就开启一个<strong>定时器</strong>，若是在这个时间内<strong>没有收到发送数据的ACK确认报文</strong>，则对该报文进行<strong>重传</strong>，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<p>TCP中有四种计时器（Timer），分别为：</p>
<ol>
<li>
<p><strong>重传计时器</strong>：在<strong>滑动窗口协议</strong>中，接受窗口会在<strong>连续收到的包序列（连续ARQ）<strong>中的</strong>最后一个包</strong>向接收端发送一个ACK。当网络拥堵的时候，发送端的数据包和接收端的ACK包都有可能丢失。TCP为了保证数据可靠传输，就规定在<strong>重传的“时间片”<strong>到了以后，如果还没有收到对方的ACK，就</strong>重发此包</strong>，以避免陷入无限等待中。</p>
</li>
<li>
<p><strong>坚持计时器</strong>：在<strong>滑动窗口协议</strong>中，当发送TCP收到<strong>窗口大小为0</strong>的确认ACK时，就坚持启动计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文。这个报文段只有一个字节的数据。他有一个序号，但他的序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接受TCP：确认已丢失，必须重传。</p>
</li>
<li>
<p><strong>保活计时器</strong>：保活计时器使用在某些实现中，用来<strong>防止在两个TCP之间的连接出现长时间的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远的处于打开状态。</p>
<p>通常设置为两小时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若<strong>发送了10个探测报文段</strong>（每一个像个75秒）还没有响应，就假定客户除了故障，因而就终止了该连接。</p>
</li>
<li>
<p><strong>时间等待计时器</strong>：四次挥收后time waiter状态中使用。</p>
</li>
</ol>
<h5 id="5-2-介绍一下ARQ协议-？">5.2 介绍一下ARQ协议 ？</h5>
<p>⾃动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p>
<ul>
<li><strong>停⽌等待ARQ协议</strong>。 停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个<strong>分组</strong>就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。
<ul>
<li><strong>优点</strong>：简单</li>
<li><strong>缺点</strong>：信道利用低，等待时间长</li>
</ul>
</li>
<li><strong>连续ARQ协议</strong>。连续 ARQ 协议可提高信道利用率。发送方维持⼀<strong>个发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方⼀般采用<strong>累计确认</strong>，对按序到达的<strong>最后⼀个分组发送确</strong>认，表明到这个分组为⽌的所有分组都已经正确收到了。
<ul>
<li><strong>优点</strong>： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点</strong>： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 ⽐如：发送方发送了 5条 消息，<strong>中间第三条丢失（3号</strong>），这时接收方<strong>只能对前两个发送确认</strong>。发送方无法知道后三个分组的下落，而只好把后<strong>三个全部重传</strong>⼀次。这也叫 <strong>Go-Back-N</strong>（回退 N），表示需要退回来重传已经发送过的N 个消息。</li>
</ul>
</li>
</ul>
<h5 id="5-2-介绍一下连续ARQ协议滑动窗口和流量控制？">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</h5>
<p>TCP 利用滑动窗口实现流量控制。流量控制是为了<strong>控制发送方发送速率，保证接收方来得及接收</strong>。 接收方发送的确认报⽂中的窗口字段可以用来控制<strong>发送方窗口</strong>大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h5 id="5-3-介绍一下拥塞控制？">5.3 介绍一下拥塞控制？</h5>
<p>为了进行拥塞控制，TCP 发送方要维持⼀个 <u>拥塞窗口(cwnd)</u> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让⾃⼰的<strong>发送窗口 == 取为拥塞窗口和接收方的接受窗口中较小的⼀个</strong>。</p>
<p>TCP的拥塞控制采用了四种算法：</p>
<ul>
<li>
<p><strong>慢开始</strong>： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把大量数据字节注⼊到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测⼀下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，<strong>每经过⼀个传播轮次RTT，cwnd加倍</strong>；</p>
</li>
<li>
<p><strong>拥塞避免</strong>： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增大，即每经过<strong>⼀个往返时间RTT，就把发送放的cwnd加1</strong>；</p>
</li>
<li>
<p><strong>快重传/快恢复</strong>：</p>
<blockquote>
<p>区分快重传，连续ARQ中间丢失是Go back n。</p>
</blockquote>
<p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，<u>它能快速恢复丢失的数据包。</u>如果<strong>接收机</strong>接收到⼀个【<strong>不按顺序】的数据段，它会⽴即给发送机发送⼀个重复确认（而不是等到自己发送数据时才捎带确认）。如果发送机接收到三个重复确认</strong>，它会假定确认指出的数据段丢失了，并⽴即重传这些丢失的数据段（<strong>而不必继续等待为该报文段设置的重传计时器的超时</strong>）。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20170823152124856" alt="img"></p>
</li>
</ul>
<h5 id="5-4-如何区分流量控制和拥塞控制？">5.4 如何区分流量控制和拥塞控制？</h5>
<ul>
<li><strong>流量控制属于通信双方协商，拥塞控制涉及通信链路全局；</strong></li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，<strong>接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定</strong>；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li>
</ul>
<h4 id="6-如何提高客户端并发数？">6.<strong>如何提高客户端并发数？</strong></h4>
<p>客户端建立的tcp数量受限于最大文件句柄数，一个连接就会建一个文件句柄，在linux 上默认是<strong>1024</strong>。</p>
<ul>
<li>使用<code>ulimit</code> 可以修改最大进程数（<strong>最大为65535</strong>）</li>
</ul>
<h4 id="7-说说HTTP、TCP、Socket-的关系是什么？">7.<strong>说说HTTP、TCP</strong>、Socket 的关系是什么？</h4>
<ul>
<li><strong>TCP/IP</strong> 代表传输控制协议/网际协议，指的是一系列协议族；</li>
<li><strong>HTTP</strong> 本身就是一个协议，是从 <u>Web 服务器和本地浏览器</u>的超文本传送协议；</li>
<li><strong>Socket</strong> 是 TCP/IP 网络的 <strong>API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<h4 id="8-什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略-？">8. 什么是半连接队列？<strong>泛洪攻击（DDos攻击的一种），以及解决策略</strong> ？</h4>
<ul>
<li>
<p><strong>半连接队列</strong></p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<blockquote>
<p>已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p>
</blockquote>
</li>
<li>
<p><strong>泛洪攻击</strong></p>
<p>在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。</p>
<ol>
<li>服务器接收到 SYN 报文段后会为该 <u>TCP分配<strong>缓存和变量</strong></u>，如果<u>攻击分子<strong>伪造大量不存在的IP地址</strong>，大量地往服务器发送 SYN 报文段</u>，服务器的连接资源终将被耗尽，导致<strong>内存溢出</strong>无法继续服务。</li>
<li>当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为<strong>半连接</strong>，同时会被服务端写入一个<strong>半连接队列</strong>。<br>
想象一下，如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的<strong>半连接队列很快会被写满</strong>，从而导致无法工作。</li>
</ol>
</li>
<li>
<p><strong>解决策略</strong></p>
<p><strong>设置验证机制</strong>：当服务器接受到 SYN 报文段时，<strong>不直接为该 TCP 分配资源</strong>，而只是打开一个<u>半开的套接字</u>。接着会使用 SYN 报文段的<u>源 Id，目的 Id，端口号</u>以及只有服务器自己知道的一个<u>秘密函数生成一个 cookie，并<strong>把 cookie作为序列号响应</strong></u> 给客户端。</p>
<p>如果客户端是正常建立连接，将会返回一个确认字段为 <strong>cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源 。</p>
<p><strong>防火墙过滤</strong>： 暂不了解具体</p>
</li>
</ul>
<h4 id="9-为什么DNS（域名解析）用UDP，而区域传送用TCP">9.<strong>为什么DNS（域名解析）用UDP，而区域传送用TCP?</strong></h4>
<ul>
<li><strong>DNS用UDP</strong>：客户端向DNS服务器查询域名，一<u>般返回的内容都不超过512字节，用UDP传输即可</u>。不用经过TCP三次握手，这样<u>DNS服务器负载更低，响应更快</u>。</li>
<li><strong>区域传送用TCP：</strong> TCP协议可靠性好，<u>TCP协议传输的内容大，而UDP最大只能传512字节</u>。</li>
</ul>
<h4 id="10-说一下-TCP-粘包是怎么产生的？怎么解决粘包？">10.<strong>说一下 TCP 粘包是怎么产生的？怎么解决粘包？</strong></h4>
<p><strong>TCP粘包</strong></p>
<p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p>客户端要发送原信息是A和B两个数据包，服务端接收到之后，可能出现如下情况：</p>
<ul>
<li><strong>正常情况</strong>：读取到了A和B两个数据包；</li>
<li><strong>粘包</strong>：A和B两个数据包一起读取了；</li>
<li><strong>拆包</strong>：读取了A数据包的一部分，A的另一部分和B数据包一起读取了。</li>
</ul>
<p><strong>TCP粘包原因</strong></p>
<ul>
<li><strong>【发送方】TCP默认使用Nagle算法</strong>。客户端通过socket给服务端发送数据，为了传输更有效率，会将<strong>多次间隔较小的且数据量小的数据</strong>，通过<strong>nagle</strong>算法，合并成一个大的数据块，然后进行封包。这样做提高了效率，缺点就是你发送到服务端的数据，服务端不知道是不是完整的，不知道哪几小块数据拼起来才是原来的数据；</li>
<li><strong>【接收方】来不及接收缓存区的包</strong>，导致多个包接收；</li>
<li>TCP<strong>连接复用</strong>造成的粘包问题；</li>
<li>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</li>
</ul>
<p><strong>解决粘包</strong></p>
<p>解决问题的关键在于如何给<strong>每个数据包添加边界信息</strong>：</p>
<ol>
<li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法；</li>
<li><strong>发送端给每个数据包添加包 <u>首部</u> <strong>，首部中应该至少包含数据包的</strong>长度</strong>，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了；</li>
<li><strong>数据包之间设置边界</strong>，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开 ；</li>
<li><strong>发送端将每个数据包封装为固定长度</strong>（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li>
</ol>
<h4 id="11-TCP-UDP的区别？">11. TCP, UDP的区别？</h4>
<ul>
<li>UDP 在<strong>传送数据之前不需要先建立连接</strong>。远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作方式（⼀般用于即时通信）
<ul>
<li>⽐如： <u>QQ 语⾳、 QQ 视频 、直播</u>等等</li>
</ul>
</li>
<li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。 TCP 不提供⼴播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增大很多，还要占用许多处理机资源。
<ul>
<li>TCP ⼀般用于<u>⽂件传输、发送和接收邮件、远程登录</u>等场景。</li>
</ul>
</li>
<li><strong>数据包</strong>： TCP是<strong>报文段</strong>，UDP是<strong>用户数据报</strong>。</li>
<li><strong>应用场景</strong> ： TCP用于一些需要可靠传输的场景； UDP则应用一些即时通信场景，不需要可靠传输的场景。</li>
<li><strong>长度</strong>：UDP在DNS最长只能是512字节，TCP会更长。</li>
</ul>
<h2 id="3-3-网络层">3.3 网络层</h2>
<h4 id="1-请简单解释一下，ARP协议和ARP攻击">1.<strong>请简单解释一下，ARP协议和ARP攻击?</strong></h4>
<ul>
<li>ARP协议：地址解析协议，建立<code>IP/MAC</code>地址映射表</li>
<li>ARP攻击：</li>
</ul>
<h4 id="2-什么是ICMP协议，它的作用是什么？">2.<strong>什么是ICMP协议，它的作用是什么</strong>？</h4>
<p>用于在<strong>IP主机、路由器</strong>之间传递控制消息。</p>
<blockquote>
<p>控制消息是指：<strong>网络通不通、主机是否可达、路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
</blockquote>
<h4 id="3-请你讲一下路由器和交换机的区别？">3.<strong>请你讲一下路由器和交换机的区别？</strong></h4>
<ol>
<li>
<p><strong>动态IP</strong>：<u>路由器可以给你的局域网自动分配IP</u>，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了。<u>交换机只是用来分配网络数据的</u>。</p>
<p><u>路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP</u>。交换机可以把很多主机连起来，这些主机对外各有各的IP。</p>
</li>
<li>
<p><strong>寻址方式</strong>：路由器在<strong>网络层</strong>，<u>路由器根据IP地址寻址</u>，路由器可以处理TCP/IP协议，交换机不可以；交换机在<strong>中继层</strong>，<u>交换机根据MAC地址</u>寻址。</p>
</li>
<li>
<p><strong>防火墙</strong>：路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</p>
</li>
</ol>
<h4 id="4-请解释ping命令过程？">4.<strong>请解释<code>ping</code>命令过程？</strong></h4>
<ol>
<li>域名在DNS服务器查找IP地址；</li>
<li>通过Ping程序发送<strong>ICMP包；</strong></li>
<li>同一网段的情况下，调用IP层的<strong>ARP协议</strong>请求<strong>广播</strong>（不同网段的情况下，交给路由器处理），<strong>查找目标主机的MAC地址</strong>；</li>
<li>目标主机ARP协议收到请求后，将本机<strong>MAC地址填充</strong>并<strong>发送ARP应答</strong>回到请求发送方；</li>
<li>请求发送方发送<strong>ICMP数据</strong>到目标主机；</li>
<li>目标主机<strong>响应ICMP包</strong>；</li>
<li>请求主机收到目标主机的<strong>ICMP响应包</strong>。</li>
</ol>
<h4 id="5-（补充介绍）介绍一下IPV6？一共多少位？">5. （补充介绍）介绍一下IPV6？一共多少位？</h4>
<p><img src="https://i.loli.net/2021/05/17/i5Nz6lF9RXYsShw.png" alt="IPv6 协议基础_果子哥丶的博客-CSDN博客"></p>
<p>源IP和目的IP地址都是，128（4*32）位（图中标识不清晰）！</p>
<h4 id="6-介绍一下IP地址分类？C类哪些是保留地址？网络号全-0-全-1-，主机号全-0-全1-分别什么含义？">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</h4>
<ul>
<li>
<p><strong>IP地址分类</strong></p>
<p><code>IP地址 == &#123;&lt;网络号&gt;，&lt;主机号&gt;&#125;</code></p>
<p><img src="https://i.loli.net/2021/05/17/ZINJCj9l8WM7qhf.jpg" alt="img"></p>
<ul>
<li>
<p><strong>A类</strong>： 第1位固定为0，网络号只有7位 。0（0000 0000）的IP地址是<strong>保留地址</strong>，意思是“本网络” ； 127（0111 1111）的IP地址也是<strong>保留地址</strong>，作为本地环回软件测试 。</p>
<blockquote>
<p>特别的，<strong>主机号全1</strong>的是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80">广播地址</a>，它代表了网络全部的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>。</p>
</blockquote>
</li>
<li>
<p><strong>B类</strong>： 第1、2位固定为10，网络号有14位可以使用 。</p>
<blockquote>
<p>B类地址网络号为128.0（1000 000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p>
</blockquote>
</li>
<li>
<p><strong>C类</strong>： 第1、2、3位固定为110，网络号有21位可以使用 。</p>
<blockquote>
<p>（快手问）C类IP地址包含<strong>私有C类地址</strong>，范围从192.0.0.0 到223.255.255.255，其中私有C类地址范围从<strong>192.168.0.0 到192.168.255.255。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>全0或者全1的含义</strong></p>
<ul>
<li>
<p><strong>网络号全0：</strong>（1）如果主机号也为全0，那么此类ip地址可以当源端但不可以做目的端 （2）如果主机号不全为0，那么此类ip地址的使用和（1)相同，只是它代表的是网络上特定的主机</p>
</li>
<li>
<p><strong>网络号全1：<strong>全1的网络号和</strong>任意的主机号</strong>组合当做<strong>回环地址</strong>来使用。</p>
<blockquote>
<p>例如：127（0111 1111）的IP地址</p>
</blockquote>
</li>
<li>
<p><strong>主机号全0：</strong> 全为0，所得到的地址就是192.168.100.0，它是一个网络地址，代表的是一个<strong>网段</strong>；</p>
</li>
<li>
<p><strong>主机号全1：</strong> 机号全1 代表的是<strong>广播地址</strong>，广播地址是不可以做源端的，但是可以做目的端。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-应用层">3.4 应用层</h2>
<h4 id="1-请你谈谈DNS的寻址过程？">1.<strong>请你谈谈DNS的寻址过程？</strong></h4>
<p>（1）检查<strong>浏览器缓存、检查本地hosts文</strong>件：是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</p>
<p>（2）如果没有，则查找<strong>本地DNS解析器缓存</strong>：是否有这个网址的映射，如果有，返回映射，解析完成。</p>
<blockquote>
<p><strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</p>
</blockquote>
<p>（3）如果没有，则查找填写或分配的<strong>首选DNS服务器</strong>：称为本地DNS服务器。服务器接收到查询时：</p>
<ul>
<li>
<p>如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。</p>
</li>
<li>
<p>如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。</p>
</li>
</ul>
<p>（4）如果本地DNS服务器也失效：</p>
<ul>
<li>如果未采用<u>转发模式</u>（<strong>迭代</strong>，从上至下）（1）<strong>本地DNS服务器</strong>就把<strong>请求发至13台根DNS</strong>，根DNS服务器收到请求后，会判断这个域名（<a target="_blank" rel="noopener" href="http://xn--bvs.com">如.com</a>）是谁来授权管理，<u>并返回一个负责该顶级域名服务器的IP</u>，（2）本地DNS服务器收到顶级域名服务器IP信息后，继续向该<strong>顶级域名</strong>服务器IP发送请求，（3）该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，（4）将解析结果<strong>返回<u>本地DNS服务器</u>，再由本地DNS服务器</strong>返回解析结果，查询完成。</li>
<li>如果采用<u>转发模式</u>（<strong>递归</strong>，从下至上）（1）则此DNS服务器就会把请求转<strong>发至上一级DNS服务器</strong>，（2）如果上一级DNS服务器不能解析，则继续向上请求，（3）最终将解析结果依次<u>返回本地DNS服务器</u>，本地DNS服务器再返回给客户机，查询完成。</li>
</ul>
<h5 id="1-1-怎么获取13台根服务器？">1.1 怎么获取13台根服务器？</h5>
<p>ping -R ? 抓包？</p>
<h5 id="1-2-解释一下DNS劫持和DNS污染？">1.2 <strong>解释一下DNS劫持和DNS污染</strong>？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903991764058126">什么是http劫持 ? </a></p>
</blockquote>
<p><strong>一、DNS劫持</strong></p>
<p>DNS劫持某些手段取得<strong>某域名的解析记录控制权</strong>，进而修改此域名的解析结果，返回给用户一个错误的查询结果。</p>
<ul>
<li>
<p><strong>劫持过程</strong></p>
<ol>
<li>
<p>客户端发起域名请求到DNS解析服务器（一般是LocalDNS），<u>但此时DNS解析服务器被攻击篡改</u>；</p>
</li>
<li>
<p>被攻击篡改后的DNS解析服务器将请求转发给虚假服务器；</p>
<blockquote>
<p>DNS查询没有任何认证机制且基于UDP不可靠连接，因此很容易被篡改。</p>
</blockquote>
</li>
<li>
<p>虚假服务器返回<u>响应虚假信息</u>给被攻击篡改后的DNS解析服务器（也可能直接不响应）；</p>
</li>
</ol>
</li>
<li>
<p><strong>解决办法</strong></p>
<p>DNS劫持的本质是<strong>运营商的DNS解析服务器被攻击篡改</strong></p>
<ul>
<li>使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）</li>
<li>直接使用ip进行访问</li>
</ul>
</li>
</ul>
<p><strong>二、DNS污染</strong></p>
<p>DNS污染是一种让一般用户由于<strong>得到虚假目标主机IP</strong>而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。因为是不是<u>劫持单个DNS服务器，而是监听所有的，所以个人比较难防范。</u></p>
<ul>
<li>
<p><strong>污染原理</strong></p>
<ol>
<li>
<p>通过对UDP端口53上的<strong>DNS查询进行入侵检测</strong>；</p>
<blockquote>
<p>由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改。</p>
</blockquote>
</li>
<li>
<p>一经发现与关键词相匹配的请求则<u><strong>立即伪装成目标域名的解析服务器</strong></u>（NS，Name Server）给查询者返回虚假结果。</p>
</li>
</ol>
</li>
<li>
<p><strong>解决办法</strong></p>
<ol>
<li>VPN代理或者域名远程解析的方法解决</li>
<li>通过修改Hosts，手动设置<u>域名正确的IP地址</u></li>
</ol>
</li>
</ul>
<h4 id="2-Forward和Redirect的区别？">2. <strong>Forward和Redirect的区别</strong>？</h4>
<ul>
<li>
<p><strong>浏览器 URL 地址</strong>：Forward 是服务器<u>内部的重定向</u>，服务器<strong>内部请求某个 servlet</strong>，然后获取响应的内容，<strong>浏览器的 URL 地址不会变化</strong>；Redirect 是客户端请求服务器，然后服务器给客户端返回了一个<strong>302</strong> 状态码和<strong>新的 location</strong>，客户端<u><strong>重新发起 HTTP 请求</strong></u>，服务器给客户端响<u>应 location 对应的 URL 地址，</u>浏览器的 <strong>URL 地址发生了变化</strong>。</p>
</li>
<li>
<p><strong>数据的共享</strong>：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，<strong>request 中的信息在 servlet 间是共享</strong>的。Redirect 发起了<strong>两次 HTTP 请求</strong>分别使用<strong>不同的request</strong>。</p>
</li>
<li>
<p><strong>请求的次数</strong>：Forward 只有一次请求；Redirect 有两次请求。</p>
</li>
</ul>
<h4 id="3-请你简单讲解一下，负载均衡反向代理模式的优点、缺点？">3.<strong>请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</strong></h4>
<blockquote>
<p>联系实际：<a target="_blank" rel="noopener" href="https://server.zol.com.cn/633/6339623_all.html">正反向代理、科学上网、VPN之间的关系</a> 和<a target="_blank" rel="noopener" href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">翻墙基本原理（看他的其他文章补充）</a></p>
</blockquote>
<p>【基本介绍】</p>
<ol>
<li>
<p><strong>反向代理</strong>（Reverse Proxy）：方式是指<u>以代理服务器来接受internet上的连接请求</u>，然后将请求转发给内部网络上的服务器，并将从<strong>服务器上得到的结果返回给internet上请求连接的客户端</strong>，此时代理服务器对外就表现为一个服务器；</p>
<ul>
<li>
<p><strong>优点</strong>： 网络络外部用户不能直接访问真实的服务器，具备额外的安全性</p>
</li>
<li>
<p><strong>缺点</strong>： 反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器；限制了应用范围；</p>
<p><u><strong>针对每一次代理，代理服务器就必须打开两个连接</strong></u>，一个对外，一个对内，因此在并发连接请求数量非常大的时候，<strong>代理服务器的负载也就非常大了</strong>，在最后代理服务器本身会成为服务的瓶颈。</p>
</li>
</ul>
</li>
<li>
<p><strong>反向代理负载均衡技术</strong>：是把将来自internet上的连接请求以反向代理的方式动态地<strong>转发</strong>给内部网络上的<strong>多台服务器</strong>进行处理，从而达到负载均衡的目的。</p>
<ul>
<li><strong>实现</strong>：apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。</li>
<li><strong>优点</strong>：可以将优化的 <u>负载均衡策略和代理服务器的高速缓存技术</u>结合在一起，提升静态网页的访问速度，提供有益的性能</li>
<li><strong>缺点</strong>：</li>
</ul>
</li>
</ol>
<h5 id="3-1-请解释下负载均衡的相关算法？">3.1 请解释下负载均衡的相关算法？</h5>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。</p>
<ul>
<li>给配置高、负载低的机器配置更高的权重，让其处理更多的请求；</li>
<li>给配置低、负载高的机器分配较低的权重，降低系统负载。</li>
</ul>
<p>下面是几种比较相关的算法。</p>
<ul>
<li>
<p><strong>加权轮询算法</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">加权轮询算法</a></p>
</blockquote>
<ul>
<li>
<p>基本定义</p>
<ol>
<li>假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn}</li>
<li>currentPos 表示当前选择的实例 ID，初始化为 -1；</li>
<li>currentWeight 表示当前权重，初始值为 max(S)；</li>
<li>max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。</li>
</ol>
</li>
<li>
<p>算法过程</p>
<ol>
<li>从上一次调度实例起，<strong>遍历后面</strong>的每个实例；</li>
<li>若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)；</li>
<li><strong>直到</strong> 遍历的实例的权重 &gt;= currentWeight 时结束，<strong>此时实例为需调度的实例</strong>；</li>
<li>每次调度重复步骤 1、2、3；</li>
</ol>
</li>
<li>
<p>算法实例</p>
<p><img src="https://i.loli.net/2021/05/30/YCVDN4miMvPy7sJ.png" alt="image-20210529232315965"></p>
<p>例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下：</p>
<p><img src="https://i.loli.net/2021/05/30/7A4s6i3opra8LWR.png" alt="image-20210529232350799"></p>
</li>
<li>
<p>算法优缺点</p>
<ul>
<li>
<p><strong>优点</strong>： 相比 <u>简单轮询</u> 方式，通过权重进行分配，更加均匀</p>
</li>
<li>
<p><strong>缺点</strong>：如下一个极端情况</p>
<blockquote>
<p>服务实例 S = {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。</p>
</blockquote>
<p>关于这点，可以采用  <a target="_blank" rel="noopener" href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html#">平滑加权轮询</a> 调度算法 。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>一致性哈希算法</strong></p>
<p>负载均衡算法中的哈希算法，就是根据某个值生成一个哈希值，然后对应到某台服务器上去，即<strong>哈希环</strong>。</p>
<p><img src="https://i.loli.net/2021/05/30/fAa2jzXxGZ7lVq1.png" alt="image-20210529232953082"></p>
<p>但是可能出现一种，<strong>哈希倾斜</strong>的情况：A负责的区域太大，B，C负责的小。这个时候采用虚拟节点去解决，这里不表。</p>
</li>
</ul>
<h5 id="3-2-DNS-负载均衡是什么策略？">3.2 DNS 负载均衡是什么策略？</h5>
<blockquote>
<p>参考：<a href=""></a></p>
</blockquote>
<ul>
<li><strong>原理</strong>： 还是不太明白，DNS递归查询本身就是个负载均衡策略吧？多台服务器满足同一个查询服务？</li>
</ul>
<h4 id="4-请说明一下http和https的区别？">4.<strong>请说明一下http和https的区别？</strong></h4>
<ol>
<li>https协议要申请证书到ca，需要一定<u>经济成本</u>；</li>
<li>http是明文传输，https是加密的安全传输；</li>
<li>（🚩*1）连接的端口不一样，http是<strong>80</strong>，https是<strong>443</strong>；</li>
<li>http连接很简单，没有状态；</li>
<li>https是ssl加密的传输，身份认证的网络协议，相对http明文传输比较安全。</li>
</ol>
<h5 id="4-1-讲一讲http的请求报文和响应报文？协议？">4.1 讲一讲http的请求报文和响应报文？协议？</h5>
<ul>
<li>
<p><strong>请求报文和协议</strong></p>
<p>一个HTTP请求报文由<strong>请求行（request line）</strong>、<strong>请求头部（header）</strong>、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="https://i.loli.net/2021/05/17/uxX1gbcnhTsS9td.png" alt="img"></p>
<ul>
<li>
<p><strong>请求行</strong> ：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。</p>
<blockquote>
<p><strong>HTTP协议</strong> :  的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
</blockquote>
</li>
<li>
<p><strong>请求头部</strong>： 请求头部由<strong>关键字/值</strong>对组成，每行一对，关键字和值用英文冒号“:”分隔 。 请求头部<strong>通知服务器有关于客户端请求的信息</strong>。</p>
<blockquote>
<p>User-Agent：产生请求的浏览器类型。</p>
<p>Accept：客户端可识别的内容类型列表。</p>
<p><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>
</blockquote>
</li>
<li>
<p><strong>请求数据 :</strong> 请求数据<strong>不在GET方法中使用，而是在POST方法</strong>中使用。POST方法适用于需要客户填写表单的场合。</p>
</li>
</ul>
</li>
<li>
<p><strong>响应报文和协议</strong></p>
<p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空格、响应数据</strong>。</p>
<p><img src="https://i.loli.net/2021/05/17/QNIRoY5f7jk6sHv.jpg" alt="img"></p>
<ul>
<li><strong>状态行</strong> ： 状态行（status line）通过提供一个状态码来说明所请求的资源情况。如<strong>404</strong>等</li>
</ul>
</li>
</ul>
<h5 id="4-2-一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</h5>
<ul>
<li><strong>HTTP/1.1单个 TCP 连接在同一时刻只能处理一个请求</strong>。意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠；</li>
<li><strong>Pipelining 技术 &amp; Multiplexing。</strong> Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；</li>
</ul>
<blockquote>
<p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？</p>
</blockquote>
<ul>
<li>维持和服务器已经建立的 TCP 连接，在同一连接上<strong>顺序处理多个请求</strong>；</li>
<li><strong>和服务器建立多个 TCP 连接</strong>。</li>
</ul>
<h4 id="5-请说明一下http1-0-和https1-1-区别？">5.<strong>请说明一下http1.0 和https1.1 区别</strong>？</h4>
<ul>
<li><strong>长连接</strong>
<ul>
<li>HTTP1.0默认使用短连接，每次HTTP请求都需要建立新的TCP连接，连接不能复用；</li>
<li>HTTP1.1支持<strong>持久连接和请求的流水线处理（但不是并发！！</strong>），在<strong>一个TCP连接上可以传送多个HTTP请求和响应</strong>，<u>减少建立和关闭TCP连接的消耗和延迟，提高效率</u></li>
</ul>
</li>
<li><strong>host字段</strong>
<ul>
<li>在<strong>HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名</strong>（hostname）</li>
<li>HTTP1.1的请求消息和响应消息都应支持Host头域（<u>补充：F12 抓包可以看到</u>），且请求消息中如果<strong>没有Host头域</strong>，会<strong>报400 Bad Request错误</strong></li>
</ul>
</li>
<li><strong>缓存处理</strong>
<ul>
<li>HTTP1.1则引入了更多的缓存控制策略</li>
</ul>
</li>
<li><strong>带宽优化及网络连接的使用</strong>
<ul>
<li>HTTP1.0中存在浪费带宽现象，例如：（1）客户端只需要某个对象的一部分，而服务器却<u>将整个对象发送过来</u>；(2) 下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包；</li>
<li>HTTP1.1则在请求头中引入range头域，它允许<strong>只请求资源的某个部分(因此也支持断点重传)</strong>，即返回码是206；</li>
</ul>
</li>
<li><strong>新增一些错误通知状态码</strong>
<ul>
<li>如：409（Conflict）表示请求的资源与资源的当前状态发生冲突 。</li>
</ul>
</li>
</ul>
<h4 id="6-请说明一下http1-0-和https2-0-区别？">6.<strong>请说明一下http1.0 和https2.0 区别</strong>？</h4>
<h4 id="7-请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？">7.<strong>请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程</strong>？</h4>
<ol>
<li>
<p>在浏览器地址栏中输入URL；</p>
</li>
<li>
<p>DNS域名解析，获得域名相对应的IP地址（详见：<u>应用层DNS寻址过程</u>）；</p>
<blockquote>
<p>浏览器首先会从（1）本地浏览器缓存、hosts文件是否存在相应的域名、IP对应关系，如果有则向这个IP地址发送请求，如果没有则向（2）本地DNS<strong>解析器</strong>缓存中查找，如果都没有，（3）再去DNS<strong>服务器</strong>中找IP。</p>
</blockquote>
</li>
<li>
<p>浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手；然后 <u><strong>向服务器发送HTTP请求</strong></u>，请求数据包</p>
<blockquote>
<p><strong>HTTP请求是由三部分组成：请求行、请求报头和请求正文</strong>。</p>
<p>与服务器建立了连接后，就可以向服务器发起请求了。发送HTTP请求的过程就是<u>构建HTTP请求报文</u>，并通过TCP协议发送到服务器指定端口（<u>HTTP协议80/8080，HTTPS协议443</u>）。</p>
</blockquote>
</li>
<li>
<p>服务端（由web服务器）处理收到的请求</p>
<blockquote>
<p>服务器端收到请求后，由web服务器（准确来说应该是HTTP服务器）处理请求，诸如Apache、Ngnix、IIS 。</p>
</blockquote>
</li>
<li>
<p>服务器返回相应结果（响应报文）至浏览器</p>
<blockquote>
<p>HTTP响应报文也是由三部分组成：<strong>状态码、响应报头和响应报文</strong>。</p>
<p>状态码是由三位数组成，<u>第一个数字定义了响应的类别</u>：</p>
<ul>
<li><strong>1XX</strong>：指示信息，表示请求已接受，继续处理；</li>
<li><strong>2XX</strong>：成功，表示请求已被成功接收、理解、接受；</li>
<li><strong>3XX</strong>：重定向，要完成请求必须进行更进一步的操作；</li>
<li><strong>4XX</strong>：客户端错误，请求有语法错误或无法实现；</li>
<li><strong>5XX</strong>：服务器端错误，服务器未能实现合法的请求。</li>
</ul>
</blockquote>
</li>
<li>
<p>四次挥手关闭TCP连接</p>
<blockquote>
<p>四次挥手，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。</p>
</blockquote>
</li>
<li>
<p>浏览器解析渲染页面</p>
<blockquote>
<p>浏览器在 <u>收到HTML、CSS、JS文件</u>后，就需要进行渲染。</p>
<p>（1）浏览器解析HTML文件构建<u>DOM树</u>，（2）然后解析CSS文件构建<u>渲染树</u>，（3）等到渲染树构建完成后，浏览器开始布局渲染树并将其<u>绘制到屏幕</u>上</p>
</blockquote>
</li>
</ol>
<h4 id="8-请解释一下SSL工作过程（Https传输过程）？">8.<strong>请解释一下SSL工作过程（Https传输过程）？</strong></h4>
<blockquote>
<p>https是http的扩展，在传输层使用了安全协议：<strong>安全套接字层SSL(Secure Socket Layer)</strong>。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
</blockquote>
<blockquote>
<p><strong>公钥</strong>通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。公钥和私钥是通过一种算法得到的一个密钥对(即一个公钥和一个私钥)。</p>
<ul>
<li>通过这种算法得到的密钥对能保证在世界范围内是唯一的。</li>
<li>使用这个密钥对的时候,如果用其中一个密钥加密一段数据，必须用另一个密钥解密。</li>
</ul>
</blockquote>
<p>SSL/TLS协议的基本思路是采用<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p><img src="https://i.loli.net/2021/04/21/aH6gjc5UT9Xu2io.png" alt="image-20210421171336262"></p>
<p>所以基本过程是：</p>
<blockquote>
<p>（1） 客户端向服务器端索要并验证公钥。</p>
<p>（2） 双方协商生成&quot;对话密钥&quot;。</p>
<p>（3） 双方采用&quot;对话密钥&quot;进行加密通信。</p>
</blockquote>
<ol>
<li>
<p><strong>协商加密算法</strong>。客户端（通常是浏览器）先向服务器发出<u>加密通信的请求</u>，这被叫做ClientHello请求；</p>
<blockquote>
<p>（1） 支持的协议版本，比如TLS 1.0版。</p>
<p>（2） <u>一个客户端生成的随机数</u>，来生成&quot;对话密钥&quot;。</p>
<p>（3） 支持的加密方法，比如RSA公钥加密。</p>
<p>（4） 支持的压缩方法。</p>
</blockquote>
</li>
<li>
<p><strong>服务器回应</strong>。服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello；</p>
<blockquote>
<p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p>
<p>（2） <u>一个服务器生成的随机数</u>，稍后用于生成&quot;对话密钥&quot;。</p>
<p>（3） 确认使用的加密方法，比如RSA公钥加密。</p>
<p>（4） 服务器证书。</p>
</blockquote>
</li>
<li>
<p><strong>客户端鉴别</strong>。客户端收到服务器回应以后，（1）<u>首先验证服务器证书</u>：如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>（2）<u>如果证书没有问题，客户端就会从证书中取出服务器的公钥</u>。然后，向服务器发送下面三项信息：</p>
<blockquote>
<p>（1） <u>一个随机数</u>。该随机数用服务器公钥加密，防止被窃听。</p>
<p>（2） <u>编码改变通知</u>，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
<p>（3） <u>客户端握手结束通知</u>，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
</blockquote>
</li>
<li>
<p><strong>会话秘钥计算</strong>。 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;（使用3个随机数生成更安全）；</p>
<blockquote>
<p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
</blockquote>
</li>
<li>
<p><strong>安全数据传输</strong>。双方用会话秘钥加密和解密之间传送的数据。</p>
</li>
</ol>
<h5 id="8-1-公钥如何保证不被篡改？说一说证书。">8.1 公钥如何保证不被篡改？说一说证书。</h5>
<p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<ul>
<li>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
</li>
<li>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，<strong>会对已申请的公开密钥做数字签名</strong>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
</li>
<li>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过（<strong>证书不可信浏览器会提示</strong>），就可以开始通信了。</p>
</li>
</ul>
<h5 id="8-2-公钥加密计算量太大，如何减少耗用的时间？">8.2 公钥加密计算量太大，如何减少耗用的时间？</h5>
<p>每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于<strong>对话密钥是对称加密</strong>，所以<strong>运算速度非常快</strong>，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>
<h5 id="8-3-为什么有的时候刷新页面不需要重新建立-SSL-连接？">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</h5>
<p>TCP 连接有的时候会被浏览器和服务端维持一段时间，<strong>TCP 不需要重新建立，SSL 自然也会用之前的</strong>。</p>
<h4 id="9-介绍一下常见的几种非对称加密算法？优缺点？">9. 介绍一下常见的几种非对称加密算法？优缺点？</h4>
<ul>
<li>
<p><strong>非对称加密</strong></p>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p>
</li>
<li>
<p><strong>常用非对称加密算法</strong></p>
<p><img src="https://i.loli.net/2021/04/21/8cmyAzUZYDw5vJt.png" alt="面试题——对称加密和非对称加密3"></p>
<ul>
<li>RSA：由 RSA 公司发明，是一个支持<strong>变长密钥</strong>的公共密钥算法，需要加密的文件块的长度也是可变的</li>
<li>DSA（Digital Signature Algorithm）<strong>：数字签名</strong>算法，是一种标准的 DSS（数字签名标准）</li>
<li>ECC（Elliptic Curves Cryptography）<strong>：椭圆曲线加密</strong></li>
</ul>
</li>
<li>
<p><strong>非对称加密优缺点</strong></p>
<ul>
<li><strong>优点</strong>： 可以更安全地将公开密钥传输给通信发送方；</li>
<li><strong>缺点</strong>： 运算速度慢。</li>
</ul>
</li>
</ul>
<h4 id="10-公钥加密–私钥解密与公钥解密–私钥加密有什么区别">10.<strong>公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</strong></h4>
<p>主要是应用场景不同。</p>
<ul>
<li>
<p>加解密：公钥加密，私钥解密</p>
<blockquote>
<p>不希望别人知道我的消息，<u>所以只有我才能解密</u>，所以可得出公钥负责加密，私钥负责解密</p>
</blockquote>
</li>
<li>
<p>签名：私钥签名，公钥验签</p>
<blockquote>
<p>是不希望有人冒充我发消息，只有<u>我才能发布这个签名</u>，所以可得出私钥负责签名，公钥负责验证</p>
</blockquote>
</li>
<li>
<p><strong>https可以只有非对称加密吗?</strong></p>
<p>https<u>验证证书阶段是非对称加密</u>，但是在数据传输阶段是对称加密。<strong>https不可以只有非对称加密</strong>：</p>
<ul>
<li><strong>非对称加密</strong>的加解密<strong>效率是非常低</strong>的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</li>
<li>在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</li>
</ul>
</li>
</ul>
<h4 id="11-HTTPS-为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS-绝对安全吗？">11. <strong>HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</strong></h4>
<ul>
<li>
<p><strong>安全</strong>：因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性；</p>
</li>
<li>
<p><strong>CA证书</strong>： <u>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器</u>，而 HTTPS 协议主要解决的便是网络传输的安全性问题，所以需要CA证书</p>
</li>
<li>
<p><strong>证书生成</strong>： 如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但<strong>浏览器通常只是提示安全风险，并不限制网站不能访问</strong>，所以从技术上<strong>谁都可以生成证书</strong>，只要有证书就可以完成网站的 HTTPS 传输。</p>
</li>
<li>
<p><strong>不绝对安全</strong>： 不是绝对安全的，可以通过中间人攻击。</p>
<blockquote>
<p>CA证书不是可以解决“中间人”吗？</p>
</blockquote>
<p>过程原理：</p>
<ol>
<li>本地请求被劫持（<u>如DNS劫持等</u>），所有请求均发送到中间人的服务器</li>
<li>中间人服务器返回中间人自己的证书（<strong>但是这一步服务器不是会对服务器证书进行验证吗？</strong>）</li>
<li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li>
<li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li>
<li>中间人以客户端的请求内容再向官方网站发起请求</li>
<li>因为中间人与服务器的通信过程是合法的，官方网站通过建立的安全通道返回加密后的数据</li>
<li>中间人凭借与官方网站建立的对称加密算法对内容进行解密</li>
<li>中间人通过与客户端建立的对称加密算法对官方内容返回的数据进行加密传输</li>
<li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li>
</ol>
</li>
</ul>
<h4 id="12-http应答码中的301-2-4、500、502、503、504状态码进行解释？">12. <strong>http应答码中的301/2/4、500、502、503、504状态码进行解释</strong>？</h4>
<ul>
<li>
<p><strong>200：</strong>  请求成功。</p>
</li>
<li>
<p><img src="https://i.loli.net/2021/04/21/MRi5Oy9Ltd3v8uA.png" alt="image-20210421150625709"></p>
</li>
<li>
<p><strong>500：</strong> 500 (<strong>服务器内部错误</strong>) 服务器遇到错误，无法完成请求。 例如，服务器<strong>无法识别请求方法</strong>时可能会返回此代码。</p>
</li>
<li>
<p><strong>501：<strong>服务器</strong>不支持请求的功能</strong>，无法完成请求</p>
</li>
<li>
<p><strong>502：</strong> 作为<strong>网关或者代理工作的服务器</strong>尝试执行请求时，从<u>上游服务器</u>接收到<strong>无效</strong>的响应。</p>
</li>
<li>
<p><strong>503：</strong> 由于超载或系统维护，服务器暂时的<strong>无法处理客户端</strong>的请求。</p>
</li>
<li>
<p><strong>504(及时)</strong>：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p>
</li>
</ul>
<h4 id="13-介绍一下http请求get、post等？">13.<strong>介绍一下http请求get、post等</strong>？</h4>
<p><img src="https://i.loli.net/2021/04/21/WRLspE4fvjdKq8F.png" alt="image-20210421140204266"></p>
<p><strong>重点区分一下get和post：</strong></p>
<ul>
<li>
<p><code>get</code> ：GET方法用于使用给定的URI从给定服务器中<u>检索信息</u>，即从指定资源中请求数据。</p>
<ul>
<li><strong>GET请求是可以缓存的</strong>，浏览器历史记录中查找到GET请求；<strong>长度有限制</strong>；不安全，<strong>url会暴露请求的参数</strong></li>
</ul>
</li>
<li>
<p><code>post</code>：POST方法用于将数据发送到服务器以<u>创建或更新资源</u> 。</p>
<ul>
<li><strong>POST请求不会被缓存</strong>；<strong>长度无限制</strong>；更安全</li>
</ul>
</li>
<li>
<p><strong>特别的：<code>GET产生一个TCP数据包;POST产生两个TCP数据包。</code></strong></p>
<ul>
<li>
<p>get：http header和body一并发送出去 ；</p>
</li>
<li>
<p>post：浏览器先发送header，服务器响应100 continue，浏览器再发送body 。</p>
<blockquote>
<p>⚠️ post是不一定会发生两个的。</p>
<ul>
<li>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送；</li>
<li>header 和 body 分开发送<strong>是部分浏览器或框架的请求方法</strong>，不属于 post 必然行为。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="13-1-Get方法长度有限制是怎么回事？">13.1 Get方法长度有限制是怎么回事？</h5>
<p>HTTP 协议没有 Body 和 URL 的长度限制，<strong>对 URL 限制的大多是浏览器 / 服务器的原因</strong>。</p>
<ul>
<li>服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制；</li>
<li>浏览器也会设置url有限。</li>
</ul>
<h5 id="13-2-POST-方法相比GET方法是绝对安全吗？">13.2 POST 方法相比GET方法是绝对安全吗？</h5>
<ul>
<li>POST 比 GET 安全，因为数据在地址栏上不可见；</li>
<li><strong>POST不是绝对安全</strong>，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</li>
</ul>
<p>想要安全，只有使用<strong>HTTPS</strong>。</p>
<h4 id="14-HTTP是不保存状态的协议-如何保存用户状态">14.  HTTP是不保存状态的协议,如何保存用户状态?</h4>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太⼀样。</p>
<ul>
<li><strong>Cookie ⼀般用来保存用户<u>信息</u></strong>
<ul>
<li>我们在 Cookie 中<strong>保存已经登录过得用户信息</strong>，下次访问网站的时候页面可以⾃动帮你登录的⼀些基本信息给填了；</li>
<li>⼀般的网站都会有<strong>保持登录</strong>也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以<strong>存放了⼀个 Token 在 Cookie</strong>中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录⼀般要将 Token<br>
重写)；</li>
<li>登录⼀次网站后访问网站其他页面不需要重新登录。</li>
</ul>
</li>
<li><strong>Session 的主要作用就是通过服务端记录用户的<u>状态</strong></u>。
<ul>
<li><strong>典型的场景是购物⻋</strong>，当你要添加商品到购物⻋的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li>
<li><strong>既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢</strong>？大部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来方式来跟踪。</li>
</ul>
</li>
</ul>
<h4 id="15-cookie-、session的作用和区别？">15. <strong>cookie 、session的作用和区别</strong>？</h4>
<ul>
<li>
<p><strong>Cookie</strong></p>
<ul>
<li>
<p><strong>作用</strong>： 服务器发送到用户浏览器并保存在本地的一小块数据，它会在<u>浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</u>。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p>
<blockquote>
<p>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Session</strong></p>
<ul>
<li><strong>作用</strong>： Session 代表着服务器和客户端<strong>一次会话的过程</strong>，Session <u>对象存储特定用户会话所需的属性及配置信息</u>。</li>
</ul>
</li>
<li>
<p><strong>二者区别</strong></p>
<ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端（浏览器），Session 保存在服务器端；</li>
<li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效；</li>
<li><strong>安全性</strong>： Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些；</li>
<li><strong>存储大小不同</strong>：  <u>单个 Cookie 保存的数据不能超过 4K</u>，Session 可存储数据远高于 Cookie；</li>
<li><strong>存取类型的不同</strong>，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
</ul>
</li>
</ul>
<h5 id="15-1-Session的共享方式？（好未来问过）">15.1 Session的共享方式？（好未来问过）</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jing99/p/11785070.html">Session如何共享</a></p>
</blockquote>
<ul>
<li>
<p><strong>问题描述</strong></p>
<ol>
<li>在集群环境中，假设客户端第一次访问服务A，服务A响应返回了一个sessionId并且存入了本地Cookie中。第二次不访问服务A了，转去访问服务B；</li>
<li>访问服务B的时候，会将sessionId加入到请求头中，而服务B因为通过sessionId没有找到相对应的数据，因此它就会<strong>创建一个新的sessionId并且响应返回给客户端</strong></li>
</ol>
<p>这样就造成了不能共享Session的问题。</p>
</li>
<li>
<p><strong>解决方案</strong></p>
<ol>
<li><strong>使用Cookie实现</strong>。 将系统用户的Session信息加密、序列化后，以Cookie的方式， 统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有Cookie内容的特性，从而实现用户的Cookie化Session在多服务间的共享访问。</li>
<li><strong>数据库同步session。</strong>  每次将session数据存到数据库中。这个方案还是比较可行的。
<ul>
<li><strong>缺点</strong>： Session的并发读写能力取决于MySQL数据库的性能，对数据库的压力大，同时需要自己实现Session淘汰逻辑，以便定时从数据表中更新、删除 Session记录，当并发过高时容易出现表锁。</li>
</ul>
</li>
<li><strong>使用token代替session。</strong> 就是Token方式替代了，但是还是没解决。</li>
<li><strong>Spring-Sesion实现</strong> 。将原本需要由Web服务器创建会话的过程转交给Spring-Session进行创建。Spring-Session会将原本应该保存在Web服务器内存的Session存放到Redis中。然后<strong>Web服务器之间通过连接Redis来共享数据</strong>，达到Sesson共享的目的。</li>
</ol>
</li>
</ul>
<h4 id="16-Cookie-和-Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904009061367821">一文彻底搞懂Cookie、Session、Token到底是什么</a></p>
</blockquote>
<ul>
<li>
<p><strong>为什么需要session？</strong></p>
<blockquote>
<p>既然浏览器已经通过<code>Cookie</code>实现了有状态这一需求，那么为什么又来了一个<code>Session</code>呢？</p>
</blockquote>
<p>如果将账户的一些重要信息都存入<code>Cookie</code>中的话，一旦<strong>被拦截</strong>，那么我们所有的账户信息都会丢失掉。所以就出现了<code>Session</code>，在一次会话中将重要信息保存在<code>Session</code>中，浏览器只记录<code>SessionId</code>一个<code>SessionId</code>对应一次会话请求。</p>
</li>
<li>
<p><strong>session和cookie二者关联</strong></p>
<p><img src="https://i.loli.net/2021/05/04/jNerb9CXZ6Jpgs2.jpg" alt="img"></p>
<blockquote>
<p>以用户一次登录为例。</p>
</blockquote>
<ol>
<li>用户第一次请求服务器的时候，用户提交包含<strong>用户名和密码</strong>的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 <strong>Redis</strong> 中，它在 Redis 中的 Key 称为 Session ID；并将此 Session 的唯一标识信息 SessionID 返回给浏览器；</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名；</li>
<li>当用户第二次访问服务器的时候，请求会自动判断<u>此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端</u>；</li>
<li>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 <u>Session 信息，如果没有找到说明用户没有登录或者登录失效</u>，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ol>
</li>
<li>
<p><strong>什么是Token？</strong></p>
<blockquote>
<p><code>Session</code>是将要验证的信息存储在服务端，并以<code>SessionId</code>和数据进行对应，<code>SessionId</code>由客户端存储，在请求时将<code>SessionId</code>也带过去，因此实现了状态的对应。</p>
</blockquote>
<p>但是，而<code>Token</code>是在服务端将<strong>用户信息经过Base64Url【编码，不是加密】过后传给在客户端</strong>，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了。</p>
<p>这个方法叫做<strong>JWT(Json Web Token)</strong>。</p>
<blockquote>
<p>一个例子理解：基于Token的身份验证流程，在服务端不需要存储用户的登录记录 。</p>
<ol>
<li>
<p>客户端<strong>使用用户名跟密</strong>码请求登录</p>
</li>
<li>
<p>服务端收到请求，去验证用户名与密码</p>
</li>
<li>
<p>验证成功后，服务端会<strong>签发一个 Token</strong>，再把这个 Token 发送给客户端</p>
<blockquote>
<p>Token在服务器端，可以保存在Redis缓存中。</p>
</blockquote>
</li>
<li>
<p>客户端收到 Token 以后可以把它存储起来，比如<strong>放在 Cookie 里或者 Local Storage</strong> 里</p>
</li>
<li>
<p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>
</li>
<li>
<p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
</li>
</ol>
</blockquote>
<ul>
<li>
<p><strong>Token的优点</strong></p>
<ol>
<li><strong>无状态，可扩展和解耦</strong>： 使用 token 而不是 cookie 的最大优点应该就是无状态，<strong>后端不需要保持对 token 的记录，每个 token 都是独立的</strong>，包含了检查其有效性的所有数据，并通过申明传达了用户信息。</li>
<li><strong>在 JWT 中存储数据</strong> ： 当使用 cookie 进行验证时，你是将 session id 存储到 cookie 里，JWT 允许你存储任何类型的元数据，只要是合法的 JSON。</li>
<li><strong>自包含</strong>：由于串包含了用户所需要的信息，避免了多次查询数据库。</li>
</ol>
</li>
<li>
<p><strong>JWT介绍</strong></p>
<p>JWT有三部分组成：Header，Payload，Signature。</p>
<p><img src="https://i.loli.net/2021/05/26/AC6ULh5293HQngE.png" alt="image-20210526214555872"></p>
<ul>
<li>
<p><strong>Header：</strong> 一个Json对象，描述JWT的元数据，通常是下面这样子的。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 签名的算法为HS256</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>    # Token类型为JWT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Payload：</strong> 也是一个Json对象，用来存放实际需要传输的数据，也可以自己定义一些私有字段，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoMing&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Signature</strong>： <strong>对前面的两部分的数据进行签名</strong>，<strong>防止数据篡改</strong> 。</p>
<blockquote>
<p>首先需要定义一个<strong>秘钥</strong>，这个秘钥只有服务器才知道，不能泄露给用户，然后使用<strong>Header中指定的签名算法</strong>(默认情况是HMAC SHA256)。算出签名以后将Header、Payload、Signature三部分拼成一个字符串，<strong>每个部分用<code>.</code>分割开来</strong>，就可以返给用户了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="16-1-session和cookie应该如何去选择（适用场景）？">16.1 session和cookie应该如何去选择（适用场景）？</h5>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在<strong>考虑数据复杂性时首选 Session</strong>；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<strong>考虑安全考虑session</strong></li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此<strong>不建议将所有的用户信息都存储到 Session 中，一般是cookie和session配合使用的</strong>。</li>
</ul>
<h4 id="17-说说HTTP、TCP、Socket-的关系是什么？">17.<strong>说说HTTP、TCP、Socket 的关系是什么</strong>？</h4>
<ul>
<li>TCP/IP 代表<u>传输控制协议/网际协议</u>，指的是一系列协议族；</li>
<li>HTTP 本身就是一个协议，是<u>从 Web 服务器传输超文本到本地浏览器</u>的传送协议；</li>
<li><strong>Socket 是 TCP/IP 网络的 API</strong> ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<h2 id="3-5-其它">3.5 其它</h2>
<h4 id="1-介绍一下CDN-？-CDN分发节点各个数据都一样吗？">1. 介绍一下CDN ？ <strong>CDN</strong>分发节点各个数据都一样吗？</h4>
<ul>
<li>
<p><strong>CDN，即内容分发网络</strong></p>
<ul>
<li>
<p><strong>解决静态网页加载</strong></p>
<p>不同地区用户访问服务器速度不同，<strong>可以把静态网页放在不同地区的服务器，这样用户可以就近去连接</strong>，大大提升体验；</p>
</li>
<li>
<p>发展转换成，<strong>就近接入解决访问网络资源</strong></p>
<ol>
<li>如一个电信用户送请求，进入解析系统，会<strong>让用户连接到最近的边缘节点</strong>，然后请求数据；</li>
<li>如果边缘节点没有数据，则去访问<strong>源节点</strong>；</li>
<li>源节点也没有，就会去访问<strong>主干节点，去联通服务器中查找；</strong></li>
<li>最后返回数据。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>CDN分发节点各个数据不一样</strong></p>
<p>不一样，就相当于DNS服务器<strong>缓存</strong>了些域名→ip数据，如果没有的话还要向上级查询，最终把源站数据拉下来。</p>
</li>
</ul>
<h4 id="2-什么是CDN三级溯源？">2.  什么是CDN三级溯源？</h4>
<ul>
<li><strong>CDN目的</strong>。CDN 系统设计的首要目标是<strong>尽量减少用户的访问响应时间</strong></li>
<li><strong>CDN实现思路</strong>。为达到这一目标，CDN 系统应该<strong>尽量将用户所需要的内容存放在距离用户最近的位置</strong>。也就是说，负责为用户提供内容服务的 <strong>Cache设备应部署在物理上的网络边缘位置</strong>，我们称这一层为 CDN边缘层 。</li>
<li><strong>CDN系统架构</strong>。CDN 系统中负责全局性管理和控制的设备组成 中心层 ，<strong>中心层同时保存着最多的内容副本</strong>，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</li>
</ul>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210813124031742.png" alt="image-20210813124031742"></p>
<p>各位同学们好：<br>
我们今年大数据课程已经接近尾声，这门课已经开设了三年，每年都会邀请同学们来共同建设。每年我们也都会根据同学们的反馈进行完善，今年我们预计会进行一次更大的系统性更新。<br>
按照当初承诺，现在我们统计下大家开源贡献，请按照示例，在进行下方评论完成填写。</p>
<ul>
<li>[注1] ：为保证大家隐私情况，该Issue<strong>会在三天内统计完毕后关闭</strong>，请及时填写~</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">组号</th>
<th style="text-align:center">贡献类型（文档建设、Issue、PR等）</th>
<th style="text-align:center">链接（或其它证明截图）</th>
<th style="text-align:center">贡献人</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01组</td>
<td style="text-align:center">issue</td>
<td style="text-align:center"><a href="">test-issue</a></td>
<td style="text-align:center">张三（20196666）、李四（20197777）</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>感谢大家的积极参与！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/46361/">https://hwh.zone/p/46361/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/44980/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">校招笔记（二）_计算机基础_Linux&amp;Git</div></div></a></div><div class="next-post pull-right"><a href="/p/15646/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（四）_计算机基础_操作系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（七）_计算机基础_数据结构</div></div></a></div><div><a href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">校招笔记（九）_计算机基础_相关补充</div></div></a></div><div><a href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（八）_计算机基础_场景&智力题</div></div></a></div><div><a href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（五）_计算机基础_MySQL</div></div></a></div><div><a href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（二）_计算机基础_Linux&Git</div></div></a></div><div><a href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（四）_计算机基础_操作系统</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">三、计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ISO-OSI%E6%A8%A1%E5%9E%8B-%E5%92%8C-TCP-IP-%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.1 ISO&#x2F;OSI模型  和 TCP&#x2F;IP 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP-IP-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE-%E5%92%8C-ISO-OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">1.请你简要介绍一下TCP&#x2F;IP 五层协议 和 ISO&#x2F;OSI七层协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%A0%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%84%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">2.请你简要介绍一下各层的协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-RARP-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">2.1 RARP 工作原理？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AB%AF%E5%8F%A3%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F%E6%9C%89%E6%95%88%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-text">3. 端口在哪一层？有效端口范围？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-text">3.2 运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-TCP%E6%8A%A5%E6%96%87%E5%A4%B4%EF%BC%9FUDP%E6%8A%A5%E6%96%87%E5%A4%B4%EF%BC%9F"><span class="toc-text">0. TCP报文头？UDP报文头？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%EF%BC%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%843%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%89%EF%BC%9F"><span class="toc-text">1. 请你说明一下，TCP协议的3次握手（进行连接）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-ISN-%EF%BC%88Initial-Sequence-Number%EF%BC%89%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">1.1 ISN （Initial Sequence Number）是固定的吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-text">2.为什么要三次握手？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-text">2.1 三次握手可以携带数据吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%EF%BC%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%89%EF%BC%9F"><span class="toc-text">3.请你说明一下，TCP协议的4次挥手（断开连接）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%A6%81%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%8F%8C%E5%B7%A5%EF%BC%8C%E4%B8%8D%E5%9F%BA%E4%BA%8E%E5%8D%8A%E5%8F%8C%E5%B7%A5%E5%91%A2%EF%BC%9F%E5%9F%BA%E4%BA%8E%E5%8D%8A%E5%8F%8C%E5%B7%A5%E5%8F%AF%E4%BB%A5%E6%94%B9%E4%B8%BA%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%97%EF%BC%9F"><span class="toc-text">3.1 为什么TCP四次挥手要基于全双工，不基于半双工呢？基于半双工可以改为三次挥手吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">3.2（重点） 服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AD%89%E5%BE%85%E6%98%AF2MSL%EF%BC%9F"><span class="toc-text">4. 为什么要有TIME_WAIT 状态？为什么等待是2MSL？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2MSL"><span class="toc-text">4.1 为什么是2MSL?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E8%AF%B7%E9%97%AETCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E5%8F%AF%E9%9D%A0%EF%BC%9F%E5%93%AA%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%BC%9A%E6%9C%89%E6%89%80%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-text">5. 【重点】请问TCP为什么要更可靠？哪种场景会有所应用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">5.1 超时重传机制原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BARQ%E5%8D%8F%E8%AE%AE-%EF%BC%9F"><span class="toc-text">5.2 介绍一下ARQ协议 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">5.2 介绍一下连续ARQ协议滑动窗口和流量控制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">5.3 介绍一下拥塞控制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">5.4 如何区分流量控制和拥塞控制？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B9%B6%E5%8F%91%E6%95%B0%EF%BC%9F"><span class="toc-text">6.如何提高客户端并发数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B4%E8%AF%B4HTTP%E3%80%81TCP%E3%80%81Socket-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7.说说HTTP、TCP、Socket 的关系是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%EF%BC%88DDos%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5-%EF%BC%9F"><span class="toc-text">8. 什么是半连接队列？泛洪攻击（DDos攻击的一种），以及解决策略 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88DNS%EF%BC%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%EF%BC%89%E7%94%A8UDP%EF%BC%8C%E8%80%8C%E5%8C%BA%E5%9F%9F%E4%BC%A0%E9%80%81%E7%94%A8TCP"><span class="toc-text">9.为什么DNS（域名解析）用UDP，而区域传送用TCP?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%AF%B4%E4%B8%80%E4%B8%8B-TCP-%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-text">10.说一下 TCP 粘包是怎么产生的？怎么解决粘包？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-TCP-UDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">11. TCP, UDP的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">3.3 网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%8CARP%E5%8D%8F%E8%AE%AE%E5%92%8CARP%E6%94%BB%E5%87%BB"><span class="toc-text">1.请简单解释一下，ARP协议和ARP攻击?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFICMP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.什么是ICMP协议，它的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.请你讲一下路由器和交换机的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E8%A7%A3%E9%87%8Aping%E5%91%BD%E4%BB%A4%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">4.请解释ping命令过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%EF%BC%88%E8%A1%A5%E5%85%85%E4%BB%8B%E7%BB%8D%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIPV6%EF%BC%9F%E4%B8%80%E5%85%B1%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%9F"><span class="toc-text">5. （补充介绍）介绍一下IPV6？一共多少位？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BIP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%EF%BC%9FC%E7%B1%BB%E5%93%AA%E4%BA%9B%E6%98%AF%E4%BF%9D%E7%95%99%E5%9C%B0%E5%9D%80%EF%BC%9F%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%85%A8-0-%E5%85%A8-1-%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%85%A8-0-%E5%85%A81-%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">6. 介绍一下IP地址分类？C类哪些是保留地址？网络号全 0 全 1   ，主机号全 0 全1 分别什么含义？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">3.4 应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88DNS%E7%9A%84%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.请你谈谈DNS的寻址过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%9613%E5%8F%B0%E6%A0%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F"><span class="toc-text">1.1 怎么获取13台根服务器？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BDNS%E5%8A%AB%E6%8C%81%E5%92%8CDNS%E6%B1%A1%E6%9F%93%EF%BC%9F"><span class="toc-text">1.2 解释一下DNS劫持和DNS污染？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Forward%E5%92%8CRedirect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. Forward和Redirect的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E3%80%81%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">3.请你简单讲解一下，负载均衡反向代理模式的优点、缺点？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">3.1 请解释下负载均衡的相关算法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-DNS-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%98%AF%E4%BB%80%E4%B9%88%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">3.2 DNS 负载均衡是什么策略？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.请说明一下http和https的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E8%AE%B2%E4%B8%80%E8%AE%B2http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%EF%BC%9F%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">4.1 讲一讲http的请求报文和响应报文？协议？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%B8%AD%E5%A4%9A%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E5%8F%91%E7%94%9F%E5%8F%AF%E4%BB%A5%E3%80%90%E5%90%8C%E6%97%B6%E3%80%91%E4%B8%80%E8%B5%B7%E5%8F%91%E7%94%9F%E5%90%97%EF%BC%9F"><span class="toc-text">4.2  一个TCP连接中多个HTTP请求发生可以【同时】一起发生吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bhttp1-0-%E5%92%8Chttps1-1-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5.请说明一下http1.0 和https1.1 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bhttp1-0-%E5%92%8Chttps2-0-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">6.请说明一下http1.0 和https2.0 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B7%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E6%8E%A5%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AAURL%EF%BC%8C%E5%88%B0%E6%9C%80%E5%90%8E%E5%B1%95%E7%A4%BA%E5%87%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">7.请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BSSL%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%88Https%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%EF%BC%89%EF%BC%9F"><span class="toc-text">8.请解释一下SSL工作过程（Https传输过程）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-%E5%85%AC%E9%92%A5%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9F%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%AF%81%E4%B9%A6%E3%80%82"><span class="toc-text">8.1 公钥如何保证不被篡改？说一说证书。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E8%AE%A1%E7%AE%97%E9%87%8F%E5%A4%AA%E5%A4%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E8%80%97%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-text">8.2 公钥加密计算量太大，如何减少耗用的时间？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E7%9A%84%E6%97%B6%E5%80%99%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8B-SSL-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">8.3 为什么有的时候刷新页面不需要重新建立 SSL 连接？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">9. 介绍一下常见的几种非对称加密算法？优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E2%80%93%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86%E4%B8%8E%E5%85%AC%E9%92%A5%E8%A7%A3%E5%AF%86%E2%80%93%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">10.公钥加密–私钥解密与公钥解密–私钥加密有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-HTTPS-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81CA%E8%AF%81%E4%B9%A6%EF%BC%9F%E5%8F%AA%E6%9C%89%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%90%97%EF%BC%9FHTTPS-%E7%BB%9D%E5%AF%B9%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-text">11. HTTPS 为什么安全？为什么需要CA证书？只有认证机构可以生成证书吗？HTTPS 绝对安全吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-http%E5%BA%94%E7%AD%94%E7%A0%81%E4%B8%AD%E7%9A%84301-2-4%E3%80%81500%E3%80%81502%E3%80%81503%E3%80%81504%E7%8A%B6%E6%80%81%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%A7%A3%E9%87%8A%EF%BC%9F"><span class="toc-text">12. http应答码中的301&#x2F;2&#x2F;4、500、502、503、504状态码进行解释？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bhttp%E8%AF%B7%E6%B1%82get%E3%80%81post%E7%AD%89%EF%BC%9F"><span class="toc-text">13.介绍一下http请求get、post等？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-Get%E6%96%B9%E6%B3%95%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-text">13.1 Get方法长度有限制是怎么回事？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-POST-%E6%96%B9%E6%B3%95%E7%9B%B8%E6%AF%94GET%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%9D%E5%AF%B9%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-text">13.2 POST 方法相比GET方法是绝对安全吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-text">14.  HTTP是不保存状态的协议,如何保存用户状态?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-cookie-%E3%80%81session%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15. cookie 、session的作用和区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-1-Session%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E5%A5%BD%E6%9C%AA%E6%9D%A5%E9%97%AE%E8%BF%87%EF%BC%89"><span class="toc-text">15.1 Session的共享方式？（好未来问过）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Cookie-%E5%92%8C-Session%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E8%81%94%EF%BC%9F%EF%BC%88%E9%97%AE%E8%BF%87%EF%BC%89token%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BC%98%E7%82%B9%EF%BC%8C%EF%BC%88JWT%EF%BC%89%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">16.  Cookie 和 Session有什么关联？（问过）token有什么作用，优点，（JWT）结构是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-1-session%E5%92%8Ccookie%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%8E%BB%E9%80%89%E6%8B%A9%EF%BC%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9F"><span class="toc-text">16.1 session和cookie应该如何去选择（适用场景）？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%AF%B4%E8%AF%B4HTTP%E3%80%81TCP%E3%80%81Socket-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17.说说HTTP、TCP、Socket 的关系是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%85%B6%E5%AE%83"><span class="toc-text">3.5 其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCDN-%EF%BC%9F-CDN%E5%88%86%E5%8F%91%E8%8A%82%E7%82%B9%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%83%BD%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-text">1. 介绍一下CDN ？ CDN分发节点各个数据都一样吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFCDN%E4%B8%89%E7%BA%A7%E6%BA%AF%E6%BA%90%EF%BC%9F"><span class="toc-text">2.  什么是CDN三级溯源？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a><time datetime="2021-12-05T08:28:39.054Z" title="发表于 2021-12-05 16:28:39">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/1/" title="无题">无题</a><time datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/62712/" title="C++从零开始（零）">C++从零开始（零）</a><time datetime="2021-12-05T08:22:28.029Z" title="发表于 2021-12-05 16:22:28">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56326/" title="Hexo快速打造属于自己的网站">Hexo快速打造属于自己的网站</a><time datetime="2021-11-29T12:10:54.202Z" title="发表于 2021-11-29 20:10:54">2021-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&amp;智力题">校招笔记（八）_计算机基础_场景&amp;智力题</a><time datetime="2021-11-26T13:37:19.761Z" title="发表于 2021-11-26 21:37:19">2021-11-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>