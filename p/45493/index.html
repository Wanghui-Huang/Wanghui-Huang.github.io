<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（一）_Java_锁 | royhuang's blog</title><meta name="keywords" content="JAVA,校招"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（一）_Java_锁">
<meta property="og:url" content="https://hwh.zone/p/45493/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hwh.zone/img/about-bg.jpg">
<meta property="article:published_time" content="2021-11-26T12:03:48.668Z">
<meta property="article:modified_time" content="2021-12-03T03:57:29.165Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="校招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hwh.zone/img/about-bg.jpg"><link rel="shortcut icon" href="/img/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/45493/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（一）_Java_锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:57:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">校招笔记（一）_Java_锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-26T12:03:48.668Z" title="发表于 2021-11-26 20:03:48">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:57:29.165Z" title="更新于 2021-12-03 11:57:29">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（一）_Java_锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我的校招记录：<a target="_blank" rel="noopener" href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>算法能力（“刷题”）</strong></td>
<td style="text-align:center">这部分就是耗时间多练习，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td>
<td style="text-align:center">补充练习：<a target="_blank" rel="noopener" href="https://codetop.cc/">codeTop</a></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td>
<td style="text-align:center">C++后端后续更新</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>项目&amp;实习</strong></td>
<td style="text-align:center">主要是怎么准备项目，后续更新</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="1-5-锁">1.5 锁</h2>
<h4 id="【新增】-java常用的并发工具类？">【新增】 java常用的并发工具类？</h4>
<blockquote>
<p>这篇不错：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163654320">《今天面试了吗》- 并发编程之AQS同步工具类</a></p>
</blockquote>
<p>JUC就是java.util.concurrent包，这个包俗称JUC，里面都是<strong>解决并发问题</strong>。</p>
<p>常用四大并发工具包（以下都是基于<strong>AQS</strong>实现的）：</p>
<ol>
<li>
<p><strong>CountDownLatch</strong>： CyclicBarrier描述的是“允许一组线程相互等待，直到<strong>到达某个公共屏障点</strong>，才会进行后续任务”。</p>
<p>而<strong>CountDownLatch</strong>所描述的是“在<strong>完成一组正在其他线程中</strong>执行的操作之前，它允 一个或多个线程一直等待”。</p>
<p>在API中是这样描述的：用给定的计数初始CountDownLatch。由于调用了countDown方法，所以在当前计数到达零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次（计数无法被重置。如果需要重置计数，请考虑使CyclicBarrier）。</p>
</li>
<li>
<p><strong>CyclicBarrier</strong>：CyclicBarrier是一个同步辅助类。它允许<strong>一组线程互相等待</strong>，<strong>直到到达某个公共屏障点</strong>。在涉及一组固定大小的线程的程序里，这些线程必须不时的互相等待，此时CyclicBarrier 很有用。因为CyclicBarrier在释放等待线程后可以重用，因此成为循环的屏障。</p>
<blockquote>
<p>使用**await()**方法，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。当所有线程都到达了屏障，结束阻塞，所有线程可继续执行后续逻辑。</p>
</blockquote>
</li>
<li>
<p><strong>Semaphore</strong>：信号量Semaphore是一个控制访问<strong>多个共享资源的计数器</strong>，和CountDownLatch一样，其本质上是一个“共享锁”。在API是这么介绍信号量的：一个计数信号量，从概念上讲，信号量维护了一个许可集。</p>
</li>
<li>
<p><strong>ExChanger</strong> ：Exchanger是一个同步器，字面上就可以看出这个类的主要作用是交换数据。Exchanger有点<strong>类似CyclicBarrier</strong>，前面说到CyclicBarrier是一个栅栏，到达栅栏的 线程需要等待一定数量的线程到达后，才能通过栅栏。Exchanger可以看成是一个双向的栅栏。线程1到达栅栏后，会首先观察有没有其他线程已经到达栅栏，如果没有就会等待。如果已经有其他线程（比如线程2）到达了，就会<strong>以成对的方式交换各自携带的信息</strong>，因此Exchanger非常适合<strong>两个线程</strong>之间的<strong>数据交换</strong>。</p>
</li>
</ol>
<h4 id="1-5-1-synchronized-相关">1.5.1 synchronized 相关</h4>
<h5 id="1-1-重点-说一说自己对于-synchronized-关键字的了解-synchronized-底层原理">1.1 [重点]<strong>说一说自己对于 synchronized 关键字的了解? synchronized 底层原理</strong> ?</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理(阿里面试题)</a></p>
</blockquote>
<ul>
<li>
<p><strong>基本了解</strong></p>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<ul>
<li>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是<strong>依赖于底层的操作系统的<u>Mutex Lock</u></strong> 来实现的；</li>
<li>Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，<strong>而操作系统实现线程之间的切换</strong>时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。</li>
</ul>
</li>
<li>
<p><strong>moniter介绍</strong></p>
<blockquote>
<p><strong>Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用</strong>。</p>
</blockquote>
<p>在HotSpot虚拟机中，Monitor是基于C++的<strong>ObjectMonitor类</strong>实现的，其主要成员包括：</p>
<ul>
<li>_owner：指向持有ObjectMonitor对象的线程</li>
<li>_WaitSet：存放处于wait状态的线程队列，即调用wait()方法的线程</li>
<li>EntryList：存放处于等待锁block状态的线程队列</li>
<li>_count：约为_WaitSet 和 _EntryList 的节点数之和</li>
<li>_cxq: 多个线程争抢锁，会先存入这个单向链表</li>
<li>_recursions: 记录重入次数</li>
</ul>
</li>
<li>
<p><strong>底层原理</strong></p>
<p>synchronized 关键字底层原理属于 JVM 层面。</p>
<p><strong>① synchronized同步语句块的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 JDK ⾃带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：</p>
<ul>
<li>
<p>⾸先切换到类的对应⽬录执行 javac SynchronizedDemo.java 命令⽣成编译后的 .class ⽂件，然后执行 <code>javap -c -s-v -l SynchronizedDemo.class</code></p>
</li>
<li>
<p><img src="https://i.loli.net/2021/05/16/DTSB86Z2GcRy9XC.png" alt="image-20210516130259067"></p>
</li>
</ul>
<p><strong>synchronized</strong>同步语句块的实现使用的是monitorenter和 monitorexit指令，其中<strong>monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置</strong>。</p>
<ol>
<li>
<p>当执行monitorenter 指令时，线程试图获取锁也就是获取 monitor的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1 ;</p>
<blockquote>
<p>monitor对象存在于每个Java对象的对象头中 synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p>
</blockquote>
</li>
<li>
<p>相应的在执行monitorexit 指令后，<strong>将锁计数器设为0</strong>，表明锁被释放；</p>
</li>
<li>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>
</li>
</ol>
</li>
</ul>
<p><strong>② synchronized修饰方法的的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/16/oElScfCHI978Qtw.png" alt="image-20210516131938787"></p>
<ul>
<li>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是⼀个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问。</p>
<blockquote>
<p>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象</strong>。</p>
</blockquote>
<p>两种同步方式<strong>本质上没有区别</strong>，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的<strong>互斥原语mutex</strong>来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
</li>
</ul>
<h5 id="1-2-请你谈谈关于Synchronized和ReentrantLock？">1.2 <strong>请你谈谈关于Synchronized和ReentrantLock？</strong></h5>
<ul>
<li>
<p><strong>相似点</strong></p>
<ul>
<li>
<p><strong>都是阻塞式同步</strong>：一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待；</p>
<blockquote>
<p>线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p>
</blockquote>
</li>
<li>
<p><strong>都是可重入锁</strong>：是同一个线程可重复获得锁，每获得一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
</li>
</ul>
</li>
<li>
<p><strong>不同点</strong></p>
<ul>
<li>
<p><strong>实现原理</strong>： Synchronized是java语言的关键字，是原生语法层面的互斥， JVM 层面；ReentrantLock是JDK 1.5后的API层面的互斥锁，需要<u>lock()和unlock()方法配合try/finally语句块来完成</u>；</p>
<blockquote>
<p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p>
</blockquote>
</li>
<li>
<p><strong>是否避免死锁</strong>： synchronized<strong>在发生异常时</strong>，会自动释放线程占有的锁，<strong>因此不会导致死锁现象</strong>发生；Lock不会主动适应 <code>unLock()</code> 释放，必须手动在f<code>inally</code>释放；相⽐synchronized，ReentrantLock增加了⼀些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p>
</li>
<li>
<p><u><strong>线程等待可中断</strong>：</u> Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务；而synchronized却不行，使用synchronized时，等待的线程会一直等待下去；</p>
</li>
<li>
<p><strong>公平锁</strong>： synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁；</p>
<ul>
<li><strong>选择性通知</strong>： synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。<br>
Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使⽤notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，⽤ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，<u>而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</u>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1-3-synchronized锁住的是什么，在项目中遇到了吗？">1.3 <strong>synchronized锁住的是什么，在项目中遇到了吗</strong>？</h5>
<p>synchronized本身并不是锁，锁本身是一个对象，synchronized最多相当于“加锁”操作，所以synchronized并不是锁住代码块。</p>
<p>（<strong>重点</strong>）Java中的每一个对象都可以作为锁，具体表示有三种形式：</p>
<p><img src="https://i.loli.net/2021/05/04/LzjeqdIi5rbM819.png" alt="image-20210504232344320"></p>
<blockquote>
<p>面试中面试官经常会说：“单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁方式实现单例模式的原理呗！”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton       <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">       <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance WX <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>
<p>这段代码其实是分为三步执行：</p>
<ol>
<li>
<p>为 uniqueInstance 分配内存空间</p>
</li>
<li>
<p>初始化 uniqueInstance</p>
</li>
<li>
<p>将 uniqueInstance 指向分配的内存地址</p>
</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，<u>但此时 uniqueInstance 还未被初始化</u>。</p>
<h5 id="1-4-synchronized锁的优化机制了解吗？">1.4 <strong>synchronized锁的优化机制了解吗</strong>？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903726545633287">死磕Synchronized底层实现</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术团队</a></p>
</blockquote>
<p>synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括：</p>
<ul>
<li>自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁；</li>
<li>锁的状态从低到高依次为：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</li>
</ul>
<p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p>
<p>常见的锁：</p>
<ul>
<li>
<p><strong>无锁</strong>：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，<strong>但同时只有一个线程能修改成功</strong>。</p>
<blockquote>
<p>锁到底存在哪里呢？答案就是对象头中。</p>
<p>对象头主要又包括了两部分数据：Mark Word（标记字段）、Class Point（类型指针）。</p>
</blockquote>
<ol start="0">
<li>
<p>初始mark word 将是可偏向状态，此时的 <u>是否偏向锁</u> 为 0，表示当前没有任何一个线程持有该锁。</p>
<p><img src="https://i.loli.net/2021/05/21/bNepQwU6scYXCv5.png" alt="image-20210521210754337"></p>
</li>
</ol>
</li>
<li>
<p><strong>偏向锁</strong>：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<blockquote>
<p>JDK1.6 中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁。在<strong>第一次</strong>获得锁时，会有一个 CAS 操作（见下）；<strong>之后</strong>该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的 CAS 命令。</p>
</blockquote>
<ol>
<li>
<p><strong>CASE 1 :</strong> 线程<strong>第一次</strong>获得锁，如果<strong>未偏向</strong>，通过 <strong>CAS</strong> 指令：</p>
<p><img src="https://i.loli.net/2021/05/21/fwEX4OAMFnyWrbJ.png" alt="image-20210521210949942"></p>
<ul>
<li><strong>插入线程ID :</strong> 向mark word插入线程ID</li>
<li><strong>偏向锁标识</strong>：将 mark word 中的偏向锁标识从<code>0→1</code></li>
<li><s><strong>锁标志位</strong>：不修改！因为不变！</s></li>
</ul>
<p>如果操作成功：，则说明获得了偏向锁，以后当前<u>线程等于owner</u>就可以<strong>零成本</strong>的直接获得锁；</p>
<p>如果操作失败，说明有其它线程获取了锁：</p>
<ul>
<li><strong>如果偏向线程还存在</strong>：直接进行升级为轻量级锁；</li>
<li><strong>如果偏向线程不存在：先修改锁标识为01→00</strong> ，再升级为轻量级锁。</li>
</ul>
</li>
<li>
<p><strong>CASE 2 :</strong>  这是<strong>一次可重入</strong>，偏向线程是自己。</p>
<p>在<u>当前线程栈</u>中找到一个可用的 <strong>Lock Record</strong> <strong>：并将其 obj 指向锁对象 &amp; Displaced Mark Word 置为null</strong></p>
<img src="https://i.loli.net/2021/05/18/LXj2NZi7fVOzpox.png" alt="img" style="zoom:50%;" />
</li>
</ol>
</li>
<li>
<p><strong>轻量级锁</strong>：当发现多线程竞争时，偏向锁会升级为轻量级锁，一般来说，会在 safepoint（此时用户代码不会执行）中去查看<u>偏向的线程是否还存活</u>。</p>
<p><img src="https://i.loli.net/2021/05/18/anN1S6AD7MI9gK8.jpg" alt="img"></p>
<ol>
<li>如果偏向的线程已经不存活或者不在同步块中，则将对象头的 mark word 改为无锁状态（unlocked），<strong>重新偏向新的线程</strong>；</li>
<li>如果存活且还在<strong>同步块</strong>中，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁的加锁逻辑中；</li>
</ol>
<p>轻量级锁的处理流程 ：</p>
<ol start="3">
<li>发现已经有偏向的线程了，则会<strong>先 撤 销偏向锁，然后升级为轻量锁</strong> 。通过<strong>CAS命令更新</strong>：</li>
</ol>
<p><img src="https://i.loli.net/2021/06/02/BMyh36f2OPCGkKe.png" alt="image-20210602161303534"></p>
<ul>
<li>
<p><strong>修改此前 <u>当前线程栈帧Lock Record</u>：</strong> （1）Displaced Mark Word 复制 mark word （此时<strong>无锁</strong>状态）中的现有内容</p>
</li>
<li>
<p><strong>修改mark word <strong>：<u>mark word 指向</strong>当前线程栈帧Lock Record的</strong> <strong>Displaced Mark Word</strong>的地址</u>，见上图；</p>
</li>
<li>
<p><strong>修改锁标志位</strong>： <code>01 → 00</code></p>
<p><img src="https://i.loli.net/2021/05/21/QNDEreAK6Ulohvg.png" alt="image-20210521214141329"></p>
</li>
</ul>
<ol start="4">
<li>
<p>上述CAS更新成功，则<strong>当前线程获得了对象的锁</strong>  ；</p>
<p>如果不成功：</p>
<ul>
<li>
<p>检查Mark Word是否指向当前线程的栈帧的Lock Record ，是则是一次<strong>可重入</strong></p>
<blockquote>
<p>设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用。然后结束。</p>
</blockquote>
</li>
<li>
<p>如果不是则是进行<strong>自旋等待</strong></p>
</li>
</ul>
</li>
<li>
<p>当<strong>1.自旋超过一定的次数</strong>（默认10），或者<strong>2.一个线程在持有锁，一个在自旋，又有第三个来访时</strong>，轻量级锁升级为重量级锁。</p>
</li>
</ol>
</li>
<li>
<p><strong>重量级锁</strong>：内置锁在Java中被抽象为<strong>监视器锁（monitor）</strong>。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种<strong>同步方式的成本非常高</strong>，<u>包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等</u>。</p>
<blockquote>
<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。<strong>每一个Java对象就有一把看不见的锁Monitor</strong>，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个<strong>Owner</strong>字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
</blockquote>
<p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。<u>线程去获取重量级锁，其实就是就尝试获取对象的monitor锁。</u></p>
<blockquote>
<p>即将 monitor锁的 <strong>Owner字段修改为当前线程ID</strong> 。</p>
</blockquote>
<p>如果获取成功，此时线程获得了锁，<strong>CAS修改</strong> ：</p>
<ol start="2">
<li>
<p><strong>修改mark word</strong> ：然后将对象头mark word 改为<strong>指向该 monitor 的指针</strong>。</p>
</li>
<li>
<p><strong>锁标志位</strong>：<code>00 → 10</code></p>
<p><img src="https://i.loli.net/2021/05/21/NLFv3fKIh14RlzY.png" alt="image-20210521214213205"></p>
</li>
</ol>
</li>
</ul>
<h5 id="1-5-为什么说Synchronized是非公平锁，这样的优缺点是什么？">1.5 <strong>为什么说Synchronized是非公平锁，这样的优缺点是什么</strong>？</h5>
<p>并非是按照申请锁的时间前后给等待线程分配锁的，<strong>每当锁被释放后，任何一个线程都有机会竞争到锁</strong>。</p>
<ul>
<li><strong>优点</strong>：这样做的目的是为了提高执行性能；</li>
<li><strong>缺点</strong>：是可能产生线程饥饿现象。</li>
</ul>
<h5 id="1-6-为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？">1.6 <strong>为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么</strong>？</h5>
<blockquote>
<p>没看完，了解了下核心问题：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jojop/p/14022029.html">https://www.cnblogs.com/jojop/p/14022029.html</a></p>
</blockquote>
<ul>
<li>
<p><strong>synchronized悲观锁</strong></p>
<p>Synchronized显然是一个悲观锁，因为它的并发策略是悲观的：</p>
<ul>
<li><strong>不管是否会产生竞争，任何的数据都必须加锁</strong>。</li>
</ul>
</li>
<li>
<p><strong>synchronized原理</strong></p>
<p>Synchronized是通过<strong>获取对象内部的一个叫做监视器锁（monitor</strong>）来实现的，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。</p>
<blockquote>
<p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p>
</blockquote>
<ol>
<li>
<p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</p>
</li>
<li>
<p>如果线程已经占有该monitor，<u>只是重新进入</u>，则进入monitor的进入数加1；</p>
</li>
<li>
<p>如果<u>其他线程已经占用了monitor，则该线程进入阻塞状态</u>，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ol>
</li>
<li>
<p><strong>乐观锁实现原理：CAS</strong></p>
<blockquote>
<p>参考好文：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94762520">一文彻底搞懂CAS实现原理</a></p>
</blockquote>
</li>
</ul>
<h5 id="1-7-（CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？">1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</h5>
<p>乐观锁的核心算法是CAS（Compared And Swap，比较并交换）：</p>
<ul>
<li>
<p><strong>关键逻辑</strong>： CAS，有几个重要的参数：</p>
<p>（1）<strong>this</strong>，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。</p>
<p>（2）<strong>valueOffset</strong>，value 变量的内存偏移地址。</p>
<p>（3）<strong>expect</strong>，期望更新的值。</p>
<p>（4）<strong>update</strong>，要更新的最新值。</p>
<p>如果原子变量中的 <strong>value 值等于 expect</strong>，则使用 update 值更新该值并返回 true，否则返回 false。</p>
</li>
<li>
<p><strong>CAS特性</strong>： CAS具有原子性，它的原子性由CPU硬件指令实现保证。</p>
<ul>
<li>【<strong>缺点1</strong>】<strong>ABA问题</strong>：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。
<ul>
<li><strong>解决ABA：</strong> 在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code></li>
</ul>
</li>
<li>【<strong>缺点2】只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li>
<li>【<strong>缺点3</strong>】<strong>循环时间长开销大</strong>：对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
</li>
<li>
<p><strong>CAS源码分析</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014858404?utm_source=sf-similar-article">Java CAS 原理分析</a></p>
</blockquote>
<blockquote>
<p>CAS 全称是 compare and swap，是一种用于在<strong>多线程环境下实现同步</strong>功能的机制。</p>
</blockquote>
<p>CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。</p>
<p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，下面是具体分析。</p>
<ul>
<li>
<p><strong>背景介绍</strong></p>
<p>在多核心时代下，<strong>多个核心通过同一条总线和内存以及其他硬件进行通信</strong>。</p>
<p><img src="https://segmentfault.com/img/remote/1460000014858409?w=1598&amp;h=710" alt="img"></p>
<p><strong>CPU 的多个核心同时对同一片内存进行操作</strong>，会导致错误。例如，递增指令<code>inc dword ptr [...]</code>，等价于<code>DEST = DEST + 1</code>。该指令包含三个操作<code>读-&gt;改-&gt;写</code>，涉及两次访存。</p>
<ol>
<li>核心1,2从内存读取数据<code>1</code>，并写到各自寄存器中</li>
<li>核心1将寄存器中数据<code>1→2</code></li>
<li>核心2将寄存器中数据<code>1→2</code></li>
<li>然后都写回主存，此时为<code>2</code></li>
</ol>
<p>可以看到，由于核心2在核心1<strong>写入主存操作完成前进行读取</strong>，导致并不是我们期望的<code>3</code> 。</p>
<p>通过在递增<code>inc</code> 指令前添加 lock 前缀，可以让核心独占某个内存区域，由此可以避免上面问题。lock 前缀保证核心独占某片内存区域，有两种方式：</p>
<ol>
<li><strong>总线锁</strong>。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作；</li>
<li><strong>缓存锁</strong>。若<strong>某处</strong>内存数据被缓存在处理器缓存中，处理器发出的 LOCK# 信号不会锁定总线，而是<strong>锁定缓存对应的内存区域</strong>。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。（<strong>不是乐观机制都可以操作吗？不能写入内存</strong>？）</li>
</ol>
</li>
<li>
<p><strong>源码分析</strong></p>
<blockquote>
<p>我们分析，<code>java.util.concurrent.atomic</code> 包下的原子类 <code>AtomicInteger</code> 中的 <code>compareAndSet</code> 方法 。</p>
</blockquote>
<ol>
<li>
<p>AtomicInteger具体实现中，compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 compareAndSwapInt 方法中；</p>
</li>
<li>
<p>compareAndSwapInt是一个native方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算变量 value 在类对象中的偏移</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe的compareAndSwapInt 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compareAndSwapInt 是 native 类型的方法，继续往下看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们进入unsafe.cpp（compareAndSwapInt是native方法）具体实现中，看看调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，</span></span><br><span class="line"><span class="comment"> * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset</span></span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="built_in"><span class="keyword">sizeof</span></span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载</span></span><br><span class="line"><span class="comment">   * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析 Windows 平台下的 Atomic::cmpxchg 函数为例，看看具体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic_windows_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line"><span class="meta">                       __asm je L0      \</span></span><br><span class="line"><span class="meta">                       __asm _emit 0xF0 \</span></span><br><span class="line"><span class="meta">                       __asm L0:</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是多核 CPU</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">// 将参数值放入寄存器中</span></span><br><span class="line">    mov edx, dest  <span class="comment">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中</span></span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, <span class="function">compare_value</span></span><br><span class="line"><span class="function">    <span class="title">LOCK_IF_MP</span><span class="params">(mp)</span>  <span class="comment">// 核心比较写入操作</span></span></span><br><span class="line"><span class="function">    cmpxchg dword ptr [edx], ecx</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中LOCK_IF_MP实际内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// LOCK_IF_MP</span></span><br><span class="line">    cmp mp, <span class="number">0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，</span></span><br><span class="line"><span class="comment">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令前加 lock 前缀。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    je L0</span><br><span class="line">     <span class="comment">/* 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。*/</span></span><br><span class="line">    _emit <span class="number">0xF0</span></span><br><span class="line">L0:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span></span><br><span class="line"><span class="comment">     *   cmpxchg: 即“比较并交换”指令</span></span><br><span class="line"><span class="comment">     *   dword: 全称是 double word，在 x86/x64 体系中，一个</span></span><br><span class="line"><span class="comment">     *          word = 2 byte，dword = 4 byte = 32 bit</span></span><br><span class="line"><span class="comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元</span></span><br><span class="line"><span class="comment">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。</span></span><br><span class="line"><span class="comment">     *          那么 [edx] 表示内存地址为 dest 的内存单元</span></span><br><span class="line"><span class="comment">     *        </span></span><br><span class="line"><span class="comment">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值</span></span><br><span class="line"><span class="comment">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>实际举例说明</strong></p>
<p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p>
<blockquote>
<p>下面以 getAndIncrement实现来说明。</p>
</blockquote>
<ol>
<li>
<p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量，用来计算得到value值（3）要加上的值，由于是递增所以是1</p>
<blockquote>
<p>⚠️ <strong>为什么不传value的值，而是偏移量</strong>？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p>
</blockquote>
</li>
<li>
<p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p>
<ul>
<li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li>
</ul>
</li>
<li>
<p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p>
<p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p>
<p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p>
<p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p>
<p>（4）否则写入失败，通过不断自旋（循环）期望得到执行</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="1-8-请说明一下synchronized的-u-可重入-u-怎么实现？">1.8 <strong>请说明一下synchronized的<u>可重入</u>怎么实现</strong>？</h5>
<p>每个锁关联一个线程持有者对象和一个计数器。</p>
<ol>
<li>当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁（即monitor对象）而调用相应方法。</li>
<li>当一个线程请求成功后，JVM对象头会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。</li>
<li>而该持有锁的线程如果<strong>再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增</strong>。</li>
<li>当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</li>
</ol>
<h5 id="1-9-在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？">1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</h5>
<p>第一次调用Hashcode：当<u>对象的hashCode()方法</u>（非用户自定义）第一次被调用时，JVM会生成对应的<strong>identity hash code</strong>值，并将该值<u>存储到Mark Word</u>中 。</p>
<blockquote>
<p>后续如果该对象的hashCode()方法再次被调用则不会再通过JVM进行计算得到，<strong>而是直接从Mark Word中获取，保证唯一相同</strong>。</p>
</blockquote>
<ul>
<li><strong>无锁状态</strong>：在无锁状态下，Mark Word中可以存储对象的identity hash code值 ；</li>
<li><strong>偏向锁状态</strong>：需要计算其identity hash code的话，则它的偏向锁会被撤销（因为没有保存的位置），并且锁会膨胀为轻量级锁或者重量锁 ；</li>
<li><strong>轻量锁状态</strong>：<u>线程栈帧</u>的Lock Recode可以记录存储Displaced Mark Word ，所以轻量级锁可以和identity hash code <strong>共存</strong> ；</li>
<li><strong>重量级锁状态</strong>：<u>ObjectMonitor</u>类里有字段HashCode<strong>可以记录</strong>非加锁状态<strong>下的mark word，所以重量级锁也可以和identity hash code共存</strong>；</li>
</ul>
<h5 id="1-10-Synchronized-确定不可中断吗？如果一个线程访问Synchronized-代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？">1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/deel_feel/article/details/105771902">https://blog.csdn.net/deel_feel/article/details/105771902</a></p>
</blockquote>
<p>正确说法时：<strong>只有获取到锁之后才能中断，等待锁时不可中断</strong>。</p>
<h4 id="1-5-2-Reetrantlock-相关">1.5.2 Reetrantlock 相关</h4>
<p>ReentrantLock意思为可重入锁 。</p>
<h5 id="2-1-非公平锁和公平锁在reetrantlock里的实现过程是怎样的？">2.1 <strong>非公平锁和公平锁在reetrantlock里的实现过程是怎样的</strong>？</h5>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">美团技术文章-java-lock</a></p>
</blockquote>
<ul>
<li>
<p>公平锁：那么锁的 <u>获取顺序</u> 就应该符合请求的 <u>绝对时间顺序</u>，FIFO</p>
</li>
<li>
<p>非公平锁：只要<strong>CAS</strong>设置同步状态成功state，则表示当前线程获取了锁</p>
<blockquote>
<p>但公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待。</p>
</blockquote>
</li>
</ul>
<p>【<strong>源码分析</strong>】</p>
<ul>
<li>
<p><strong>基本结构</strong></p>
<p>根据代码可知，ReentrantLock里面有一个内部类<strong>Sync</strong>，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。</p>
<ul>
<li>Sync有公平锁FairSync和非公平锁NonfairSync两个子类；</li>
<li>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</li>
</ul>
<p><img src="https://i.loli.net/2021/05/21/YDAreyBEImxQfj2.png" alt="img"></p>
</li>
<li>
<p><strong>公平和非公平锁区分</strong></p>
<p><img src="https://i.loli.net/2021/05/21/zsPnT7qrXN5ovKZ.png" alt="img"></p>
<p>公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在<strong>CAS获取同步状态时</strong>，多了一个限制条件：<strong>hasQueuedPredecessors()</strong>。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"></p>
<ul>
<li><strong>该方法主要做一件事情</strong>：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</li>
</ul>
</li>
</ul>
<h5 id="2-2-ReentrantLock的实现原理？">2.2 ReentrantLock的实现原理？</h5>
<p>ReentrantLock的实现基于队列同步（AbstractQueuedSynchronizer，后面简称AQS）。关于AQS的实现原理见下。</p>
<p>ReentrantLock的核心，是通过修改AQS中state的值来同步锁的状态。</p>
<h5 id="2-3-希望等待一段时间锁没有获取，可以自动放弃用哪种锁？">2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</h5>
<p>Lock（ReentranLock）</p>
<p>但是基于AQS的源码哪里体现了？ 应该Lock锁的代码里自己的实现吧。</p>
<h4 id="1-5-3-AQS-相关">1.5.3 AQS 相关</h4>
<h5 id="3-1-什么是AQS请你简单介绍一下？">3.1 什么是AQS请你简单介绍一下？</h5>
<p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p>
<p><img src="https://i.loli.net/2021/05/16/QhJg8pnTv3zWj4w.png" alt="image-20210516144436982"></p>
<p><strong>AQS是⼀个用来构建锁和同步器的框架</strong>，使⽤AQS能简单且高效地构造出应用⼴泛的大量的同步器。</p>
<ul>
<li>例如：ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS非常轻松容易地构造出符合我们⾃⼰需求的同步器。</li>
</ul>
<h5 id="3-2-请介绍一下AQS原理？">3.2 请介绍一下AQS原理？</h5>
<blockquote>
<p>后续建议研读：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p>
</blockquote>
<p>先带着问题来进行看下面内容：</p>
<blockquote>
<p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是CLH变体的FIFO双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：可以详细看下2.3.1.3小节。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p>
<p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>
</blockquote>
<ul>
<li>
<p><strong>核心原理概览</strong></p>
<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，<u>这个机制AQS是⽤CLH队列锁实现的</u>，即将暂时获取不到锁的线程加⼊到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是⼀个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/16/XqshLCnMYKbB7Ip.png" alt="image-20210516145134124"></p>
<p>AQS使用⼀个int成员变量<code>state</code>来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。<strong>AQS使⽤CAS对该同步状态进行原子操作实现对其值的修改</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使⽤volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作 。</p>
<img src="https://i.loli.net/2021/05/28/g7GORpXKhuo8aS4.png" alt="image-20210526122910138" style="zoom:67%;" />
</li>
<li>
<p><strong>AQS 对资源的共享方式</strong><br>
AQS定义两种资源共享方式，可以通过修改state字段来实现多线程的独占（经典如ReentranLock）和共享模式。</p>
<p><img src="https://i.loli.net/2021/05/26/YdcSGMs5jgiFnmk.png" alt="img"></p>
<ul>
<li><strong>Exclusive（独占）</strong>：只有⼀个线程能执行，如ReentrantLock。⼜可分为公平锁和非公平锁：
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share（共享）</strong>：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>
</ul>
</li>
<li>
<p><strong>AQS详细原理</strong></p>
<blockquote>
<p>最终参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/90851418">从源码角度彻底理解ReentrantLock(重入锁)</a></p>
</blockquote>
<blockquote>
<p>以下是基于ReentractLock语境下进行分析。</p>
</blockquote>
<ul>
<li>
<p><strong>加锁过程：非公平锁</strong></p>
<blockquote>
<p>简单来说：<strong>新建线程→CAS尝试快速获取锁→tryAcquire()CAS修改state→addWaiter() 获取失败CAS尝试插入队尾入队→acquireQueued等待前驱线程唤醒继续CAS获取锁</strong></p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-28c16752466cd95dfe0504f0306d6352_720w.jpg" alt="img"></p>
<p>加锁流程从<code>lock.lock()</code>开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入该源码,正确找到sycn的实现类后可以看到真正有内容的入口方法：</p>
</li>
</ul>
<ol>
<li><strong>CAS尝试快速加锁</strong>，在ReentranLock只有state=0，才能更新成功（因为是非多线程共享资源）</li>
<li>获取锁失败执行acquire方法</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 加锁流程真正意义上的入口</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以cas方式尝试将AQS中的state从0更新为1</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          acquire(<span class="number">1</span>);<span class="comment">//获取锁失败则执行该方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>acquire</code> 在主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter() 和 acquireQueued() 。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>acquire流程1：tryAcquire()</strong></p>
<p>tryAcquire()在公平和非公平下获取的方式不一样，这里<strong>只说非公平</strong>实现。</p>
<ol>
<li>
<p>如果<strong>state==0（未被其它线程持有）</strong>，<strong>CAS</strong>尝试获取锁,</p>
</li>
<li>
<p>如果当前线程==持有锁的线程，<strong>可重入</strong> ，<strong>state+1</strong></p>
<ol start="3">
<li>
<p>否则 reture false获取锁失败，加入等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程实例</span></span><br><span class="line">     <span class="keyword">int</span> c = getState();<span class="comment">//获取state变量的值,即当前锁被重入的次数</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">//state为0,说明当前锁未被任何线程持有</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//以cas方式获取锁</span></span><br><span class="line">             setExclusiveOwnerThread(current);  <span class="comment">//将当前线程标记为持有锁的线程</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获取锁成功,非重入</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//当前线程就是持有锁的线程,说明该锁被重入了</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//计算state变量要更新的值</span></span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);<span class="comment">//非同步方式更新state值</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//获取锁成功,重入</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//走到这里说明尝试获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>acquire流程2：addWaiter()</strong></p>
<p>主要逻辑如下：</p>
<ol>
<li>首先通过new Node()创建一个空结点；</li>
<li>如果队列不空**，以<strong>CAS</strong>方式让新节点插入到队尾;</li>
<li>如果队列为空，执行<code>enq(node)</code> 逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null</span></span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);<span class="comment">//入队的逻辑这里都有</span></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               Node t = tail;<span class="comment">//t指向当前队列的最后一个节点,队列为空则为null</span></span><br><span class="line">               <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize  //队列为空</span></span><br><span class="line">                   <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">//构造新结点,CAS方式设置为队列首元素,当head==null时更新成功</span></span><br><span class="line">                       tail = head;<span class="comment">//尾指针指向首结点</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;  <span class="comment">//队列不为空</span></span><br><span class="line">                   node.prev = t;</span><br><span class="line">                   <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">//CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功</span></span><br><span class="line">                       t.next = node;    <span class="comment">//原尾结点的next指针指向当前结点</span></span><br><span class="line">                       <span class="keyword">return</span> t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>acquire流程3：acquireQueued()</strong></p>
<blockquote>
<p><strong>线程加入同步队列后，获取锁的流程是什么呢</strong>？</p>
<p>简单来说，就是不断判断当前是否是老二，并尝试去获取锁。</p>
</blockquote>
<img src="https://pic4.zhimg.com/v2-f83b087a039a8de3f9815d9018e2273f_b.jpg" alt="img" style="zoom:80%;" />
<ul>
<li><code>SIGNAL ：</code>意味着线程释放锁后会唤醒后面阻塞的线程。毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//死循环,正常情况下线程只有获得锁才能跳出循环</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获得当前线程所在结点的前驱结点</span></span><br><span class="line">              <span class="comment">//第一个if分句</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                  setHead(node); <span class="comment">//将当前结点设置为队列头结点</span></span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;<span class="comment">//正常情况下死循环唯一的出口</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//第二个if分句</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">//判断是否要阻塞当前线程</span></span><br><span class="line">                  parkAndCheckInterrupt())      <span class="comment">//阻塞当前线程</span></span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p><strong>解锁：非公平锁</strong></p>
<img src="https://i.loli.net/2021/05/26/sSQZlA2paTcNKXi.png" alt="image-20210526170709280" style="zoom:67%;" />
</li>
<li>
<p><strong>加锁：公平锁</strong></p>
<blockquote>
<p>简单来说：<strong>新来线程→【必须】先CAS加入等待队列→等待前驱节点释放锁（state=0），如果是老二则获取锁</strong>。</p>
</blockquote>
<p>公平锁加锁入口加锁从：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally void lock() &#123;</span><br><span class="line">    acqiuire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前非公平锁的逻辑中，线程有三次机会获取锁：</p>
<ol>
<li><strong>新创建时</strong>，CAS尝试修改state=1，去获取</li>
<li><strong>可重入</strong>，当前获取锁线程为自己</li>
<li><strong>前驱节点释放锁</strong>，自己作为老二被唤醒</li>
</ol>
<p>而<strong>公平锁</strong>，只能按加入队列的<u>先后次序 &amp; 可重入</u>获得锁 ：</p>
<ol>
<li>
<p>所有线程在获取锁前<strong>必须先加入同步队列</strong></p>
</li>
<li>
<p>如果state=0，<code>hasQueuedPredecessors</code>判断当前是头节点，则获取锁</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/05/26/wZSLYOP4bTGEqRJ.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h5 id="3-3-为什么基于FIFO的同步队列可以实现非公平锁？">3.3 为什么基于FIFO的同步队列可以实现非公平锁？</h5>
<p>因为非公平锁，除了等<strong>前驱节点唤醒去获取锁</strong> ，还有以下三种方式获取锁：</p>
<ol>
<li>
<p><strong>新创建时</strong>，CAS尝试修改state=1，去获取</p>
<blockquote>
<p>公平锁：进来先执行<code>hasQueuedPredecessors()</code> , 看等待队列是否有有效节点，有的话不能获取锁！</p>
</blockquote>
</li>
<li>
<p><strong>可重入</strong>，当前获取锁线程为自己</p>
<blockquote>
<p>公平锁：也可以</p>
</blockquote>
</li>
<li>
<p><strong>同步队列等待</strong>，等待唤醒获取锁</p>
<blockquote>
<p>公平锁：也可以</p>
</blockquote>
</li>
</ol>
<p>并且在锁释放时：是<strong>先释放锁（修改state=-1），再去唤醒后继节点</strong></p>
<ol>
<li>会导致新来的线程，可能在<strong>后继节点被唤醒前</strong>就获取了锁，这就不会公平</li>
</ol>
<h5 id="3-4-【易忘】为什么非公平锁性能好？">3.4 【易忘】为什么非公平锁性能好？</h5>
<ol>
<li>.线程不必加入等待队列就可以获得锁,不仅<strong>免去了构造结点并加入队列的繁琐操作</strong> ，<strong>节省了线程阻塞、唤醒</strong>的开销（这涉及到上下文的切换）；</li>
<li><strong>减少CAS竞争</strong>。如果<strong>线程必须要加入阻塞队列才能获取锁</strong>,那<strong>0</strong>将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视</li>
</ol>
<h5 id="3-4-AQS-有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景-？">3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</h5>
<p><img src="https://i.loli.net/2021/05/26/OWhD4Hu3GkBP2vc.png" alt="image-20210526215800096"></p>
<ul>
<li>
<p><strong>Semaphore(信号量)：<strong>Semaphore(信号量)可以指定</strong>多个</strong>线程<strong>同时</strong>访问某个资源； <strong>synchronized 和 ReentrantLock</strong> 都是⼀次只允许<strong>⼀个</strong>线程访问<strong>同时</strong>某个资源。</p>
<blockquote>
<p>计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号标S的数值，P操作会减少它。</p>
<p>运行P（wait()），信号标S的值将被减少。企图进入临界区段的进程，需要先运行P（wait()）。当信号标<strong>S减为负值</strong>时，进程会被挡住，不能继续；当<strong>信号标S不为负值</strong>时，进程可以获准进入临界区段。</p>
</blockquote>
</li>
<li>
<p><strong>CountDownLatch （倒计时器）</strong>： CountDownLatch是⼀个同步⼯具类，用来协调多个线程之间的同步。这个⼯具通常用来控制线程等待，<u>它可以让<strong>某⼀个线程等待直到倒计时结束</strong></u>，再开始执行。</p>
</li>
<li>
<p><strong>CyclicBarrier(循环栅栏)</strong>： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能⽐ CountDownLatch 更加复杂和强大。主要应用场景和CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让⼀组线程到达⼀个屏障（也可以叫同步点）时被阻塞，直到最后⼀个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续⼲活。</p>
<blockquote>
<p>CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调⽤**await()**方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>
</blockquote>
</li>
</ul>
<p><strong>CountDownLatch的应用场景</strong></p>
<p>我们要读取处理<strong>6</strong>个⽂件，这6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这6个⽂件的处理的结果进行统计整理。</p>
<p>为此我们定义了⼀个线程池和<strong>count为6的 CountDownLatch 对象</strong> 。使用线程池处理读取任务，每⼀个线程处理完之后就将count-1，调用 CountDownLatch 对象的 await() 方法，直到所有⽂件读取完之后，才会接着执行后面的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理⽂件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建⼀个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">     ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">     <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span></span><br><span class="line">CountDownLatch(threadCount);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">         threadPool.execute(() → &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理⽂件的业务操作</span></span><br><span class="line">                ......</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示⼀个⽂件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       threadPool.shutdown();</span><br><span class="line">       System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-4-Volatile-关键字">1.5.4 Volatile 关键字</h4>
<h5 id="4-0-JMM-是什么-？-缓存一致性协议MESI-CPU内存屏障？JAVA内存屏障？">4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06717ac8312c">并发编程-（4）-JMM基础（总线锁、缓存锁、MESI缓存一致性协议、CPU 层面的内存屏障）</a></p>
</blockquote>
<ul>
<li>
<p><strong>JMM定义</strong></p>
<p>全称Java Memory Model（java内存模型）是一系列的Java虚拟机平台对开发者提供的多线程环境下的内存可见性、是否可以重排序等问题的无关具体平台的统一的保证。</p>
</li>
<li>
<p><strong>MESI 缓存一致性协议协议</strong></p>
<ul>
<li>
<p><strong>缓存不一致问题</strong></p>
<p>CPU处理速度，远大于I/O设备（磁盘），为了解决了处理器与内存的速度矛盾，引入了<strong>高速缓存</strong>。但是由此也带来了缓存不一致的问题。</p>
<ul>
<li><strong>每个线程都会缓存内存的数据在各自寄存器中</strong>，在<strong>不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样</strong>就会存在缓存不一致的问题。</li>
</ul>
</li>
<li>
<p><strong>MESI协议内容</strong></p>
<p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，<strong>最常见的就是 MESI 协议</strong>：<br>
MESI 表示缓存行的四种状态，分别是：</p>
<blockquote>
<p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的 读写操作，而且<strong>也监听(snoop)其它 Cache 的读写操作</strong>。</p>
</blockquote>
<ul>
<li><strong>M(Modify)</strong> 表示共享<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中， 并且是被修改状态，也就是缓存的数据和主内存中的<strong>数据不一致</strong>。</li>
<li><strong>E(Exclusive)</strong> 表示缓存的独占状态，<strong>数据</strong>只缓存在<strong>当前 CPU 缓存</strong>中，并且<strong>没有被修改</strong>。</li>
<li><strong>S(Shared)</strong> 表示<strong>数据</strong>可能被<strong>多个 CPU 缓存</strong>，并且各个缓存中的<strong>数据和主内存数据一致</strong>。</li>
<li><strong>I(Invalid)</strong> 表示缓存已经<strong>失效</strong>。</li>
</ul>
<p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：</p>
<p><img src="https://i.loli.net/2021/06/11/YbfKoySNDMX5swn.png" alt="image-20210611200929872"></p>
<ul>
<li><strong>CPU 读请求</strong>：缓存处于 M、E、S 状态都可以被读取，I 状 态 CPU 只能从主存中读取数据；</li>
<li><strong>CPU 写请求</strong>：缓存处于 M、E 状态才可以被写。对于 S 状 态的写，需要将<strong>其他 CPU 中缓存行置为无效</strong>才可写。</li>
</ul>
</li>
<li>
<p><strong>Store Bufferes（存储缓存）</strong></p>
<blockquote>
<p>CPU 缓存行的状态是通过消息传递来进行的，如果 CPU0 要对一个在缓存中<strong>共享的变量</strong>进行<strong>写入</strong>，首先发送一个失效的消息给到其他缓存了该数据的 CPU。并且要<strong>等到他们的确认回执</strong>。CPU0 在这段时间内都会处于<strong>阻塞状态</strong>。</p>
</blockquote>
<p>为了避免阻塞带来的资源浪费。在 cpu 中引入 了 Store Bufferes（存储缓存） 和 Invalidate Queue（无效队列）。</p>
<ul>
<li>CPU0 写入共享数据时，<strong>直接把数据写入到 store bufferes 中，同时发送 invalidate 消息，然后继续去处理其他指令</strong>；</li>
<li>收到其他所有 CPU 发送了 invalidate ACK消息时，<strong>再将 store bufferes 中的数据数据存储至 cache 中</strong>；</li>
<li>最后再从<strong>本地Cache同步到主内存</strong>。</li>
</ul>
</li>
<li>
<p><strong>CPU层面内存屏障</strong></p>
<blockquote>
<p>内存屏障就是<strong>将 Store Bufferes 中的指令写入到内存</strong>，从而使得其他访问同一共享内存的线程的可见性。</p>
</blockquote>
<p>硬件层的内存屏障分为两种：<strong>Load Barrier （读屏障</strong>）和 <strong>Store Barrier（写屏障）及 Full Barrier（全屏障</strong>）是读屏障和写屏障的合集。</p>
<ul>
<li><strong>写屏障</strong>：强制<strong>把写缓冲区/高速缓存</strong>中的脏数据等<strong>写回主内存</strong></li>
<li><strong>读屏障</strong>：将缓冲区/高速缓存中相应的<strong>数据失效</strong>。</li>
</ul>
</li>
<li>
<p><strong>JAVA 内存屏障</strong></p>
<p>java的内存屏障通常所谓的四种，<strong>LoadLoad（LL）, StoreStore（SS）, LoadStore（LS）, StoreLoad（SL</strong>)实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li><strong>LoadLoad（LL）屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreStore（SS）屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><strong>LoadStore（LS）屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreLoad（SL）屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-什么是HappenBefore原则？">4.1 什么是HappenBefore原则？</h5>
<p>在 JMM 中，<strong>如果一个操作执行的结果需要对另一个操作【可见】，那么这两个操作必须要存在 happens-before 关系</strong>。这两个操作可以是同一个线程，也可以是不同的线程。</p>
<p><strong>它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</strong> 。</p>
<ul>
<li>
<p><strong>HappenBefore原则</strong></p>
<ul>
<li>
<p><strong>as-if-serial 规则（程序顺序执行）</strong>：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。</p>
</li>
<li>
<p><strong>volatile 变量规则</strong>，对于 volatile 修饰的变量的<strong>写操作</strong>， 一定 happen-before 后续对于 volatile 变量的<strong>读操作</strong>;</p>
</li>
<li>
<p><strong>监视器锁规则（monitor lock rule）</strong>：对一个监视器的解锁，happens-before于随后对这个监视器的加锁。</p>
</li>
<li>
<p><strong>传递性规则</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
</li>
<li>
<p><strong>start 规则</strong>：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作。</p>
</li>
<li>
<p><strong>join 规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。</p>
</li>
</ul>
</li>
<li>
<p><strong>举例说明：什么是指令重排序</strong>？</p>
<p>请看下面代码：</p>
<blockquote>
<p><strong>假设</strong> 线程A执行writer()方法之<strong>后</strong>，线程B执行reader()方法，那么线程B执行4的时候一定能看到线程A写入的值吗？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;           <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;     <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;       <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;    <span class="comment">//4</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是<strong>肯定的</strong>。因为根据happens-before规则，我们可以得到如下关系：</p>
<ol>
<li>根据<strong>程序顺序规则</strong>，1 happens-before 2；3 happens-before 4</li>
<li>根据<strong>volatile规则</strong>，2 happens-before 3；</li>
<li>根据<strong>传递性规则</strong>，1 happens-before 4 。</li>
</ol>
<p>因此，综合运用<strong>程序顺序规则、volatile规则及传递性规则</strong>，我们可以得到1 happens-before 4，即线程B在执行4的时候一定能看到A写入的值。</p>
</li>
</ul>
<h5 id="4-2-Volatile-关键字原理">4.2 Volatile 关键字原理</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5428507.html">https://www.cnblogs.com/paddix/p/5428507.html</a> 。</p>
</blockquote>
<p>此题考察的是<code>volatile</code>这个关键字。可以从<code>volatile</code>的作用和<code>volatile</code>的原理这三个方面来进行回答。<strong>volatile只能保证变量的可见性、有序性，但是不能保证原子性</strong>。</p>
<ul>
<li><strong>可见性实现原理</strong></li>
</ul>
<blockquote>
<p>为了实现<strong>volatile可见性</strong>和<strong>happen-befor</strong>的语义。JVM底层是通过一个叫做“<strong>内存屏障（基于MESI）</strong>”的东西来完成（也实现了<strong>有序性</strong> ？）。</p>
</blockquote>
<p><strong>线程本身并不直接与主内存进行数据的交互</strong>，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。</p>
<p>使用<strong>MESI</strong> 协议，使得<strong>任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值</strong>。</p>
<blockquote>
<p>最终目标：保证了<strong>缓存的一致性</strong>。</p>
<p>具体的话，下面是用<strong>内存屏障</strong>来实现的。</p>
</blockquote>
<ol>
<li>修改本地工作内存，强制刷回主内存；</li>
</ol>
<p><img src="https://i.loli.net/2021/06/11/JTFaYRu13pfQg9d.png" alt="image-20210611204633903"></p>
<ol start="2">
<li>
<p>强制让其他线程的工作内存失效过期；</p>
<p><img src="https://i.loli.net/2021/06/11/2kphvOoJu4K65Hb.png" alt="image-20210611204715422"></p>
</li>
<li>
<p>其他线程重新从主内存加载最新值；</p>
<p><img src="https://i.loli.net/2021/06/11/rvo58ueDB6CPyMa.png" alt="image-20210611204743839"></p>
</li>
</ol>
<ul>
<li>
<p><strong>有序性实现原理</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42764468/article/details/106898608">https://blog.csdn.net/qq_42764468/article/details/106898608</a></p>
</blockquote>
<p>从源代码到最终执行的指令，可能会经过三种重排序：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2845835-8fc217f556cd34f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p>
</li>
<li>
<p><strong>【指令】重排序</strong>，<strong>JMM</strong> 会要求编译器生成指令时，会<strong>插入内存屏障</strong>来禁止处理器重排序。</p>
</li>
</ul>
<blockquote>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止：①特定类型的编译器重排序和②处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
<ul>
<li>
<p><strong>编译器重排序</strong>，<strong>JMM</strong> <strong>禁止了特定类型的编译器</strong>重排序（不是所有的编译器重排序都要禁止）。</p>
</li>
<li>
<p><strong>内存重排序</strong>：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序</p>
</li>
</ul>
<p>JVM 是<strong>使用内存屏障来禁止【指令】重排，从而达到：可见性 + 部分有序性</strong>效果。</p>
<blockquote>
<p><strong>lock前缀指令实际相当于一个内存屏障</strong>？ 下面不是可见性吗？？？</p>
</blockquote>
<p>对volatile变量的<strong>写</strong>操作与普通变量的主要区别有两点：</p>
<ol>
<li>
<p>修改volatile变量<strong>前</strong>，<strong>会强制将修改后的值刷新的主内存中</strong>。</p>
<blockquote>
<p>每个volatile写操作前插入<strong>StoreStore（SS）屏障</strong></p>
</blockquote>
</li>
<li>
<p>修改volatile变量<strong>后</strong>，<strong>会导致其他线程工作内存中对应的变量值失效</strong>，因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p>
<blockquote>
<p>在写操作后插入StoreLoad屏障；</p>
</blockquote>
</li>
</ol>
<p>对volatile变量的<strong>读</strong>操作类似：</p>
<ol>
<li>
<p>在每个volatile读操作前插入<strong>LoadLoad（LL）屏障</strong>；</p>
<blockquote>
<p>确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。</p>
</blockquote>
</li>
<li>
<p>在读操作后插入<strong>LoadStore（LS屏障</strong>）。</p>
<blockquote>
<p>确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。</p>
</blockquote>
</li>
</ol>
<h5 id="4-3-volatile为什么不能保证原子性？">4.3 volatile为什么不能保证原子性？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/simpleDi/p/11517150.html">为什么volatile能保证有序性不能保证原子性</a></p>
</blockquote>
<p>对于i++这种复合操作，即使使用volatile关键字修饰也不能保证操作的原子性，可能会引发数据不一致问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>
<p>上述<code>i++</code>操作，其实分为三个操作：</p>
<ol>
<li>
<p>线程读取i</p>
</li>
<li>
<p>temp = i + 1</p>
</li>
<li>
<p>i = temp</p>
</li>
</ol>
<p>A,B两个线程多线程操作时：</p>
<ol>
<li>
<p>A线程读取i并执行了 temp = i + 1的操作， 此时的 i（0） 的值还没有变化</p>
</li>
<li>
<p>此时B也读入i并执行temp = i + 1操作，此时i（0）也没变化</p>
<blockquote>
<p>⚠️ 虽然有MESI协议，但是<code>temp</code>不保存变量<code>i</code>所在内存区域，<strong>是cpu内部的计算</strong>，不会被立马刷新内存！</p>
</blockquote>
</li>
<li>
<p>当A写入i = temp（1）时，由于可见性立马在主存被刷新了值 i=1</p>
</li>
<li>
<p>当B也写入i = temp时，<strong>此时A依旧是1，而不是2</strong></p>
</li>
</ol>
<h5 id="4-4-并发编程的三个重要特性-？">4.4 <strong>并发编程的三个重要特性</strong> ？</h5>
<ol>
<li><strong>原子性 :</strong> ⼀个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的⼲扰而中断，<strong>要么所有的操作都执行，要么都不执行</strong>。 <code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性 <strong>：当</strong>⼀个变量对共享变量进行了修改，那么另外的线程都是⽴即可以看到修改后的最新值</strong>。 volatile 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性</strong>：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。 <code>volatile</code> 关键字可以禁⽌指令进行重排序优化。</li>
</ol>
<h5 id="4-5-说说-synchronized-关键字和-volatile-关键字的区别？">4.5 <strong>说说</strong> synchronized <strong>关键字和</strong> volatile <strong>关键字的区别</strong>？</h5>
<p>synchronized关键字和volatile关键字比较：</p>
<ul>
<li>
<p><strong>volatile关键字是线程同步的轻量级实现</strong>，所以volatile性能肯定⽐synchronized关键字要好。</p>
</li>
<li>
<p><strong>volatile关键字只能用于变量</strong>，而synchronized关键字可以修饰方法以及代码块。</p>
<blockquote>
<p>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引⼊的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用<br>
synchronized 关键字的场景还是更多⼀些。</p>
</blockquote>
</li>
<li>
<p><strong>volatile关键字只能保证数据的可见性</strong>，但不能保证数据的原子性。synchronized关键字两者都能保证。</p>
</li>
<li>
<p><strong>多线程访问volatile关键字不会发生阻塞</strong>，而synchronized关键字可能会发⽣阻塞</p>
</li>
</ul>
<h4 id="1-5-5-Atomic-原子类">1.5.5 Atomic 原子类</h4>
<h5 id="5-1-什么是Atomic-原子类？">5.1 什么是Atomic 原子类？</h5>
<p>所以，所谓原子类说简单点就是<strong>具有原子/原子操作特征的类</strong>。</p>
<blockquote>
<p>在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执行的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。</p>
</blockquote>
<h5 id="5-2-JUC-包中的原子类是哪4类">5.2 JUC <strong>包中的原子类是哪</strong>4<strong>类</strong>?</h5>
<p><img src="https://i.loli.net/2021/05/16/vS4DHpKCN9bjnTF.png" alt="image-20210516152124223"></p>
<h5 id="5-3-Volatile-和-atomic-变量区别？">5.3 Volatile 和  atomic  变量区别？</h5>
<ul>
<li>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</li>
<li>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h5 id="5-4-讲讲-AtomicInteger-的使用-？">5.4 讲讲 AtomicInteger 的使用 ？</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并⾃增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并⾃减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输⼊的数值等于预期值，则以原子方式将该值设置为输⼊值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet设置之后可能导致其他线程在之后的⼀小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 基本类型也要是原子类</span></span><br><span class="line">       <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="comment">//使⽤AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-5（重点提问）-AtomicInteger-原理？">5.5（重点提问） AtomicInteger 原理？</h5>
<p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 和 <strong>native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>我们以自增方法为例： <code>getAndIncrement</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，本质是在调用 unsafe中的 <code>getAndAddInt</code></p>
<blockquote>
<p>unsafe中的compareAndSwapInt方法参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSwapInt(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x);  <span class="comment">// x是准备更新的值</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="comment">// getIntVolatile方法获取到期望值value后去调用compareAndSwapInt方法，失败则进行重试</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5是计算得到的期望值，获取此时内存的最新值（因为value是votilate修饰，修改总是被能及时看到）</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.<span class="built_in">getIntVolatile</span>(var1, var2);</span><br><span class="line">    <span class="comment">// 计算传入compareAndSwapInt的四个参数</span></span><br><span class="line">    <span class="comment">// var1：传入的this对象；var2：value内存偏移值；var5：期望值，希望和【var2】一致； var5+var4：var5+var4（1），递增</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.<span class="built_in">compareAndSwapInt</span>(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终总结如下</strong></p>
<p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile</strong> 来保证原子操作。AtomicInteger 的主要方法都是通过调用Unsafe类方法去实现，如 compareAndSet 实际是调用AtomicInteger 的compareAndSwapInt方法。</p>
<p>下面以 getAndIncrement实现来说明。</p>
<ol>
<li>
<p>getAndIncrement调用了 Unsafe的getAndAddInt方法，传递了（1）当前this对象，（2）value偏移量valueoffset，用来计算得到value值（3）要加上的值，由于是递增所以是1</p>
<blockquote>
<p>⚠️ <strong>为什么不传value的值，而是偏移量</strong>？ 传偏移量是为了计算value所在的内存地址，进而获取最新的value值。</p>
</blockquote>
</li>
<li>
<p>getAndAddInt采用CAS方式进行更新，还需要进行当前期望值的计算</p>
<ul>
<li>通过<code>getIntVolatile</code>获取到<strong>线程此时内存value值</strong>（期望值），也就是记录<strong>执行CAS前</strong>的内存最新value值；</li>
</ul>
</li>
<li>
<p>然后开始执行Unsafe的 <code>compareAndSwapInt</code> ，主要是通过<code>Atomic::cmpxchg</code> 逻辑来实现</p>
<p>（1）将要dest（value内存地址），compareValue（期望值），exchange_value（要更新的值）写入寄存器中</p>
<p>（2）线程如果是运行多核CPU，上<strong>LOCK#锁，将dest内存区域锁住</strong> ；否则不上LOCK#锁</p>
<p>（3）执行cmpxchg（比较并交换命令），如果dest的value值（<strong>执行CAS中</strong>的最新value值） == compareValue，则写入exchange_value ；</p>
<p>（4）否则写入失败，通过不断<strong>自旋（循环</strong>）期望得到执行</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/45493/">https://hwh.zone/p/45493/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a></div><div class="post_share"><div class="social-share" data-image="/img/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/8959/"><img class="prev-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">校招笔记（一）_Java_多线程</div></div></a></div><div class="next-post pull-right"><a href="/p/42516/"><img class="next-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（一）_Java_JVM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/51787/" title="校招笔记（一）_Java_Java入门"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_Java入门</div></div></a></div><div><a href="/p/42516/" title="校招笔记（一）_Java_JVM"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_JVM</div></div></a></div><div><a href="/p/8959/" title="校招笔记（一）_Java_多线程"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_多线程</div></div></a></div><div><a href="/p/7257/" title="校招笔记（一）_Java_面对对象"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_面对对象</div></div></a></div><div><a href="/p/21069/" title="校招笔记（一）_Java_集合"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_集合</div></div></a></div><div><a href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（七）_计算机基础_数据结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E9%94%81"><span class="toc-text">1.5 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E6%96%B0%E5%A2%9E%E3%80%91-java%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F"><span class="toc-text">【新增】 java常用的并发工具类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-synchronized-%E7%9B%B8%E5%85%B3"><span class="toc-text">1.5.1 synchronized 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E9%87%8D%E7%82%B9-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3-synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 [重点]说一说自己对于 synchronized 关键字的了解? synchronized 底层原理 ?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8ESynchronized%E5%92%8CReentrantLock%EF%BC%9F"><span class="toc-text">1.2 请你谈谈关于Synchronized和ReentrantLock？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-synchronized%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-text">1.3 synchronized锁住的是什么，在项目中遇到了吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-synchronized%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">1.4 synchronized锁的优化机制了解吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Synchronized%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.5 为什么说Synchronized是非公平锁，这样的优缺点是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4synchronized%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.6 为什么说synchronized是一个悲观锁？乐观锁的实现原理又是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-7-%EF%BC%88CAS%E5%8E%9F%E7%90%86%E9%87%8D%E7%82%B9%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9FCAS%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F%E8%AF%B4%E8%AF%B4CAS%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">1.7 （CAS原理重点）什么是CAS？CAS的缺点？说说CAS源码实现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8Bsynchronized%E7%9A%84-u-%E5%8F%AF%E9%87%8D%E5%85%A5-u-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">1.8 请说明一下synchronized的可重入怎么实现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-9-%E5%9C%A8synchronized%E5%81%8F%E5%90%91%E9%94%81%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E8%B0%83%E7%94%A8hashcode%E6%96%B9%E6%B3%95%EF%BC%8Cmarkword%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.9 在synchronized偏向锁过程中，调用hashcode方法，markword会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-10-Synchronized-%E7%A1%AE%E5%AE%9A%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AESynchronized-%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%83%BD%E5%90%A6%E4%B8%AD%E6%96%AD%EF%BC%9F%E6%AF%94%E5%A6%82%E4%BD%BF%E7%94%A8Stop%EF%BC%9F%E6%98%AF%E5%9C%A8%E4%B8%AD%E6%96%AD%E5%89%8D%E8%BF%98%E6%98%AF%E4%B8%AD%E6%96%AD%E5%90%8E%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%9F"><span class="toc-text">1.10 Synchronized 确定不可中断吗？如果一个线程访问Synchronized 代码，其它线程可以能否中断？比如使用Stop？是在中断前还是中断后获取锁？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-Reetrantlock-%E7%9B%B8%E5%85%B3"><span class="toc-text">1.5.2 Reetrantlock 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81%E5%9C%A8reetrantlock%E9%87%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">2.1 非公平锁和公平锁在reetrantlock里的实现过程是怎样的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">2.2 ReentrantLock的实现原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E5%B8%8C%E6%9C%9B%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E9%94%81%E6%B2%A1%E6%9C%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E6%94%BE%E5%BC%83%E7%94%A8%E5%93%AA%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="toc-text">2.3 希望等待一段时间锁没有获取，可以自动放弃用哪种锁？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-AQS-%E7%9B%B8%E5%85%B3"><span class="toc-text">1.5.3 AQS 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AFAQS%E8%AF%B7%E4%BD%A0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">3.1 什么是AQS请你简单介绍一下？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BAQS%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">3.2 请介绍一下AQS原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8EFIFO%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="toc-text">3.3 为什么基于FIFO的同步队列可以实现非公平锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-%E3%80%90%E6%98%93%E5%BF%98%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%80%A7%E8%83%BD%E5%A5%BD%EF%BC%9F"><span class="toc-text">3.4 【易忘】为什么非公平锁性能好？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-AQS-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCountDownLatch%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%EF%BC%9F"><span class="toc-text">3.4 AQS 有哪些组件，请简单介绍一下？介绍一下CountDownLatch的应用场景 ？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1.5.4 Volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0-JMM-%E6%98%AF%E4%BB%80%E4%B9%88-%EF%BC%9F-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEMESI-CPU%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9FJAVA%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-text">4.0 JMM 是什么 ？ 缓存一致性协议MESI ? CPU内存屏障？JAVA内存屏障？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFHappenBefore%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">4.1 什么是HappenBefore原则？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">4.2 Volatile 关键字原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-text">4.3 volatile为什么不能保证原子性？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7-%EF%BC%9F"><span class="toc-text">4.4 并发编程的三个重要特性 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.5 说说 synchronized 关键字和 volatile 关键字的区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-5-Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">1.5.5 Atomic 原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AFAtomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9F"><span class="toc-text">5.1 什么是Atomic 原子类？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-JUC-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%93%AA4%E7%B1%BB"><span class="toc-text">5.2 JUC 包中的原子类是哪4类?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-Volatile-%E5%92%8C-atomic-%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5.3 Volatile 和  atomic  变量区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E8%AE%B2%E8%AE%B2-AtomicInteger-%E7%9A%84%E4%BD%BF%E7%94%A8-%EF%BC%9F"><span class="toc-text">5.4 讲讲 AtomicInteger 的使用 ？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5%EF%BC%88%E9%87%8D%E7%82%B9%E6%8F%90%E9%97%AE%EF%BC%89-AtomicInteger-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">5.5（重点提问） AtomicInteger 原理？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/0/" title="无题">无题</a><time datetime="2021-12-05T08:28:39.054Z" title="发表于 2021-12-05 16:28:39">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/1/" title="无题">无题</a><time datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/62712/" title="C++从零开始（零）：写在前面">C++从零开始（零）：写在前面</a><time datetime="2021-12-05T08:22:28.029Z" title="发表于 2021-12-05 16:22:28">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56326/" title="Hexo快速打造属于自己的网站">Hexo快速打造属于自己的网站</a><time datetime="2021-11-29T12:10:54.202Z" title="发表于 2021-11-29 20:10:54">2021-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&amp;智力题">校招笔记（八）_计算机基础_场景&amp;智力题</a><time datetime="2021-11-26T13:37:19.761Z" title="发表于 2021-11-26 21:37:19">2021-11-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>