<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++从零开始（二）：务实基础（增）复合类型及转换 | royhuang's blog</title><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 四、复合类型及转换 什么是复合类型？这听起来好像是有点新奇的概念。 从基本数据类型（比如int、char）或其他复合数据类型构造出来的数据类型，就称为复合类型。 在前面我们已经接触过所谓的复合类型：   数组（std::string、std::array 等）、指针类型（函数指针或者说函">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从零开始（二）：务实基础（增）复合类型及转换">
<meta property="og:url" content="https://hwh.zone/p/6587/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 四、复合类型及转换 什么是复合类型？这听起来好像是有点新奇的概念。 从基本数据类型（比如int、char）或其他复合数据类型构造出来的数据类型，就称为复合类型。 在前面我们已经接触过所谓的复合类型：   数组（std::string、std::array 等）、指针类型（函数指针或者说函">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2022-01-16T13:04:18.006Z">
<meta property="article:modified_time" content="2022-02-10T04:00:32.180Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="C++基础">
<meta property="article:tag" content="结构体">
<meta property="article:tag" content="枚举">
<meta property="article:tag" content="类型转换">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/6587/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++从零开始（二）：务实基础（增）复合类型及转换',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-10 12:00:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++从零开始（二）：务实基础（增）复合类型及转换</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-16T13:04:18.006Z" title="发表于 2022-01-16 21:04:18">2022-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-10T04:00:32.180Z" title="更新于 2022-02-10 12:00:32">2022-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">从零开始</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">C++基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++从零开始（二）：务实基础（增）复合类型及转换"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p>
</blockquote>
<div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div>
<h2 id="四、复合类型及转换">四、复合类型及转换</h2>
<p><strong>什么是复合类型？这听起来好像是有点新奇的概念</strong>。</p>
<p><u>从基本数据类型（比如<code>int</code>、<code>char</code>）或其他复合数据类型构造出来</u>的数据类型，就称为复合类型。</p>
<p>在前面我们已经接触过所谓的复合类型：</p>
<ul>
<li>
<p>数组（<code>std::string</code>、<code>std::array</code> 等）、指针类型（函数指针或者说函数，指向对象的指针等）、引用类型。</p>
</li>
<li>
<p>举个例子，下面函数<code>func</code> 类型是<code>void()(int, double)</code> ，它由基本类型组成，使其成为复合类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>本章主要介绍的复合类型是结构体（注意结构体大小计算）和枚举（注意枚举作用范围问题），以及各种类型之间的转换：</p>
<ul>
<li>用户隐式转换及发生的情况；</li>
<li>用户四种显示转换，包含C风格和C++风格；</li>
<li>t特别补充，string类型和其它类型之间的转换。</li>
</ul>
<h3 id="4-1-结构体">4.1 结构体</h3>
<h4 id="4-1-1-从C谈起">4.1.1 从C谈起</h4>
<p>在C语言中定义一个典型结构体<code>struct</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> gender[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;; <span class="comment">// *这里有个分号，易遗漏</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 2.声明&amp;初始化，结合&#123;&#125;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">People</span> <span class="title">people</span> =</span> &#123;<span class="string">&quot;royhuang&quot;</span>,<span class="string">&quot;male&quot;</span>,<span class="number">25</span>&#125;; </span><br><span class="line">    <span class="comment">// 3.访问，C/C++中结构体成员默认都是public可以直接访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your name: %s \n&quot;</span>,people.name); <span class="comment">// royhuang</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时还是新手C玩家的我，很难说出<code>struct</code>到底带来什么好处。只能隐隐约约感觉到，<code>struct</code>组合<u>多个</u>且有<u>逻辑关联</u>的数据<u>增强了程序逻辑性和可读性</u>。</p>
<p><strong>那么<code>struct</code> 除了组织有逻辑关联的数据提高代码可读性和一致性，在实际编码中还有其它应用吗</strong>？</p>
<p>在第三章函数，我们提到过：结构体还可用于<u>函数传递多个参数</u>或者<u>函数返回多个值</u>。</p>
<ul>
<li>
<p><strong>传递多个参数</strong></p>
<p>传递一个结构体作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPeople</span><span class="params">(<span class="keyword">const</span> struct People&amp; people)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your name: %s \n&quot;</span>,people.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your gender: %s \n&quot;</span>,people.gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your age: %d \n&quot;</span>,people.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">People</span> <span class="title">people</span> =</span> &#123;<span class="string">&quot;royhuang&quot;</span>,<span class="string">&quot;male&quot;</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    <span class="built_in">printPeople</span>(people);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然这相比传递多个参数要清爽很多（且不易出错）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPeople</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* gender, <span class="keyword">const</span> <span class="keyword">int</span> age)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>返回多个值</strong></p>
<p>函数只能返回一个参数，除了使用元组，结构体是不二的选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct People&amp; <span class="title">cleanPeople</span><span class="params">(People&amp; people)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    people.name=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    people.gender=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    people.age=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-1-2-C-中struct">4.1.2 C++中struct</h4>
<p>C++中struct兼容了C，在此基础上还进行了扩展：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">C</th>
<th style="text-align:center">C++</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">成员</td>
<td style="text-align:center">只有数据</td>
<td style="text-align:center">数据，函数等都可以</td>
</tr>
<tr>
<td style="text-align:center">访问权限</td>
<td style="text-align:center">public</td>
<td style="text-align:center">默认public，有private</td>
</tr>
<tr>
<td style="text-align:center">是否可以继承</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>在C中结构体声明必须带上<code>struct</code> 关键字，而C++中可以直接使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> <span class="title">people1</span>;</span> <span class="comment">// C</span></span><br><span class="line">People people1; <span class="comment">// C++</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>C++中，struct增加了private访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了兼容C）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> gender[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">People</span>(<span class="keyword">const</span> <span class="keyword">char</span>* peole_name,<span class="keyword">const</span> <span class="keyword">char</span>* peole_gender,<span class="keyword">int</span> peole_age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(name,peole_name,<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(gender,peole_gender,<span class="number">5</span>);</span><br><span class="line">        age = peole_age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPeople</span><span class="params">(<span class="keyword">const</span> People&amp; people)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;your name:&quot;</span> &lt;&lt;people.name&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;your gender: &quot;</span>&lt;&lt;people.gender&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;your age: &quot;</span>&lt;&lt;people.age&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">char</span> girl_friend[<span class="number">10</span>];</span><br><span class="line">&#125;; <span class="comment">// 分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    People people = &#123;<span class="string">&quot;royhuang&quot;</span>,<span class="string">&quot;male&quot;</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    people.<span class="built_in">printPeople</span>(people);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以继承，实现了多态。</p>
</li>
</ol>
<p>显然，C++中struct和class区别已经不大。</p>
<h4 id="4-1-3-结构体大小和比较">4.1.3 结构体大小和比较</h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuweiyuxiang/article/details/85997084">c++中的sizeof()运算符</a>、<a target="_blank" rel="noopener" href="https://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/">C/C++中 sizeof 的用法总结</a></p>
</blockquote>
<p><strong>从基本数据类型说起</strong>。</p>
<p>对于short、int、long简单内置数据类型，可采用<code>sizeof</code> 关键字计算大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;  </span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); <span class="comment">// 值为4  </span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(i);   <span class="comment">// 值为4，等价于sizeof(int)  </span></span><br><span class="line"><span class="keyword">sizeof</span> i;    <span class="comment">// 值为4  </span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">2</span>);   <span class="comment">// 值为4，等价于sizeof(int)，因为2的类型为int  </span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">2</span> + <span class="number">3.14</span>); <span class="comment">// 值为8，等价于sizeof(double)，因为此表达式的结果的类型为double  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ary[<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">10</span>]; <span class="comment">// OK，编译无误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>sizeof和strlen的区别</strong>？</p>
<ul>
<li><strong>运算符与函数</strong>：sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li>
<li><strong>参数类型</strong>：sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；<u>strlen的参数只能是字符指针且结尾是’\0’的字符串</u>。</li>
<li><strong>值确定时机</strong>：sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in"><span class="keyword">sizeof</span></span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">      <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，<strong>基本数据类型的内存大小是和系统相关的</strong>，所以在不同的系统下取值可能不同。比如，long 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节。</p>
<p>本节均假设<strong>按4字节对齐</strong>（int在32位/64位都占4字节） 。</p>
<h5 id="sizeof-计算结构体大小">sizeof 计算结构体大小</h5>
<p>结构体的sizeof为了提高存取效率，涉及到字节<strong>对齐</strong>问题。</p>
<p>其对齐规则如下:</p>
<ol>
<li><strong>顺序存储</strong>：分配内存的顺序是按照声明的顺序进行<strong>顺序存储</strong>；</li>
<li><strong>偏移量</strong>：每个变量相对于起始位置的偏移量，必须是<strong>该变量类型大小的整数倍</strong>，不是整数倍空出内存，直到偏移量是整数倍为止；</li>
<li><strong>整体大小</strong>：最后整个结构体的大小必须是，<strong>变量类型最大值的整数倍</strong>。</li>
</ol>
<p>以下实例说明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：24，而不是1+8+4=13。这是因为 ：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211223175820728.png" alt="image-20211223175820728"></p>
<ol>
<li>char a 的偏移量为 0，占用 1Byte；</li>
<li>double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8；</li>
<li>int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式；</li>
<li>结构体大小必须是最大成员大小的整数倍，（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以最后还需填充4byte。</li>
</ol>
<p><strong>嵌套结构体和unio共用体对齐规则又有所不同</strong>。</p>
<ul>
<li>
<p><strong>嵌套结构体</strong></p>
<p>对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为：</p>
<ol>
<li>展开后的结构体的第一个成员的<strong>偏移量</strong>应当是被展开的结构体中<strong>最大</strong>（非嵌套不要求最大）的成员的整数倍。</li>
<li>结构体大小必须是<strong>最大成员大小的整数倍</strong>，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">    &#125; ss;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码输出：16。分析过程同前，这里只给出图示。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211223180812242.png" alt="image-20211223180812242"></p>
</li>
<li>
<p><strong>Unio共用体</strong></p>
<p>union 中变量共用内存，原则如下：</p>
<ol>
<li>内存大小应以最长的为准；</li>
<li>满足上述条件下，还应是最长成员的整数倍大小。</li>
</ol>
<p>例如，下面例子输出共用体大小为：<strong>24</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];  <span class="comment">// 数组大小=成员*长度=5*4=20</span></span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后输出补足4byte，满足是double(8字节)整数倍</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(C) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别的，请思考：</p>
<ul>
<li><strong>将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32</strong>？</li>
</ul>
<p>你可在评论区写下你的见解。</p>
</li>
</ul>
<h5 id="扩展：sizeof计算类对象大小">扩展：sizeof计算类对象大小</h5>
<p>关于类占用的内存空间，有以下几点需要注意：</p>
<ol>
<li>
<p><strong>虚函数</strong>：编译器需要为类构建虚函数表，类<strong>中需要存储一个指针</strong>指向这个虚函数表的首地址。</p>
<p><strong>注意不管有几个虚函数，都只建立一张表</strong>，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。</p>
</li>
<li>
<p><strong>静态成员</strong>：被类所有实例所共享的，它<strong>不计入</strong>sizeof计算的空间。</p>
</li>
<li>
<p><strong>普通函数或静态函数</strong>：都存储在栈中，不计入sizeof计算的空间。</p>
</li>
<li>
<p><strong>类成员</strong>：采用字节对齐的方式分配空间；</p>
</li>
</ol>
<p>以下为实例说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 虚函数：需要一个指针指向虚函数表</span></span><br><span class="line">        <span class="comment">// 32位系统指针大小为 4Byte，64位系统指针大小为 8Byte</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funa</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 普通函数或静态函数或静态成员：不计入</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fund</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> si; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// char占1字节</span></span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="comment">// int首先要偏移3字节，是sizeof(int)整数倍</span></span><br><span class="line">        <span class="comment">// int本身占4字节</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 最后总大小为：指针大小+1+3+4 = 12 OR 16</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(D) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上输出为：12（32位系统）或者16（64位系统）。具体占用请查看代码中注释。</p>
<p><strong>类成员对齐方式和结构体有所不同</strong>，未尽细节将在未来补充。</p>
<h5 id="空类-结构体大小">空类/结构体大小</h5>
<blockquote>
<p>思考源自于：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/266041176">空类的大小为什么是1？</a></p>
</blockquote>
<p>经过实践，无论是空类还是空结构体，其大小<strong>均为1而不是0</strong>。</p>
<p>看了一下比较信服的解答是：</p>
<ul>
<li>
<p>如果长度是0，那么把他塞给一个指针，指针指到哪里呢？不考虑指针，这个类自己存在哪里呢？如果我一下子申明100万个实例，都不占用内存吗？</p>
</li>
<li>
<p>c++ 中规定<strong>不同的对象必须拥有不同的地址</strong>，如果为0会导致两个空类的地址一样。</p>
<blockquote>
<p>但是为啥空类一定要有不同的地址来去区分不同的对象？</p>
</blockquote>
</li>
</ul>
<h5 id="结构体比较">结构体比较</h5>
<p>C++结构体直接进行比较会出错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line">    A b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;not equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# g++ -std=c++11 test.cpp -o test.out</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:21:9: error: no match for ‘operator==’ (operand types are ‘A’ and ‘A’)</span><br><span class="line">     if(a==b)</span><br></pre></td></tr></table></figure>
<p>有两种办法解决这个问题：</p>
<ol>
<li>
<p>结构体 <code>a</code> 和 <code>b</code> 每个元素逐个比较，指针比较它们的地址。</p>
</li>
<li>
<p>自己重载操作符<code>==</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> A&amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> a_is_equal = (a==other.a);</span><br><span class="line">        <span class="keyword">bool</span> b_is_equal = (b==other.b);</span><br><span class="line">        <span class="keyword">bool</span> c_is_equal = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">3</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i] != other.c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                c_is_equal =<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a_is_equal &amp;&amp; b_is_equal &amp;&amp; c_is_equal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line">    A b&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;not equal&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">equal</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="4-1-4-扩展阅读：为什么C-还保留struct？">4.1.4 扩展阅读：为什么C++还保留struct？</h4>
<p>在C++中，除了默认访问控制符、模板参数，struct和class基本完全一致，struct存在的意义是什么，全用class不好吗？</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">struct</th>
<th style="text-align:center">class</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">继承默认权限</td>
<td style="text-align:center">struct默认是public</td>
<td style="text-align:center">class默认是private</td>
</tr>
<tr>
<td style="text-align:center">模板参数</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
</tbody>
</table>
<p>这里面的原因主要是：</p>
<ol>
<li><strong>历史包袱</strong>。给 C 语言程序开发人员有一个归属感；</li>
<li><strong>兼容</strong> 。让 C++ 编译器兼容以前用 C 语言开发出来的项目，比如系统库<code>stdlib.h</code> 等。</li>
</ol>
<h3 id="4-2-枚举">4.2 枚举</h3>
<h4 id="4-2-1-枚举初识">4.2.1 枚举初识</h4>
<p>和结构体类似，枚举也是组织了<u>有逻辑关系的数据</u>，不过枚举：</p>
<ul>
<li>数据只能是同类型（我们定义的枚举类型）；</li>
<li>相比struct/class，枚举enum更像是一种弱组织类型，如果你有一组相关的常量最好使用枚举。</li>
</ul>
<p>举个例子吧，用枚举组合三元色（常量）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>  // 最佳实践：首字母大写</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    red,</span><br><span class="line">    blue,</span><br><span class="line">    green,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color paint = red;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比用0、1、2分别定义三元色，代码可读性提高了很多。</p>
<h5 id="枚举是整数符号常量">枚举是整数符号常量</h5>
<p><strong>枚举到底什么</strong>？</p>
<p>好吧，标题已经出卖了答案：<strong>枚举其实就是整数符号常量（默认是int</strong>）。</p>
<p>和<code>char</code> 情况有点类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>char 实际上存储的是一个 1 字节的整数值，即字符<code>'A'</code>被转换为整数值（在本例中为<code>65</code>）并存储。</p>
<p>只不过打印<code>cout</code>类对<code>&lt;&lt;</code>进行了重载，直接打印<code>c</code> 出来的是<code>'A'</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;c;  <span class="comment">// A</span></span><br></pre></td></tr></table></figure>
<p>回到枚举<code>enum</code> ：</p>
<ul>
<li>枚举会自动分配一个整数值。默认情况下，第一个枚举器被分配整数值<code>0</code>，每个后续枚举器的值都比前一个<code>+1</code>；</li>
<li>我们也可以自定义枚举值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    cat = <span class="number">-3</span>,</span><br><span class="line">    dog,         <span class="comment">// -2</span></span><br><span class="line">    pig,         <span class="comment">// -1</span></span><br><span class="line">    horse = <span class="number">5</span>,</span><br><span class="line">    giraffe,     <span class="comment">// 6</span></span><br><span class="line">    chicken      <span class="comment">// 7</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal animal = dog;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你的宠物是：&quot;</span> &lt;&lt; animal;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的宠物是：-2</span><br></pre></td></tr></table></figure>
<p><strong>好吧你的宠物是<code>-2</code>，编译器隐式将枚举转换为了整数（并没有像char一样打印字符，std::cout没有对枚举类型Animal进行重载</strong>）。</p>
<p>不过，编译器不会将整数隐式转换为枚举数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="number">-2</span>;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>需要显式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">static_cast</span>&lt;Animal&gt;(<span class="number">-2</span>);</span><br></pre></td></tr></table></figure>
<p>上面我们验证了enum的主要用法和特性，但可以更完美一点优雅打印枚举数吗，就像char一样？</p>
<h5 id="优雅打印枚举数">优雅打印枚举数</h5>
<p>怎么优雅打印枚举数？</p>
<p>C++中并没有提供相关函数。这只有我们自己来实现，<code>if-else</code>或<code>switch</code> 逐个判断是最容易想到的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">printAnimal</span><span class="params">(Animal animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (animal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> cat:   <span class="keyword">return</span> <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> dog:   <span class="keyword">return</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> pig:   <span class="keyword">return</span> <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">        <span class="comment">// 省略其它的判断</span></span><br><span class="line">        <span class="keyword">default</span>:    <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这需要显式调用<code>printAnimal</code> 方法，看起来有点笨拙。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = dog;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;你的宠物是：&quot;</span> &lt;&lt; <span class="built_in">printAnimal</span>(animal);</span><br></pre></td></tr></table></figure>
<p><strong>直接重载<code>std::cout</code> 类运算符<code>&lt;&lt;</code>是更好的做法</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, Animal animal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (animal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> cat:   <span class="keyword">return</span> <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> dog:   <span class="keyword">return</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> pig:   <span class="keyword">return</span> <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">        <span class="comment">// 省略其它的判断</span></span><br><span class="line">        <span class="keyword">default</span>:    <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以打印字符串看起来聪明了很多：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = dog;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;你的宠物是：&quot;</span> &lt;&lt; animal;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的宠物是：dog</span><br></pre></td></tr></table></figure>
<h5 id="认识枚举作用域">认识枚举作用域</h5>
<p><strong>枚举内部数据和枚举具有同样的作用范围，也就是枚举对内部数据作用范围无限制</strong>。</p>
<p>回到最开始的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 直接就使用了red</span></span><br><span class="line">    <span class="comment">// 也可以通过前缀Color::red</span></span><br><span class="line">    Color paint = red;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>red</code> 和 <code>enum Color</code> 作用域是一致的，都是全局类型。</p>
<p>这种设置，调用起来很方便，但是<strong>在两个不同枚举类定义相同的数据，会使得命令空间污染，导致编译错误</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    red,</span><br><span class="line">    green,</span><br><span class="line">    blue, <span class="comment">// blue 表示颜色</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Feeling</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    happy,</span><br><span class="line">    tired,</span><br><span class="line">    blue, <span class="comment">// blue表示心情</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你再尝试调用，编译无法通过，两个<code>blue</code> 冲突：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color paint = blue; <span class="comment">//  error: redeclaration of ‘blue’</span></span><br></pre></td></tr></table></figure>
<p>虽然可以通过显式指定前缀避免错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color paint = Color::blue; </span><br></pre></td></tr></table></figure>
<p>但终归是埋下了隐患。</p>
<p><strong>更好的做法是使用命名空间<code>namespace</code> 限定范围，这样我们可以在不同枚举类定义相同的数据</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        red,</span><br><span class="line">        green,</span><br><span class="line">        blue,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> feeling</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Feeling</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        happy,</span><br><span class="line">        tired,</span><br><span class="line">        blue, </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 现在必须加上作用域区域的名称</span></span><br><span class="line">    color::Color paint  =  color::blue ;</span><br><span class="line">    feeling::Feeling me = feeling::blue ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最佳实践">最佳实践</h5>
<p>使用枚举请显式指明枚举类型，比如<code>color::blue</code> 而非直接使用<code>blue</code>。</p>
<h4 id="4-2-2-范围枚举">4.2.2 范围枚举</h4>
<h5 id="为什么需要范围枚举？">为什么需要范围枚举？</h5>
<p>非范围枚举看起来很好，但会带来一些问题：</p>
<ul>
<li><strong>隐式转换的危害</strong>。非范围枚举会隐式地将枚举类型转换为整数类型，这有时候会造成一些意料之外的错误（比如不同枚举类型进行比较，下举例说明）；</li>
<li><strong>非强制要求前缀</strong>。这显然和我们刚刚提到的枚举最佳实践不符。</li>
</ul>
<p><strong>范围枚举</strong>的特性很好地解决了上述问题：</p>
<ul>
<li>范围枚举是<strong>强类型的</strong>（不会隐式转换为整数）和<strong>强作用域的</strong>（必须指定前缀）；</li>
<li>其余和非范围枚举没什么区别。</li>
</ul>
<h5 id="范围枚举初识">范围枚举初识</h5>
<p>范围枚举通过<code>enum class</code> 声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     red, </span><br><span class="line">     blue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    banana, </span><br><span class="line">    apple,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先认识下范围枚举的<u>强作用域</u>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color c = red;  <span class="comment">// error，identifier &quot;red&quot; is undefined</span></span><br></pre></td></tr></table></figure>
<p>必须显式指定作用范围，契合了最佳实践：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color c = Color::red; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>再来认识范围枚举的<u>强类型</u>（不会隐式转换）。</p>
<ol>
<li>
<p>无法直接打印</p>
<p>因为范围枚举不会隐式转换为<code>int</code> ，<code>std::cout</code> 无法直接打印。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; Fruit::banana;</span><br></pre></td></tr></table></figure>
<p>除非你显式进行转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(Fruit::banana);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不能直接比较两个不同枚举类型</p>
<p>下面代码编译能通过吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color color = Color::red ; </span><br><span class="line">    Fruit fruit = Fruit::banana ; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color == fruit) </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;color和fruit相等\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;color和fruit不相等\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是无范围枚举上述代码不会编译出错，甚至会打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color和fruit相等</span><br></pre></td></tr></table></figure>
<p>因为<code>red</code>和<code>banana</code> 都被隐式转换为<code>int</code>类型，值都为<code>0</code> 。</p>
<p>但如果是范围枚举，上述代码会直接报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile error: the compiler doesn&#x27;t know how to compare different types Color and Fruit</span><br></pre></td></tr></table></figure>
<p>范围枚举不会转换任何可以与另一种类型进行比较的类型。</p>
<p>不过，<strong>比较同一类型是ok的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Color::red == Color::blue) <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="最佳实践-2">最佳实践</h5>
<p>请尽量使用范围枚举，它更安全。</p>
<p>虽然在实际编码我们还是可能会使用非范围枚举，因为非范围枚举隐式转换可避免大量手动<code>static_casting</code> 。但是，只是偶尔的需要<code>static_casting</code> 便不能构成拒接范围枚举的理由。</p>
<h3 id="4-X-类型转换🌟">4.X 类型转换🌟</h3>
<p><strong>什么是类型转换</strong>？</p>
<p>将值从一种数据类型转换为另一种数据类型的过程，称为类型转换。</p>
<p><strong>C++的类型有几种</strong>？</p>
<p>C++的类型转换分为两种，一种为隐式转换，另一种为显式转换：</p>
<ul>
<li><strong>隐式转换</strong>：编译器<u>自动</u>进行的类型转换，就是隐式转换；</li>
<li><strong>显式转换</strong>：程序员<u>显式</u>使用<code>_cast</code> 类型转换符进行类型转换，就是显式转换。</li>
</ul>
<p><strong>C++ 中的绝大多数类型转换都是隐式类型转换</strong>。</p>
<p>所以，我们先来接触隐式类型转换吧。</p>
<h4 id="4-X-1-隐式转换">4.X.1 隐式转换</h4>
<p>隐式转换可以分为两个部分，<u>标准转换</u>和<u>用户自定义转换</u>，我们来看看它们是什么。</p>
<h5 id="标准转换">标准转换</h5>
<p>标准转换就是编译器里内置的一些类型转换规则：</p>
<ul>
<li>数值提升</li>
<li>数值转换</li>
<li>算术转换</li>
<li>数组退化成指针、函数转换成函数指针</li>
<li>数据类型指针到void指针的转换、nullptr_t到数据类型指针的转换</li>
<li>特定语境下要求的转换，比如if里要求bool类型的值、枚举类型转换为整型</li>
<li>…</li>
</ul>
<p>可以看到，这些转换基本针对<u>基本数据类型</u>、<u>指针</u>、或<u>数组</u>这种内置的聚合类型的。</p>
<p>先从第一个数值提升说起吧。</p>
<ul>
<li>
<p><strong>数值提升</strong></p>
<p><strong>数值提升是什么</strong>？</p>
<p>顾名思义，数值提升就是将更小的数据类型（比如<code>char</code>） 转换为更大的数据类型（通常是<code>int</code>或者<code>double</code>）。显然这种提升是<u>安全</u>的，它不会丢失精度。</p>
<p>数值提升也分为两个子类别：浮点提升和整数提升。</p>
<ul>
<li>
<p><strong>浮点提升</strong></p>
<p>浮点提升规则很简单，就是<code>float</code> 可以隐式提升为<code>double</code> 。一个例子就能明白：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDouble</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printDouble</span>(<span class="number">4.0f</span>); <span class="comment">// 4.0f是float被隐式提升double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>整型提升</strong></p>
</li>
</ul>
<blockquote>
<p><code>char</code>、<code>bool</code>、<code>short</code> 、<code>int</code>、<code>long</code> 都是整型。</p>
</blockquote>
<p>整型提升说白了，就是比<code>int</code> 小的数据类型，尽量往<code>int</code> 或 <code>unsigned int</code>上靠。它的规则大致总结如下：</p>
<ol>
<li>无符号或者有符号char、short 优先隐式转换为int，如果int不够容纳，则转换为 unsigned int；</li>
<li>bool也转换为int，false变成0，true变成1。</li>
</ol>
<p>举一个小例子。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s =  <span class="number">3</span> ;  <span class="comment">// short</span></span><br><span class="line">    <span class="built_in">printInt</span>(s);    </span><br><span class="line">    <span class="built_in">printInt</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">// char</span></span><br><span class="line">    <span class="built_in">printInt</span>(<span class="literal">true</span>); <span class="comment">// bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数值之间的转换就结束了</strong>？</p>
<p>看到这儿或许你会说作者是不是遗漏了，<code>int→float</code> 之类的整型提升介绍呢？</p>
<p>其实，<code>int→float</code> 、还有宽类型→窄类型的转换都被归类为<u>数值转换</u>。当然这只是学术上的区别，你不必太过纠结这点。</p>
</li>
<li>
<p><strong>数值转换</strong></p>
<p><strong>什么是数值转换</strong>？</p>
<p>数值提升未提到的转换，都是数值转换。</p>
<p>回答这么敷衍？好吧，我具体一点。</p>
<p>数值转换可分为以下五种规则：</p>
<ol>
<li>
<p>整型可转换为任何其它整型（不包括整型提升）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">3</span>; </span><br><span class="line">  <span class="keyword">long</span> l = <span class="number">3</span>; </span><br><span class="line">  <span class="keyword">char</span> ch = s; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>浮点类型转换为任何其他浮点类型（不包括浮点提升）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.0</span>; </span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>整数类型转换为任何浮点类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将浮点类型转换为任何整数类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3.5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将整数类型或浮点类型转换为 bool</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到：<strong><u>数值转换</u>和<u>数值提升</u>的规则综合起来就是一句话：C++中基本任意整型之间都可以进行隐式转换</strong>。</p>
<p><strong>但数值转换会带来一些危险</strong>。</p>
<p>由于数值转换可以将：宽类型→窄类型、浮点类型→整数类型，这会导致精度丢失。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点类型→整数类型</span></span><br><span class="line">  <span class="keyword">float</span> a = <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">int</span> b = a ;  <span class="comment">// a = 1.0 , 小数部分丢失</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 宽类型→窄类型</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1000000</span>;</span><br><span class="line">  <span class="keyword">char</span> d = a; <span class="comment">// d = 64（&#x27;@&#x27;） , a被截断</span></span><br></pre></td></tr></table></figure>
<p>另一点比较隐蔽，<u>隐式转换总是转换为右值</u>（显式转换也是）。</p>
<p>听起来好像没什么毛病，但是和引用结合起来就坏事了，我们知道引用只能用左值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">long</span> &amp;b = a; <span class="comment">// error，无法使用右值初始化引用</span></span><br><span class="line">  <span class="keyword">long</span> &amp;b = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(a); <span class="comment">// error,显式转换也是右值</span></span><br></pre></td></tr></table></figure>
<p>解决办法也很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.和引用类型保持一致</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">long</span> tmp = a;</span><br><span class="line">  <span class="keyword">long</span> &amp;b = tmp; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.使用const修饰，这样可以接受右值初始化</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">long</span> &amp;b = a; </span><br></pre></td></tr></table></figure>
<p>扩展到函数也是一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span>&amp; value)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">func</span>(a);</span><br></pre></td></tr></table></figure>
<p><strong>这也是为什么很多教程说尽量用const修饰引用：这样可以使得函数参数可以隐满足式转换规则</strong>。</p>
</li>
<li>
<p><strong>算术转换</strong></p>
<p>算术转换就是当操作数不是同一类型时，会隐式转换为同一类型进行再进行操作。</p>
<p>算术转换优先级列表：</p>
<ul>
<li>long double  &gt; double &gt; float &gt; unsigned long long &gt; long long &gt; long &gt; unsigned int &gt; int</li>
</ul>
<p>注意到最低优先级是int。</p>
<p>算术转换只有两条规则：</p>
<ul>
<li>如果至少有一个操作数的类型在优先级列表中，则将具有较低优先级的操作数转换为具有较高优先级的操作数的类型；</li>
<li>否则（两个操作数的类型都不在列表中），两个操作数都进行类型提升。</li>
</ul>
<p>一个简单例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.5</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">typeid</span></span>(i + d).<span class="built_in">name</span>(); <span class="comment">// 最终类型为d，double优先级更高，所以i提升为double </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>指针相关转换</strong></p>
<p>这些我们之前其实都基本见过：</p>
<ul>
<li>数组退化成指针、函数转换成函数指针</li>
<li>数据类型指针到void指针的转换、nullptr_t到数据类型指针的转换</li>
<li>…</li>
</ul>
<p>举个小例子加深下印象就好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* i = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line"><span class="keyword">void</span>* ptr = i;  <span class="comment">// 所以之前说void类型接受任何类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* pc = <span class="number">0</span>;   <span class="comment">// int 转换为 Null 指针再转换为char*指针</span></span><br><span class="line"><span class="keyword">char</span>* pc = <span class="literal">nullptr</span>;        <span class="comment">// nullptr转换为char*指针</span></span><br><span class="line">dog* pd = <span class="keyword">new</span> <span class="built_in">yellowdog</span>(); <span class="comment">// 指针类型转换，子类 yellowdog 指针转换为父类 dog 指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>特殊语境下转换</strong></p>
<p>以if为例，if接受bool类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">3</span>)  <span class="comment">// 3转换为bool类型，这里是true(非0值都转换为true)</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;fine&quot;</span>&lt;&lt;std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bool也是整型，其实也就是前面说别的，C++中整型几乎都可以进行隐式转换。</p>
</li>
</ul>
<h5 id="别踩坑：char和int的转换？">别踩坑：char和int的转换？</h5>
<p>前面我们说到，char和int可以隐式转换。但这可能会带来一些意外的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> a = c;   <span class="comment">// a=49</span></span><br></pre></td></tr></table></figure>
<p>此时是将<code>c</code> 的ASCII码<code>49</code>（数字的ASCII码从<code>48</code>开始，即<code>'0'</code>开始） 赋值给变量<code>a</code>。</p>
<p>如果需要获取<code>c</code>存储值<code>'1'</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = c<span class="number">-48</span>;  <span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">int</span> a2 = c-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure>
<h5 id="用户自定义转换🌟">用户自定义转换🌟</h5>
<blockquote>
<p>这部分内容有点超前，适合有一定面对对象基础的同学。</p>
</blockquote>
<p><strong>怎么进行用户定义转换</strong>？</p>
<p>用户自定义的隐式转换是隐式转换的重头戏，一般指两方面内容:</p>
<ol>
<li>
<p><strong>转换构造函数</strong>，利用接受<u>单个参数</u> 或 <u>第一个参数其余参数都提供了默认值</u> 的构造函数，将<u>其他类型对象→转换为本对象</u>。</p>
<blockquote>
<p>C++ 会将任何构造函数视为隐式转换运算符。</p>
</blockquote>
</li>
<li>
<p><strong>类型转换重载</strong>， <u>重载指定类型</u>，将<u>本类的对象→转换为指定类型对象</u>。</p>
</li>
</ol>
<p>两者合起来可以构成一个双向转换关系，下面我们看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 1.转换构造函数</span></span><br><span class="line">        <span class="built_in">dog</span>(string name) &#123;m_name = name;&#125; </span><br><span class="line">        <span class="comment">// 2.类型转换重载</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_name;&#125; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s2dog</span><span class="params">(cosnt dog&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// nothing;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      string dogname = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">      <span class="comment">// 1.转换构造函数</span></span><br><span class="line">      dog d = dogname; <span class="comment">// ok</span></span><br><span class="line">      <span class="built_in">s2dog</span>(<span class="string">&quot;dog&quot;</span>);    <span class="comment">// ok</span></span><br><span class="line">      <span class="comment">// 2.类型转换</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; <span class="built_in">string</span>(d) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is dog</span><br></pre></td></tr></table></figure>
<p>第一种隐式转换方式看起来有点让人费解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog d = dogname;</span><br></pre></td></tr></table></figure>
<p>它也没有重载 <code>=</code> ，怎么就<code>string</code>→<code>dog</code>转换了？</p>
<p>这是因为<code>dog(string name) &#123;m_name = name;&#125;</code> 有两层含义，除了构造函数外，它还可以作为隐式转换函数，将 <code>string</code> 对象转换为 <code>dog</code> 对象。</p>
<p>具体过程还涉及到复制初始化（<u>5.2.2</u>节详解）：</p>
<ol>
<li>表达式从右到左，构造函数<code>dog(string)</code>作为转换构造函数 ，编译器先创建<code>dog</code>临时匿名对象，使得<code>=</code>两边操作类型一致；</li>
<li>然后构造函数<code>dog(string)</code> ，初始化匿名对象；</li>
<li>编译器创建对象<code>d</code> ；</li>
<li>调用复制构造函数，匿名对象作为复制构造函数参数，初始化对象<code>d</code> 。</li>
</ol>
<p><strong>用户自定义转换有什么危险</strong>？</p>
<p>隐式转换总是或多或少有点危险，用户自定义隐式转换也不例外。</p>
<ul>
<li>比如，我们只是想声明一个构造函数，但是会自动被识别为转换构造函数——将<code>string</code> →<code>dog</code>也许并不是我们的本意 。</li>
<li>通常编码需避免双向隐式转换，我们开头的例子是不好的编程实践。</li>
</ul>
<p>如果不想构造函数进行隐式转换，可以用 <code> explicit</code> 进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">dog</span><span class="params">(string)</span> </span>&#123;m_name = name;&#125;</span><br></pre></td></tr></table></figure>
<p>此时进行隐式转换会出错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string dogname = <span class="string">&quot;dog&quot;</span>;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>只能进行显示转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string dogname = <span class="keyword">static_cast</span>&lt;dog&gt;(<span class="string">&quot;dog&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>用户自定义转换有什么好处</strong>？</p>
<p>隐式转换并不是一无是处，它仍然有存在的意义。</p>
<p>下面声明一个<code>Rational</code> 有理数类，处理数字类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">int</span> den;</span><br><span class="line">    <span class="comment">// 1.构造函数隐式转换</span></span><br><span class="line">	<span class="built_in">Rational</span>(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>)</span><br><span class="line">		: <span class="built_in">num</span>(numberator), <span class="built_in">den</span>(denominator) &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.重载运算符*</span></span><br><span class="line">    Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.num*rhs.num, lhs.den*rhs.den);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rational r1 = <span class="number">23</span>;</span><br><span class="line">    Rational r2 = r1 * <span class="number">2</span>;</span><br><span class="line">    Rational r3 = <span class="number">3</span> * r1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码定义了一个有理数类 <code>Rational</code>，它的构造函数接受 2 个默认参数，分别代表分子和分母，给该构造函数传递一个参数时，<code>Rational</code> 具有隐式转换的特性，所以我们可以直接将数字赋值给 <code>Rational</code> 对象，如：<code>Rational r1 = 23;</code> 。</li>
<li>为了避免双向转换，这里并没有定义将 <code>Rational</code> 转换为 <code>int</code> 的转换函数，而当我们想实现 <code>Rational</code> 对象和 <code>int</code> 之间自由的算术运算时，我们需要定义全局的操作符重载，如上面的 <code>operator*</code> 定义了有理数的乘法云算符。</li>
</ul>
<h5 id="最佳实践-3">最佳实践</h5>
<p>类型转换是危险的操作，使用更长的操作符（后文将提到的显式转换）提醒同事和将来的自己注意安全。</p>
<h4 id="4-X-2-显式转换">4.X.2 显式转换</h4>
<p>显式转换主要有两个作用：</p>
<ol>
<li>完成C++隐式转换无法完成的工作，比如范围枚举中将<code>eunm</code> 类型→<code>int</code> ；</li>
<li>尽可能的替代隐式转换，在程序显式的声明这是个转换操作——这很专业。</li>
</ol>
<p>C++/C总是难以分开的，先从C中显式转换说起吧。</p>
<h5 id="C风格显式转换">C风格显式转换</h5>
<p>在标准 C 编程中，转换是通过 <code>()</code> 运算符完成的，类型的名称要转换的值放在括号内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">double</span>)x;</span><br></pre></td></tr></table></figure>
<p>C风格的转换格式看起来很简单，但其实有不少缺点：</p>
<ol>
<li><u>转换太过随意，可以在任意类型之间转换</u>。可以把一个指向const对象的指针转换成指向非const对象的指针，把一个指向基类对象的指针转换成一个派生类对象的指针。这些转换之间的差距是非常巨大的，但是传统的C语言风格的类型转换没有区分这些。</li>
<li><u>C风格的转换没有统一的关键字和标示符</u>。对于大型系统，做代码排查时容易遗漏和忽略。</li>
</ol>
<p>为此，C++ 引入了<code>_cast</code>强制转换运算符。</p>
<h5 id="C-显式转换">C++显式转换</h5>
<p>C++转换风格完美的解决了C风格两个问题：</p>
<ol>
<li>对类型转换做了细分，提供了四种不同类型转换，以支持不同需求的转换；</li>
<li>类型转换有了统一的标示符，利于代码排查和审查。</li>
</ol>
<p>四种不同类型的转换分别是：</p>
<ul>
<li>
<p><code>static_cast</code>，命名上理解是静态类型转换，如int转换→char，转换失败不返回NULL。</p>
</li>
<li>
<p><code>dynamic_cast</code>，命名上理解是动态类型转换，如子类和父类之间的多态类型转换，转换失败返回<u>NULL</u>。</p>
<blockquote>
<p>⚠️ 所以上行转换（子类→父类）这种安全转换用static_cast是可以的，但是下行转换（父类→子类）这种不安全的转换使用dynamic_cast，失败会返回NULL，会运行时检查。</p>
</blockquote>
</li>
<li>
<p><code>const_cast</code>，去除const属性，如常量指针/引用转换→非常量指针/引用。</p>
</li>
<li>
<p><code>reinterpret_cast</code>，仅仅重新解释类型，没有进行二进制的转换。</p>
</li>
</ul>
<h5 id="static-cast">static_cast</h5>
<p><strong>什么时候使用static_cast</strong>？</p>
<ul>
<li><strong>基本数据类型之间的转换</strong>，如把int转换为char，带来安全性问题由程序员来保证；</li>
<li><strong>把空指针转换成目标类型的空指针</strong>；</li>
<li><strong>把任何类型的表达式转为void类型</strong>；</li>
<li>（不推荐）类层次结构中<u>基类和派生类之间指针或引用</u>的转换：上行转换（子类→父类）是安全的；下行转换（父类→子类）由于没有动态类型检查，所以是不安全的。</li>
</ul>
<p><strong>隐式转换都建议使用static_cast进行标明和替换</strong>。</p>
<p>例如，下面隐式转换都可替换为显式的static_cast转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(n); <span class="comment">// 基本类型转换</span></span><br><span class="line"><span class="keyword">int</span> *pn = &amp;n;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span> *&gt;(&amp;n) <span class="comment">// 无关类型指针转换，编译错误，应该使用reinterpret_cast</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(pn); <span class="comment">// 任意类型转换成void类型</span></span><br></pre></td></tr></table></figure>
<h5 id="dynamic-cast">dynamic_cast</h5>
<p><strong>什么时候使用dynamic_cast</strong>？</p>
<p>只有在<u>派生类之间</u>转换时才使用dynamic_cast，<u>type-id必须是类指针，类引用或者<code>void*</code></u>。</p>
<ul>
<li><strong>使用时基类必须要有虚函数</strong>，因为dynamic_cast是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数才会有虚函数表（如果一个类没有虚函数，那么一般意义上，这个类的设计者也不想它成为一个基类）。</li>
</ul>
<p><strong>和static_cast对比有什么区别</strong>？</p>
<ul>
<li>下行转换，dynamic_cast是安全的（当类型失败时，转换过来的是<u>空指针</u>），而static_cast是不安全的（当类型不一致时，<u>转换过来的是错误意义的指针</u>，可能造成踩内存、非法访问等各种问题）。</li>
<li>dynamic_cast还可以进行交叉转换。</li>
</ul>
<p>一个简单示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> m_iNum;</span><br><span class="line">      <span class="comment">// 基类必须有虚函数，保持多态性才能使用dynamic_cast</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span>:</span> <span class="keyword">public</span> BaseClass </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">char</span> *m_szName[<span class="number">100</span>];</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">　　</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseClass* pb = <span class="keyword">new</span> <span class="built_in">DerivedClass</span>();</span><br><span class="line">    <span class="comment">// 子类-&gt;父类，静态类型转换，正确但不推荐</span></span><br><span class="line">    DerivedClass *pd1 = <span class="keyword">static_cast</span>&lt;DerivedClass*&gt;(pb);</span><br><span class="line">    <span class="comment">// 子类-&gt;父类，动态类型转换，正确</span></span><br><span class="line">    DerivedClass *pd2 = <span class="keyword">dynamic_cast</span>&lt;DerivedClass*&gt;(pb);</span><br><span class="line"></span><br><span class="line">    BaseClass* pb2 = <span class="keyword">new</span> <span class="built_in">BaseClass</span>();</span><br><span class="line">    <span class="comment">// 父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界</span></span><br><span class="line">    DerivedClass *pd21 = <span class="keyword">static_cast</span>&lt;DerivedClass*&gt;(pb2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类-&gt;子类，动态类型转换，安全的。结果是NULL</span></span><br><span class="line">    DerivedClass *pd22 = <span class="keyword">dynamic_cast</span>&lt;DerivedClass*&gt;(pb2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="const-cast">const_cast</h5>
<p>cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符，<u>用来去除常量性</u>，程序员对这个操作负责。</p>
<ul>
<li>常量指针转换为非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换为非常量引用，并且仍然指向原来的对象</li>
</ul>
<p>注意转换类型只能是指针或引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> SA ra;</span><br><span class="line">    ra.i = <span class="number">10</span>; <span class="comment">// error，直接修改const类型</span></span><br><span class="line">    SA &amp;rb = <span class="keyword">const_cast</span>&lt;SA&amp;&gt;(ra);</span><br><span class="line">    rb.i = <span class="number">10</span>; <span class="comment">// ok，去除了常量性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="reinterpret-cast">reinterpret_cast</h5>
<p><strong>非常危险的操作符，谨慎使用</strong>。</p>
<ul>
<li>reinterpret_cast可以在指针和引用里进行肆无忌惮的转换；</li>
<li>reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组；</li>
<li>reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差。</li>
</ul>
<p>一般用来不同类型的指针或引用之间转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* p_a = &amp;a;</span><br><span class="line"><span class="keyword">bool</span>* p_c = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">bool</span>*&gt;(p_a);</span><br><span class="line">std::cout &lt;&lt; *p_c&lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="最佳实践-4">最佳实践</h5>
<ul>
<li>
<p><strong>什么时候使用显式转换</strong>？</p>
<p>在所有需要转换的地方都应该尽量使用显式转换。</p>
</li>
<li>
<p><strong>四种显式转换该怎么选择</strong>？</p>
<p>⚠️ 除了static_cast可用于非指针、引用类型，<strong>其它转换符都必须是指针或引用</strong>。</p>
<ul>
<li>static_cast：基本类型转换、类下行转换、空指针和其它指针的转换；</li>
<li>reinterpret_cast：不同类型的指针类型转换；</li>
<li>const_cast：将常量指针/引用转换为非常量指针/引用；</li>
<li>daynamic_cast：多态类之间的类型转换。</li>
</ul>
</li>
</ul>
<h4 id="4-X-3-类型转换补充：string">4.X.3 类型转换补充：string</h4>
<p>这里主要总结下<u>上面没提到，平时又经常用到的</u>转换：</p>
<ol>
<li>string和char等基本类型的转换；</li>
<li>string和char[]之间转换；</li>
<li>string和其它类型数组（比如int[]）之间的转换。</li>
</ol>
<p>1和2在<u>1.8.3</u> &amp; <u>1.8.4</u> 节都已介绍过，为了完整性这里再次进行简单总结。</p>
<h5 id="string↔基本类型">string↔基本类型</h5>
<blockquote>
<p>string不是内置类型，使用static_cast是不行的，比如int↔string。</p>
</blockquote>
<p>string↔基本类型有两种方式：</p>
<ol>
<li>使用输入、输出流作为媒介实现；</li>
<li>使用C++11<code>std::string</code>内置的相关函数实现。</li>
</ol>
<p>为了通用性，我们先介绍 <code>std::istringstream</code>和<code>std::ostringstream</code>  作为媒介如何实现转换。</p>
<ul>
<li><code>std::istringstream</code> ，即输入流：构造函数<u>接受数据的输入</u>，然后使用<code>&gt;&gt;</code> 提取流中数据；</li>
<li><code>std::ostringstream</code> ，即输出流：使用<code>&lt;&lt;</code> 接受数据的输入，使用成员方法如<code>str()</code> 提取流中数据。</li>
</ul>
<p>下面是具体实例。</p>
<ul>
<li>
<p><strong>string→基本类型</strong></p>
<p>基本思路：用string对象初始化<u>输入</u>流 → 输入流写入<code>&gt;&gt;</code>其它类型中（string此时会被自动转换）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    std::string str = <span class="string">&quot;233&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iStream</span><span class="params">(str)</span></span>;</span><br><span class="line">    iStream&gt;&gt;a;   <span class="comment">// 输出流自动转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>string←基本类型</strong></p>
<p>基本思路：用<code>&lt;&lt;</code>初始化<u>输出</u>流 → 输出流对象调用<code>str()</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">233</span>;</span><br><span class="line">std::ostringstream oStream;</span><br><span class="line">oStream&lt;&lt;b;</span><br><span class="line">oStream.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>好消息，C++11给广大程序员带来了福音，提供了大量已经定义好的方法</strong>。</p>
<blockquote>
<p>更多介绍，可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lmb1612977696/article/details/78273629">c++ string和其他类型互转</a></p>
</blockquote>
<p>但注意，char↔string的转换方法未实现，我们可使用以下方式实现转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">std::string str = c;  <span class="comment">// char → string</span></span><br><span class="line"></span><br><span class="line">c = str[<span class="number">0</span>];  <span class="comment">// string → char</span></span><br></pre></td></tr></table></figure>
<p>下面对常用的转换方法进行介绍。</p>
<ul>
<li>
<p><strong>string→基本类型</strong></p>
<p>常用方法原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string→int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span><span class="params">( <span class="keyword">const</span> std::string&amp; str, std::<span class="keyword">size_t</span>* pos = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="comment">// string→long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">stol</span><span class="params">( <span class="keyword">const</span> std::string&amp; str, std::<span class="keyword">size_t</span>* pos = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="comment">// string→float</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">stof</span><span class="params">( <span class="keyword">const</span> std::string&amp; str, std::<span class="keyword">size_t</span>* pos = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">   <span class="keyword">int</span> a = std::<span class="built_in">stoi</span>(str);</span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">float</span> = std::<span class="built_in">stof</span>(str);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>string←基本类型</strong></p>
<p>常用方法原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">long</span> value )</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">float</span> value )</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">( <span class="keyword">double</span> value )</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">   std::string str1 = std::<span class="built_in">to_string</span>(a);</span><br><span class="line">   <span class="keyword">float</span> b = <span class="number">1.2</span>;</span><br><span class="line">   std::string str1 = std::<span class="built_in">to_string</span>(b);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="string↔char">string↔char[]</h5>
<p>string和char[]数组之间的转换比较简单，因为string内置了相关方法。</p>
<ul>
<li>
<p><strong>char[]← string</strong></p>
<p>如果是字符串常量，C++可以隐式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c_arr[] = <span class="string">&quot;royhuang&quot;</span>;  <span class="comment">// &quot;royhuang&quot;是string类型的字符串常量，可以隐式转换</span></span><br><span class="line">  <span class="keyword">char</span>* p_c_arr = <span class="string">&quot;royhuang&quot;</span>; <span class="comment">// 这里没发生隐式转换，但p_c_arr指向了字符串常量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  对于非字符串常量，`std::string`同样提供了`c_str()` 和 `data()` 等方法，不过要注意：</span><br><span class="line">  </span><br><span class="line">  - 返回类型只能是`const char*` ，也就是必须为常量，且是指针，</span><br><span class="line">  </span><br><span class="line">  ```cpp</span><br><span class="line">std::string str = &quot;royhuang&quot;;</span><br><span class="line">  </span><br><span class="line">const char* c_arr1 = str.c_str();</span><br><span class="line">  const char* c_arr2 = str.data();</span><br><span class="line">  // const char c_arr3[] = str.data();  // 非法</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>char[] → string</strong></p>
<p>string构造函数接受字符串数组：<code>string::string(const char* szCString)</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c_arr[] = <span class="string">&quot;royhuang&quot;</span>;  </span><br><span class="line"></span><br><span class="line">std::string str&#123; c_arr &#125;;  <span class="comment">// 构造函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是如果涉及到字符串分隔符，就比较麻烦点，参考下文处理。</p>
<h5 id="string→其它类型数组">string→其它类型数组</h5>
<p><strong>如果是分割每一个字符为数组元素，可以转换为：string→char[]→其它类型数组</strong>。</p>
<p>下面展示了：string→int[] ，这里使用了容器vector。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; i_arr;</span><br><span class="line">    i_arr.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// tips：预先分配一些空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.先转换为char数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_arr = str3.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">// 2.char数组再转换为其它类型数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c:str3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意是c-&#x27;0&#x27;，不是static_cast&lt;int&gt;(c)</span></span><br><span class="line">        <span class="comment">// c-&#x27;0&#x27;算术类型提升为int</span></span><br><span class="line">        i_arr.<span class="built_in">push_back</span>(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>string←其它类型数组，没啥意义一般很少需要</strong>。</p>
<p>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">45</span>,<span class="number">45</span>,<span class="number">67</span>,<span class="number">144</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>转换为<code>454567144</code> 有啥用呢？一般不需要这么做。更多的反而是怎么将一个int类型转换string。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">string str = std::<span class="built_in">to_string</span>(i);</span><br></pre></td></tr></table></figure>
<p><strong>其实上面介绍都是很特殊的string→数组情况：分割每一个字符为数组元素。但往往我们需要处理的是如何按指定规则分割<u>子串</u>为数组元素</strong>：</p>
<p>比如，如何将：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;12,45,56&quot;</span> ;</span><br></pre></td></tr></table></figure>
<p>转换为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>最常见的便是<u>按指定分隔符来分割字符串</u>为新数组元素。</p>
<h5 id="string指定分割→数组">string指定分割→数组</h5>
<p>对于指定分隔符来分割字符串，再转换为数组。一般而言有如下思路：</p>
<ol>
<li>通过string成员函数：find+substr函数；</li>
<li>通过C语言中分割函数：strtok函数；</li>
<li>通过stringstream实现。</li>
</ol>
<p>这里主要介绍第1种，完整的介绍可参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5876a9f49413">C++字符串分割方法总结</a> 。</p>
<ul>
<li>find函数原型： <code>size_t find (const string&amp; str, size_t pos = 0) const;</code>；</li>
<li>substr函数原型： <code>string substr (size_t pos = 0, size_t len = npos) const;</code> 。</li>
</ul>
<p><strong>以string→int[]为例</strong> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      std::string str = <span class="string">&quot;12,45,56&quot;</span> ;</span><br><span class="line">      std::vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">const</span> std::string pattern = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">      str += pattern;   <span class="comment">// 方便处理最后一个字符串</span></span><br><span class="line">      <span class="keyword">size_t</span>  pre_pos = <span class="number">0</span>; </span><br><span class="line">      <span class="keyword">size_t</span>  pos = str.<span class="built_in">find</span>(pattern);</span><br><span class="line">      <span class="keyword">while</span> (pos != str.npos) <span class="comment">// 如果没找到分隔符则终止</span></span><br><span class="line">      &#123;</span><br><span class="line">          string temp = str.<span class="built_in">substr</span>(pre_pos,pos);</span><br><span class="line">          arr.<span class="built_in">push_back</span>(std::<span class="built_in">stoi</span>(temp));</span><br><span class="line">          <span class="comment">// 保留剩下的字符串作为新串</span></span><br><span class="line">          str = str.<span class="built_in">substr</span>(pos+<span class="number">1</span>,str.<span class="built_in">length</span>());</span><br><span class="line">          <span class="comment">// 查找新字符串第一个分隔符的位置</span></span><br><span class="line">          pos = str.<span class="built_in">find</span>(pattern); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="leetcode实战">leetcode实战</h5>
<p>以经典题型为例，将下面转换为多维数组，第一行输入的是长度。</p>
<blockquote>
<p>3</p>
<p>11  12  13</p>
<p>14  15   16</p>
<p>17   18  19</p>
</blockquote>
<p>完整实现代码如下：可见关键是如何实现分割字符串的函数（面试时这种常用函数最好直接背下）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strSplit</span><span class="params">(<span class="keyword">const</span> std::string src_str, vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">const</span> string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    std::string str = src_str;</span><br><span class="line">    str += pattern;   <span class="comment">// 方便处理最后一个字符串</span></span><br><span class="line">    <span class="keyword">size_t</span>  pre_pos = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">size_t</span>  pos = str.<span class="built_in">find</span>(pattern);</span><br><span class="line">    <span class="keyword">while</span> (pos != str.npos) <span class="comment">// 如果没找到分隔符则终止</span></span><br><span class="line">    &#123;</span><br><span class="line">        string temp = str.<span class="built_in">substr</span>(pre_pos,pos);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">stoi</span>(temp));</span><br><span class="line">        <span class="comment">// 保留剩下的字符串作为新串</span></span><br><span class="line">        str = str.<span class="built_in">substr</span>(pos+<span class="number">1</span>,str.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// 查找新字符串第一个分隔符的位置</span></span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">      <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// std::getline(std::cin,N); // getline不能接受类型int的参数</span></span><br><span class="line">      std::cin&gt;&gt;N;</span><br><span class="line">      std::cin.<span class="built_in">ignore</span>(); <span class="comment">// 读取后面的换行符，getline不需要处理这个问题</span></span><br><span class="line">      </span><br><span class="line">      vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; array ; <span class="comment">// vector比内置数组好用</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;N ; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           std::string cur_line;</span><br><span class="line">           std::<span class="built_in">getline</span>(cin,cur_line);</span><br><span class="line">           vector&lt;<span class="keyword">int</span>&gt; vec_tmp ;</span><br><span class="line">           <span class="built_in">strSplit</span>(cur_line,vec_tmp,<span class="string">&quot; &quot;</span>);</span><br><span class="line">           array.<span class="built_in">push_back</span>(vec_tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最佳实践-5">最佳实践</h5>
<p>不涉及到数组：</p>
<ul>
<li>
<p><strong>如果是基本类型之间的互转</strong>，隐式转换虽然也可以实现，但最好使用<code>static_cast</code>显式转换；</p>
<p>不过需要注意char↔int之间的转换，也许你并不需要char类型的ASCII值。</p>
</li>
<li>
<p><strong>如果是指针、引用、多态、常量转非常量之间的转换</strong>，请使用显示转换；</p>
</li>
<li>
<p><strong>如果string和基本类型转换</strong>，使用<code>std::string</code> 内置的函数库效率最高。</p>
</li>
</ul>
<p>涉及到数组：</p>
<ul>
<li><strong>如果是string↔char[]，不涉及到分割子串</strong>，使用<code>std::string</code> 内置函数可以很方便进行转换；</li>
<li><strong>如果是string→其它类型数组（单向，反向没多大意义），不涉及到分割子串</strong> ，按string→char[]→其它类型数组转换即可；</li>
<li><strong>如果是string→其它类型数组（单向），涉及到分割子串</strong> ：
<ul>
<li>先借助find和substr函数切割出子串数组（string[]）；</li>
<li>再将每个子串转换为其它类型（内置函数实现，如stoi）。</li>
</ul>
</li>
</ul>
<p>最后，请尽量避免使用隐式转换。</p>
<h2 id="更新记录">更新记录</h2>
<div class="timeline">
<div class="timenode"><div class="meta"><p><p>2022-01-22 ：更新笔记</p>
</p></div><div class="body"><ol><li>第一次更新</li></ol></div></div>
</div>
<h2 id="参考资料">参考资料</h2>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中已经有面向对象的概念，那struct还有啥存在的意图：https://www.zhihu.com/question/23174488<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中四种强制类型转换区别详解：https://blog.csdn.net/chen134225/article/details/81305049<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">没有学不会的C++：用户自定义的隐式类型转换 ：https://juejin.cn/post/6844903798100459533<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/6587/">https://hwh.zone/p/6587/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/C-%E5%9F%BA%E7%A1%80/">C++基础</a><a class="post-meta__tags" href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a><a class="post-meta__tags" href="/tags/%E6%9E%9A%E4%B8%BE/">枚举</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">类型转换</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/26224/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++从零开始（二）：务实基础（上）快速入门</div></div></a></div><div class="next-post pull-right"><a href="/p/17506/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++从零开始（三）：面对对象（上）快速入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211214212828.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（一）：环境搭建（上）VSCode远程开发</div></div></a></div><div><a href="/p/60158/" title="C++从零开始（三）：面对对象（下）继承和虚函数"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">C++从零开始（三）：面对对象（下）继承和虚函数</div></div></a></div><div><a href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211215040434.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</div></div></a></div><div><a href="/p/43924/" title="C++从零开始（三）：面对对象（中）运算符重载"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-27</div><div class="title">C++从零开始（三）：面对对象（中）运算符重载</div></div></a></div><div><a href="/p/26224/" title="C++从零开始（二）：务实基础（上）快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">C++从零开始（二）：务实基础（上）快速入门</div></div></a></div><div><a href="/p/51595/" title="C++从零开始（二）：务实基础（下）函数"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-09</div><div class="title">C++从零开始（二）：务实基础（下）函数</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-text">四、复合类型及转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">4.1 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E4%BB%8EC%E8%B0%88%E8%B5%B7"><span class="toc-text">4.1.1 从C谈起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-C-%E4%B8%ADstruct"><span class="toc-text">4.1.2 C++中struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%AF%94%E8%BE%83"><span class="toc-text">4.1.3 结构体大小和比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sizeof-%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F"><span class="toc-text">sizeof 计算结构体大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9Asizeof%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F"><span class="toc-text">扩展：sizeof计算类对象大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F"><span class="toc-text">空类&#x2F;结构体大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83"><span class="toc-text">结构体比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88C-%E8%BF%98%E4%BF%9D%E7%95%99struct%EF%BC%9F"><span class="toc-text">4.1.4 扩展阅读：为什么C++还保留struct？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9E%9A%E4%B8%BE"><span class="toc-text">4.2 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%9E%9A%E4%B8%BE%E5%88%9D%E8%AF%86"><span class="toc-text">4.2.1 枚举初识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E6%98%AF%E6%95%B4%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F"><span class="toc-text">枚举是整数符号常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E6%89%93%E5%8D%B0%E6%9E%9A%E4%B8%BE%E6%95%B0"><span class="toc-text">优雅打印枚举数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%9E%9A%E4%B8%BE%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">认识枚举作用域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E8%8C%83%E5%9B%B4%E6%9E%9A%E4%B8%BE"><span class="toc-text">4.2.2 范围枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%8C%83%E5%9B%B4%E6%9E%9A%E4%B8%BE%EF%BC%9F"><span class="toc-text">为什么需要范围枚举？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9E%9A%E4%B8%BE%E5%88%9D%E8%AF%86"><span class="toc-text">范围枚举初识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2"><span class="toc-text">最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-X-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%F0%9F%8C%9F"><span class="toc-text">4.X 类型转换🌟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-X-1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.X.1 隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BD%AC%E6%8D%A2"><span class="toc-text">标准转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%AB%E8%B8%A9%E5%9D%91%EF%BC%9Achar%E5%92%8Cint%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">别踩坑：char和int的转换？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%F0%9F%8C%9F"><span class="toc-text">用户自定义转换🌟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-3"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-X-2-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.X.2 显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">C风格显式转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">C++显式转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-cast"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const-cast"><span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reinterpret-cast"><span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-4"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-X-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A1%A5%E5%85%85%EF%BC%9Astring"><span class="toc-text">4.X.3 类型转换补充：string</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E2%86%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">string↔基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E2%86%94char"><span class="toc-text">string↔char[]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E2%86%92%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">string→其它类型数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E6%8C%87%E5%AE%9A%E5%88%86%E5%89%B2%E2%86%92%E6%95%B0%E7%BB%84"><span class="toc-text">string指定分割→数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#leetcode%E5%AE%9E%E6%88%98"><span class="toc-text">leetcode实战</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-5"><span class="toc-text">最佳实践</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-text">更新记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/60158/" title="C++从零开始（三）：面对对象（下）继承和虚函数">C++从零开始（三）：面对对象（下）继承和虚函数</a><time datetime="2022-02-08T08:24:59.978Z" title="发表于 2022-02-08 16:24:59">2022-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43924/" title="C++从零开始（三）：面对对象（中）运算符重载">C++从零开始（三）：面对对象（中）运算符重载</a><time datetime="2022-01-27T06:47:34.826Z" title="发表于 2022-01-27 14:47:34">2022-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/17506/" title="C++从零开始（三）：面对对象（上）快速入门">C++从零开始（三）：面对对象（上）快速入门</a><time datetime="2022-01-24T07:37:07.955Z" title="发表于 2022-01-24 15:37:07">2022-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/6587/" title="C++从零开始（二）：务实基础（增）复合类型及转换">C++从零开始（二）：务实基础（增）复合类型及转换</a><time datetime="2022-01-16T13:04:18.006Z" title="发表于 2022-01-16 21:04:18">2022-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <h1 id="tree-toc-title" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/categories/">目 录 </a> </h1>
      <h5 id="tree-toc-subtitle" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/">royhuang's blog</a> </h5>
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）VSCode远程开发</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/60158/" title="C++从零开始（三）：面对对象（下）继承和虚函数"><i class="post-icon gg-file-document"></i>C++从零开始（三）：面对对象（下）继承和虚函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43924/" title="C++从零开始（三）：面对对象（中）运算符重载"><i class="post-icon gg-file-document"></i>C++从零开始（三）：面对对象（中）运算符重载</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/6587/" title="C++从零开始（二）：务实基础（增）复合类型及转换"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（增）复合类型及转换</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/26224/" title="C++从零开始（二）：务实基础（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51595/" title="C++从零开始（二）：务实基础（下）函数"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（下）函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/24237/" title="C++从零开始（二）：务实基础（中）指针和引用"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（中）指针和引用</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/">
          C++进阶
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17506/" title="C++从零开始（三）：面对对象（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（三）：面对对象（上）快速入门</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记（初步整理）"><i class="post-icon gg-file-document"></i>Git基础笔记（初步整理）</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>