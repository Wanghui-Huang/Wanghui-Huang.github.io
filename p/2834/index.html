<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门 | royhuang's blog</title><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 作为一名C&#x2F;C++程序员，g++&#x2F;Makefile&#x2F;CMake等相关工具是必备的基础。但之前使用中一直存在一些困惑，因此参考了一些资料[1][2][3]，动笔写了这篇文章，希望可以帮助自己或大家：  对编译处理过程有个基本认知； 能初步使用编译工具g++&#x2F;Makefile&#x2F;CMake；">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从零开始（二）：环境搭建（下）g++&#x2F;Makefile&#x2F;CMake快速入门">
<meta property="og:url" content="https://hwh.zone/p/2834/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 作为一名C&#x2F;C++程序员，g++&#x2F;Makefile&#x2F;CMake等相关工具是必备的基础。但之前使用中一直存在一些困惑，因此参考了一些资料[1][2][3]，动笔写了这篇文章，希望可以帮助自己或大家：  对编译处理过程有个基本认知； 能初步使用编译工具g++&#x2F;Makefile&#x2F;CMake；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211215040434.png">
<meta property="article:published_time" content="2021-12-05T08:24:40.924Z">
<meta property="article:modified_time" content="2022-02-19T09:58:33.518Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="CMake">
<meta property="article:tag" content="Makefile">
<meta property="article:tag" content="g++">
<meta property="article:tag" content="C++环境搭建">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211215040434.png"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/2834/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-19 17:58:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-19T09:58:33.518Z" title="更新于 2022-02-19 17:58:33">2022-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">从零开始</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">C++环境搭建</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p>
</blockquote>
<div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div>
<p>作为一名C/C++程序员，g++/Makefile/CMake等相关工具是必备的基础。但之前使用中一直存在一些困惑，因此参考了一些资料<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085
">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365
">[2]</span></a></sup><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html
">[3]</span></a></sup>，动笔写了这篇文章，希望可以帮助自己或大家：</p>
<ul>
<li>对编译处理过程有个基本认知；</li>
<li>能初步使用编译工具g++/Makefile/CMake；</li>
<li>能初步使用CMake编译大型项目。</li>
</ul>
<p>才疏学浅，若有错误不吝指正。</p>
<h3 id="g">g++</h3>
<p>在下文中，我们将多次利用了g++编译代码。为了方便后续学习Makefile和CMake，我们先进行简单总结。</p>
<p>以hello.cpp为例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速入门">快速入门</h4>
<p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。</p>
<p>当然，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.cpp -lstdc++ -o hello.out</span><br></pre></td></tr></table></figure>
<p>不过我们还是主要熟悉g++基本用法来编译C++代码。</p>
<ol>
<li>
<p>g++最简单的编译方式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ hello.cpp</span></span><br></pre></td></tr></table></figure>
<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定可执行程序文件名</p>
<p>我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 名为hello.out 的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ hello.cpp -o hello.out</span><br></pre></td></tr></table></figure>
<p>执行 hello.out:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多个 C++ 代码文件</p>
<p>如 a.cpp、b.cpp，编译命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ a.cpp cpp、b.cpp -o test.out</span><br></pre></td></tr></table></figure>
<p>生成一个 test.out可执行文件。</p>
</li>
</ol>
<p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 hello.cpp 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -Wall -std=c++11 hello.cpp -o hello.out</span><br></pre></td></tr></table></figure>
<h4 id="g-常用命令选项">g++ 常用命令选项</h4>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-ansi</td>
<td style="text-align:center">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">只编译并生成目标文件。</td>
</tr>
<tr>
<td style="text-align:center">-DMACRO</td>
<td style="text-align:center">以字符串&quot;1&quot;定义 MACRO 宏。</td>
</tr>
<tr>
<td style="text-align:center">-DMACRO=DEFN</td>
<td style="text-align:center">以字符串&quot;DEFN&quot;定义 MACRO 宏。</td>
</tr>
<tr>
<td style="text-align:center">-E</td>
<td style="text-align:center">只运行 C 预编译器。</td>
</tr>
<tr>
<td style="text-align:center">-g</td>
<td style="text-align:center">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td style="text-align:center">-IDIRECTORY</td>
<td style="text-align:center">指定额外的头文件搜索路径DIRECTORY。</td>
</tr>
<tr>
<td style="text-align:center">-LDIRECTORY</td>
<td style="text-align:center">指定额外的函数库搜索路径DIRECTORY。</td>
</tr>
<tr>
<td style="text-align:center">-lLIBRARY</td>
<td style="text-align:center">连接时搜索指定的函数库LIBRARY。</td>
</tr>
<tr>
<td style="text-align:center">-m486</td>
<td style="text-align:center">针对 486 进行代码优化。</td>
</tr>
<tr>
<td style="text-align:center">-o</td>
<td style="text-align:center">FILE 生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td style="text-align:center">-O0</td>
<td style="text-align:center">不进行优化处理。</td>
</tr>
<tr>
<td style="text-align:center">-O</td>
<td style="text-align:center">或 -O1 优化生成代码。</td>
</tr>
<tr>
<td style="text-align:center">-O2</td>
<td style="text-align:center">进一步优化。</td>
</tr>
<tr>
<td style="text-align:center">-O3</td>
<td style="text-align:center">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td style="text-align:center">-shared</td>
<td style="text-align:center">生成共享目标文件。通常用在建立共享库时。</td>
</tr>
<tr>
<td style="text-align:center">-static</td>
<td style="text-align:center">禁止使用共享连接。</td>
</tr>
<tr>
<td style="text-align:center">-UMACRO</td>
<td style="text-align:center">取消对 MACRO 宏的定义。</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">不生成任何警告信息。</td>
</tr>
<tr>
<td style="text-align:center">-Wall</td>
<td style="text-align:center">生成所有警告信息。</td>
</tr>
</tbody>
</table>
<h3 id="编译过程初探">编译过程初探</h3>
<p>现在让我们从一个简单的例子，来一步步探讨下编译过程。</p>
<p>准备的<code>hello.cpp</code>程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对它进行简单的编译&amp;输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  hello.cpp -o hello.out  <span class="comment"># 文件名可包含指定路径</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当前路径生成了<code>hello.out</code>文件，这是一个可执行的二进制文件。</p>
<p><strong>hello.out本质是什么</strong> ?</p>
<p><strong>一个程序（比如hello.out）本质是由数据段、代码段、.bss段组成。</strong></p>
<p>下图展示了一个虚拟进程（程序）内存空间<u>运行时</u>分布布局（下图.bss段和数据段合并了）：</p>
<ul>
<li>
<p>注意到此时<u>还多了堆&amp;栈用来给程序运行时进行空间分配</u>；</p>
</li>
<li>
<p>高地址的1GB（Linux下如此，Windows默认2GB）空间分配给内核，也称为<strong>内核空间</strong>；剩下的3GB分给用户，也称<strong>用户空间</strong>。</p>
</li>
</ul>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5e8d39d19a216fd03392d36081e70b7e.jpg" alt="你确定你理解内存分配吗？" style="zoom:80%;" />
<ul>
<li>
<p><strong>栈（Stack</strong>）：存储代码中调用函数、定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；</p>
</li>
<li>
<p><strong>文件映射区域 ：</strong> 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 <code>mmap</code> 函数所分配的虚拟地址空间。</p>
</li>
<li>
<p><strong>堆（Heap</strong>）：存储那些生存期<u>与函数调用无关的数据</u>，如动态分配的内存。</p>
</li>
<li>
<p><strong>.bss段</strong>：全称Block Started by Symbol，也就是未被初始化的<strong>全局</strong>变量、<strong>静态</strong>变量的内容的一块内存区域。</p>
</li>
<li>
<p><strong>数据段（.data</strong>）：保存<strong>全局</strong>变量、<strong>常量</strong>、静态变量的内容的一块内存区域，区别.bss段在于变量已经被初始化。比如：</p>
</li>
<li>
<p><strong>代码段（.text &amp; .init</strong>）： <code>.text</code> 用于存放整个程序中的代码； <code>.init</code> 用于存放系统中用来初始化启动你的程序的一段代码 。</p>
</li>
</ul>
<p>回来神来，让我们继续执行一下试试：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208140718480.png" alt="image-20211208140718480"></p>
<p>我们的代码被正确执行了。但这整个过程的细节被隐藏了，如果不了解清楚对我们以后的学习工作阻碍很大。</p>
<p>正式开始接触细节前，我们先大致了解下上述编译过程（四步）：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200423003518622.png" alt="C/C++程序编译的过程| 码农家园"></p>
<ol>
<li><code>预处理</code>：资源进行等价替换，生成<strong>预编译文件</strong>（<strong>.i</strong>文件）；</li>
<li><code>编译</code> ：生成<strong>汇编代码</strong>（<strong>.s</strong>文件）；</li>
<li><code>汇编</code> ：将汇编代码最终生成<strong>机器代码</strong>（<strong>.o</strong>文件）；</li>
<li><code>链接</code>：动态或静态链接外部函数/库(lib)/变量，生成<strong>可执行的二进制(hex)文件/静态库(.a)文件/动态库(.so)文件</strong>。</li>
</ol>
<p>现在让我们来逐步分析。</p>
<h4 id="预处理">预处理</h4>
<p>预处理的主要作用：通过内建功能对<strong>预处理指令进行等价文本替换</strong>。</p>
<p>一般地，<code>C/C++</code> 程序的源代码中包含以 <code>#</code> 开头的各种编译指令，被称为<strong>预处理指令</strong>。根据ANSI C 定义，主要包括：<strong>文件包含、宏定义、条件编译和特殊控制</strong>等4大类<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107
">[7]</span></a></sup>。</p>
<ul>
<li>
<p><strong>文件包含</strong>：例如常用的预处理指令 <code>#include &lt;iostream&gt;</code> ，预编译阶段会使用系统目录下<code>iostream</code>文件中的全部内容，替换 <code>#include &lt;iostream&gt;</code> 。</p>
<blockquote>
<p><code>#include &quot;xxx.h&quot;</code> ，表示使用当前目录下xxx.h文件，<code>&lt;&gt;</code> 是在系统目录下查找。</p>
</blockquote>
</li>
<li>
<p><strong>宏定义展开及处理</strong>： 预处理阶段会将定义的常量符号进行等价替换，e.g. <code>#define A 100</code> , 所有的宏定义符号A都会被替换成<code>100</code>。还会将一些内置的宏展开，比如用于显示文件全路径的<code>__FILE__</code>。</p>
</li>
<li>
<p><strong>条件编译处理</strong>: 如 <code>#ifdef，#ifndef，#else，#elif，#endif</code>等，这些条件编译指令的引入，使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预处理时会将那些不必要的代码过滤掉，防止文件重复包含等。</p>
</li>
<li>
<p>其它：特殊控制处理…</p>
</li>
</ul>
<p>特别的，预处理过程还会发生：</p>
<ul>
<li><strong>添加行号和文件名标识</strong>： 比如在文件<code>hello.i</code>中就有类似 <code># 2 &quot;main.c&quot; 2</code> 的内容，以便于编译时编译器产生调试用的行号信息，编译时产生编译错误或警告时能够显示行号；</li>
<li>清理注释内容等。</li>
</ul>
<p>在这一步，我们亲眼瞧瞧<strong>预处理的等价文本替换</strong>究竟做了什么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E hello.cpp &gt; hello.i  <span class="comment"># 输出文件重定向到hello.i中</span></span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ol>
<li>
<p><strong>文件包含</strong>：我们之前引入的头文件 <code>#include &lt;iostream&gt;</code> ，<strong>预处理后会将<code>#include &lt;iostream&gt;</code> 代码替换为iostream文件的内容，插入到<code>hello.i</code>中</strong>。</p>
<p>文件过长，以下是部分截图：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208235953948.png" alt="image-20211208235953948"></p>
<p>特别的，<strong>iostream文件本身也#include了头文件，同样会被替换</strong>，也就是进行大杂烩嵌套拼接。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200422202617233.png" alt="在这里插入图片描述" style="zoom:80%;" />
</li>
<li>
<p>其它，<u>条件编译处理</u>、<u>添加行号和标识</u>等也一并可以（左图）观察到。</p>
</li>
</ol>
<h4 id="编译">编译</h4>
<p>编译过程是整个程序构建的核心部分，也是最复杂的部分之一，其工作就是把预处理完生成的 <code>.i</code> 文件进行一系列的<strong>词法分析、语法分析、语义分析以及代码优化</strong>，最终产生相应的汇编代码文件，也就是 <code>.s</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S hello.cpp -o hello.s  <span class="comment"># 该命令包含等价替换过程</span></span><br></pre></td></tr></table></figure>
<p>打开当前目录下<code>hello.s</code> ，入目即是熟悉的汇编天书：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208150625682.png" alt="image-20211208150625682"></p>
<h4 id="汇编">汇编</h4>
<p>相对来说比较简单，每个汇编语句都有相对应的机器指令，只需根据汇编代码语法和机器指令的对照表翻译过来就可以了。</p>
<p>有了上述汇编代码后，我们便可以将其转换为机器码（<code>.o</code>文件，即object file）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c hello.cpp -o hello.o  <span class="comment"># -c 表示不进行链接，只生成目标文件</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208151441286.png" alt="image-20211208151441286"></p>
<p>但是在这一步还不能直接执行，会报错：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208151833947.png" alt="image-20211208151833947"></p>
<p>这是因为我们还<strong>没有链接其它相应的文件</strong>，因此会报错。我们来试试链接再生成可执行代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.o -o hello.out</span><br></pre></td></tr></table></figure>
<p>然后执行：<code>./hello.out</code></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211208160023661.png" alt="image-20211208160023661"></p>
<p>假装惊喜的发现（是的就是这么戏精），文件确实已经被成功执行了。</p>
<p>那么，<strong>链接过程中究竟发生了什么？为什么一定要链接后才能执行</strong>？</p>
<h4 id="链接">链接</h4>
<h5 id="链接过程究竟做了什么？">链接过程究竟做了什么？</h5>
<p><strong>链接就是进行符号解析和重定位</strong>的过程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="符号解析：https://www.jianshu.com/p/2786533a34c9
">[4]</span></a></sup>。</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<p><strong>为什么一定要进行符号解析和重定位</strong>？</p>
<p>比如我们上一步生成的可执行文件<code>hello.o</code> 执行出错，就是因为<strong>符号<code>std::cout</code>没有进行解析和重定位</strong>。</p>
<p>在前面预处理阶段，我们知道 <code>#include&lt;iostream&gt;</code> 会被替换为头文件<code>iostream</code>中的内容。</p>
<p>但头文件<code>iostream</code>中的符号，如<code>cout</code>只是被定义，并没有实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> ostream cout;		<span class="comment">/// Linked to standard output</span></span><br></pre></td></tr></table></figure>
<p>具体是在<code>libstdc++.so.6</code>中被实现的。我们必须要让编译器找到<code>libstdc++.so</code>，也就是通过链接，然后将<strong>cout符号解析重定向libstdc++.so中</strong>。这样，<code>cout</code>才可以被正常执行。</p>
<h5 id="准备代码片段">准备代码片段</h5>
<p>为了更清楚的说明整个过程，我们不妨换一个例子，<strong>不使用系统库文件</strong>（预处理后的文件太复杂）。</p>
<ul>
<li>
<p>Main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*,<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="built_in">swap</span>(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Libtest.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到：Libtest.cpp<strong>不引用</strong>任何外部变量符号，但Main.cpp文件会<strong>引用</strong>Libtest.cpp中的<strong>shared变量</strong> 和 <strong>swap函数</strong>。</p>
<p>那么，<strong>Main.cpp中外部符号即shared和swap，怎么样才能被正确解析到Libtest.cpp中</strong>？</p>
<h5 id="链接前置知识">链接前置知识</h5>
<blockquote>
<p>下面有不理解的地方，建议阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fellow1988/p/6158240.html">ELF学习–重定位文件</a></p>
</blockquote>
<p>继续讲解前，我们还需补充几个基本概念<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572
">[5]</span></a></sup>：</p>
<ul>
<li>
<p><strong>符号和外部符号</strong></p>
<ul>
<li>在链接中，我们将函数和变量统称为<strong>符号</strong>（<strong>Symbol</strong>）；</li>
<li>在本目标文件中使用，而又没有在本目标文件中定义的全局符号，称为<strong>外部符号</strong>（<strong>External Symbol</strong>）。</li>
</ul>
</li>
<li>
<p><strong>重定位表</strong></p>
<p>由于<strong>外部符号在编译后并不能确定其位置地址（链接重定位后才能确定</strong>）。所以需要这么一个文件：<strong>将需要重定位的外部符号进行标记</strong>。</p>
<p>比如，编译后<code>Main.o</code> 文件符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Main.cpp -o Main.o # -c参数表示不进行链接</span><br><span class="line">objdump -r Main.o</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可见，<code>shared</code>和<code>swap()</code>为外部符号被标记记录，显然，<strong>这些符号是需要被解析重定向</strong>的。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201402682.png" alt="image-20211227201402682"></p>
</li>
</ul>
<p>但是<strong>Libtest.o中没有外部符号</strong>，因此其重定位表为空。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o Libtest.o</span><br><span class="line">objdump -r Libtest.o</span><br></pre></td></tr></table></figure>
<p>重定位表为空。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227215524264.png" alt="image-20211227215524264"></p>
</li>
<li>
<p><strong>符号表</strong></p>
<p>目标文件使用<strong>符号表</strong>（<strong>Symbol Table</strong>）来记录本目标文件中的<strong>全局符号</strong>的信息。</p>
<p>e.g. <strong>自定义的全局符号地址</strong>，这样别的文件中引用了该自定义的全局符号，就可以查找其真实地址。</p>
<ul>
<li>
<p><strong>Main.o符号表</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s Main.o</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Main.o定义了全局符号<code>main</code>，使用到了外部符号<code>shared</code>和<code>swap</code>。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201514728.png" alt="image-20211227201514728"></p>
<p><code>UND</code> 即表示未定义需要重定义。</p>
</li>
</ul>
</li>
<li>
<p><strong>Libtest.o的符号表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s Libtest.o</span><br></pre></td></tr></table></figure>
<p>Libtest.o定义了符号<code>shared</code>和<code>swap</code>，没有使用到外部符号</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227201608874.png" alt="image-20211227201608874"></p>
</li>
</ul>
</li>
</ul>
<h5 id="静态链接过程">静态链接过程</h5>
<blockquote>
<p><strong>静态链接的主要目的：1）将多个目标文件合并，2）并处理各目标文件用到的外部符号（e.g. main.cpp 中的 swap和shared）</strong>，对外部符号重定位（ 调整地址到真正定义实现的地方，e.g.，swap→Libtest.o），最后生成<strong>可独立运行</strong>的可执行文件。</p>
</blockquote>
<p>现在我们进行静态链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -static Main.cpp Libtest.cpp -o main.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">g++ -c Main.cpp  -o Main.o</span><br><span class="line">g++ -c Libtest.cpp  -o Libtest.o</span><br><span class="line">g++ -static Main.o Libtest.o -o main.out <span class="comment"># 目标文件（可执行文件）静态链接</span></span><br></pre></td></tr></table></figure>
<p>静态链接一般采用<strong>两步链接</strong>（<strong>Two-pass Linking</strong>）的方法，下面以链接 Main.cpp 和 Libtest.cpp为例具体说明。</p>
<p><strong>第一步，空间与地址分配。</strong></p>
<p>扫描<strong>所有的编译生成的可重定向文件（Main.o和Libtest.o）并合并</strong>，同时获得其以下信息：</p>
<ol>
<li>
<p><strong>全局符号表</strong>：包含所有的符号定义和符号引用；</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号名</th>
<th style="text-align:center">状态</th>
<th style="text-align:center">所在目标文件</th>
<th style="text-align:center">…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main</td>
<td style="text-align:center">定义</td>
<td style="text-align:center">Main</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">shared</td>
<td style="text-align:center"><strong>引用</strong></td>
<td style="text-align:center">Main</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">swap</td>
<td style="text-align:center"><strong>引用</strong></td>
<td style="text-align:center">Mian</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">shared</td>
<td style="text-align:center">定义</td>
<td style="text-align:center">Lib</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">swap</td>
<td style="text-align:center">定义</td>
<td style="text-align:center">Lib</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>段信息</strong>：各个段的长度、属性和位置。</p>
</li>
</ol>
<p><strong>第二步，符号解析与重定位。</strong></p>
<ol>
<li>
<p>查看<strong>全局符号表</strong>，发现<code>shared</code>需要重定位；</p>
</li>
<li>
<p>在<strong>全局符号表</strong>发现Libtest.o定义了<code>shared</code>；</p>
</li>
<li>
<p>查看<strong>Libtest.o的符号表</strong>以及第一步的<strong>段信息</strong>，确定<code>shared</code>的地址；</p>
</li>
<li>
<p>再查看<strong>Main.o的重定位表</strong>，找到所有<code>shared</code>需要重定位的地址，修改为<code>shared</code>的真实地址；</p>
<blockquote>
<p>Main.o和Libtest.o被合并，必须要查看重定位表，知道哪些是属于Main的<code>share</code>，进行重定位。</p>
</blockquote>
</li>
<li>
<p>继续查看<strong>全局符号表</strong>，发现<code>swap</code> 需要重定位，过程同上；</p>
</li>
<li>
<p>直至所有的<strong>符号引用都被修改为真实地址</strong>，结束。</p>
</li>
</ol>
<p>我们可以反编译一下最后的可执行文件，看看是否如上所示已经全部重定义完成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d main.out &gt; tmp.txt</span><br></pre></td></tr></table></figure>
<p>例如，主函数中调用的swap函数的地址被修正为40050d。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227204728883.png" alt="image-20211227204728883"></p>
<p><strong>其它信息合并</strong></p>
<p>在静态链接下，链接器还会将<strong>各个目标文件的代码段和数据段【合并拷贝】到可执行文件</strong>，因此静态链接下可执行文件当中<strong>包含了所依赖的所有代码和数据</strong>。</p>
<ul>
<li>
<p>在本例中，Main.o和Libtest.o中的代码段和数据段被合并拷贝到可执行文件中，然后进行解析重定位。</p>
</li>
<li>
<p>下图进行了图解展示合并过程。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/807220-2e1bc10a88be493b" alt="img"></p>
</li>
</ul>
<p>看到这里，相信你已经明白，在静态链接中外部符号：</p>
<ul>
<li><strong>为什么要被解析重定位</strong>：外部符号能被定位到真正实现的地方；</li>
<li><strong>如何被解析重定位</strong>：通过符号表实现。</li>
</ul>
<p>同时，静态链接还会将需要的目标文件进行合并，因此体积比较大。</p>
<h5 id="动态链接过程">动态链接过程</h5>
<p><strong>为什么需要动态链接</strong>？</p>
<p>试试想想以下两种糟糕的情况：</p>
<ul>
<li>
<p><strong>空间浪费</strong>： 假设你是个腾讯技术专家，你写的代码Libtest.cpp性能挺好，于是开源出来<strong>生成一个静态库</strong>给其它人也用用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c Libtest.cpp -o libtest.o</span><br><span class="line">ar cqs libtest.a libtest.o</span><br></pre></td></tr></table></figure>
<p>github反应不错，你的大作很受欢迎，基本机器上每个程序都调用了你的库。但是<strong>由于每个程序都静态链接你的静态库libtest.a，导致每个程序都会【拷贝】Libtest.a中的代码</strong>，造成了很大的空间浪费。</p>
</li>
<li>
<p><strong>更新困难</strong>： 不幸的是，你不但技术精湛<s>头发稀少</s>同时精力旺盛，经常对你的大作libtest.a进行更新。这样你每更新一次，<strong>为了跟上你技术专家的步伐，所有的程序都要重新编译一次，来静态链接拷贝你的最新代码</strong>。情况严重的话，这可能收到一些礼貌的问候。</p>
</li>
</ul>
<p>聪明的你，自然想到号召大家使用<strong>动态链接</strong>：</p>
<ul>
<li>对那些组成程序的目标文件，比如你的libtest，不进行直接链接，而只是将<strong>必要信息写入了可执行文件，等到程序要运行时才进行链接</strong>。这样他们只用下载你大作libtest.so最新的版本，可执行文件运行时就会自动（动态）链接新版本，从而<strong>不用重新编译</strong>了。</li>
</ul>
<p>于是你开心地开始尝试下动态链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment"># 生成的动态库的名字必须是lib+名字.so</span></span><br><span class="line">g++ -shared  -o libtest.so Libtest.cpp</span><br><span class="line"><span class="comment"># 保存在/usr/lib64/下</span></span><br><span class="line">mv libtest.so  /usr/lib64/</span><br><span class="line"><span class="comment"># 动态链接你的大作libtest.so，可以直接使用-ltest来引用</span></span><br><span class="line">g++  Main.cpp  -L/usr/lib64/ -ltest -o main.out</span><br></pre></td></tr></table></figure>
<p>得到可执行文件<code>main.out</code>。</p>
<p>但是<code>main.out</code><strong>仅包含了<code>libtest.so</code> 的相关符号信息</strong>，并没有将 <code>libtest.so</code>和 <code>main.out</code>合并。只有当我们执行 <code>./main.out</code> ，此时才会动态加载<code>Libtest.so</code> 。</p>
<blockquote>
<p>前面提到的<code>hello.out</code>中的<code>std::cout</code> 也是动态链接的：</p>
<ol>
<li>编译生成了可执行文件<code>hello.out</code> ，但此时<code>hello.out</code>只包含了<code>cout</code>符号信息；</li>
<li>执行可执行文件<code>hello.out</code>时 ，根据<code>cout</code>符号信息加载<code>libstdc++.so.6</code> 动态库。</li>
</ol>
</blockquote>
<p>从上也回答本节开头的问题：<strong>动态链接生成的可执行文件体积小，避免了空间浪费，同时灵活性强</strong>。这也就是使用动态链接的主要原因。</p>
<p>那么，动态链接的需要的动态库，和静态链接需要的静态库又是什么呢？</p>
<h5 id="静态库和动态库">静态库和动态库</h5>
<blockquote>
<p>Windows下的静态库和动态库分别为<code>.lib</code>和<code>.dll</code> 结尾的文件，本节中仅以在Linux系统中说明相关概念。</p>
</blockquote>
<p>Linux 下的库有两种<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361">[8]</span></a></sup>：<strong>静态库(.a</strong>)和<strong>共享库（动态库，.so</strong>） ，都采用以下方式进行链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【例】Main.cpp动态链接libtest.so，静态链接需加上-static参数</span></span><br><span class="line"><span class="comment"># -L：指定搜素路径，:可分隔多个路径</span></span><br><span class="line"><span class="comment"># -l：指定库名，前缀&quot;lib&quot;和后缀&quot;.a&quot; 或&quot;.so&quot;省略</span></span><br><span class="line">g++  Main.cpp  -L/usr/lib64/ -ltest -o main.out</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>静态库</strong></p>
<ul>
<li>
<p><strong>特点</strong>：编译过程中已经被载入可执行程序，因此体积较大；</p>
</li>
<li>
<p><strong>命名</strong>：.a为后缀，lib为前缀， 例如 <code>libtest.a</code> ；</p>
</li>
<li>
<p><strong>生成</strong>：先生成<code>.o</code> 文件，再用<code>ar</code>工具可生成；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o libtest.o</span><br><span class="line">ar cqs libtest.a libtest.o</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>链接路径</strong>：</p>
<ol>
<li><strong>参数-L</strong>：ld会去找gcc/g++命令中的参数<code>-L</code>指定的路径；</li>
<li><strong>环境变量</strong>：gcc的环境变量<code>LIBRARY_PATH</code>，它指定程序<strong>静态</strong>链接库文件搜索路径；</li>
<li><strong>默认库</strong>：再找默认库目录 <code>/lib</code>、 <code>/usr/lib</code>、 <code>/usr/local/lib</code>。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>动态库</strong></p>
<ul>
<li>
<p><strong>特点</strong>：可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小；</p>
</li>
<li>
<p><strong>命名</strong>：.so为后缀，lib为前缀，通常还会加上版本号， 例如 <code>libtest.a.0.1</code> ;</p>
</li>
<li>
<p><strong>生成</strong>：<code>g++</code>工具可生成；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Libtest.cpp -o libtest.o</span><br><span class="line">g++ -shared  libtest.o -o libtest.so.1.0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>链接路径</strong>：</p>
<ol>
<li><strong>参数-L</strong>：ld会去找gcc/g++命令中的参数<code>-L</code>指定的路径；</li>
<li><strong>环境变量</strong>：gcc的环境变量<code>LD_LIBRARY_PATH</code>，它指定程序<strong>动态</strong>链接库文件搜索路径；</li>
<li><strong>配置文件</strong>：配置文件 <code>/etc/ld.so.conf</code> 中指定动态库路径；</li>
<li><strong>默认库</strong>：再找默认库目录 <code>/lib</code>、 <code>/usr/lib</code>。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="全过程总结">全过程总结</h4>
<blockquote>
<p>源码到执行全过程分析。</p>
</blockquote>
<p>在linux中程序的加载（不是链接），涉及到linker和loader两个工具。linker主要涉及动态链接库的使用，loader主要涉及软件的加载。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/807220-3b44242bee5ba363" alt="img" style="zoom:80%;" />
<p>上图是一个典型的编译将源文件<code>main.cpp</code> 生成可执行文件<code>myProc.out</code> 并执行的过程 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -L/usr/lib -laaa  -lbbb -o myProc.out </span><br><span class="line">./myProc.out </span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>链接前</strong>：依次按预处理→编译→汇编，生成可执行文件<code>main.o</code> ；</p>
</li>
<li>
<p><strong>链接</strong>：分静态链接和动态链接。</p>
<ul>
<li><strong>静态链接</strong>：对<code>main.o</code> 中未定义的符号进行解析重定位到静态库<code>aaa.o</code> 中，然后把需要的目标文件<code>lib1.o</code> 、<code>lib2.o</code> 和<code>main.o</code> 的.text段、.data段、.bss段进行合并生成初步的可执行文件<code>myProc.out</code> ；</li>
<li><strong>动态链接</strong>：此时<code>main.o</code> 中依旧有部分符号没有被解析，它们的实现存于动态库<code>bbb.so</code>中 ，但动态链接仅将<code>bbb.so</code> 相关<u>符号信息</u>保存在<code>myProc.out</code>中。</li>
</ul>
<p>现在我们获取最终的可执行文件<code>myProc.out</code>。</p>
</li>
<li>
<p><strong>执行</strong>：执行可执行文件。</p>
<p><code>myProc.out</code> 由代码段（.text，只读可执行），数据段（.data，只读），.bss段组成，现在看看如何被加载到内存中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./myProc.out  <span class="comment"># 开始执行程序，通过loader加载器加载程序</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内存映射</strong>。loader启动通过mmap系统调用，将代码段和数据段映射到<u>虚拟内存</u>中 ，不占物理内存；</li>
<li><strong>动态库加载</strong>。动态链接器将编译时指明依赖的动态链接库，映射到虚拟内存中；</li>
<li><strong>执行<code>.text</code> 中指令</strong>。程序开始运行，通常伴随着栈、堆空间分配等。</li>
</ul>
</li>
</ol>
<h3 id="编译工具简介">编译工具简介</h3>
<p>在前面我们简单使用g++进行文件编译、执行。当然，主要还是偏“<strong>务虚</strong>”探讨了下编译的过程及原理。</p>
<p>接下来，我们将偏”<strong>务实</strong>“的介绍一下基本三大编译工具的使用 ：g++/Makefile/CMake。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/catkin.jpg" alt="ROS课程讲义--2.1 Catkin编译系统_jinking01的专栏-CSDN博客"></p>
<p>三者关系如上图所示。</p>
<ul>
<li><strong>gcc/g++</strong>：Linux编译器有gcc/g++，随着源文件的增加，直接用gcc/g++命令的方式<strong>效率较低</strong>，于是发明了Makefile来进行编译；</li>
<li><strong>Makefile</strong>： Makefile描述了整个工程的编译、链接等规则，可以<strong>有效的减少大工程中需要编译和链接的文件，只编译和链接那些需要修改的文件</strong>。然而随着工程体量的增大，Makefile也不能满足需求，于是便出现了Cmake工具；</li>
<li><strong>CMake</strong>：CMake是一个跨平台的编译(Build)工具，可以用简单的语句来描述所有平台的编译过程。早期的make需要程序员写Makefile文件进行编译，而现在CMake能够通过对<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=cmakelists.txt&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2255027085%22%7D">CMakeLists.txt</a>的编辑，<strong>轻松实现对复杂工程的组织</strong>。</li>
</ul>
<p>具体实操练习掌握。</p>
<h3 id="Makefile">Makefile</h3>
<h4 id="快速入门-2">快速入门</h4>
<p>Makefile基本格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>target（目标）</strong> ： 目标文件, 可以是 Object File, 也可以是可执行文件；</p>
</li>
<li>
<p><strong>prerequisites（前置条件）</strong> ： 生成target所需要的文件或者目标；</p>
</li>
<li>
<p><strong>command（命令）</strong>： make需要执行的命令(任意的shell命令)，Makefile中的命令必须以 <code>[tab],即四个空格</code> 开头。</p>
</li>
</ul>
<p><strong>基本语法</strong></p>
<blockquote>
<p>先熟悉以下偏理论总结上的东西，实践时互相验证效果更好~</p>
</blockquote>
<p>Makefile包含了五个重要的东西：<strong>显示规则、隐晦规则、变量定义、文件指示和注释</strong>。</p>
<ul>
<li><strong>显示规则</strong>： 即<strong>需要指明target和prerequisite文件</strong>。
<ul>
<li><u>一条规则可以包含多个target</u>，这意味着其中每个target的prerequisite都是相同的；</li>
<li><u>当其中的一个target被修改后</u>，整个规则中的其他target文件都会被重新编译或执行。</li>
</ul>
</li>
<li><strong>隐晦规则</strong>：make自动推导功能所执行的规则。</li>
<li><strong>变量和定义</strong>：Makefile中定义的变量，一般是字符串。</li>
<li><strong>文件指示</strong>：通常指以下
<ol>
<li>Makefile中引用其他Makefile；</li>
<li>指定Makefile中有效部分；</li>
<li>定义一个多行命令。</li>
</ol>
</li>
<li><strong>注释</strong>：只有行注释<code>#</code> 。</li>
</ul>
<h5 id="一起试试">一起试试</h5>
<p>我们准了一段代码<code>DisplayImage.cpp</code>：使用c++和opencv对图片进行读取和显示。</p>
<p>为了方便阅读，代码已经尽量精简。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    Mat image = cv.<span class="built_in">imread</span>( argv[<span class="number">1</span>], <span class="number">1</span> );</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    cv.<span class="built_in">namedWindow</span>(<span class="string">&quot;Display Image&quot;</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    cv.<span class="built_in">imshow</span>(<span class="string">&quot;Display Image&quot;</span>, image);</span><br><span class="line">    cv.<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先给出已完成的Makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfig</span><br><span class="line"></span><br><span class="line">CXXFLAGS:=<span class="variable">$(<span class="built_in">shell</span> pkg-config --cflgs --libs opencv)</span></span><br><span class="line"></span><br><span class="line"><span class="section">DispalyImage:DispalyImage.o</span></span><br><span class="line">		g++ DispalyImage.o -o DispalyImage</span><br><span class="line"><span class="section">DispalyImage.o:DispalyImage.cpp</span></span><br><span class="line">        g++ -c DispalyImage.cpp -o DispalyImage.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm *o test</span><br></pre></td></tr></table></figure>
<p>现在建议我们<strong>从下往上</strong>分析：</p>
<ol>
<li>
<p><strong>编写clean</strong> ：删除所有的.o文件和可执行文件，避免过多的中间文件产生；</p>
</li>
<li>
<p><strong>编写 DispalyImage.o:DispalyImage.cpp</strong> ：根据之前的格式，<code>target  : prerequisites</code> ，这个时候 <code>target</code> 为   <strong>DispalyImage.o</strong> ，<code>prerequisites</code> 为<strong>DispalyImage.cpp</strong> 。</p>
<p>下一行的g++命令，将cpp文件进行编译为object file（<code>.o</code> 文件）。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">DispalyImage.o:DispalyImage.cpp</span></span><br><span class="line">        g++ -c DispalyImage.cpp -o DispalyImage.o</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>编写 DispalyImage:DispalyImage.o</strong> ：在上一步我们得到了编译后的目标文件 DispalyImage.o 。现在我们可以build生成可执行文件DispalyImage。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">DispalyImage:DispalyImage.o</span></span><br><span class="line">		g++ DispalyImage.o -o DispalyImage</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>应用OpenCV库和头文件</strong> 。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/royhuang/lib/pkgconfig</span><br><span class="line"></span><br><span class="line">CXXFLAGS:=<span class="variable">$(<span class="built_in">shell</span> pkg-config --cflgs --libs opencv)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>PKG_CONFIG_PATH</code> ：添加指定路径到环境变量。如上例，添加了路径<code>/home/royhuang/lib/pkgconfig</code>到环境变量 ，这样我们就可以直接在命令行中使用<code>pkg-config</code>命令 。</p>
</li>
<li>
<p><code>CXXFLAGS</code> ：指定文件（.h文件或lib文件）的路径，使得编译时可以找到相应头文件和库文件。</p>
<p>在本例中，<code>pkg-config</code>命令可查看opencv的include头文件的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --libs 参数可查看库文件</span></span><br><span class="line">shell pkg-config --cflgs  opencv</span><br></pre></td></tr></table></figure>
<p>同时引入头文件和库文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --cflgs --libs opencv</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>有了<code>makefile</code>文件后，我们就可以make生成可执行文件<code>DisplayImage</code>了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动查找当前目录下叫“Makefile”或“makefile”的文件</span></span><br><span class="line">make </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">./DisplayImage ../01.jpg</span><br></pre></td></tr></table></figure>
<p>从上也可总结出：<strong>Makefile 包含了所有的规则和目标，而 make 则是为了完成目标而去解释 Makefile 规则的工具</strong>。</p>
<p>总的来说，Makefile的基本套路就是以上，熟练使用需要实际项目多练习下。</p>
<h4 id="进阶学习">进阶学习</h4>
<p>这里准备举一些较复杂的项目，怎么来编写Makefile文件。</p>
<p>但是一般较复杂的项目我现在一般用<strong>CMake</strong>，也是后文需要介绍的。因此这里复杂项目Makefile编写案例，暂时留白，后续补上。</p>
<p>当然，你可以先看看：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程 - 阮一峰</a> 。</p>
<h3 id="CMake">CMake</h3>
<p>早期的make需要程序员写Makefile文件，进行编译。而现在CMake能够通过对<code>CmakeLists.txt</code>的编辑，轻松实现对复杂工程的组织。</p>
<h4 id="快速入门-3">快速入门</h4>
<p>首先，我们在Linux系统（CentOS）下安装下CMake：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake</span><br></pre></td></tr></table></figure>
<p>一般使用CMake生成Makefile并编译的流程如下：</p>
<ol>
<li>编写<code>CMakeLists.txt</code>，假定其路径为<code>PATH</code>；</li>
<li>执行命令<code>cmake PATH</code>生成Makefile；</li>
<li>最后使用<code>make</code>进行编译。</li>
</ol>
<h5 id="一起试试-2">一起试试</h5>
<p>我们准备一个<code>hello.cpp</code> 文件，它所在的目录如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- build  <span class="comment"># cmake生成的中间文件都放这</span></span><br><span class="line">|-- hello.cpp</span><br><span class="line">|-- CMakeLists.txt <span class="comment"># 每个子目录下都要有CMakeLists.txt文件</span></span><br></pre></td></tr></table></figure>
<p>文件内容很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.cpp */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello Cpp!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们编写的<code>CMakeLists.txt</code>，每一行代码解释如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开</span></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(helloDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限定CMAKE最低版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCS</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. PROJECT_ROOT_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加C++11特性</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable 从一组源文件编译出一个可执行文件 </span></span><br><span class="line"><span class="comment"># 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.out</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.out <span class="variable">$&#123;PROJECT_ROOT_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>开始编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成makefile等中间文件</span></span><br><span class="line"><span class="comment"># 生成的可执行文件 【如果要可以被调试】，还要带上参数：cmake -DCMAKE_BUILD_TYPE:STRING=Debug</span></span><br><span class="line"><span class="built_in">cd</span> ./build  &amp;&amp; cmake ..</span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>最后执行刚刚生成的可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.out</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211209221810181.png" alt="image-20211209221810181"></p>
<p>看到这里，相信你对CMake有了个基本的认知。在前面我们也知道，CMake通常是用来编译大型项目的。</p>
<p>那么，<strong>大型项目结构是什么样的？又如何进行编译呢</strong>？</p>
<h4 id="大型项目结构">大型项目结构</h4>
<blockquote>
<p>主要参考：<a target="_blank" rel="noopener" href="https://github.com/hattonl/cpp-project-structure">cpp-project-structure</a>。</p>
</blockquote>
<p>这里假定项目名为 <code>my_poject</code> ，一个完整的大项目结构通常如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">my_poject  </span><br><span class="line">├── deploy <span class="comment"># 存放部署、交付的文件 </span></span><br><span class="line">│   └── bin      <span class="comment"># 项目生成的可执行文件</span></span><br><span class="line">│   └── lib      <span class="comment"># 项目生成的库文件</span></span><br><span class="line">│   └── include  <span class="comment"># 项目对外提供的头文件</span></span><br><span class="line">├── build  <span class="comment"># 存放cmake产生的中间文件</span></span><br><span class="line">│   └── release</span><br><span class="line">│   └── debug  </span><br><span class="line">├── doc      <span class="comment"># 存放项目文档</span></span><br><span class="line">├── src      <span class="comment"># 存放资源文件</span></span><br><span class="line">│   └── pic            </span><br><span class="line">├── 3rdparty <span class="comment"># 存放第三方库</span></span><br><span class="line">│   └── lib       <span class="comment"># 库文件  </span></span><br><span class="line">│   └── include   <span class="comment"># 头文件</span></span><br><span class="line">├── my_poject <span class="comment"># 项目【代码源文件】</span></span><br><span class="line">|   └── module_1</span><br><span class="line">│        ├── 1.cpp</span><br><span class="line">│        ├── 1.h</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">|   └── module_2</span><br><span class="line">│        ├── 2.cpp</span><br><span class="line">│        ├── 2.h</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">├── tools     <span class="comment"># 项目构建支持工具，如编译器</span></span><br><span class="line">├── scripts   <span class="comment"># 脚本文件，如预处理脚本</span></span><br><span class="line">├── config    <span class="comment"># 配置文件</span></span><br><span class="line">│   └── xxx.yml       </span><br><span class="line">│   └── yyy.yml   </span><br><span class="line">├── <span class="built_in">test</span>      <span class="comment"># 测试代码</span></span><br><span class="line">├── LICENSE   <span class="comment"># 版权信息</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build.sh  <span class="comment"># 构建项目的脚本</span></span><br><span class="line">├── .gitignore</span><br><span class="line">├── README.md <span class="comment"># 项目说明文件</span></span><br><span class="line">└── sample    <span class="comment"># 示例代码</span></span><br></pre></td></tr></table></figure>
<h4 id="编译复杂项目">编译复杂项目</h4>
<p>现在我们举一个复杂点的，<strong>多层级项目</strong>如何用CMake进行编译。</p>
<p>整个目录结构如下（为方便，进行了精简）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|-- 3rdparty </span><br><span class="line">|   |-- include</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- deploy </span><br><span class="line">|   |-- bin</span><br><span class="line">|   `-- lib</span><br><span class="line">|-- build</span><br><span class="line">|-- hello  <span class="comment"># 整个项目源码</span></span><br><span class="line">|   |-- module1</span><br><span class="line">|   |   |-- people.cpp</span><br><span class="line">|   |   |-- people.h</span><br><span class="line">|   |   `-- CMakeLists.txt</span><br><span class="line">|   |-- module2</span><br><span class="line">|   |   |-- bird.cpp</span><br><span class="line">|   |   |-- bird.h</span><br><span class="line">|   |   `-- CMakeLists.txt</span><br><span class="line">|   |-- hello.cpp</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|-- LICENSE</span><br><span class="line">|-- README.md</span><br><span class="line">|-- src</span><br><span class="line">|   `-- video</span><br><span class="line">|       `-- 1577414323962.mp4</span><br></pre></td></tr></table></figure>
<p>其中<code>hello</code>目录下各源文件如下：</p>
<ul>
<li>
<p><code>moule1/people</code> 相关源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*people.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;people.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">people_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;people say : Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*people.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">people_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>moule2/bird</code> 相关源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*bird.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bird_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;bird say : Hello Cpp!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*bird.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bird_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>hello/hello.cpp</code> 源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./module1/people.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./module2/bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">people_hello</span>();</span><br><span class="line">    <span class="built_in">bird_hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后给出各个目录下的CMakeLists.txt文件。</p>
<div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tags-1">module1</button></li><li class="tab"><button type="button" data-href="#tags-2">module2</button></li><li class="tab"><button type="button" data-href="#tags-3">hello</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tags-1"><ul>
<li>
<p><strong>module1</strong></p>
<p>编译生成动态库<code>libmodule1.so</code> 。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录（module1）下的相关文件,并赋值给MODULE1_SRC</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MODULE1_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so</span></span><br><span class="line"><span class="comment"># 【注1】不需要写全libmodule1.so，只需写module即可，cmake会自动补全。</span></span><br><span class="line"><span class="comment"># 【注2】SHARED参数指定生成动态库（.so文件），不加参数默认生成静态库（.a）文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(module1 SHARED <span class="variable">$&#123;MODULE1_SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-2"><ul>
<li>
<p><strong>module2</strong></p>
<p>编译生成动态库<code>libmodule2.so</code> ，基本同前。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录（module2）下的相关文件,并赋值给MODULE2_SRC</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. MODULE2_SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的源文件（MODULE1_SRC）生成库文件libmodule1.so</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(module2 SHARED <span class="variable">$&#123;MODULE2_SRC&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tags-3"><ul>
<li>
<p><strong>hello</strong></p>
<p>编译生成可执行文件<code>hello.out</code> ，然后链接<code>libmodule1.so</code>和 <code>libmodule2.so</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式：&lt;命令名&gt;(参数 参数值) ，中间参数空格隔开</span></span><br><span class="line"><span class="comment"># 设置项目名</span></span><br><span class="line"><span class="keyword">project</span>(helloDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件保存路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/../deploy/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限定CMAKE最低版本</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将module1和module2文件夹加入子目录,这样cmake就可以去其中查找编译</span></span><br><span class="line"><span class="comment"># 【注1】没有这个会报错，ld:找不到 -lmoudle1 和 -lmoudle2</span></span><br><span class="line"><span class="comment"># 【注2】这里只能用相对路径，不是hello项目下的路径，是指</span></span><br><span class="line"><span class="comment">#       build下的相对路径。</span></span><br><span class="line"><span class="comment">#       因为最后make是在build路径下，libmoudule1.so和</span></span><br><span class="line"><span class="comment">#       libmoudule2.so是分别保存在build/moudle1 和build/module2下</span></span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./module1) </span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(./module2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录所有源代码文件，并赋值给PROJECT_ROOT_SRCS</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. PROJECT_ROOT_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加C++11特性</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【编译】</span></span><br><span class="line"><span class="comment"># add_executable 从一组源文件编译出一个可执行文件 </span></span><br><span class="line"><span class="comment"># 这里将$&#123;PROJECT_ROOT_SRCS&#125;中文件编译，生成可执行文件hello.out</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello.out <span class="variable">$&#123;PROJECT_ROOT_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【链接】</span></span><br><span class="line"><span class="comment"># 将目标文件与库文件进行链接，不显示指示文件后缀（如 module1.so），优先链接动态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(</span><br><span class="line">    hello.out </span><br><span class="line">    module2 </span><br><span class="line">    module1</span><br><span class="line">) </span><br></pre></td></tr></table></figure>
<p>特别的，如果你还引用了第三方库，还应该做如下修改。</p>
<blockquote>
<p>假设你引用的第三方库为<code>ffmpeg</code> ，相关头文件和库文件都放在<code>3rdparty</code>目录下。</p>
</blockquote>
<ul>
<li>
<p>增加ffmpeg库文件和头文件搜索路径</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>../<span class="number">3</span>rdparty/inclue)</span><br><span class="line"><span class="comment"># 库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>../<span class="number">3</span>rdparty/lib)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链接ffmepeg相应库</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接ffmpeg库</span></span><br><span class="line"><span class="comment"># 将目标文件与库文件进行链接</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(</span><br><span class="line">    hello.out </span><br><span class="line">    module2 </span><br><span class="line">    module1</span><br><span class="line">    libavcodec.so   <span class="comment"># 显示指定动态库</span></span><br><span class="line">    libavdevice.so  </span><br><span class="line">    libavfilter.so</span><br><span class="line">    libavformat.so</span><br><span class="line">    libavutil.so</span><br><span class="line">    libpostproc.so</span><br><span class="line">    libswresample.so</span><br><span class="line">    libswscale.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>准备好所有的文件后，我们开始进行cmake构建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./build</span><br><span class="line">cmake ../hello &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211210122630662.png" alt="image-20211210122630662"></p>
<p>在<code>bin</code> 下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../deploy/bin/hello.out </span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211210122942175.png" alt="image-20211210122942175"></p>
<p>👨‍💻 CMake相关介绍到此完结。</p>
<h3 id="写在最后">写在最后</h3>
<p>这篇博客主要介绍了编译的基本过程和原理，以及常用的编译工具（g++/Makefile/CMake）使用。</p>
<p>从构思大纲到最后初步完工大概用了五天，比最初预估的进度多花了一倍时间。最主要的原因就是中间我一直在删删改改，特别是写<u>编译过程初探</u>这一节：<strong>每写完一个版本，我就自己先看一遍再问自己：你真的能看明白吗</strong>？还是有些不理解的地方，就继续Google些资料看，直到把自己说服----至少文章逻辑上自恰了。同时也更深刻地体会到了：<strong>自己觉得懂了可能不是真的懂了，能把别人讲明白才可能算是懂了</strong>。</p>
<p>C++环境相关介绍就先告一段落了，接下来准备整理一下<strong>C++基础相关知识</strong>（有事情做的感觉还不错😀 ），回复完论文评审意见后尽快开始更新。</p>
<h3 id="更新记录">更新记录</h3>
<div class="timeline">
<div class="timenode"><div class="meta"><p><p>2022-01-24 ：更新笔记</p>
</p></div><div class="body"><ol><li>增加可执行文件执行过程分析</li></ol></div></div>

<div class="timenode"><div class="meta"><p><p>2021-12-20 ：更新笔记</p>
</p></div><div class="body"><ol><li>增加g++相关介绍</li></ol></div></div>

<div class="timenode"><div class="meta"><p><p>2021-12-10 ：上传初稿</p>
</p></div><div class="body"><ol><li>第一次更新，发布初稿</li></ol></div></div>
</div>
<h3 id="参考资料">参考资料</h3>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">g++，CMake和Makefile了解一下 ： https://zhuanlan.zhihu.com/p/55027085<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Linux下使用CMake编译C++：https://zhuanlan.zhihu.com/p/373256365<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">阮一峰--编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">符号解析：https://www.jianshu.com/p/2786533a34c9<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">计算机原理系列之七-链接过程分析：https://luomuxiaoxiao.com/?p=572<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">静态链接与动态链接在链接过程和文件结构上的区别：https://www.polarxiong.com/<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">gcc编译生成可执行文件的过程中发生了什么：https://blog.csdn.net/albertsh/article/details/89309107<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C/C++中关于静态链接库(.a)、动态链接库（.so）的编译与使用：https://blog.csdn.net/qq_27825451/article/details/105700361<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">cpp_new_features：https://github.com/0voice/cpp_new_features/blob/main/<a href="#fnref:9" rev="footnote"> ↩</a></span></li></ol></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/2834/">https://hwh.zone/p/2834/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/CMake/">CMake</a><a class="post-meta__tags" href="/tags/Makefile/">Makefile</a><a class="post-meta__tags" href="/tags/g/">g++</a><a class="post-meta__tags" href="/tags/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">C++环境搭建</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211215040434.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/62712/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++从零开始（零）</div></div></a></div><div class="next-post pull-right"><a href="/p/18652/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211214212828.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++从零开始（一）：环境搭建（上）VSCode远程开发</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211214212828.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（一）：环境搭建（上）VSCode远程开发</div></div></a></div><div><a href="/p/17506/" title="C++从零开始（七）：面对对象（上）快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-24</div><div class="title">C++从零开始（七）：面对对象（上）快速入门</div></div></a></div><div><a href="/p/60158/" title="C++从零开始（九）：面对对象（下）继承和虚函数"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">C++从零开始（九）：面对对象（下）继承和虚函数</div></div></a></div><div><a href="/p/43924/" title="C++从零开始（八）：面对对象（中）运算符重载"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-27</div><div class="title">C++从零开始（八）：面对对象（中）运算符重载</div></div></a></div><div><a href="/p/6587/" title="C++从零开始（六）：务实基础（下）复合类型及转换"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">C++从零开始（六）：务实基础（下）复合类型及转换</div></div></a></div><div><a href="/p/26224/" title="C++从零开始（三）：务实基础（上）快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">C++从零开始（三）：务实基础（上）快速入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#g"><span class="toc-number">1.</span> <span class="toc-text">g++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">g++ 常用命令选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%9D%E6%8E%A2"><span class="toc-number">2.</span> <span class="toc-text">编译过程初探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">2.2.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96"><span class="toc-number">2.3.</span> <span class="toc-text">汇编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">2.4.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E7%A9%B6%E7%AB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">链接过程究竟做了什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="toc-number">2.4.2.</span> <span class="toc-text">准备代码片段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">链接前置知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.4.</span> <span class="toc-text">静态链接过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.5.</span> <span class="toc-text">动态链接过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">2.4.6.</span> <span class="toc-text">静态库和动态库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">全过程总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">编译工具简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile"><span class="toc-number">4.</span> <span class="toc-text">Makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-2"><span class="toc-number">4.1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%B5%B7%E8%AF%95%E8%AF%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">一起试试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.2.</span> <span class="toc-text">进阶学习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMake"><span class="toc-number">5.</span> <span class="toc-text">CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-3"><span class="toc-number">5.1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%B5%B7%E8%AF%95%E8%AF%95-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">一起试试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">大型项目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE"><span class="toc-number">5.3.</span> <span class="toc-text">编译复杂项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">6.</span> <span class="toc-text">写在最后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-number">7.</span> <span class="toc-text">更新记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/37224/" title="C++从零开始（开源）：一文读懂muduo">C++从零开始（开源）：一文读懂muduo</a><time datetime="2023-03-11T05:48:01.602Z" title="发表于 2023-03-11 13:48:01">2023-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/45495/" title="C++从零开始（十二）：Linux系统编程入门">C++从零开始（十二）：Linux系统编程入门</a><time datetime="2022-04-03T05:45:34.660Z" title="发表于 2022-04-03 13:45:34">2022-04-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/17467/" title="C++从零开始（十一）：C++进阶（下）STL">C++从零开始（十一）：C++进阶（下）STL</a><time datetime="2022-02-14T09:55:49.585Z" title="发表于 2022-02-14 17:55:49">2022-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/51012/" title="C++从零开始（十）：C++进阶（上）模板">C++从零开始（十）：C++进阶（上）模板</a><time datetime="2022-02-11T08:17:22.936Z" title="发表于 2022-02-11 16:17:22">2022-02-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <h1 id="tree-toc-title" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/categories/">目 录 </a> </h1>
      <h5 id="tree-toc-subtitle" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/">royhuang's blog</a> </h5>
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/6587/" title="C++从零开始（六）：务实基础（下）复合类型及转换"><i class="post-icon gg-file-document"></i>C++从零开始（六）：务实基础（下）复合类型及转换</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/26224/" title="C++从零开始（三）：务实基础（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（三）：务实基础（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51595/" title="C++从零开始（五）：务实基础（下）函数"><i class="post-icon gg-file-document"></i>C++从零开始（五）：务实基础（下）函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/24237/" title="C++从零开始（四）：务实基础（中）指针和引用"><i class="post-icon gg-file-document"></i>C++从零开始（四）：务实基础（中）指针和引用</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/">
          C++进阶
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51012/" title="C++从零开始（十）：C++进阶（上）模板"><i class="post-icon gg-file-document"></i>C++从零开始（十）：C++进阶（上）模板</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17467/" title="C++从零开始（十一）：C++进阶（下）STL"><i class="post-icon gg-file-document"></i>C++从零开始（十一）：C++进阶（下）STL</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
          C++环境搭建
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）VSCode远程开发</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/">
          C++面对对象
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17506/" title="C++从零开始（七）：面对对象（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（七）：面对对象（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/60158/" title="C++从零开始（九）：面对对象（下）继承和虚函数"><i class="post-icon gg-file-document"></i>C++从零开始（九）：面对对象（下）继承和虚函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43924/" title="C++从零开始（八）：面对对象（中）运算符重载"><i class="post-icon gg-file-document"></i>C++从零开始（八）：面对对象（中）运算符重载</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">
          Linux系统编程
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45495/" title="C++从零开始（十二）：Linux系统编程入门"><i class="post-icon gg-file-document"></i>C++从零开始（十二）：Linux系统编程入门</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记（初步整理）"><i class="post-icon gg-file-document"></i>Git基础笔记（初步整理）</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>