<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（一）_Java_多线程 | royhuang's blog</title><meta name="keywords" content="JAVA,校招"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（一）_Java_多线程">
<meta property="og:url" content="https://hwh.zone/p/8959/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hwh.zone/img/about-bg.jpg">
<meta property="article:published_time" content="2021-11-26T12:01:58.657Z">
<meta property="article:modified_time" content="2021-12-03T03:56:53.300Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="校招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hwh.zone/img/about-bg.jpg"><link rel="shortcut icon" href="/img/ico-cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/8959/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（一）_Java_多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:56:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">校招笔记（一）_Java_多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-26T12:01:58.657Z" title="发表于 2021-11-26 20:01:58">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:56:53.300Z" title="更新于 2021-12-03 11:56:53">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（一）_Java_多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我的校招记录：<a target="_blank" rel="noopener" href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>算法能力（“刷题”）</strong></td>
<td style="text-align:center">这部分就是耗时间多练习，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td>
<td style="text-align:center">补充练习：<a target="_blank" rel="noopener" href="https://codetop.cc/">codeTop</a></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td>
<td style="text-align:center">C++后端后续更新</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>项目&amp;实习</strong></td>
<td style="text-align:center">主要是怎么准备项目，后续更新</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="1-4-多线程">1.4 多线程</h2>
<h4 id="0-三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1-100呢？交替打印奇偶10次呢？">0.<strong>三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</strong></h4>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/370130458">https://zhuanlan.zhihu.com/p/370130458</a></p>
</blockquote>
<h5 id="0-1-synchronized-条件变量">0.1 <strong>synchronized + 条件变量</strong></h5>
<ol>
<li>
<p><strong>synchronized + 条件变量</strong>（循环打印1次）</p>
<p>思路如下：</p>
<ul>
<li>新建三个线程1、2、3 ，分别负责打印A、B、C；同时，每个线程对应一个条件变量：<code>num%3==当前线程条件变量?</code> ；</li>
<li>把打印的代码用synchronized 加锁，每个线程拿到锁后，<strong>while循环判断</strong>是否满足当前线程的条件变量 ；</li>
<li><strong>如果满足</strong> ，便执行后续逻辑打印当前线程，之后<strong>notifyall()唤醒其它线程</strong>；</li>
<li><strong>如果不满足</strong>，执行wait等待释放锁；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>synchronized + 条件变量</strong>（循环打印10次）</p>
<p>打印10次，只需让三个线程，尝试去竞争10次锁即可。所以在<strong>synchronized前加上for循环</strong>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ACB</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">// targetNum ： 每个线程应该满足的对应条件变量</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) </span><br><span class="line">                &#123;   <span class="comment">// while ：线程阻塞在wait(),再次被唤醒应该先检查下是否满足条件，因为这个时候未必轮到当前线程执行；用if会导致直接往下执行。</span></span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Wait_Notify_ACB  wait_notify_acb = <span class="keyword">new</span> Wait_Notify_ACB ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            wait_notify_acb.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>synchronized + 条件变量</strong>（打印1~100)</p>
<p>设置一个全局变量，synchronized 中加锁函数对num+1，保证只要每次只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_100</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxnum = <span class="number">10</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123; <span class="comment">//想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章</span></span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + num);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_100  wait_notify_100 = <span class="keyword">new</span> Wait_Notify_100 ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>synchronized + 条件变量</strong>（奇偶打印10次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Wait_Notify_Odd_Even</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    Wait_Notify_Odd_Even(<span class="keyword">int</span> initCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOddEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> <span class="comment">// 这里不用while循环判断，是因为下次notifyAll的一定是奇数或偶数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print( Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    System.out.println(++count);</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Wait_Notify_Odd_Even waitNotifyOddEven = <span class="keyword">new</span> Wait_Notify_Odd_Even(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">//为了保证线程odd先拿到锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="0-2-join">0.2 join</h5>
<p><code>join()</code>方法**：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行**。</p>
<p>基于这个原理，我们使得三个线程按顺序执行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——&gt;线程2——&gt;线程3。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Join_ABC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(<span class="keyword">null</span>),<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t1),<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> printABC(t2),<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1-&gt;t2-&gt;t3的执行顺序。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printABC</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">printABC</span><span class="params">(Thread beforeThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(beforeThread!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join(); </span><br><span class="line">                    System.out.print(Thread.currentThread().getName());</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="0-3-Lock">0.3 Lock</h5>
<p>该方法很容易理解，不管哪个线程拿到锁，<strong>只有符合条件的才能打印</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Lock_ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock(); <span class="comment">// 不符合要求直接释放锁，不会像sync一样阻塞在sync或wait处</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock_ABC lockABC = <span class="keyword">new</span> Lock_ABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="0-4-Semaphore">0.4 <strong>Semaphore</strong></h5>
<p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p>
<ul>
<li>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠；</li>
<li>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，<strong>并将信号量内部的计数器加1</strong>，之前进入休眠的线程将被唤醒并再次试图获得信号量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">//因为先执行线程A，所以这里设s1的计数器为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(Semaphore currentThread, Semaphore nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentThread.acquire();       <span class="comment">//阻塞当前线程，即信号量的计数器减1为0</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.release();          <span class="comment">//唤醒下一个线程，即信号量的计数器加1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SemaphoreABC printer = <span class="keyword">new</span> SemaphoreABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s1, s2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s2, s3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s3, s1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-线程基本">1.4.1 线程基本</h3>
<h4 id="1-什么是线程和进程？如何保证线程安全？">1. 什么是线程和进程？<strong>如何保证线程安全？</strong></h4>
<h5 id="1-1-什么是线程和进程？">1.1 什么是线程和进程？</h5>
<ul>
<li>
<p><strong>什么是进程？</strong></p>
<p><strong>进程是程序的⼀次执行过程，是系统运行程序的基本单位</strong>，因此进程是<strong>动态</strong>的。系统运行⼀个程序即是⼀个进程从创建，运行到消亡的过程。</p>
<blockquote>
<p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe ⽂件的运行）。在Windows操作系统中，一个程序只对应一个进程，里面可以有一个或多个线程。</p>
<p><img src="https://i.loli.net/2021/05/16/cxYPKI1LnR4V3Mt.png" alt="image-20210516101110229"></p>
</blockquote>
</li>
<li>
<p><strong>什么是线程？</strong></p>
<p><strong>线程与进程相似，但线程是⼀个⽐进程更小的执行单位</strong>。⼀个进程在其执行的过程中可以产⽣多个线程。</p>
<ul>
<li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有⾃⼰的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li>
</ul>
<p>所以系统在产⽣⼀个线程，或是在各个线程之间作<u>切换⼯作</u>时，<strong>负担要⽐进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p>⼀个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p>
</blockquote>
</li>
</ul>
<h5 id="1-2-如何保证线程安全？">1.2 如何保证线程安全？</h5>
<ol>
<li><strong>原子性</strong>，简单说就是<u>相关操作不会中途被其他线程干扰，一般通过同步机制实现</u>；</li>
<li><strong>可见性</strong>，<u>是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓</u>，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的；</li>
<li><strong>有序性</strong>，<u>是保证线程内串行语义，避免指令重排</u>等。</li>
</ol>
<h5 id="1-3-为什么程序计数器、虚拟机栈和本地方法栈是-u-线程-u-私有的">1.3 为什么程序计数器、虚拟机栈和本地方法栈是<u>线程</u>私有的?</h5>
<ul>
<li>
<p><strong>程序计数器为什么是私有</strong></p>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪⼉了。</p>
<p>所以，程序计数器<u>私有</u>主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
</li>
<li>
<p><strong>虚拟机栈和本地方法栈为什么私有</strong></p>
<ul>
<li>
<p><strong>虚拟机栈</strong>： <u>每个 Java 方法在执行的同时会创建⼀个栈帧用于存储局部变量表、操作数栈、常量池引用等信息</u>。从方法调用直⾄执行完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中<strong>⼊栈和出栈</strong>的过程。</p>
</li>
<li>
<p><strong>本地方法法栈</strong>： 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行</strong> <strong>Java</strong> 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <strong>Native方法服务</strong>。 在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。</p>
</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
</li>
</ul>
<h4 id="2-创建线程的方式（非线程池）？-哪种最好？">2.<strong>创建线程的方式（非线程池）？ 哪种最好？</strong></h4>
<p>一般有三种方式来进行创建：</p>
<ol>
<li>
<p><strong>继承Thread类</strong>：（1）定义Thread类的子类，并重写该类的run方法（2）创建Thread子类的实例对象 （3）调用对象start()方法</p>
<blockquote>
<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用this即可获取当前线程；</li>
<li>缺点：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>实现Runnable接口</strong>：（1）定义runnable接口的<strong>实现类</strong>，并重写该接口的run()方法 （2）创建实现类的实例对象（3）调用线程对象的start()方法来启动该线程</p>
</li>
<li>
<p><strong>通过Callable和Future创建线程</strong>：（1）创建Callable接口的实现类，<strong>并实现call()方法</strong>（2）创建Callable实现类的实例，并使用FutureTask类来包装Callable对象（3）使用FutureTask对象作为Thread对象的target创建并启动新线程（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
</li>
</ol>
<p>其中 <u>实现Runnalbe接口更好</u>  ，使用实现Runnable接口的方式创建的线程<strong>可以处理同一资源</strong>，从而实现资源的共享。</p>
<h4 id="3-如何停止一个正在运行的线程？">3.<strong>如何停止一个正在运行的线程？</strong></h4>
<ol>
<li>
<p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止；</p>
</li>
<li>
<p>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法；</p>
</li>
<li>
<p>使用interrupt方法中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">           sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;week up from blcok...&quot;</span>);</span><br><span class="line">            stop = <span class="keyword">true</span>; <span class="comment">// 在异常处理代码中修改共享变量的状态</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    System.out.println(getName() + <span class="string">&quot; is exiting...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadDemo3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>          InterruptedException </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">          MyThread m1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">          System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">          m1.start();</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;Interrupt thread...: &quot;</span> +           m1.getName());</span><br><span class="line">          m1.stop = <span class="keyword">true</span>; <span class="comment">// 设置共享变量为true</span></span><br><span class="line">          m1.interrupt(); <span class="comment">// 阻塞时退出阻塞状态</span></span><br><span class="line">          Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程休眠3秒以便观察线程m1的中断情况</span></span><br><span class="line">          System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">       &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="4-什么是Daemon线程？它有什么意义？">4.<strong>什么是Daemon线程？它有什么意义？</strong></h4>
<p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p>
<ul>
<li><strong>意义</strong>：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</li>
</ul>
<h4 id="5-说说CyclicBarrier和CountDownLatch的区别？">5.<strong>说说CyclicBarrier和CountDownLatch的区别？</strong></h4>
<p>两个看上去有点像的类，都在<code>java.util.concurrent</code>下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>
<ol>
<li>CyclicBarrier的某个线程运行到某个点上之后，<strong>该线程即停止运行</strong>，<strong>直到所有的线程都到达了这个点</strong>，所有线程才重新运行CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值**-1**而已，该线程继续运行；</li>
<li>CyclicBarrier<strong>只能唤起一个任务</strong>，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，<strong>CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</strong></li>
</ol>
<h4 id="6-请你简要说明一下线程的基本状态以及状态之间的关系？">6.<strong>请你简要说明一下线程的基本状态以及状态之间的关系？</strong></h4>
<p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p>
<ol>
<li><strong>新建状态</strong>：new语句创建的线程对象处于新建状态，仅被分配了内存；</li>
<li><strong>等待状态</strong>： 当线程在new之后，并且<u>在调用start方法前</u>，线程处于等待状态 ;</li>
<li><strong>就绪状态</strong>： 其他线程调用它的**start()**方法，该线程就进入就绪状态，<u>只差等待cpu的使用权 </u> ;</li>
<li><strong>运行状态</strong>： <u>线程占用CPU，执行程序代码</u>  ;</li>
<li><strong>阻塞状态</strong>： 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。<u>阻塞状态分为三种：</u>
<ul>
<li><u>等待阻塞:</u> 运行的线程执行**wait()**方法，JVM会把该线程放入等待池中；</li>
<li><u>同步阻塞:</u> 运行的线程在获取<strong>对象同步锁</strong>时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中；</li>
<li><u>其他阻塞:</u> 运行的线程执行Sleep()方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。</li>
</ul>
</li>
<li><strong>死亡状态</strong>： 线程执行完<strong>run()方法中的代码</strong>，或者遇到了未捕获的异常，就会退出run()方法，结束生命周期</li>
</ol>
<h4 id="7-notify-和notifyAll-有什么区别？">7. <strong>notify()和notifyAll()有什么区别？</strong></h4>
<ul>
<li><strong>notify可能会导致死锁（why？</strong>），而notifyAll则不会；</li>
<li>使用notifyall,可以唤醒 所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</li>
</ul>
<h4 id="8-sleep-和wait-有什么区别？">8. <strong>sleep()和wait() 有什么区别？</strong></h4>
<ul>
<li>
<p><strong>继承的类</strong>：sleep()方法，我们首先要知道该方法是属于Thread类中的；而wait()方法，则是属于Object类中的；</p>
<blockquote>
<p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>。休眠时间期满后，该线程不一定会立即执行被CPU调度，只是到了就绪状态。</p>
</blockquote>
</li>
<li>
<p><strong>是否释放锁</strong>：sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<strong>在调用sleep()方法的过程中，线程不会释放对象锁；当调用wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池；</p>
</li>
<li>
<p><strong>用处</strong>： <strong>Wait 通常被用于线程间交互/通信</strong>，sleep 通常被用于暂停执行；</p>
</li>
<li>
<p><strong>再次唤醒</strong>： wait() 方法被调用后，线程不会⾃动苏醒，需要别的线程调用同⼀个对象上的 notify() 或者notifyAll() 方法。sleep() 方法执行完成后，线程会⾃动苏醒。</p>
</li>
</ul>
<h5 id="8-1-Thread类中的yield方法有什么作用？">8.1 <strong>Thread类中的yield方法有什么作用？</strong></h5>
<p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h5 id="8-2-java-中Wait、Sleep和Yield方法的区别？">8.2 <strong>java 中Wait、Sleep和Yield方法的区别？</strong></h5>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p>
<h4 id="9-volatile-是什么-可以保证有序性吗">9. <strong>volatile 是什么?可以保证有序性吗?</strong></h4>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存；</li>
<li>禁止进行指令重排序。</li>
</ol>
<p><strong>能保证有序性</strong>，因为禁止指令重排。</p>
<h4 id="10-为什么wait-notify-和-notifyAll这些方法不在thread类里面？">10. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/321674476">https://www.zhihu.com/question/321674476</a></p>
<p>明显的原因是<strong>JAVA提供的锁是对象级的而不是线程级的</strong>，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。<u>如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了</u>。</p>
<ul>
<li>简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</li>
</ul>
<h4 id="11-为什么wait和notify方法要在同步块中调用？">11.<strong>为什么wait和notify方法要在同步块中调用？</strong></h4>
<ul>
<li><u>wait()方法<strong>强制当前线程释放对象锁</strong></u>。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法；</li>
<li>在调用对象的notify()和notifyAll()方法之前，<u>调用线程必须<strong>已经得到该对象的锁</strong></u>。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</li>
</ul>
<h4 id="12-（没细看）Java中interrupted-和-isInterruptedd方法的区别？">12. （没细看）<strong>Java中interrupted 和 isInterruptedd方法的区别？</strong></h4>
<p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法。</p>
<h3 id="1-4-2-线程池">1.4.2 线程池</h3>
<h4 id="1-请你解释一下什么是线程池（thread-pool）？">1.<strong>请你解释一下什么是线程池（thread pool）？</strong></h4>
<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，<u>使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</u>。 除此之外：</p>
<ul>
<li>提高性能，利用多线程压榨CPU算力；</li>
<li>提高线程的可管理性，限制线程数量并可以进行统一的分配、调优和监控。</li>
</ul>
<h5 id="1-1-请介绍一下使用线程池任务执行过程？"><strong>1.1 请介绍一下使用线程池任务执行过程？</strong></h5>
<p><strong>核心参数</strong>：其中<code>corePool</code>是核心线程池（保活线程），<code>maximumPool</code>是总线程池（保活线程+工作线程），<code>blockQueue </code>是等待任务队列，<code>rejectedExecutionHandler</code>是拒绝策略：</p>
<p><img src="https://i.loli.net/2021/04/19/Pn4wc5621hqIXpl.png" alt="image-20210419235537833" style="zoom: 33%;" /><img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom: 67%;" /></p>
<p><strong>流程：corePoolSize→队列→maximumPool→拒绝策略</strong></p>
<ol>
<li>未达到corePoolSize时，核心线程池会开辟新线程运行任务（<u>可以使用已有线程吗？</u>），<strong>任务结束后线程不销毁</strong>；</li>
<li>达到corePoolSize，而任务队列未满时，新任务提交到等待队列，<strong>线程空闲时间超过keepAliveTime时被销毁；</strong></li>
<li>任务队列也满了，但未超过最大线程数，新建工作线程执行任务；</li>
<li>超过最大线程数时，<strong>按拒绝策略处理</strong>，包括：<u>抛出异常、使用调用者线程运行任务、丢弃新任务、丢弃队列头任务</u>等。</li>
</ol>
<h5 id="1-2-线程池会回收核心线程吗？">1.2 线程池会回收核心线程吗？</h5>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038836285">线程池是怎么回收空闲线程的</a></p>
</blockquote>
<p>会，可以通过allowCoreThreadTimeOut参数来进行设置。</p>
<ul>
<li>
<p>先回忆一下整体线程池流程</p>
<img src="https://segmentfault.com/img/remote/1460000038860133" alt="iShot2021-01-03 20.18.23.png" style="zoom:67%;" />
</li>
<li>
<p><strong>excute方法</strong></p>
<p>我们的任务放到线程池后，是从调用execute执行开始的。<br>
<img src="https://i.loli.net/2021/05/26/hc4w6ZIbm57CpOQ.png" alt="image-20210526234652655" style="zoom: 67%;" /></p>
<ul>
<li>
<p>核心是addWorker办法， 里面最最重要的就是初始化Worker同时启动thread。</p>
</li>
<li>
<p>Worker实现了Runnable接口，我们直接看它的run方法，看截图的③处标记，抽离出来一个runWorker方法：</p>
<p><img src="https://i.loli.net/2021/05/26/39woAvIR4QjNfxd.png" alt="iShot2021-01-03 20.39.22.png"></p>
<p>也就是说：①处是一个while循环，<strong>getTask</strong>方法就是从线程池队列取任务，<strong>如果取不到任务</strong>就会执行</p>
<p>​                   ②<strong>一旦跳出while循环，即进入到processWorkExit方法，这就是回收Worker</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>getTask方法</strong></p>
<p>可以看到，①判断是否回收线程的条件，<strong>timed</strong> ，有两种情况要回收线程：</p>
<ol>
<li><strong>wc&gt;corePoolSize</strong> ，当前线程数大于核心线程数</li>
<li><strong>allowCoreThreadTimeOut</strong>，核心线程超时，所以<strong>核心线程是会被回收</strong>的</li>
</ol>
<p>然后②处就是从任务队列取任务了，<strong>带了timeOut参数的poll方法超时</strong> ，未能从任务队列获取任务即返回null，从而实现最终的<strong>线程回收</strong>。</p>
<blockquote>
<p>不是processWorkExit处理吗，怎么在getTask处理，还是得好好看看。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/05/26/hxJerXAo16msf38.png" alt="image-20210526235850331"></p>
</li>
</ul>
<h4 id="2-请介绍一下什么是生产者消费者模式？">2.<strong>请介绍一下什么是生产者消费者模式？</strong></h4>
<p><img src="https://uploadfiles.nowcoder.com/images/20180925/308572_1537880635592_7142B8354CA8A352B2B805F997C71549" alt="img"></p>
<p>生产者消费者问题是线程模型中的经典问题：</p>
<ul>
<li>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</li>
</ul>
<h4 id="3-线程池的拒绝策略有哪些？">3.<strong>线程池的拒绝策略有哪些？</strong></h4>
<p>主要有4种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li>
<li><strong>CallerRunsPolicy</strong>：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：<strong>丢弃等待队列中最旧</strong>的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常</li>
</ol>
<h4 id="4-如何创建一个线程池（四大方法）？相关参数（七大参数）是什么">4.<strong>如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</strong></h4>
<p>java通过Executors提供<strong>四大方法</strong>：</p>
<ol>
<li><strong>newCachedThreadPool</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，<strong>可灵活回收空闲线程，若无可回收，则新建线程</strong>；</li>
<li><strong>newFixedThreadPool</strong>：创建一个定长线程池，<u>可控制线程最大并发数</u>，<strong>超出的线程会在<u>队列中等待</u></strong>；</li>
<li><strong>newScheduledThreadPool</strong>：创建一个定长线程池，<u>支持定时及周期性任务执行</u>；</li>
<li><strong>newSingleThreadExecutor</strong>： 创建一个<u>单线程化的线程池</u>，它只会用<strong>唯一的工作线程</strong>来执行任务，保证<u>所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</u>。</li>
</ol>
<p><strong>七大参数设置</strong>：</p>
<ol>
<li>
<p><strong>corePoolSize</strong>：当使用了<code>LinkedBlockingQueue = new LinkedBlockQueue</code>的时候，<strong>队列长度默认无限长</strong>，会导致线程数量永远等于<code>corePoolSize</code>，任务激增时任务响应时间也激增；</p>
</li>
<li>
<p><strong>maximumPoolSize</strong>：线程池中线程个数，增加线程的公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>任务数</mtext><mo>−</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext>原线程数</mtext><mo>÷</mo><mtext>原任务数</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(任务数-queueCapacity) \times (原线程数 \div 原任务数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">任务数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">原线程数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">原任务数</span><span class="mclose">)</span></span></span></span>；</p>
</li>
<li>
<p><strong>keepAliveTime</strong>：线程最大（空闲）存活时间；</p>
</li>
<li>
<p><strong>rejectedExecutionHandler</strong>：线程被拒绝的解决方案，可以自己重写；</p>
</li>
<li>
<p><strong>workQueue</strong> ： 阻塞队列；</p>
</li>
<li>
<p><strong>unit</strong>：keepAliveTime的单位 ；</p>
</li>
<li>
<p><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</p>
</li>
</ol>
<h4 id="5-线程池核心线程数corePoolSize怎么设置呢？">5.<strong>线程池核心线程数corePoolSize怎么设置呢？</strong></h4>
<p>分为CPU密集型和IO密集型来考虑：</p>
<ul>
<li>
<p><strong>CPU密集型</strong>。这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <code>N（CPU 核心数）+1</code>。</p>
<blockquote>
<p><u>比 CPU 核心数多出来的一个线程</u> ：是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
</blockquote>
</li>
<li>
<p><strong>IO密集型</strong>。这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： <code>核心线程数=CPU核心数量*2</code></p>
</li>
</ul>
<h4 id="6-（不熟悉）Java线程池中队列常用类型有哪些？">6.<strong>（不熟悉）Java线程池中队列常用类型有哪些？</strong></h4>
<ul>
<li><code>ArrayBlockingQueue</code> ：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序；</li>
<li><code>LinkedBlockingQueue</code> :一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue ；</li>
<li><code>SynchronousQueue</code> : 一个不存储元素的阻塞队列；</li>
<li><code>PriorityBlockingQueue</code>： 一个具有优先级的无限阻塞队列，PriorityBlockingQueue 也是基于最小二叉堆实现。</li>
</ul>
<h4 id="7-有三个线程T1-T2-T3-如何保证顺序执行？">7.<strong>有三个线程T1,T2,T3,如何保证顺序执行？</strong></h4>
<p>因为在每个线程的run方法中用join()方法限定了三个线程的执行顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// t2线程内run方法最开始，引用t1.join，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// t3线程内run方法最开始，引用t2.join，等待t2线程执行完</span></span><br><span class="line">                        t2.join();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                          &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                         System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//这里三个线程的启动顺序可以任意，大家可以试下！</span></span><br><span class="line">         t3.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-多线程">1.4.3 多线程</h3>
<h4 id="1-请简述一下实现多线程同步的方法？-为什么需要使用多线程？使用多线程会带来什么问题？">1.<strong>请简述一下实现多线程同步的方法？</strong> 为什么需要使用多线程？使用多线程会带来什么问题？</h4>
<ul>
<li>
<p><strong>同步方法</strong>：可以使用synchronized、lock、volatile和ThreadLocal来实现同步。</p>
</li>
<li>
<p><strong>为什么需要使用多线程？</strong></p>
<ul>
<li>减少<strong>上下文切换开销</strong>（共享进程的堆和方法区 ，注意，减少≠没有）</li>
<li>利用好多线程机制可以大大提<strong>高系统整体的并发能⼒</strong>以及性能</li>
<li><strong>多核时代</strong> ：多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算⼀个复杂的任务，我们只用⼀个线程的话，CPU <strong>只会⼀个 CPU 核⼼</strong>被利用到，而创建多个线程就可以让多个 CPU 核⼼被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
</li>
<li>
<p><strong>带来的问题？</strong></p>
<ul>
<li><u>内存泄漏、上下⽂切换、死锁</u>还有受限于硬件和软件的资源闲置问题。</li>
</ul>
</li>
</ul>
<h4 id="2-什么是线程安全？如何保证线程安全？">2. 什么是线程安全？如何保证线程安全？</h4>
<blockquote>
<p>好文：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94762520">一文搞懂CAS</a></p>
</blockquote>
<ul>
<li>
<p><strong>什么是线程安全？</strong></p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。<u>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的</u>，就是线程安全的。</p>
</li>
<li>
<p><strong>如何保证线程安全？</strong></p>
<ol>
<li><strong>使用 synchronized 关键字</strong> 。开销比较大</li>
<li><strong>使用Lock 锁</strong> 。高并发场景下，使用 Lock 锁要比使用synchronized 关键字，在性能上得到极大的提高。因为 Lock 底层是通过 AQS + CAS 机制来实现的。</li>
<li><strong>使用 Atomic 原子类</strong> 。使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，性能较高。</li>
<li><strong>使用Volatile？不可行！</strong> 因为无法保证原子性。</li>
</ol>
</li>
</ul>
<h4 id="3-线程安全需要保证几个基本特征？">3.<strong>线程安全需要保证几个基本特征？</strong></h4>
<ul>
<li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将<br>
线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li>
<li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h4 id="4-【待补充】如何在线程安全的情况下实现一个计数器？">4. 【待补充】<strong>如何在线程安全的情况下实现一个计数器？</strong></h4>
<p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p>
<h4 id="5-多线程中的i-线程安全吗？请简述一下原因？">5.<strong>多线程中的i++线程安全吗？请简述一下原因？</strong></h4>
<p>不安全，因为<strong>i++不是原子性操作</strong>。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p>
<h4 id="6-介绍一下ThreadLocal原理？">6.<strong>介绍一下ThreadLocal原理？</strong></h4>
<blockquote>
<p>一篇讲的不错的文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wupeixuan/p/12638203.html">https://www.cnblogs.com/wupeixuan/p/12638203.html</a></p>
</blockquote>
<p>当多线程访问共享可变数据时，涉及到线程间同步的问题，<u><strong>并不是</strong>所有时候，都要用到共享数据</u>，所以就需要线程封闭出场了。<strong>数据都被封闭在各自的线程之中</strong>，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p>
<p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，<u>每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量</u>，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p>
<ul>
<li>
<p><strong>使用示例</strong></p>
<p>在下面例子中，TreadLocal 做到多个线程对同一对象 set 操作，但是 get 获取的值还都是每个线程 set 的值，体现了线程的封闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal变量，每个线程都有一个副本，互不干扰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 主线程设置值</span></span><br><span class="line">        THREAD_LOCAL.set(<span class="string">&quot;wupx&quot;</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之前，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                <span class="comment">// 此时新建线程Thread-0取到的是null，意味着不同线程取到的值不同的</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">&quot;huxy&quot;</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                System.out.println(<span class="string">&quot;重新设置之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值为：&quot;</span> + v);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 等待所有线程执行结束</span></span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-0线程执行之后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程取到的值：&quot;</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  输出结果 */</span></span><br><span class="line"><span class="comment">// 虽然Thread-0已经改变了值，但是main取到的值依旧是一样的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0线程执行之前，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">Thread-0线程取到的值：null</span></span><br><span class="line"><span class="comment">重新设置之后Thread-0线程取到的值为：huxy</span></span><br><span class="line"><span class="comment">Thread-0线程执行结束</span></span><br><span class="line"><span class="comment">Thread-0线程执行之后，main线程取到的值：wupx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>ThreadLocal原理</strong></p>
<p>ThreadLocal有一个<strong>静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组</strong>，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p>
<p><img src="https://i.loli.net/2021/05/16/MXKyQxYDjWdOku2.png" alt="image-20210516142348550"></p>
<ul>
<li>
<p><strong>ThreadLocalMap</strong></p>
<blockquote>
<p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个<strong>线程有多个 ThreadLocal 对象时</strong>时，需要一个容器来管理多 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p>
</blockquote>
<p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，<strong>Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值</strong>。ThreadLocalMap 解决 hash 冲突的方式采用的是<strong>线性探测法</strong>，如果发生冲突会继续寻找下一个空的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 键值对实体的存储结构</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// 当前线程关联的 value，这个 value 并没有用弱引用追踪</span></span><br><span class="line">		Object value;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 构造键值对</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> k k 作 key,作为 key 的 ThreadLocal 会被包装为一个弱引用</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> v v 作 value</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">			<span class="keyword">super</span>(k);</span><br><span class="line">			value = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始容量，必须为 2 的幂</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存储 ThreadLocal 的键值对实体数组，长度必须为 2 的幂</span></span><br><span class="line">	<span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ThreadLocalMap 元素数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扩容的阈值，默认是数组大小的三分之二</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Set方法</strong></p>
<blockquote>
<p>调用 ThreadLocal对象.set(value)，实际在调用当前线程的ThreadLocalMap对象.set(this,value) ，会把当前 <code>threadLocal</code> 对象作为 key，想要保存的对象作为 value，存入 map。</p>
</blockquote>
<p>set 方法的流程主要是：</p>
<ul>
<li>先获取到当前线程的引用</li>
<li>利用这个引用来获返回当前线程到 ThreadLocalMap</li>
<li>如果 map 为空，则去创建一个 ThreadLocalMap</li>
<li>如果 map 不为空，就利用 ThreadLocalMap 的 <code>set (this当前对象，value)</code> 添加键值对</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前 ThreadLocal 对象关联 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要存储在此线程的线程副本的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回当前ThreadLocal所在的线程</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 返回当前线程持有的map</span></span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果 ThreadLocalMap 不为空，则直接存储&lt;ThreadLocal, T&gt;键值对</span></span><br><span class="line">        <span class="comment">// 此时this是ThreadLocal对象，这是在ThreadLocal类中</span></span><br><span class="line">		map.set(<span class="keyword">this</span>, value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 否则，需要为当前线程初始化 ThreadLocalMap，并存储键值对 &lt;this, firstValue&gt;</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程 thread 持有的 ThreadLocalMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Get方法</strong></p>
<blockquote>
<p>调用ThreadLocal对象.get() 方式时，实际在调用ThreadLocalMap对象.getEntry(this) 方法。this是当前ThreadLocal对象。</p>
</blockquote>
<p>get 方法的主要流程为：</p>
<ul>
<li>先获取到当前线程的引用</li>
<li>获取当前线程内部的 ThreadLocalMap对象</li>
<li>如果 map 存在，则获取当前 ThreadLocal 对应的 value 值</li>
<li>如果 map 不存在或者找不到 value 值，则调用 setInitialValue() 进行初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前 ThreadLocal 对象关联的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回当前 ThreadLocal 所在的线程</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	<span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 从 map 中拿到 entry</span></span><br><span class="line">		ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">			T result = (T) e.value;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若 map 为空，则对当前线程的 ThreadLocal 进行初始化，最后返回当前的 ThreadLocal 对象关联的初值，即 value</span></span><br><span class="line">	<span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>resize 方法</strong></p>
<p>当前线程的 ThreadLocalMap 中的 ThreadLocal 的个数超过容量阈值时，ThreadLocalMap 就要开始扩容了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="7-为什么ThreadLocal造成内存泄漏？">7.<strong>为什么<code>ThreadLocal</code>造成内存泄漏？</strong></h4>
<p>ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多 个ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是管理线程中多个 ThreadLocal。</p>
<blockquote>
<p>源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构：</p>
<p>底层是数组<code>Entry[] table</code>，数组的元素是 Entry类：<strong>Entry 的两个属性， key 是 ThreadLocal类型的引用，value 是 ThreadLocal 的值</strong>。</p>
</blockquote>
<ul>
<li><strong>原因</strong>：<code>ThreadLocalMap</code>的key为<strong>弱引用</strong>（有用但非必需，下一次GC会被回收），value为<strong>强引用</strong>（GC过程不会被回收），<u>有可能造成key被GC，value没被G</u>C，<code>ThreadLocalMap</code>中出现<code>null</code>为key的<code>Entry</code>，产生<u>内存泄漏</u>（<strong>软引用</strong>：有用但非必需，内存溢出之前被回收）；</li>
<li><strong>解决</strong>： 调用<code>set()</code>、<code>get()</code>和<code>remove()</code>方法时，会自动清理掉key为<code>null</code>的记录，但使用<code>ThreadLocal</code>方法后<strong>手动<code>remove()</code></strong>。</li>
</ul>
<h4 id="8-什么是多线程中的上下文切换？">8.<strong>什么是多线程中的上下文切换？</strong></h4>
<p><u>一个线程<strong>让出处理器使用权</strong>，就是“切出”；另外一个线程获取处理器使用权，就是“切入”。</u>在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。</p>
<h4 id="9-请问什么是死锁-deadlock">9.<strong>请问什么是死锁(deadlock)?</strong></h4>
<p>死锁是指<u>两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</u>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p>
<h4 id="10-JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？">10. <strong>JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</strong></h4>
<p><u>最简单方法：<strong>指定获取锁的顺序，并强制线程按照指定的顺序获取锁</strong>。</u></p>
<p>因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。或者通过破坏死锁的四个条件：</p>
<ul>
<li><strong>互斥</strong> ： 不可能破坏。</li>
<li><strong>破坏请求和保持条件</strong>：进程必须 <u>等所有要请求的资源都空闲时才能申请资源</u>， 这种方法会使<strong>资源浪费严重</strong> 。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源。</li>
<li><strong>破坏不可抢占条件</strong>： 方法代价大，实现复杂。</li>
<li><strong>破坏循坏等待条件</strong> ：对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对<u>资源的利用率比前两种都高</u>，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/8959/">https://hwh.zone/p/8959/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a></div><div class="post_share"><div class="social-share" data-image="/img/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/21069/"><img class="prev-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">校招笔记（一）_Java_集合</div></div></a></div><div class="next-post pull-right"><a href="/p/45493/"><img class="next-cover" src="/img/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（一）_Java_锁</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/42516/" title="校招笔记（一）_Java_JVM"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_JVM</div></div></a></div><div><a href="/p/51787/" title="校招笔记（一）_Java_Java入门"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_Java入门</div></div></a></div><div><a href="/p/45493/" title="校招笔记（一）_Java_锁"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_锁</div></div></a></div><div><a href="/p/21069/" title="校招笔记（一）_Java_集合"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_集合</div></div></a></div><div><a href="/p/7257/" title="校招笔记（一）_Java_面对对象"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_面对对象</div></div></a></div><div><a href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><img class="cover" src="/img/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（七）_计算机基础_数据结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.4 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BB%96%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0A%E3%80%81B%E3%80%81C%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%98%AF%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B010%E6%AC%A1%E5%91%A2%EF%BC%9F%E4%BE%9D%E6%AC%A1%E6%89%93%E5%8D%B01-100%E5%91%A2%EF%BC%9F%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B610%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">0.三个线程，如何让他们按顺序打印A、B、C？如果是循环打印10次呢？依次打印1~100呢？交替打印奇偶10次呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1-synchronized-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">0.1 synchronized + 条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-2-join"><span class="toc-text">0.2 join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-3-Lock"><span class="toc-text">0.3 Lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0-4-Semaphore"><span class="toc-text">0.4 Semaphore</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC"><span class="toc-text">1.4.1 线程基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">1. 什么是线程和进程？如何保证线程安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.1 什么是线程和进程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">1.2 如何保证线程安全？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%98%AF-u-%E7%BA%BF%E7%A8%8B-u-%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-text">1.3 为什么程序计数器、虚拟机栈和本地方法栈是线程私有的?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E9%9D%9E%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89%EF%BC%9F-%E5%93%AA%E7%A7%8D%E6%9C%80%E5%A5%BD%EF%BC%9F"><span class="toc-text">2.创建线程的方式（非线程池）？ 哪种最好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">3.如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AFDaemon%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">4.什么是Daemon线程？它有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4CyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5.说说CyclicBarrier和CountDownLatch的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B7%E4%BD%A0%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">6.请你简要说明一下线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7. notify()和notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-sleep-%E5%92%8Cwait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8. sleep()和wait() 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">8.1 Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-java-%E4%B8%ADWait%E3%80%81Sleep%E5%92%8CYield%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8.2 java 中Wait、Sleep和Yield方法的区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-volatile-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E5%90%97"><span class="toc-text">9. volatile 是什么?可以保证有序性吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify-%E5%92%8C-notifyAll%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8thread%E7%B1%BB%E9%87%8C%E9%9D%A2%EF%BC%9F"><span class="toc-text">10. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-text">11.为什么wait和notify方法要在同步块中调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%EF%BC%88%E6%B2%A1%E7%BB%86%E7%9C%8B%EF%BC%89Java%E4%B8%ADinterrupted-%E5%92%8C-isInterruptedd%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">12. （没细看）Java中interrupted 和 isInterruptedd方法的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">1.4.2 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88thread-pool%EF%BC%89%EF%BC%9F"><span class="toc-text">1.请你解释一下什么是线程池（thread pool）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.1 请介绍一下使用线程池任务执行过程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E5%9B%9E%E6%94%B6%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">1.2 线程池会回收核心线程吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">2.请介绍一下什么是生产者消费者模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3.线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E5%9B%9B%E5%A4%A7%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%9F%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%EF%BC%88%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.如何创建一个线程池（四大方法）？相关参数（七大参数）是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0corePoolSize%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%91%A2%EF%BC%9F"><span class="toc-text">5.线程池核心线程数corePoolSize怎么设置呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%EF%BC%88%E4%B8%8D%E7%86%9F%E6%82%89%EF%BC%89Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">6.（不熟悉）Java线程池中队列常用类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9C%89%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1-T2-T3-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">7.有三个线程T1,T2,T3,如何保证顺序执行？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.4.3 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">1.请简述一下实现多线程同步的方法？ 为什么需要使用多线程？使用多线程会带来什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">2. 什么是线程安全？如何保证线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-text">3.线程安全需要保证几个基本特征？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E3%80%90%E5%BE%85%E8%A1%A5%E5%85%85%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="toc-text">4. 【待补充】如何在线程安全的情况下实现一个计数器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84i-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">5.多线程中的i++线程安全吗？请简述一下原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BThreadLocal%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">6.介绍一下ThreadLocal原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocal%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">7.为什么ThreadLocal造成内存泄漏？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">8.什么是多线程中的上下文切换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%AF%B7%E9%97%AE%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81-deadlock"><span class="toc-text">9.请问什么是死锁(deadlock)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-JAVA%E4%B8%AD%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9DN%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEN%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6%E5%8F%88%E4%B8%8D%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">10. JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56326/" title="Hexo快速打造属于自己的网站">Hexo快速打造属于自己的网站</a><time datetime="2021-11-29T12:10:54.202Z" title="发表于 2021-11-29 20:10:54">2021-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&amp;智力题">校招笔记（八）_计算机基础_场景&amp;智力题</a><time datetime="2021-11-26T13:37:19.761Z" title="发表于 2021-11-26 21:37:19">2021-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构">校招笔记（七）_计算机基础_数据结构</a><time datetime="2021-11-26T13:20:04.945Z" title="发表于 2021-11-26 21:20:04">2021-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis">校招笔记（六）_计算机基础_Redis</a><time datetime="2021-11-26T13:16:21.848Z" title="发表于 2021-11-26 21:16:21">2021-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL">校招笔记（五）_计算机基础_MySQL</a><time datetime="2021-11-26T12:57:42.047Z" title="发表于 2021-11-26 20:57:42">2021-11-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>