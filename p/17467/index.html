<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++从零开始（十一）：C++进阶（下）STL | royhuang's blog</title><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 九、STL STL 即“标准模板库”（ “Standard Template Library”） 的缩写， 是C++标准库的一部分，使用时不用单独安装，直接引入头文件即可。 比如： 12# include &lt;vector&gt;  &#x2F;&#x2F; 引入vector# include &lt;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从零开始（十一）：C++进阶（下）STL">
<meta property="og:url" content="https://hwh.zone/p/17467/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 九、STL STL 即“标准模板库”（ “Standard Template Library”） 的缩写， 是C++标准库的一部分，使用时不用单独安装，直接引入头文件即可。 比如： 12# include &lt;vector&gt;  &#x2F;&#x2F; 引入vector# include &lt;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2022-02-14T09:55:49.585Z">
<meta property="article:modified_time" content="2022-02-23T08:37:50.948Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="C++进阶">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/17467/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++从零开始（十一）：C++进阶（下）STL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-23 16:37:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++从零开始（十一）：C++进阶（下）STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-14T09:55:49.585Z" title="发表于 2022-02-14 17:55:49">2022-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-23T08:37:50.948Z" title="更新于 2022-02-23 16:37:50">2022-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">从零开始</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/">C++进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>93分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++从零开始（十一）：C++进阶（下）STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p>
</blockquote>
<div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div>
<h1>九、STL</h1>
<p>STL 即“标准模板库”（ “Standard Template Library”） 的缩写， 是C++标准库的一部分，使用时不用单独安装，直接引入头文件即可。</p>
<p>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>  <span class="comment">// 引入vector</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span>   <span class="comment">// 引入array</span></span></span><br></pre></td></tr></table></figure>
<p>STL发展历史重要时刻一览：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/Ko9ammy.png" alt="Ko9ammy"></p>
<ul>
<li>1987年：贝尔实验室Stepanov 进行C++泛型软件库的研究；</li>
<li>1992年：Alex Stepanov 正式提出 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Standard_Template_Library">STL（Standard Template Library）</a>；</li>
<li>1994年：STL 正式纳入 C++ 标准化进程之中，随者 C++ 标准的改进，STL 也不断做着相应演化；</li>
<li>1998年：ANSI/ISO C++ 标准正式定案，STL 正式成为C++ 标准库不可或缺的重要组成部分。</li>
</ul>
<p>STL 几乎所有的代码都采用了<u>模板类</u>和<u>模版函数</u>的方式，由此提供了很好的代码重用机会。</p>
<p>STL从广义上讲分为三类：</p>
<ul>
<li>
<p><strong>container（容器</strong>），使得我们可以直接使用不同的数据结构，如vector（底层是数组）、list（底层是链表）、map（底层是红黑树）等来组织数据。这为我们高效组织不同数据，提供了极大的方便。</p>
</li>
<li>
<p><strong>algorithm（算法</strong>），则方便了我们对<u>容器（或数组）中的数据</u>进行各种骚操作，如排序（sort）、查找（find）、合并（merge）等。STL算法提供了现成的接口（函数），可以快速实现上述操作。而且一般来说，STL的实现远比我们自身实现的算法要高效，尽量避免自己造轮子，直接使用STL中的接口函数更好。</p>
</li>
<li>
<p><strong>iterator（迭代器</strong>），提供了遍历<u>不同容器（或数组）的元素</u>时的统一访问方式。这得益于STL为每种容器类设计了一个内嵌的<strong>iterator类</strong>，不同的容器都有自己专属的<code>iterator</code>，因此访问不同容器中的数据可统一使用<code>container&lt;type&gt;::iterator</code>方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;    <span class="comment">// vector</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator t = v.<span class="built_in">begin</span>();  <span class="comment">// iterator</span></span><br><span class="line"></span><br><span class="line">array&lt;<span class="keyword">int</span>,5&gt; arr &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// array</span></span><br><span class="line">array&lt;<span class="keyword">int</span>,5&gt;::iterator t = arr.<span class="built_in">begin</span>(); <span class="comment">// iterator</span></span><br></pre></td></tr></table></figure>
<p>普通数组名也可视为一个指向首元素的迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">*(arr++);    <span class="comment">// 2, arr作为迭代器</span></span><br></pre></td></tr></table></figure>
<p>更妙的是，迭代器使得容器和算法的实现<u>可以分开</u>，必要时又可作为“粘合剂”将二者联系起来。</p>
</li>
</ul>
<p>现在我们按：迭代器、容器、算法的顺序依次对STL进行详细介绍。</p>
<h2 id="9-1-迭代器">9.1 迭代器</h2>
<p>正如前述，迭代器用于遍历容器（或数组）中存储的元素。</p>
<h3 id="9-1-1-认识迭代器">9.1.1 认识迭代器</h3>
<h4 id="容器迭代器：iterator">容器迭代器：iterator</h4>
<p>STL 标准库为每一种标准容器定义了迭代器，我们可以按照下面方式进行访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;容器类名&gt;::iterator </span><br></pre></td></tr></table></figure>
<p>就像：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator;</span><br><span class="line">array&lt;<span class="keyword">int</span>,5&gt;::iterator;</span><br></pre></td></tr></table></figure>
<p>这里的类成员<code>&lt;容器类名&gt;::iterator </code>对于不同容器，返回的是不同功能的迭代器。</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双链表</td>
<td style="text-align:center">双向迭代器</td>
</tr>
<tr>
<td style="text-align:center">set / multiset / map / multimap</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">双向迭代器</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单链表</td>
<td style="text-align:center">正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">unordered_map / unordered_set / …</td>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">stack / queue</td>
<td style="text-align:center">对基础容器list、deque等进行封装</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
</tbody>
</table>
<p>上述三种迭代器解释如下：</p>
<blockquote>
<p>以下<code>p</code>、<code>q</code>代表对应的迭代器。</p>
</blockquote>
<ul>
<li>
<p><strong>输入、输出迭代器</strong>：比较特殊，它们不是把容器（或数组）当做操作对象，而是把输入流/输出流作为操作对象。</p>
<ul>
<li>输入迭代器：<u>只读</u>，一次传递 ，为输入迭代器预定义实现只有<code>istream_iterator</code>和<code>istreambuf_iterator</code>，用于从一个输入流中读取数据。其支持的操作符有 *<strong>p,++p,p++,p!=q,p == q</strong> ；</li>
<li>输出迭代器：<u>只写</u>，一次传递 ，为输出迭代器的预定义实现只有<code>ostream_iterator</code>和<code>ostreambuf_iterator</code>，用于向一个输出流写数据。支持的操作符和输入迭代器一致。</li>
</ul>
</li>
<li>
<p><strong>正向迭代器</strong>：结合了输入、输出迭代器几乎所有的功能，支持正向遍历、取值、赋值及相关比较操作。</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p++ 或 ++p</td>
<td style="text-align:center">返回p<strong>后一个</strong>元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">*p</td>
<td style="text-align:center">获取迭代器所指向元素的值</td>
</tr>
<tr>
<td style="text-align:center">p = p+1</td>
<td style="text-align:center">赋值操作</td>
</tr>
<tr>
<td style="text-align:center">p == p+1</td>
<td style="text-align:center">比较操作</td>
</tr>
<tr>
<td style="text-align:center">p != p+1</td>
<td style="text-align:center">比较操作</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>双向迭代器</strong>：具有<u>正向</u>迭代器的全部功能，除此之外还可以向后移动，即<code>--p</code>或<code>p--</code> 。</p>
<table>
<thead>
<tr>
<th style="text-align:center">额外操作（相比正向迭代器）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p-- 或 --p</td>
<td style="text-align:center">返回p前一个元素的迭代器</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>随机访问迭代器</strong>：具有双向迭代器的全部功能，除此之外还可以随机遍历容器元素（显然，指针就是这么一个迭代器）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">额外操作（相比双向迭代器）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p+=i</td>
<td style="text-align:center">p 往后移动 i 个元素</td>
</tr>
<tr>
<td style="text-align:center">p-=i</td>
<td style="text-align:center">p 往前移动 i 个元素</td>
</tr>
<tr>
<td style="text-align:center">p+i</td>
<td style="text-align:center">返回 p 后面第 i 个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">p-i</td>
<td style="text-align:center">返回 p 前面第 i 个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">p[i]</td>
<td style="text-align:center">返回 p 后面第 i 个元素的引用</td>
</tr>
</tbody>
</table>
<p>此外，两个随机访问迭代器 p1、p2 ：</p>
<ul>
<li>可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较；</li>
<li>表达式 p2-p1 也是有定义的，返回区间[p1,p2]的元素个数。</li>
</ul>
</li>
</ul>
<p>再思考不同容器对应的迭代器就很好理解了：</p>
<ul>
<li>底层数据结构是数组的（array/vector/deque），具体随机访问的特性，自然最适合随机迭代器；</li>
<li>底层数据结构是双链表和红黑树的（list/set/map），无法随机访问，但可以前、后方向遍历，所以使用双向迭代器；</li>
<li>底层数据结构是单链表、哈希表的（forward_list/unordered_map / unordered_set），无法随机访问也无法正向遍历，最后只能使用正向迭代器。</li>
</ul>
<p>stack / queue 为了维持特殊的数据访问规则“先进后出” / “先进先出”，不允许前/后/随机迭代器在这里使用，否则会破坏规则。</p>
<h4 id="容器其它迭代器">容器其它迭代器</h4>
<p>每个容器类除了成员<code>iterator</code>还可能有其它的迭代器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">迭代器</th>
<th style="text-align:center">使用格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">默认迭代器</td>
<td style="text-align:center"><code>&lt;容器类名&gt;::iterator</code></td>
</tr>
<tr>
<td style="text-align:center">常量正向迭代器</td>
<td style="text-align:center"><code>&lt;容器类名&gt;::const_iterator</code></td>
</tr>
<tr>
<td style="text-align:center">反向迭代器</td>
<td style="text-align:center"><code>&lt;容器类名&gt;::reverse_iterator</code></td>
</tr>
<tr>
<td style="text-align:center">常量反向迭代器</td>
<td style="text-align:center"><code>&lt;容器类名&gt;::const_reverse_iterator</code></td>
</tr>
</tbody>
</table>
<p>这些迭代器是对类成员<code>iterator</code>的进一步限制。</p>
<ul>
<li>
<p><strong>常量正向/反向迭代器</strong>：保留<code>iterator</code>的基本特性，但常量迭代器无法修改其指向的元素；</p>
</li>
<li>
<p><strong>反向迭代器</strong>：保留<code>iterator</code>的基本特性，但<code>iterator</code>进行 ++ 操作时，迭代器会指向容器中的<strong>后一个</strong>元素；而反向迭代器进行 ++ 操作时，迭代器会指向容器中的<strong>前一个元</strong>素。</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p++ 或 ++p</td>
<td style="text-align:center">返回p<strong>前一个</strong>元素的迭代器</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>不过以上 4 种定义迭代器，并不是每个容器都全部拥有。</p>
<ul>
<li>部分容器同时支持以上 4 种方式，比如 array、deque、vector；</li>
<li>而有些容器只支持部分，例如 forward_list 容器只支持正向迭代器，不支持反向迭代器。</li>
</ul>
<p>以vector为例演示vector类中四种迭代器成员的使用。</p>
<p>同前，vector的<code>iterator</code>是随机迭代器，<u>常量迭代器和反向迭代器只是对<code>iterator</code>的进一步限制，但也具有随机迭代器的基本特性</u>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// vector默认的是随机迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;随机迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>(); </span><br><span class="line">   iter[<span class="number">1</span>] = <span class="number">20</span>;  <span class="comment">// 随机迭代器特性[]</span></span><br><span class="line">   <span class="keyword">for</span>(; iter != vec.<span class="built_in">end</span>() ; iter++)</span><br><span class="line">         std::cout &lt;&lt; *(iter) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 20 3 4 5</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 常量迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;\n常量迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::const_iterator c_iter = vec.<span class="built_in">cbegin</span>(); </span><br><span class="line">   <span class="comment">// c_iter[1] = 20;  // error，只读</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意，rbegin()/crbegin() 返回的是尾元素迭代器</span></span><br><span class="line">   <span class="comment">// 反向迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;\n反向迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator r_iter = vec.<span class="built_in">rbegin</span>(); </span><br><span class="line">   <span class="keyword">for</span>(; r_iter != vec.<span class="built_in">rend</span>() ; r_iter++)</span><br><span class="line">         std::cout &lt;&lt; *(r_iter) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 5 4 3 20 1</span></span><br><span class="line">         </span><br><span class="line">   <span class="comment">// 常量反向迭代器</span></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;\n常量反向迭代器遍历：&quot;</span>;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator cr_iter = vec.<span class="built_in">crbegin</span>(); </span><br><span class="line">   <span class="comment">// c_iter[1] = 20;  // error，只读</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">随机迭代器遍历：1 20 3 4 5 </span><br><span class="line">反向迭代器遍历：5 4 3 20 1 </span><br></pre></td></tr></table></figure>
<p>实际编码中，可用<code>auto</code>关键字减少定义迭代器类型时的书写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); </span><br></pre></td></tr></table></figure>
<p>下文我们会默认采用这种书写方式。更多迭代器的使用示例会穿插在后文中。</p>
<h3 id="9-1-2-迭代器和指针？">9.1.2  迭代器和指针？</h3>
<p>迭代器和指针表现得和指针极为类似，以至于我们会产生疑惑：<strong>迭代器是什么？它就是指针吗</strong>？</p>
<p>先说结论，迭代器不是指针，它只是指针的一层封装，在STL中实现为一个模板类。</p>
<p><strong>为什么要进行这种封装</strong>？</p>
<p>这样可统一不同容器的指针操作。比如，array/list/…底层都是利用指针算术运算查找元素，但具体的行为不同，采用iterator可把底层指针操作抽象出来，根据容器不同的底层数据结构来实现不同的++、–等指针操作。</p>
<p>源码简单观察迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   </span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F12查看<code>vector&lt;int&gt;::iterator</code>定义：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216103721767.png" alt="image-20220216103721767"></p>
<ul>
<li><code>iterator</code>定义在模板类vector中，是<code> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt;</code> 的别名，注意到模板参数<code>pointer</code>；</li>
<li><code>__normal_iterator</code>是linux中STL自定义的迭代器模板，而<code>pointer</code>是普通指针类型别名，这里是<code>int*</code> 。</li>
</ul>
<p>继续进入<code>__normal_iterator</code>类中：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216105723634.png" alt="image-20220216105723634"></p>
<ul>
<li><code>_M_current</code> 类型为<code>_Iterator</code> ，即为<code>pointer</code>（这里是<code>int*</code>），它是一个指针，指向底层数组首元素 。</li>
</ul>
<p>类中还有迭代器的各种操作，以<code>++</code>操作为例：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216111955068.png" alt="image-20220216111955068"></p>
<p>可见迭代器确实只是对指针进行了一层封装，本质还是通过指针实现了各种操作。</p>
<h2 id="9-2-容器">9.2 容器</h2>
<p>STL中的容器也是模板类，本质是封装了不同的基本数据结构（数组、链表等）的模板类。STL提供三种标准容器，分别是：</p>
<ul>
<li>序列容器</li>
<li>排序容器</li>
<li>哈希容器</li>
</ul>
<p>这三种容器主要特点如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器种类</th>
<th style="text-align:center">包含的具体容器</th>
<th>底层数据结构</th>
<th style="text-align:center">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">序列容器</td>
<td style="text-align:center">vector 向量容器、list 列表容器以及 deque 双端队列容器</td>
<td>数组或链表</td>
<td style="text-align:center">序列容器中的元素以<strong>线性方式</strong>存储，但元素不是排好序的</td>
</tr>
<tr>
<td style="text-align:center">排序容器</td>
<td style="text-align:center">set 集合容器、multiset 多重集合容器、map 映射容器以及 multimap 多重映射容器</td>
<td>红黑树</td>
<td style="text-align:center">排序容器中的元素，以<strong>键值对形式</strong>存储，默认是按键值排序好的</td>
</tr>
<tr>
<td style="text-align:center">哈希容器</td>
<td style="text-align:center">unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射</td>
<td>哈希表</td>
<td style="text-align:center">哈希容器中元素同样以<strong>键值对方式</strong>存储，但元素是未排序的，元素的位置由哈希函数确定</td>
</tr>
</tbody>
</table>
<p>下面开始具体介绍。</p>
<h3 id="9-2-1-序列式容器">9.2.1 序列式容器</h3>
<p>本节主要探讨以下容器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">数组</td>
<td style="text-align:center"><strong>大小固定、无法修改</strong></td>
<td style="text-align:center">随机迭代器</td>
</tr>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">大小可变、只能<u>尾部</u>插入/删除</td>
<td style="text-align:center">随机迭代器</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">大小可变、双向队列，头尾可高效插入/删除</td>
<td style="text-align:center">随机迭代器</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双链表</td>
<td style="text-align:center">大小可变，双链表，头尾可高效插入/删除</td>
<td style="text-align:center">双向迭代器</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单链表</td>
<td style="text-align:center">大小可变，单链表，仅可在<u>头部</u>插入/删除</td>
<td style="text-align:center">前向迭代器</td>
</tr>
</tbody>
</table>
<p>它们最主要的区别，由底层数据结构决定。</p>
<h4 id="array">array</h4>
<p>array 容器底层数据结构是普通的<u>静态</u>数组，所以array大小是固定的，无法动态扩展。</p>
<p>array 容器以类模板的形式定义在 <code>&lt;array&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span></span></span><br></pre></td></tr></table></figure>
<p>这里实际是使用模板结构体<code>struct</code>，但在C++中和<code>class</code>差别不大，可以视为类模板。</p>
<p>在 <code>array&lt;_Tp,_Nm&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Nm</code>，用于指明容器的大小。</li>
</ul>
<p>一个简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, 5&gt; arr &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">auto</span> first = arr.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = arr.<span class="built_in">cend</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216180536128.png" alt="image-20220216180536128"></p>
<h5 id="底层实现">底层实现</h5>
<p>本节主要探讨以下问题：</p>
<ul>
<li>array底层数据结构？</li>
<li>array迭代器结构？</li>
</ul>
<p><strong>我们前面说过array底层是一个容量大小固定的数组，它具体是什么样呢</strong>？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 5&gt; arr&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>F12查看<code>array</code>定义：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216181435428.png" alt="image-20220216181435428"></p>
<p>注意到上面红框处的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _GLIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line"><span class="keyword">typename</span> _AT_Type::_Type    _M_elems; <span class="comment">// typename说明_AT_Type::_Type是一个类型</span></span><br></pre></td></tr></table></figure>
<p>成员 <code>_M_elems</code>便是底层数组。要分析出<code>_M_elems</code>类型，首先要知道<code>_AT_Type::_Type</code>是什么意思。</p>
<ul>
<li>
<p>注意到第一行代码，<code>_AT_Type</code>是<code>__array_traits&lt;_Tp, _Nm&gt;</code>的别名，查看<code>__array_traits</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">array_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> _Tp _Type[_Nm]; <span class="comment">// _Type是一个静态数组</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">constexpr</span> _Tp&amp;</span><br><span class="line">   _S_ref(<span class="keyword">const</span> _Type&amp; <span class="keyword">__t</span>, std::<span class="keyword">size_t</span> __n) <span class="keyword">noexcept</span></span><br><span class="line">   &#123; <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;_Tp&amp;&gt;(<span class="keyword">__t</span>[__n]); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以：<code>_AT_Type</code>就是一个array萃取类，而<code>_Type</code>是它的成员，也就是一个静态数组，类型为<code>_Tp[_Nm]</code>。</p>
</li>
</ul>
<p>回到<code>_M_elems</code>相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> _AT_Type::_Type    _M_elems;</span><br></pre></td></tr></table></figure>
<p><code>_M_elems</code>真正面貌便呼之欲出，在这个例子中<code>_Tp</code>为<code>int</code>，<code>_Nm</code>为<code>5</code> ，所以上述等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[<span class="number">5</span>] _M_elems;</span><br></pre></td></tr></table></figure>
<p><strong>每个容器都会有对应的迭代器，array的迭代器是什么</strong>？</p>
<p>说出来你有点惊讶，array的迭代器就简单实现为指针。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217191114160.png" alt="image-20220217191114160"></p>
<ul>
<li><code>iterator</code> 即为<code>_Tp *</code> ；</li>
<li><code>const_iterator</code> 即为<code>const _Tp *</code> 。</li>
</ul>
<p>所以你会发现即使array的<code>iterator</code> 没有实现<code>operator++</code>函数 ，依旧可以这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>,3&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = arr.<span class="built_in">begin</span>();  <span class="comment">// 等价于 int* iter = arr.begin(); </span></span><br><span class="line">iter++; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>因为此时就是对一个<code>int*</code>指针进行<code>++</code>操作。</p>
<p>array让我们可以灵活定义各种类型的数组，保证了安全性又几乎不损失效率。如果想使用静态数组（固定数组），array首选推荐使用。</p>
<h5 id="成员函数">成员函数</h5>
<p>array具有众多的成员函数，方便我们对array进行各种操作。</p>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rbegin()</td>
<td style="text-align:center">返回指向最后一个元素的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rend()</td>
<td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crbegin()</td>
<td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crend()</td>
<td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
</ul>
<p>包含使用的一些小例子</p>
<ul>
<li>
<p><strong>主要成员函数</strong></p>
<p>标粗部分是常用的函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center"><strong>返回容器中当前元素的数量</strong>，其值始终等于初始化 array 类的第二个模板参数 N</td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td>
</tr>
<tr>
<td style="text-align:center"><strong>at(n</strong>)</td>
<td style="text-align:center"><strong>返回容器中 n 位置处元素的引用，作用类似[]</strong>，但该函数还会检查 n 是否有效，无效会抛出 <em>out_of_range</em> 异常</td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器</td>
</tr>
<tr>
<td style="text-align:center">back()</td>
<td style="text-align:center">返回容器中最后一个元素的直接引用，该函数同样不适用于空的 array 容器</td>
</tr>
<tr>
<td style="text-align:center"><strong>data</strong>()</td>
<td style="text-align:center"><strong>返回一个指向容器首个元素的指针</strong>，利用该指针可实现复制容器中所有元素等类似功能</td>
</tr>
<tr>
<td style="text-align:center"><strong>fill(val</strong>)</td>
<td style="text-align:center"><strong>将 val 这个值赋值给容器中的每个元素</strong></td>
</tr>
<tr>
<td style="text-align:center">array1.swap(array2)</td>
<td style="text-align:center">交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>由于这些函数都比较简单，所以就不举例说明啦。</p>
<h4 id="vector">vector</h4>
<p>vector基本是平时最常用的容器之一，和 array 容器类似，底层数据结构都是数组，只不过array是静态数组大小固定，而vector底层是一个动态数组。</p>
<p>最让人欣慰的是，vector会<u>动态扩展（但不会收缩</u>）所占用的内存空间，即自动扩容，我们无需操心数组增长问题。</p>
<p>vector容器以类模板的形式定义在 <code>&lt;vector&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line">		 <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>vector&lt;_Tp,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code> ，用于指明容器中元素数据类型；</li>
<li><code>_Alloc</code> ，内存分配器，默认采用二级配置器，一般不用我们关心。</li>
</ul>
<p>简单使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// vector&lt;int,std::allocator&lt;int&gt;&gt; vec &#123;1,2,3,4,5,6&#125;; // 模板参数完整使用</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&quot;7&quot;</span>); <span class="comment">// 继续插入数据，vector自动扩容，程序员无需关心</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>(); i &lt; vec.<span class="built_in">end</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">        std::cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，相比array，vector可以很方便的使用<code>push_back</code>等方法插入新数据。</p>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h5 id="底层实现-2">底层实现</h5>
<p>在本节我们主要探讨以下问题：</p>
<ul>
<li>vector底层数据结构？</li>
<li>vector底层迭代器如何实现？</li>
<li>vector底层是如何进行初始化的？</li>
<li>vector底层自动扩容机制过程和原理？</li>
</ul>
<p><strong>我们先了解下vector类继承结构及核心成员</strong>。</p>
<p>注意到，vector 继承了 <code>_Vector_base</code> ，<code>_Vector_base</code>专门负责vector的内存管理。</p>
<p><code>_Vector_base</code>核心是内部类<code>_Vector_impl</code> ，它继承了<code>_Tp_alloc_type</code>  获得内存分配释放的功能。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216195801843.png" alt="image-20220216195801843"></p>
<p><code>_Vector_impl</code>核心成员：</p>
<ul>
<li>
<p><code>M_start</code>，<code>_M_finish</code>，<code>_M_end_of_storage</code> ：所有关于地址，容量大小等操作都需要用到这三个指针。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216195950418.png" alt="image-20220216195950418"></p>
<ul>
<li>_M_start ，代表起始位置的指针</li>
<li>_M_finish ，代表已存储的元素的末尾位置</li>
<li>_M_end_of_storage， 代表整个vector空间的结束位置</li>
</ul>
</li>
<li>
<p><code>_M_allocate</code>和<code>_M_deallocate</code>：分别分配和释放vector所用内存，vector只需要负责元素构造和析构。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216200341073.png" alt="image-20220216200341073"></p>
<ul>
<li><code>_M_allocate</code>，最终通过malloc实现内存分配；</li>
<li><code>_M_deallocate</code>，通过free实现内存释放。</li>
</ul>
</li>
</ul>
<p>了解了vector类大致结构，再来依次回答节前的问题：</p>
<ul>
<li>
<p><strong>vector底层数据结构</strong>？</p>
<p>vector底层是一个动态数组，初始化时会让指针<code>_M_start</code> （<code>_Tp*</code>类型）会指向分配内存。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216195950418.png" alt="image-20220216195950418"></p>
</li>
<li>
<p><strong>vector迭代器如何实现</strong>？</p>
<p>同前<u>9.1.2节</u>，在vector类中可找到<code>iterator</code>相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</span><br></pre></td></tr></table></figure>
<p>进入<code>__normal_iterator</code>类中：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216105723634.png" alt="image-20220216105723634"></p>
<ul>
<li>主要成员<code>_M_current</code> 类型为<code>_Iterator</code> ，即为<code>pointer</code>（这里是<code>int*</code>），它是一个指针，指向底层数组首元素 。</li>
</ul>
<p>类中还封装迭代器的各种操作，以<code>++</code>操作为例：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216111955068.png" alt="image-20220216111955068"></p>
</li>
<li>
<p><strong>vector是如何进行初始化的</strong>？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vec &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>vector类在构造时分配初始数组内存。vector类支持多种构造函数，如普通构造函数、移动构造函数、拷贝构造函数等。</p>
<p>以普通构造函数为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @brief  初始化为n个__value值，如果没指定就使用该类型默认值</span></span><br><span class="line"><span class="comment">  *  @param  __n  The number of elements to initially create.</span></span><br><span class="line"><span class="comment">  *  @param  __a  An allocator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type __n, <span class="keyword">const</span> value_type&amp; __value = value_type(),<span class="keyword">const</span> allocator_type&amp; __a = allocator_type())</span></span></span><br><span class="line"><span class="function"> : _Base(__n, __a)</span></span><br><span class="line"><span class="function"> &#123;</span> </span><br><span class="line"> 	 _M_fill_initialize(__n, __value); <span class="comment">// 初始化所有元素为__value</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>核心是调用了基类构造函数<code>_Base(__n, __a)</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt;			 _Base;</span><br></pre></td></tr></table></figure>
<p>在<code>_Vector_base</code> 查到其定义：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216204720395.png" alt="image-20220216204720395"></p>
<p>关键函数<code>_Vector_base::_M_create_storage</code>实现为：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220216204940950.png" alt="image-20220216204940950"></p>
<ul>
<li><code>_M_allocate</code> 最终就是通过<code>_M_impl.allocate</code>实现；</li>
<li><code>_M_impl.allocate</code> 最终通过malloc实现内存分配。</li>
</ul>
<p>综上所述，vector通过构造函数初始化，最终调用malloc分配了底层数组内存空间。</p>
</li>
<li>
<p><strong>vector自动扩容机制实现的过程和原理</strong>？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;7&quot;</span>); <span class="comment">// 继续插入数据，vector自动扩容，程序员无需关心</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;9&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如下所示，左图代表扩容前的存储结构，右图是扩容后的存储结构。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/20200620015208205.png" alt="img"></p>
<p>扩容条件：</p>
<ul>
<li>size()函数返回的是<u>已用空间</u>大小，capacity()返回的是<u>总空间</u>大小，capacity()-size()则是剩余的可用空间大小；</li>
<li><u>当size()和capacity()相等</u>，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</li>
</ul>
<p>扩容过程：</p>
<ol>
<li>重新分配一块<u>两倍</u>于原来大小的内存空间；</li>
<li>将原来的存储空间的元素，依次拷贝到新的<code>2*capacity</code>大小的存储空间之中。</li>
</ol>
</li>
</ul>
<h5 id="成员函数-2">成员函数</h5>
<p>vector具有众多的成员函数，方便我们对vector进行各种操作。</p>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<p>同array。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rbegin()</td>
<td style="text-align:center">返回指向最后一个元素的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rend()</td>
<td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crbegin()</td>
<td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crend()</td>
<td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
<li>
<p><strong>主要成员函数</strong></p>
<p>标粗部分是常用的函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center"><strong>返回容器中当前元素的数量</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>capacity</strong>()</td>
<td style="text-align:center">返回当前容量</td>
</tr>
<tr>
<td style="text-align:center"><strong>reserve</strong>()</td>
<td style="text-align:center">增加容器的容量</td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回容器可容纳元素的最大数量</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td>
</tr>
<tr>
<td style="text-align:center"><strong>at(n</strong>)</td>
<td style="text-align:center"><strong>返回容器中 n 位置处元素的引用，作用类似[]</strong>，但该函数还会检查 n 是否有效，如果不是会抛出 <em>out_of_range</em> 异常</td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回容器中第一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center">back()</td>
<td style="text-align:center">返回容器中最后一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center"><strong>data</strong>()</td>
<td style="text-align:center"><strong>返回一个指向容器首个元素的指针</strong>，利用该指针可实现复制容器中所有元素等类似功能</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:center">交换两个容器的所有元素</td>
</tr>
</tbody>
</table>
<p>相比array独有的方法（可以尾部插入、删除元素等）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>push_back</strong>()</td>
<td style="text-align:center">在容器的尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_back</strong>()</td>
<td style="text-align:center">移出容器尾部的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace_back</strong>()</td>
<td style="text-align:center">在容器的尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:center">移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:center">移出所有的元素，容器大小变为 0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<blockquote>
<p>关于删除vector空间释放有些小问题。</p>
</blockquote>
<p><strong>clear</strong>()、<strong>erase</strong>()方法均不会释放<u>vector</u>所占用的内存空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 5</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>()+<span class="number">1</span>);</span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 4</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 5 , capacity未改变</span></span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 5 , capacity未改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>因为vector内存占用空间只增不减</strong>：</p>
<ul>
<li>分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个；</li>
<li>所有内存空间，在<u>vector对象析构</u>时才能被系统回收。</li>
</ul>
<p>换句话说，<strong>clear</strong>()、<strong>erase</strong>()方法只是减少了vector的<code>size</code>大小，没有改变<code>capacity</code>。</p>
<p>我们可以借助<code>swap</code>方法彻底删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(vec); <span class="comment">// swap</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line">    std::cout&lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 0，彻底删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vector&lt;int&gt;()</code>使用默认构造函数建立临时vector对象，再在该临时对象上调用swap成员；</li>
<li><code>swap</code>调用之后原来vector占用的空间就等于一个默认构造的对象的大小，而临时对象就具有原来对象<code>vec</code>的大小；</li>
<li>临时对象随即被析构，其占用的空间（原来<code>vec</code>的空间）也被释放。</li>
</ul>
<p>另一方面，会动态增长和<u>缩小</u>的容器，如<code>deque</code>，便没有上面烦扰：<strong>clear</strong>()、<strong>erase</strong>()方法删除元素后，其内存也随之缩减。</p>
<p>下节我们一起来认识下吧。</p>
<h4 id="deque">deque</h4>
<p>vector 可以在尾部快速添加和移除元素，虽然<u>理论上</u>也可以在头部进行操作，但因为其底层是一个<u>一维动态数组</u>，因此无论是添加和移除元素都涉及到<u>数组所有元素</u>的移动，效率都奇差，<strong>因此STL相关头部操作的方法<code>vector::push_front()</code>都没有提供</strong>。</p>
<p><strong>deque （双端队列）用于弥补 vector 的不足，在首尾两端都可以快速添加和删除，STL会提供头、尾插入、删除方法（vector头部操作效率低，STL只提供了尾部插入、删除相关方法</strong>），其直观形式表现如下：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/179596b3b6ad50d526ea30ce5a096f1b" alt="img"></p>
<p>不过这种“整体连续”是一种假象，deque底层实际实现为一个<u>二维动态数组</u> 。正式介绍其底层实现前，我们按老规矩先介绍容器上层封装和基本使用。</p>
<p>deque容器以类模板的形式定义在 <code>&lt;deque&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line">	     <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class deque : <span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>deque&lt;_Tp,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Alloc</code>，内存分配器，默认采用二级配置器，一般不用我们关心。</li>
</ul>
<p>简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// deque没有`capacity`()函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> first = d.<span class="built_in">begin</span>(); first != d.<span class="built_in">end</span>(); first++)</span><br><span class="line">    	std::cout&lt;&lt;*first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);  <span class="comment">// size = 5 : 0 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d); <span class="comment">// size = 3 : 1 2 3  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="底层实现-3">底层实现</h5>
<p>本节我们主要探讨以下问题：</p>
<ul>
<li>deque底层数据结构及实现？</li>
<li>deque底层迭代器如何定义？</li>
<li>deque什么时候进行扩容？如何扩容？</li>
<li>deque底层如何插入、删除一个数据？</li>
</ul>
<p><strong>我们先了解下deque类继承结构及核心成员（类似vector继承结构</strong>）。</p>
<p>注意到，deque继承了 <code>_Deque_base</code> ，<code>_Deque_base</code>专门负责vector的内存管理。</p>
<p><code>_Deque_base</code>核心是内部类<code>_Deque_impl</code> ，它继承了<code>_Tp_alloc_type</code>  获得内存分配释放的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      ...</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other  _Tp_alloc_type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">Deque_impl</span>:</span> <span class="keyword">public</span> _Tp_alloc_type</span><br><span class="line">  &#123;</span><br><span class="line">      _Tp** _M_map;   <span class="comment">// map数组，其中的每个元素都是一个指针（节点），指向一块缓冲区</span></span><br><span class="line">      <span class="keyword">size_t</span> _M_map_size;</span><br><span class="line">      iterator _M_start;</span><br><span class="line">      iterator _M_finish;</span><br></pre></td></tr></table></figure>
<p><code>_Deque_impl</code>核心成员：</p>
<ul>
<li>
<p><code>_M_map</code>：二维动态数组map；</p>
</li>
<li>
<p><code>_M_start</code>，<code>_M_finish</code>：迭代器，start 迭代器记录着 map 数组中首个连续空间的信息，finish 迭代器记录着 map 数组中最后一个连续空间的信息。</p>
<p>deque的<code>begin()</code> 和 <code>end()</code> 方法就是通过他们实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _M_start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _M_finish; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>好了，现在我们可以依次回答节前的问题。</p>
<p><strong>我们先探讨第一个问题：deque底层数据结构及实现</strong>？</p>
<p>deque 容器用二维动态数组（数组名假设为 map）存储着各个连续空间的<u>首地址</u> ，每个连续空间是等长的内存缓存区域（下图中的strat和finish对应上面的<code>_M_start</code>和<code>_M_finish</code>）。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217160103198.png" alt="image-20220217160103198"></p>
<p>所以第一个问题答案总结如下：deque底层数据结构就是一个二维数组<code>_Tp**</code> ，由<code>_Deque_impl</code>类负责相关内存分配。</p>
<p>最后补充一点deque类中<code>_Map_pointer</code>介绍。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class deque : <span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Deque_base&lt;_Tp, _Alloc&gt;           _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::_Tp_alloc_type	 _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Tp_alloc_type::pointer           pointer;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="comment">// _Map_pointer，一个二级指针，指向二维数组map</span></span><br><span class="line">      <span class="keyword">typedef</span> pointer*                           _Map_pointer;</span><br></pre></td></tr></table></figure>
<p><code>_Map_pointer</code>是一个二维指针<u>类型</u>。</p>
<blockquote>
<p><code>_Map_pointer</code>其实就是<code>_Tp**</code>：</p>
<p>容易知道，<code>_Map_pointer</code> 是<code>_Deque_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer*</code> 别名；</p>
<ul>
<li>
<p>查看<code>_Tp_alloc_type</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// _Alloc是模板参数设置的分配器，_Tp是模板参数的类型</span></span><br><span class="line">    <span class="comment">// _Tp_alloc_type是空间配置器的类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other  _Tp_alloc_type;</span><br></pre></td></tr></table></figure>
<p><code>_Tp_alloc_type</code> 就是<code>other</code>的别名，经过一番艰难的求知，在<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1831752">三张图带你弄懂STL中内存分配器</a> 中确定：<code>other</code>类型其实是<code>allocator&lt;_Tp1&gt;</code>这个类型，如果我们传参为<code>int</code> 那就是<code>allocator&lt;int&gt;</code> 。</p>
</li>
<li>
<p>查看<code>pointer</code>定义：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217151742421.png" alt="image-20220217151742421"></p>
</li>
</ul>
<p>所以，最终<code>pointer*</code> 等价于<code>__Tp**</code> ，如果我们传入的类型为<code>int</code>，那就是<code>int**</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pointer*   _Map_pointer;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>继续第二个问题：deque迭代器如何定义</strong>？</p>
<p>前面我们说过，<code>_M_start</code>，<code>_M_finish</code>都是<code>iterator</code>类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br></pre></td></tr></table></figure>
<p>查看<code>_Deque_iterator</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Ref, <span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Deque_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">typedef</span> _Tp**                           _Map_pointer;</span><br><span class="line">      <span class="keyword">typedef</span> _Deque_iterator                 _Self;</span><br><span class="line"></span><br><span class="line">      _Tp* _M_cur;   <span class="comment">// 可以看成是原生指针，表示当前的元素位置</span></span><br><span class="line">      _Tp* _M_first; <span class="comment">// 缓冲区开始处，可看成是第二维第一个元素的位置  </span></span><br><span class="line">      _Tp* _M_last;  <span class="comment">// 缓冲区末端的下一个位置，第二维的最后元素的下一个位置  </span></span><br><span class="line">      _Map_pointer _M_node; <span class="comment">// _M_node指向第一维  </span></span><br></pre></td></tr></table></figure>
<p>相比deque的迭代器底层实现 ，<code>vector</code>中的迭代器就底层封装了一个光溜溜的<code>_M_current</code>指针， 简单了很多：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217181847136.png" alt="image-20220217181847136"></p>
<p><strong>第三个问题：deque什么时候进行扩容？如何扩容</strong>？</p>
<p>放一张图：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2-19121316430U40.gif" alt="deque容器的底层实现"></p>
<p>deque何时及如何扩容一目了然：</p>
<ul>
<li>扩容时机：map数组已满；</li>
<li>扩容方式：再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧map数组的空间（不释放map数组中的指针指向的空间）。</li>
</ul>
<p><strong>最后一个问题：deque底层如何插入、删除一个数据</strong>？</p>
<p>如果是插入操作，需分三种情况讨论：在容器的尾部插入、在容器的首部插入、在容器的指定位置前插入元素。这里仅以<u>在容器的尾部插入</u>为例分析。</p>
<ul>
<li>
<p>在容器的尾部插入</p>
<p>此时，<code>cur</code>指向的是含有实际值的下一个位置，<code>last</code>表示最后一个实际值的下一个位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(<span class="keyword">const</span> T&amp; t)</span><br></pre></td></tr></table></figure>
<ol>
<li>找到<code>finish</code>绑定的缓冲区，如果缓存区还有空闲位置（<code>start.cur!=start.last</code>），则在<code>cur</code>位置插入元素，并更新<code>cur++</code> ，否则转2；</li>
<li>没有空闲位置可以插入元素，则在<code>finish.node</code>（这是第一维）的后一个位置申请一个缓冲区（如果map满了，触发扩容），并将<code>finish</code>绑定到该新缓冲区，重复1中步骤插入元素。</li>
</ol>
</li>
</ul>
<p>删除操作类似，同样需要分三种情况：在容器的尾部删除、在容器的首部删除、在容器的指定位置前删除元素。这里仅以<u>在容器的尾部删除</u>为例分析。</p>
<ul>
<li>
<p>在容器的尾部删除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pop_back</span>()</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>找到<code>finish</code>绑定的缓冲区，如果finish所绑定的缓冲区上有1个或多个元素，将最后一个有效元素析构即可destroy(–finish.cur)，否则转2；</p>
</li>
<li>
<p>finish所绑定的缓冲区为空，即<code>finish.cur==finish.first</code>：</p>
<ul>
<li>
<p>先将该空缓冲区的空间释放掉deallocate_node(finish.first)；</p>
</li>
<li>
<p>再将finish绑定到上一个map结点和缓冲区；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">finish.<span class="built_in">set_node</span>(finish.node<span class="number">-1</span>);</span><br><span class="line">finish.cur=finish.last<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后将最后一个元素析（也是当前要删除的元素）构destroy(finish.cur)。</p>
</li>
</ul>
</li>
</ol>
<p><strong>从这里也可以看出，相比vector，deque确实会动态释放内存，不会只增不减</strong>。</p>
</li>
</ul>
<h5 id="成员函数-3">成员函数</h5>
<p>deque具有众多的成员函数，方便我们对deque进行各种操作。</p>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<p>同array，vector。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rbegin()</td>
<td style="text-align:center">返回指向最后一个元素的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rend()</td>
<td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crbegin()</td>
<td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crend()</td>
<td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
<li>
<p><strong>主要成员函数</strong></p>
<p>标粗部分是常用的函数。</p>
<ul>
<li>头、尾操作效率均高，所以会都提供<strong>push_front</strong>()  、<strong>push_front</strong>()等头、尾部等插入、删除方法。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center"><strong>返回容器中当前元素的数量</strong></td>
</tr>
<tr>
<td style="text-align:center"><s>capacity</s></td>
<td style="text-align:center"><s>deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center"><s>reserve</s>()</td>
<td style="text-align:center"><s>deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回容器可容纳元素的最大数量</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td>
</tr>
<tr>
<td style="text-align:center"><strong>at(n</strong>)</td>
<td style="text-align:center"><strong>返回容器中 n 位置处元素的引用，作用类似[]</strong>，但该函数还会检查 n 是否有效，如果不是会抛出 <em>out_of_range</em> 异常</td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回容器中第一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center">back()</td>
<td style="text-align:center">返回容器中最后一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center"><s>data</s>()</td>
<td style="text-align:center"><s>deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:center">交换两个容器的所有元素</td>
</tr>
</tbody>
</table>
<p>相比array独有的方法（可以<u>头、尾</u>部插入、删除元素等）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>push_back</strong>()</td>
<td style="text-align:center">在容器的尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace_back</strong>()</td>
<td style="text-align:center">在容器的尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>push_front</strong>()</td>
<td style="text-align:center">在容器的头部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace_front</strong>()</td>
<td style="text-align:center">在容器头部生成一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:center">移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:center">移出所有的元素，容器大小变为 0</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_back</strong>()</td>
<td style="text-align:center">移出容器尾部的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_front</strong>()</td>
<td style="text-align:center">移除容器头部的元素</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>这些方法都比较简单，不过多介绍。</p>
<h4 id="list">list</h4>
<p>list容器的底层是用双向链表实现的，甚至一些 STL 版本中（比如 SGI STL），list 容器的底层实现使用的是双向循环链表。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2-19121Q62J3329.gif" alt="img"></p>
<ul>
<li>a）双向链表，b）循环链表</li>
</ul>
<p><u>双链表</u>相比数组有很多好处：</p>
<ul>
<li><strong>插入和删除操作效率高（但查找效率低），头、尾插入/删除操作也是，所以STL会都提供了<code>push_front()</code>、<code>push_back()</code>等头、尾部操作方法</strong>；</li>
<li>扩展方便；</li>
<li>内存空间不要求连续，可充分利用空间；</li>
<li>…</li>
</ul>
<p>这些也是list所具有的优点。另外一个好处可能现在有点难以理解（后文会解释）：</p>
<ul>
<li>在vector中如果进行<u>插入</u>和<u>删除</u><u>操作</u>会导致<u>后续迭代器会失效</u>，而在List中：<u>插入</u>不会导致迭代器失效；删除也只会使得当前迭代器失效，后续迭代器不会失效。</li>
</ul>
<p>list容器以类模板的形式定义在 <code>&lt;list&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,</span><br><span class="line">		 <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class list : <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>list&lt;_Tp,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Alloc</code>，内存分配器，默认采用二级配置器，一般不用我们关心。</li>
</ul>
<p>简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// list没有`capacity`()函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> first = l.<span class="built_in">begin</span>(); first != l.<span class="built_in">end</span>(); first++)</span><br><span class="line">    	std::cout&lt;&lt;*first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; l &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printList</span>(l);  <span class="comment">// size = 5 : 0 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    l.<span class="built_in">pop_back</span>();</span><br><span class="line">    l.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printList</span>(l);  <span class="comment">// size = 3 : 1 2 3  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>list</code>不止是链表还是双向链表，所以我们头、尾都是可以插入/删除的。</p>
<h5 id="底层实现-4">底层实现</h5>
<p>本节我们主要探讨以下问题：</p>
<ul>
<li>list底层数据结构及实现？</li>
<li>list底层迭代器如何定义？</li>
<li>list底层如何插入、删除一个数据？</li>
</ul>
<p><strong>我们先了解下list类继承结构及核心成员（类似vector、deque继承结构</strong>）。</p>
<p>注意到，list继承了 <code>_List_base</code> ，<code>_List_base</code>专门负责list的内存管理。</p>
<p><code>_List_base</code>核心是内部类<code>_List_impl</code> ，它继承了<code>_Tp_alloc_type</code>  获得内存分配释放的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_List_node&lt;_Tp&gt; &gt;::other</span><br><span class="line">        _Node_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">List_impl</span>:</span> <span class="keyword">public</span> _Node_alloc_type</span><br><span class="line">    &#123;</span><br><span class="line">		__detail::_List_node_base _M_node;  <span class="comment">// 头结点，不存储数据</span></span><br><span class="line"></span><br><span class="line">        _List_impl(): _Node_alloc_type(), _M_node()</span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">	    _List_impl(<span class="keyword">const</span> _Node_alloc_type&amp; __a): _Node_alloc_type(__a), 	_M_node()</span><br><span class="line">	    &#123; &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;; <span class="comment">// _List_impl</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>_List_impl</code>核心成员：</p>
<ul>
<li>
<p><code>_M_node</code>：list头结点，不存储数据</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217204035277.png" alt="image-20220217204035277"></p>
</li>
</ul>
<p>好了，现在我们可以依次回答节前的问题。</p>
<p><strong>第一个问题：list底层数据结构及实现</strong>？</p>
<p>list底层是链表，头结点为<code>_M_node</code>。头节点是<code>_List_node_base</code>类型，不存储数据。</p>
<p>但数据结点是<code>_List_node</code> 类型，存储数据。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217204337102.png" alt="image-20220217204337102"></p>
<p>借助<code>_M_node</code>可以实现，list中几乎所有的成员函数。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217212702954.png" alt="image-20220217212702954"></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220217212735184.png" alt="image-20220217212735184"></p>
<p><strong>第二个问题：list底层迭代器如何定义</strong>？</p>
<p>在list类中，找到<code>iterator</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _List_iterator&lt;_Tp&gt;             iterator;</span><br></pre></td></tr></table></figure>
<p>其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 定义一堆别名</span></span><br><span class="line">    <span class="keyword">typedef</span> _List_iterator&lt;_Tp&gt;                _Self;</span><br><span class="line">    <span class="keyword">typedef</span> _List_node&lt;_Tp&gt;                    _Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                          difference_type;</span><br><span class="line">    <span class="comment">// list为一个双向链表，迭代器必须具备前移、后移的能力，所以提供了bidirectional iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> std::bidirectional_iterator_tag    iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                               pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                               reference;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 构造函数1：实例化头结点_M_node指针</span></span><br><span class="line">    _List_iterator(): _M_node() &#123; &#125;   </span><br><span class="line">    <span class="comment">// 构造函数2：给定值实例化</span></span><br><span class="line">     <span class="keyword">explicit</span> _List_iterator(__detail::_List_node_base* __x): _M_node(__x) &#123; &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>继续看看具体<code>_List_iterator</code>相关函数。</p>
<ul>
<li>
<p><code>operator++</code> 的后置自增，将当前 <code>_M_node</code> 移动到 <code>_M_node-&gt;_M_next</code> 所在的位置，并返回移动之后的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Self 是_List_iterator&lt;_Tp&gt; 一个类型别名</span></span><br><span class="line">_Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">     _M_node = _M_node-&gt;_M_next;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>operator--</code>大同小异。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	_M_node = _M_node-&gt;_M_prev;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>最后一个问题：list底层如何插入、删除一个数据</strong>？</p>
<p>大致应该就是链表的插入、删除相关操作。这里有机会再补上吧。</p>
<h5 id="成员函数-4">成员函数</h5>
<p>list具有众多的成员函数，方便我们对list进行各种操作。</p>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<p>同array、vector，deque。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rbegin()</td>
<td style="text-align:center">返回指向最后一个元素的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rend()</td>
<td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crbegin()</td>
<td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crend()</td>
<td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
<li>
<p><strong>主要成员函数</strong></p>
<p>标粗部分是常用的函数。</p>
<ul>
<li>
<p>list底层是双链表，只有双向迭代器没有随机迭代器，一些随机迭代器才支持的方法，比如<code>at(n)</code>、<code>[n]</code>都是不支持的；</p>
</li>
<li>
<p>头、尾操作效率均高，所以会提供<strong>push_front</strong>()  、<strong>push_back</strong>()等头、尾部等插入、删除方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><s>size</s>()</td>
<td style="text-align:center"><s>list没有，vector、deque有</s></td>
</tr>
<tr>
<td style="text-align:center"><s>capacity</s></td>
<td style="text-align:center"><s>list、deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center"><s>reserve</s>()</td>
<td style="text-align:center"><s>list、deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回容器可容纳元素的最大数量</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td>
</tr>
<tr>
<td style="text-align:center"><s>at(n</s>)</td>
<td style="text-align:center"><s>不支持</s></td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回容器中第一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center">back()</td>
<td style="text-align:center">返回容器中最后一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center"><s>data</s>()</td>
<td style="text-align:center"><s>list、deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:center">交换两个容器的所有元素</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>相比array独有的方法（可以<u>头、尾</u>部插入、删除元素等）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>push_back</strong>()</td>
<td style="text-align:center">在容器的尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace_back</strong>()</td>
<td style="text-align:center">在容器的尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>push_front</strong>()</td>
<td style="text-align:center">在容器的头部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace_front</strong>()</td>
<td style="text-align:center">在容器头部生成一个元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:center">移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear</strong>()</td>
<td style="text-align:center">移出所有的元素，容器大小变为 0</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_back</strong>()</td>
<td style="text-align:center">移出容器尾部的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop_front</strong>()</td>
<td style="text-align:center">移除容器头部的元素</td>
</tr>
</tbody>
</table>
<p>相比deque新增（链表的一些操作方法）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">splice()</td>
<td style="text-align:center">将一个 list 容器中的元素插入到另一个容器的指定位置</td>
</tr>
<tr>
<td style="text-align:center">remove(val)</td>
<td style="text-align:center">删除容器中所有等于 val 的元素</td>
</tr>
<tr>
<td style="text-align:center">remove_if()</td>
<td style="text-align:center">删除容器中满足条件的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>unique</strong>()</td>
<td style="text-align:center">删除容器中相邻的重复元素，只保留一个</td>
</tr>
<tr>
<td style="text-align:center"><strong>merge</strong>()</td>
<td style="text-align:center">合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的</td>
</tr>
<tr>
<td style="text-align:center">sort()</td>
<td style="text-align:center">通过更改容器中元素的位置，将它们进行排序</td>
</tr>
<tr>
<td style="text-align:center"><strong>reverse</strong>()</td>
<td style="text-align:center">反转容器中元素的顺序</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>新增的函数有点意思，合适的时候进行补充。</p>
<h5 id="迭代器失效">迭代器失效</h5>
<p>分析“迭代器失效”这个问题前，我们先回忆一下各个容器的底层数据结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">对应的迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array、vector、deque</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:center">list、forward_list</td>
<td style="text-align:center">链表</td>
<td style="text-align:center">双向迭代器</td>
</tr>
<tr>
<td style="text-align:center">set / multiset / map / multimap</td>
<td style="text-align:center">红黑树</td>
<td style="text-align:center">双向迭代器</td>
</tr>
<tr>
<td style="text-align:center">stack / queue</td>
<td style="text-align:center">list 和 deque 实现，封闭头部</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
</tbody>
</table>
<p>好了，让我们正式开始吧。</p>
<p>看下面这段看似无害的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">erase</span>(it);  <span class="comment">// 迭代器失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时却发生了错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p><strong>这段代码对于list、vector、deque等容器都会出错（array例外，它没有<code>erase</code>()方法），究其原因就是出现迭代器失效</strong>。</p>
<ol>
<li>迭代器<code>it</code> 初始化指向了第一个元素，判断条件成立进入循环体；</li>
<li>执行<code>vec.erase(it</code>)，<code>it</code>被删除；</li>
<li>执行<code>it++</code>出错，<code>it</code>已失效无法递增。</li>
</ol>
<p>得益于<code>erase</code>方法的返回值是下一个有效的 <code>iterator</code>，解决办法也很简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);  <span class="comment">// 迭代器失效</span></span><br><span class="line">        <span class="comment">// it++;  // it已经是下一个迭代器了不用++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<blockquote>
<p>⚠️ 关联容器：map、set、multimap、multiset等可以使用两种方式，但list、vector、deque无法使用下面这种方式，否则会出错（为啥？）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line">    map1.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    map1.<span class="built_in">emplace</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        map1.<span class="built_in">erase</span>(it++);  <span class="comment">// 迭代器失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>it++</code>会复制一个<code>it</code>副本传递给<code>erase()</code> 函数；</li>
<li><code>it</code>执行<code>++</code>操作；</li>
<li>最后再执行<code>erase()</code>将 复制的<code>it</code>副本删除，它和<code>it</code>指向同一元素，所以最后<code>it</code>还是失效了。</li>
</ol>
<p><strong>迭代器失效总结如下</strong>：</p>
<ul>
<li>如果底层数据结构是一维数组的（vector）
<ul>
<li>插入操作：插入位置及之后的迭代器都失效，因为插入位置后的所有元素都需要移动；如果还触发了扩容，则所有迭代器都失效；</li>
<li>删除操作：删除位置及之后的迭代器都失效，因为删除位置之后的元素都需移动；</li>
</ul>
</li>
<li>如果底层数据结构是二维数组的（deque）
<ul>
<li>插入操作：首部或者尾部插入不会使迭代器失效，因为不影响其它元素位置，中间插入会使得所有迭代器失效，因为所有元素都被影响要移动；</li>
<li>删除操作：部或尾部删除元素只会使得被删除位置的迭代器失效，中间删除会使得所有迭代器失效，原因同上。</li>
</ul>
</li>
<li>如果底层数据结构是链表的（list、forward_list）
<ul>
<li>插入操作：节点无需移动，所有迭代器有效；</li>
<li>删除操作：节点无需移动，仅删除的节点迭代器失效。</li>
</ul>
</li>
<li>如果底层数据结构是红黑树的（set / multiset / map / multimap）
<ul>
<li>插入操作：不影响其它节点，所有迭代器有效；</li>
<li>删除操作：不影响其它节点，仅删除的节点迭代器失效。</li>
</ul>
</li>
</ul>
<h4 id="forward-list">forward_list</h4>
<p>forward_list底层实现和list一样，都是链表，但是forward_list使用的是单链表，而list是双链表。</p>
<p>单链表相比双链表灵活性<u>差了</u>很多：</p>
<ul>
<li><u>尾部</u>插入、删除操作效率低；</li>
<li>只能前向遍历，不能反向遍历（因此forward_list只有前向迭代器，而且不会具有 rbegin()、rend() 之类的成员函数）；</li>
<li>…</li>
</ul>
<p><u>但是单链表空间利用利用率更高</u>（node不用保存前向指针），而且遵循<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80">奥卡姆剃刀</a>原则：“若无必要，勿增实体”——在诸多可以满足需求的结构中，选择影响范围最小的。</p>
<p>所以只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。</p>
<p>forward_list 容器以类模板的形式定义在 <code>&lt;forward_list &gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line">		 <span class="keyword">typename</span> _Alloc = allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class forward_list : <span class="keyword">private</span> _Fwd_list_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>forward_list&lt;_Tp,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Alloc</code>，内存分配器，默认采用二级配置器，一般不用我们关心。</li>
</ul>
<p>简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> forward_list&lt;<span class="keyword">int</span>&gt;&amp; fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// forward_list 没有size()方法</span></span><br><span class="line">    <span class="comment">// 用distance方法实现</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(std::<span class="built_in">begin</span>(fl), std::<span class="built_in">end</span>(fl)) &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// forward_list 没有capacity()函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> first = fl.<span class="built_in">begin</span>(); first != fl.<span class="built_in">end</span>(); first++)</span><br><span class="line">    	std::cout&lt;&lt;*first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	forward_list&lt;<span class="keyword">int</span>&gt; fl &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// fl.emplace_front(4);  // 底层是单链表，不支持尾部相关操作的函数/迭代器</span></span><br><span class="line">    fl.<span class="built_in">emplace_front</span>(<span class="number">0</span>); <span class="comment">// 头部插入，尾部不行</span></span><br><span class="line">    <span class="built_in">printList</span>(fl);    <span class="comment">// size = 4 : 0 1 2 3 </span></span><br><span class="line">    </span><br><span class="line">    fl.<span class="built_in">pop_front</span>();   <span class="comment">// 头部删除</span></span><br><span class="line">    <span class="built_in">printList</span>(fl);    <span class="comment">// size = 3 : 1 2 3  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到：</p>
<ul>
<li>forward_list只能头部进行了插入等操作，不能在尾部；</li>
<li>forward_list没有size方法，只能用distance方法实现。</li>
</ul>
<h5 id="底层实现-5">底层实现</h5>
<p>本节我们主要探讨以下问题：</p>
<ul>
<li>forward_list底层数据结构及实现？</li>
<li>forward_list底层迭代器如何定义？</li>
<li>forward_list底层如何插入、删除一个数据？</li>
</ul>
<p>forward_list底层实现和list极为相似，这里直接给出关键答案。</p>
<ul>
<li>
<p><strong>forward_list底层数据结构及实现</strong>？</p>
<p>forward_list底层是但链表，头结点为<code>_M_head</code>。头节点是<code>_Fwd_list_node_base</code>类型，不存储数据。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220218115621414.png" alt="image-20220218115621414"></p>
</li>
<li>
<p><strong>forward_list底层迭代器如何定义</strong>？</p>
<p>没啥好说的，和list差不多。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220218115822591.png" alt="image-20220218115822591"></p>
</li>
<li>
<p><strong>forward_list底层如何插入、删除一个数据</strong>？</p>
<p>就是单链表相关的操作，有头结点操作比较统一。</p>
</li>
</ul>
<h5 id="成员函数-5">成员函数</h5>
<p>forward_list具有众多的成员函数，方便我们对forward_list进行各种操作。</p>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<p>和array、vector、deque，list不同，forward_list没有尾部相关迭代器函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
<li>
<p><strong>主要成员函数</strong></p>
<p>标粗部分是常用的函数。</p>
<ul>
<li>list、forward_list底层是链表，没有随机迭代器，一些随机迭代器才支持的方法，比如at(n)都是不支持的；</li>
<li>forward_list底层是单链表，只有头部操作效率高，<u>所以尾部操作相关的方法<code>push_back()</code>等STL不提供</u>；</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><s>size</s>()</td>
<td style="text-align:center">forward_list不支持，可用<code>std::distance()</code> 方法间接实现</td>
</tr>
<tr>
<td style="text-align:center"><s>capacity</s></td>
<td style="text-align:center"><s>forward_list、list、deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center"><s>reserve</s>()</td>
<td style="text-align:center"><s>forward_list、list、deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回容器可容纳元素的最大数量</td>
</tr>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center"><strong>判断容器是否为空</strong>，和通过 <code>size()==0</code> 的判断条件功能相同，但其效率可能更快</td>
</tr>
<tr>
<td style="text-align:center"><s>at(n</s>)</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回容器中第一个元素的直接引用</td>
</tr>
<tr>
<td style="text-align:center"><s>data</s>()</td>
<td style="text-align:center"><s>forward_list、list、deque没有该方法，vector有</s></td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:center">交换两个容器的所有元素</td>
</tr>
</tbody>
</table>
<p>相比array独有的方法（可以<u>头部</u>插入、删除元素等）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>push_front</strong>()</td>
<td style="text-align:center">在容器的头部添加一个元素</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>| <strong>emplace_front</strong>() |                    在容器头部生成一个元素                    |<br>
|     <strong>erase</strong>()     | 移出一个元素或一段元素，返回指向删除元素的下一个元素的迭代器 |<br>
|     <strong>clear</strong>()     |                移出所有的元素，容器大小变为 0                |<br>
|   <strong>pop_front</strong>()   |                      移除容器头部的元素                      |</p>
<p>相比deque新增（链表相关方法）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">splice()</td>
<td style="text-align:center">将一个 forward_list容器中的元素插入到另一个容器的指定位置</td>
</tr>
<tr>
<td style="text-align:center">remove(val)</td>
<td style="text-align:center">删除容器中所有等于 val 的元素</td>
</tr>
<tr>
<td style="text-align:center">remove_if()</td>
<td style="text-align:center">删除容器中满足条件的元素</td>
</tr>
<tr>
<td style="text-align:center"><strong>unique</strong>()</td>
<td style="text-align:center">删除容器中相邻的重复元素，只保留一个</td>
</tr>
<tr>
<td style="text-align:center"><strong>merge</strong>()</td>
<td style="text-align:center">合并两个事先已排好序的 forward_list容器，并且合并之后的 forward_list容器依然是有序的</td>
</tr>
<tr>
<td style="text-align:center">sort()</td>
<td style="text-align:center">通过更改容器中元素的位置，将它们进行排序</td>
</tr>
<tr>
<td style="text-align:center"><strong>reverse</strong>()</td>
<td style="text-align:center">反转容器中元素的顺序</td>
</tr>
</tbody>
</table>
<h3 id="9-2-2-关联式容器">9.2.2 关联式容器</h3>
<p>序列式容器元素是顺序存储的，而“关联式容器”是以键值对方式存储的，顾名思义每个元素都会和一个“键”相关联的。这种特性简单解释来说，就是查找到“键”就可以查找到相关元素。</p>
<p><strong>在底层实现中，关联容器的“键值对”采用红黑树来存储</strong>，这使得可以很方便地实现排序，所以关联式容器的元素都会<u>按照键值的大小做升序排序</u>。</p>
<p>本节主要探讨以下容器：</p>
<blockquote>
<p>除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但由于哈希容器底层采用的是哈希表，而不是红黑树，放在下节<u>9.2.3</u>讲解。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">红黑树，下同</td>
<td style="text-align:center">键必须唯一，会根据键大小默认升序排序</td>
<td style="text-align:center">双向迭代器，下同</td>
</tr>
<tr>
<td style="text-align:center">multimap</td>
<td style="text-align:center"></td>
<td style="text-align:center">基本同map，但multimap 键可重复</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center"></td>
<td style="text-align:center">键和值完全相同，键依旧唯一，默认升序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">multiset</td>
<td style="text-align:center"></td>
<td style="text-align:center">基本同set，但multiset 键可重复</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="pair">pair</h4>
<p>我们知道，关联式容器存储的是“键值对”形式的数据，即<code>&lt;key,value&gt;</code>形式。</p>
<p>C++STL专门提供了pair类模板，用来封装“键值对”这种形式的数据。</p>
<p>它被定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      _T1 first;</span><br><span class="line">      _T2 second;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
<p>使用起来也很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>,string&gt; kv1&#123;<span class="number">1</span>,<span class="string">&quot;一&quot;</span>&#125;;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,string&gt; kv2&#123;<span class="number">2</span>,<span class="string">&quot;二&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改  </span></span><br><span class="line">    kv1.first = <span class="number">-1</span>;</span><br><span class="line">    kv1.second =<span class="string">&quot;负一&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较:键值对完全相关返回true，否则false</span></span><br><span class="line">    <span class="keyword">bool</span> is_equal = kv1 == kv2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap交换键值对</span></span><br><span class="line">    kv1.<span class="built_in">swap</span>(kv2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以使用<code>make_pair</code> 来创建<code>pair</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>,string&gt; kv3&#123;<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;三&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure>
<p>后面我们会大量用到这种方式创建<code>pair</code>对象。</p>
<h4 id="map">map</h4>
<p>作为关联式容器的一种，map用 <code>pair</code> 类模板创建键值对，底层结构是红黑树而且还会根据各键值对的键的大小，进行升序排序。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220218142932775.png" alt="image-20220218142932775"></p>
<p>map容器以类模板形式定义在 <code>&lt;map&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key, </span><br><span class="line">		  <span class="keyword">typename</span> _Tp, </span><br><span class="line">          <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">          <span class="keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class map</span><br></pre></td></tr></table></figure>
<p>在 <code>map&lt;_Key,_Tp,_Compare,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Key</code>，指定键的类型；</li>
<li><code>_Tp</code>，指定值的类型；</li>
<li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li>
<li><code>_Alloc</code>，默认选用二级内存分配器。</li>
</ul>
<p><strong>特别的，关联式容器（如map）的键值key都是不能修改的，只能通过：先手动删除键值对，再插入，这种间接的方式修改</strong>。</p>
<blockquote>
<p>假设关联容器允许修改键值的，因为其底层是红黑树：</p>
<ol>
<li>首先需要删除该键，然后调节平衡</li>
<li>再插入修改后的键值，再调节平衡</li>
</ol>
<p>如此一来，严重破坏了红黑树的结构，导致iterator失效，不知道应该指向之前的位置，还是指向改变后的位置。所以STL中将关联式容器的迭代器设置成const，不允许修改迭代器的值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map1 = std::map&lt;<span class="keyword">int</span>,std::string&gt; &#123; std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;一&quot;</span>),std::<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&quot;二&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">map1.<span class="built_in">find</span>(<span class="string">&quot;two&quot;</span>)-&gt;first  = <span class="number">0</span>; <span class="comment">// error，不允许修改</span></span><br></pre></td></tr></table></figure>
<p>一个简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="keyword">const</span> map&lt;<span class="keyword">int</span>,string&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    	std::cout&lt;&lt;<span class="string">&quot;&lt;key=&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot;, value=&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt; &quot;</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make_pair</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>,std::string&gt; map1 &#123; std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;一&quot;</span>),std::<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&quot;二&quot;</span>)&#125;;</span><br><span class="line">    map1[<span class="number">1</span>]; <span class="comment">// &quot;一&quot;</span></span><br><span class="line">    map1[<span class="number">2</span>]; <span class="comment">// &quot;二&quot;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    map1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="string">&quot;零&quot;</span>));</span><br><span class="line">    map1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;四&quot;</span>));</span><br><span class="line">    <span class="built_in">printMap</span>(map1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    map1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMap</span>(map1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本例中，map初始化还可以简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,std::string&gt; map1 &#123; &#123;<span class="number">1</span>,<span class="string">&quot;一&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;二&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>输出（注意打印出来的顺序按key升序打印的）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 4 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=2, value=二&gt; &lt;key=4, value=四&gt; </span><br><span class="line">size = 3 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=2, value=二&gt; </span><br></pre></td></tr></table></figure>
<h5 id="成员函数-6">成员函数</h5>
<p>map具有众多的成员函数，方便我们对map进行各种操作。</p>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<p>同array、vector，deque、list。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rbegin()</td>
<td style="text-align:center">返回指向最后一个元素的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">rend()</td>
<td style="text-align:center">返回指向第一个元素之前一个位置的反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crbegin()</td>
<td style="text-align:center">和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
<tr>
<td style="text-align:center">crend()</td>
<td style="text-align:center">和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
<li>
<p><strong>主要成员函数</strong></p>
<p>标粗部分是常用的函数。</p>
<ul>
<li>关联容器虽然底层也是双向迭代器，不是随机迭代器，一些随机迭代器才支持的方法，<strong>比如<code>at(n)</code>、<code>[n]</code>是不支持的，但支持按键值查找<code>at(key)</code>、<code>[key]</code>方法</strong>；</li>
<li><strong>关联容器不能在指定位置上删除、插入元素</strong>，所以STL没有提供<code>push_back()</code>、<code>push_front()</code>之类头尾操作方法，而是使用<code>emplace()</code> 或<code>insert()</code>。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center">若容器为空，则返回 true；否则 false</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center">返回当前 map 容器中存有键值对的个数</td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td>
</tr>
<tr>
<td style="text-align:center"><strong>operator</strong>[key]</td>
<td style="text-align:center">map容器重载了 [] 运算符，获取指定键的值，<strong>查找失败添加新的键值对</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>at</strong>(key)</td>
<td style="text-align:center">找到 map 容器中 key 键对应的值，<strong>查找失败引发 out_of_range 异常</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>insert</strong>()</td>
<td style="text-align:center">向 map 容器中插入键值对，<strong>如果key重复会覆盖</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:center">删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:center">交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace</strong>()</td>
<td style="text-align:center">基本同insert，但相比insert效率更高</td>
</tr>
<tr>
<td style="text-align:center">count(key)</td>
<td style="text-align:center">在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
<p>相比序列容器，关联容器独有的一些函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>find</strong>(key)</td>
<td style="text-align:center">在 map 容器中查找键为 key 的键值对，<strong>找到返回对应迭代器（和at、[]不同，不是返回value</strong>），如果没找到返回和 end() 方法一样的迭代器</td>
</tr>
<tr>
<td style="text-align:center">lower_bound(key)</td>
<td style="text-align:center">返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器，如果没找到返回和 end() 方法一样的迭代器</td>
</tr>
<tr>
<td style="text-align:center">upper_bound(key)</td>
<td style="text-align:center">类似上，不过返回的是第一个大于 key的（不包含等于）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>简单对比下<code>operator[key]</code> 和<code>at(key)</code> 这两种查询key的方式。</p>
<p>注意到，<code>operator[key]</code> 如果没查找到key，还会直接给map插入当前未查找到的key。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 空map</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>,std::string&gt; map1 &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// at(key)</span></span><br><span class="line">    <span class="comment">// map1.at(1); // error程序终止，抛出异常</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [key]</span></span><br><span class="line">    map1[<span class="number">1</span>];</span><br><span class="line">    std::cout&lt;&lt; map1.<span class="built_in">begin</span>()-&gt;first &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; map1.<span class="built_in">begin</span>()-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器自动初始化了value：如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串。</p>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">1,&quot;&quot;</span><br></pre></td></tr></table></figure>
<h5 id="底层实现-6">底层实现</h5>
<p>本节我们主要探讨以下问题：</p>
<ul>
<li>map底层数据结构及实现？</li>
<li>map底层迭代器如何定义？</li>
<li>map底层如何插入、删除一个数据？</li>
</ul>
<p>本节只做简单分析。</p>
<p><strong>map底层数据结构及实现</strong>？</p>
<p>前面我们说过，map底层是红黑树，可以在map代码中验证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class map</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Key    key_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp     mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt;     value_type;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;value_type&gt;::other _Pair_alloc_type;</span><br><span class="line">    <span class="comment">// 红黑树模板类</span></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;, key_compare, _Pair_alloc_type&gt; _Rep_type;  </span><br><span class="line">   <span class="comment">/// The actual tree structure.</span></span><br><span class="line">   _Rep_type _M_t; <span class="comment">// map底层的红黑树 </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>具体展开就是对红黑树的分析了，大致了解到这就行。</p>
<p><strong>map底层迭代器如何定义</strong>？</p>
<p>map中迭代器使用的是红黑中的迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Rep_type::iterator   iterator;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">Rb_tree_color</span> &#123;</span> _S_red = <span class="literal">false</span>, _S_black = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_node_base</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Rb_tree_node_base* _Const_Base_ptr;</span><br><span class="line"></span><br><span class="line">    _Rb_tree_color	_M_color;</span><br><span class="line">    _Base_ptr		_M_parent;  <span class="comment">// 父指针</span></span><br><span class="line">    _Base_ptr		_M_left;    <span class="comment">// 左指针</span></span><br><span class="line">    _Base_ptr		_M_right;   <span class="comment">// 右指针</span></span><br></pre></td></tr></table></figure>
<p><strong>map底层如何插入、删除一个数据</strong>？</p>
<p>主要是红黑树相关删除、插入操作。</p>
<h4 id="multimap">multimap</h4>
<p>multimap 容器具有和 map 极为相似的特性：</p>
<ul>
<li>multimap 容器的类模板也定义在<code>&lt;map&gt;</code>头文件；</li>
<li>也按键值对方式存储数据，底层也是红黑树结构；</li>
<li>会根据键值升序排序元素；</li>
<li>成员函数大部分相同；</li>
<li>键值无法修改；</li>
<li>…</li>
</ul>
<p>主要的不同体现在：</p>
<ul>
<li>multimap 可以同时<u>存储多个键相同的键值对</u>；</li>
<li>multimap 除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code> 等<u>直接按key获取value的方式</u>（很好理解，multimap会存在多个重复的键）。</li>
</ul>
<p>multimap 也定义在 <code>&lt;map&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key, </span><br><span class="line">		  <span class="keyword">typename</span> _Tp, </span><br><span class="line">		  <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">		  <span class="keyword">typename</span> _Alloc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class multimap </span><br></pre></td></tr></table></figure>
<p>在 <code>multimap &lt;_Key,_Tp,_Compare,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Key</code>，指定键的类型；</li>
<li><code>_Tp</code>，指定值的类型；</li>
<li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li>
<li><code>_Alloc</code>，默认选用二级内存分配器。</li>
</ul>
<p>一个简单使用实例（使用起来和map很相似）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMMap</span><span class="params">(<span class="keyword">const</span> multimap&lt;<span class="keyword">int</span>,string&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;&lt;key=&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot;, value=&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt; &quot;</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make_pair</span></span><br><span class="line">    multimap&lt;<span class="keyword">int</span>,std::string&gt; mmap1 &#123; std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;一&quot;</span>),std::<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&quot;壹&quot;</span>)&#125;; <span class="comment">// 键值相同，都是1</span></span><br><span class="line">    <span class="comment">// map1[1] = &quot;one&quot;; // error，无法修改键值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    mmap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="string">&quot;零&quot;</span>));</span><br><span class="line">    mmap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;四&quot;</span>));</span><br><span class="line">    <span class="built_in">printMMap</span>(mmap1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    mmap1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    mmap1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMMap</span>(mmap1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出（自动排序）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 4 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=1, value=壹&gt; &lt;key=4, value=四&gt; </span><br><span class="line">size = 3 : &lt;key=0, value=零&gt; &lt;key=1, value=一&gt; &lt;key=1, value=壹&gt; </span><br></pre></td></tr></table></figure>
<p><strong>关于成员函数</strong></p>
<p>multimap的成员函数，除了不能使用<code>at(key)</code>、<code>operator[key]</code> ，基本和map一致，故不单列了。</p>
<h4 id="set">set</h4>
<p>map和set都是以红黑树作为底层数据结构，所以外部表现的也极为相似：</p>
<ul>
<li>不允许出现键值重复；</li>
<li>所有的元素都会被自动排序；</li>
<li>不能通过迭代器来改变set的值，因为set的值就是键（关联容器的键值不允许修改）；</li>
<li>成员函数极为类似；</li>
<li>…</li>
</ul>
<p>主要区别在于：</p>
<ul>
<li><strong>set容器存储的键值对（key-value）的key、value完全相同。在底层实现上，map底层区别也主要是修改红黑树存储的key、value保存一致</strong>；</li>
<li>set容器除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code>获取value ，虽然在底层实现上set的key等于value，<u>但是不允许获取value</u>。</li>
</ul>
<p>对于第一个区别，我们查看set容器底层实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;</span><br><span class="line">class set</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Key     key_type;  </span><br><span class="line">      <span class="keyword">typedef</span> _Key     value_type; <span class="comment">// 和key_type一样</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::<span class="keyword">template</span> rebind&lt;_Key&gt;::other _Key_alloc_type;</span><br><span class="line">      <span class="comment">// 和map几乎一致</span></span><br><span class="line">      <span class="comment">// 唯一区别在于红黑树类模板参数key_type和value_type其实是一样的</span></span><br><span class="line">      <span class="comment">// 初始化时它们的值也一样</span></span><br><span class="line">      <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;,</span><br><span class="line">		       key_compare, _Key_alloc_type&gt; _Rep_type;</span><br><span class="line">     _Rep_type _M_t;  <span class="comment">// Red-black tree representing set.</span></span><br></pre></td></tr></table></figure>
<p>可以看到，底层实现上key、value的类型、值都会被设置为一样。set 容器类模板的定义中，也仅提供第 1 个参数（<code>_Key</code>）用于设定存储数据的类型。</p>
<p>set 容器以类模板形式定义在 <code>&lt;set&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, </span><br><span class="line">		 <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">         <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;loc = std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line">class set</span><br></pre></td></tr></table></figure>
<p>在 <code>set&lt;_Key,_Compare,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Key</code>，指定键的类型；</li>
<li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li>
<li><code>_Alloc</code>，默认选用二级内存分配器。</li>
</ul>
<p>一个简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="keyword">const</span> set&lt;<span class="keyword">int</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印set键值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    	std::cout&lt;&lt;<span class="string">&quot;key=&quot;</span>&lt;&lt;*iter&lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//  iter-&gt;first set不允许使用</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; set1 &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;; <span class="comment">// 键值不能相同</span></span><br><span class="line">    <span class="comment">// set1[1];  // error，不能使用[key]或at(key)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    set1.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">    set1.<span class="built_in">emplace</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(set1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    set1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(set1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 5 : key=0 key=1 key=2 key=3 key=4 </span><br><span class="line">size = 3 : key=0 key=1 key=2 </span><br></pre></td></tr></table></figure>
<p><strong>关于成员函数</strong></p>
<p>set、multimap的成员函数，除了不能使用<code>at(key)</code>、<code>operator[key]</code> ，基本和map一致（底层实现上就非常相似），故不单列了。</p>
<h4 id="multiset">multiset</h4>
<p>multiset和map的主要区别在于：</p>
<ul>
<li>
<p><strong>multiset可以存储相同的键值</strong>；</p>
</li>
<li>
<p>multiset键值对相同；</p>
</li>
<li>
<p>除了map/unordered_map，multiset和set、multimap一样，也不能使用<code>at(key)</code> 或 <code>operator[key]</code>，但可以使用<code>find(key)</code> 。</p>
</li>
</ul>
<p>multiset 也定义在 <code>&lt;set&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Key,</span><br><span class="line">		  <span class="keyword">typename</span> _Compare = std::less&lt;_Key&gt;,</span><br><span class="line">		  <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Key&gt; &gt;</span><br><span class="line">class multiset</span><br></pre></td></tr></table></figure>
<p>在 <code>multiset&lt;_Key,_Compare,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Key</code>，指定键的类型；</li>
<li><code>_Compare</code>：指定排序顺序，默认选用升序<code>std::less&lt;_Key&gt;</code>，也可以选用<code>std::greater&lt;_Key&gt;</code> 或者自定义排序规则；</li>
<li><code>_Alloc</code>，默认选用二级内存分配器。</li>
</ul>
<p>一个简单使用实例（使用起来和set很相似）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMSet</span><span class="params">(<span class="keyword">const</span> multiset&lt;<span class="keyword">int</span>&gt;&amp; ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; ms.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = ms.<span class="built_in">begin</span>(); iter != ms.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    	std::cout&lt;&lt;<span class="string">&quot;key=&quot;</span>&lt;&lt;*iter&lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//  iter-&gt;first ，set、multiset不允许使用</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make_pair</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; mset1 &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; <span class="comment">// 存在键值相同</span></span><br><span class="line">    <span class="comment">// mset1[1];  // error，不能使用[key]或at(key)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    mset1.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">    mset1.<span class="built_in">emplace</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMSet</span>(mset1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    mset1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    mset1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printMSet</span>(mset1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出（自动排序）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = 6 : key=0 key=1 key=1 key=2 key=3 key=4 </span><br><span class="line">size = 4 : key=0 key=1 key=1 key=2 </span><br></pre></td></tr></table></figure>
<p><strong>关于成员函数</strong></p>
<p>multimap、set、multiset的成员函数，除了不能使用<code>at(key)</code>、<code>operator[key]</code> ，基本和map一致（底层实现上就非常相似），故不单列了。</p>
<h3 id="9-2-3-无序关联式容器">9.2.3 无序关联式容器</h3>
<p>本节主要介绍以下容器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">unordered_map</td>
<td style="text-align:center">哈希表，下同</td>
<td style="text-align:center">键必须唯一，会根据键大小默认升序排序</td>
<td style="text-align:center"><u>前向</u>迭代器，下同</td>
</tr>
<tr>
<td style="text-align:center">unordered_multimap</td>
<td style="text-align:center"></td>
<td style="text-align:center">基本同前，但unordered_multimap键可重复</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">unordered_set</td>
<td style="text-align:center"></td>
<td style="text-align:center">键和值完全相同，键依旧唯一，默认升序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">unordered_multiset</td>
<td style="text-align:center"></td>
<td style="text-align:center">基本同前，但unordered_multiset键可重复</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>正如名字“unordered”所暗示的，这些关联式容器是无序的，它们<u>不会</u>像之前的map/set/multimap/multiset/等关联容器一样，自动按键值大小对存储的键值对进行排序。</p>
<p><strong>为什么无序关联容器不会自动排序了</strong>？</p>
<p>这是因为“unordered”版本的关联式容器底层数据结构采用的是<u>哈希表</u> 而不是<u>红黑树</u> ，哈希表结构不适合插入元素时进行排序。</p>
<p>哈希表（Hash table）是根据关键码值(Key value)而直接进行访问的数据结构。</p>
<p>例如， <code>std::unordered_map</code>在内存中的哈希表形式结构：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/unordered_map_layout.png" alt="Jean Guegant's Blog – Making a STL-compatible hash map from scratch - Part  1 - Beating std::unordered_map"></p>
<p>直观上来看：</p>
<ul>
<li>哈希表是一个buckets数组（C++中使用vector实现）；</li>
<li>每个bucket是一个指针，指向它外挂的键值对链表（有时候我们用“bucket”指代外挂的链表）。</li>
</ul>
<p>在哈希表查找指定key的value大致过程如下：</p>
<blockquote>
<p>以 <code>std::unordered_map</code> 中 <code>[key]</code> 或 <code>at(key)</code> 查找过程为例。</p>
</blockquote>
<ol>
<li>使用hash(key)函数进行哈希映射，得到一个key对应的哈希值；</li>
<li>将哈希值和桶数量<code>n</code> 做<code>哈希值 % n</code>运算，元素结果即bucket的编号（下标），由此定位到具体的bucket上；</li>
<li>遍历查找定位的bucket外挂的键值对链表，如果找到key返回对应<u>value</u>（<code>find(key)</code>方法返回对应迭代器），如果没找到抛出异常（<code>find(key)</code>方法返回迭代器<code>unordered_map::end()</code>）。</li>
</ol>
<p><strong>为什么要重新设计哈希表作为底层结构</strong>？</p>
<p>这涉及到红黑树和哈希表的数据结构特性：</p>
<ul>
<li>查找、修改效率上：哈希表更快（哈希映射查找），常数级别O(1)，但哈希碰撞严重最坏O(n)；红黑树更慢（二叉树二分查找），但稳定O(logn)级别；</li>
<li>插入、删除效率上：哈希表更快，常数级别O(1)，红黑树更慢，但稳定O(logn)。</li>
</ul>
<p>所以，选择哈希表作为底层结构的无序容器，增删查改效率通常是更好的。<u>一般建议选择无序关联容器，除非你真的需要key有序</u>。</p>
<h4 id="unordered-map">unordered_map</h4>
<p>unordered_map 容器和 map 容器一样：</p>
<ul>
<li>以键值对（pair类型）的形式存储数据；</li>
<li>存储的各个键值对的键互不相同且不允许被修改。</li>
</ul>
<p>但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p>
<p>unordered_map 容器以类模板形式定义在 <code>&lt;unordered_map&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Tp</span>,</span></span><br><span class="line"><span class="class">	     <span class="keyword">class</span> _<span class="title">Hash</span> =</span> hash&lt;_Key&gt;,</span><br><span class="line">	     <span class="class"><span class="keyword">class</span> _<span class="title">Pred</span> =</span> std::equal_to&lt;_Key&gt;,</span><br><span class="line">	     <span class="class"><span class="keyword">class</span> _<span class="title">Alloc</span> =</span> std::allocator&lt;std::pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span> :</span> __check_copy_constructible&lt;_Alloc&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>unordered_map&lt;_Key,_Tp,_Hash,_Pred,_Alloc&gt;</code> 模板中：</p>
<ul>
<li><code>_Key</code>，指定键的类型；</li>
<li><code>_Tp</code>，指定值的类型；</li>
<li><code>_Hash</code>：指定要使用的哈希函数，默认选用<code>hash&lt;_Key&gt;</code>，不过默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类；</li>
<li><code>_Pred</code>：unordered_map不允许键值相等，而判断是否相等的规则，就由此参数指定；</li>
<li><code>_Alloc</code>，默认选用二级内存分配器。</li>
</ul>
<p>使用简单举例。</p>
<p>和map的提供的上层函数接口基本一致，如<code>emplace()</code> 插入元素等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUMap</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">int</span>,string&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;size = &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot; : &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    	std::cout&lt;&lt;<span class="string">&quot;&lt;key=&quot;</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot;, value=&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt; &quot;</span>; </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,std::string&gt; umap1 &#123; &#123;<span class="number">1</span>,<span class="string">&quot;一&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;二&quot;</span>&#125;&#125;;</span><br><span class="line">    umap1[<span class="number">1</span>]; <span class="comment">// &quot;一&quot;</span></span><br><span class="line">    umap1[<span class="number">2</span>]; <span class="comment">// &quot;二&quot;</span></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    umap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="string">&quot;零&quot;</span>));</span><br><span class="line">    umap1.<span class="built_in">emplace</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;四&quot;</span>));</span><br><span class="line">    <span class="built_in">printUMap</span>(umap1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    umap1.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    umap1.<span class="built_in">erase</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printUMap</span>(umap1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出（未排序）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size = <span class="number">4</span> : &lt;key=<span class="number">4</span>, value=四&gt; &lt;key=<span class="number">0</span>, value=零&gt; &lt;key=<span class="number">2</span>, value=二&gt; &lt;key=<span class="number">1</span>, value=一&gt; </span><br><span class="line">size = <span class="number">3</span> : &lt;key=<span class="number">0</span>, value=零&gt; &lt;key=<span class="number">2</span>, value=二&gt; &lt;key=<span class="number">1</span>, value=一&gt; </span><br></pre></td></tr></table></figure>
<h5 id="成员函数-7">成员函数</h5>
<p>unordered_map 既可以看做是关联式容器，更属于自成一脉的无序容器。所以其成员函数可分为：</p>
<ul>
<li>迭代器相关</li>
<li>基本方法</li>
<li>无序容器独有方法</li>
</ul>
<p>我们先一睹为快。</p>
<ul>
<li>
<p><strong>迭代器相关</strong></p>
<p>无序容器只有前向迭代器，尾部操作相关迭代器和函数都没有。</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin()</td>
<td style="text-align:center">返回指向容器中第一个元素的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">end()</td>
<td style="text-align:center">返回指向容器最后一个元素之后一个位置的正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cbegin()</td>
<td style="text-align:center">和 begin() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
<tr>
<td style="text-align:center">cend()</td>
<td style="text-align:center">和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li>注意，如果是 <em>const</em> 类型容器，返回的一定是常量正向迭代器，常量迭代器不能修改指向的元素；</li>
<li>begin() 和 end() 为C++11新增，操作对象还可以是数组。</li>
</ul>
</li>
<li>
<p><strong>基本方法（基本同map</strong>）</p>
<p>标粗部分是常用的函数。</p>
<ul>
<li>无序关联容器虽然底层不是随机迭代器，一些随机迭代器才支持的方法，<strong>比如<code>at(n)</code>、<code>[n]</code>是不支持的，但支持按键值查找<code>at(key)</code>、<code>[key]</code>方法</strong>；</li>
<li><strong>关联容器不能在指定位置上删除、插入元素</strong>，所以STL没有提供<code>push_back()</code>、<code>push_front()</code>之类头尾操作方法，而是使用<code>emplace()</code> 或<code>insert()</code>。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>empty</strong>()</td>
<td style="text-align:center">若容器为空，则返回 true；否则 false</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center">返回当前 unordered_map容器中存有<strong>键值对的个数</strong></td>
</tr>
<tr>
<td style="text-align:center">max_size()</td>
<td style="text-align:center">返回 unordered_map容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td>
</tr>
<tr>
<td style="text-align:center"><strong>operator</strong>[key]</td>
<td style="text-align:center">map容器重载了 [] 运算符，获取指定键的值，<strong>查找失败添加新的键值对</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>at</strong>(key)</td>
<td style="text-align:center">找到 map 容器中 key 键对应的值，<strong>查找失败引发 out_of_range 异常</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>insert</strong>()</td>
<td style="text-align:center">向 map 容器中插入键值对，<strong>如果key重复会覆盖</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>erase</strong>()</td>
<td style="text-align:center">删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td>
</tr>
<tr>
<td style="text-align:center"><strong>swap</strong>()</td>
<td style="text-align:center">交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td>
</tr>
<tr>
<td style="text-align:center"><strong>emplace</strong>()</td>
<td style="text-align:center">基本同insert，但相比insert效率更高</td>
</tr>
<tr>
<td style="text-align:center">count(key)</td>
<td style="text-align:center">在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>无序容器独有方法</strong></p>
<p>相比序列容器、有序容器，无序容器独有的一些<u>哈希表相关</u>方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bucket_count()</td>
<td style="text-align:center">返回当前桶数量（一个线性链表代表一个桶）</td>
</tr>
<tr>
<td style="text-align:center">max_bucket_count()</td>
<td style="text-align:center">返回最多可以使用多少桶</td>
</tr>
<tr>
<td style="text-align:center"><strong>bucket_size</strong>(n)</td>
<td style="text-align:center">返回第 n 个桶中存储键值对的数量</td>
</tr>
<tr>
<td style="text-align:center">bucket(key)</td>
<td style="text-align:center">返回以 key为键的键值对所在桶的编号</td>
</tr>
<tr>
<td style="text-align:center"><strong>load_factor</strong>()</td>
<td style="text-align:center">返回 unordered_map 容器中当前的负载因子，即负载因子 = 容器存储的总键值对 / 桶数 ， load_factor() = size() / bucket_count()</td>
</tr>
<tr>
<td style="text-align:center">max_load_factor()</td>
<td style="text-align:center">返回或者设置当前 unordered_map 容器的负载因子</td>
</tr>
<tr>
<td style="text-align:center"><strong>rehash</strong>(n)</td>
<td style="text-align:center">将当前容器底层使用桶的数量设置为 n</td>
</tr>
<tr>
<td style="text-align:center"><strong>reserve</strong>()</td>
<td style="text-align:center">将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个键值对（不超过最大负载因子）所需的数量，并重新整理容器</td>
</tr>
<tr>
<td style="text-align:center">hash_function()</td>
<td style="text-align:center">返回当前容器使用的哈希函数对象</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>对于无序容器的独有方法进行测试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUmapInfo</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;string, string&gt;&amp; umap)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 初始桶数: &quot;</span> &lt;&lt; umap.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 最大可使用桶数: &quot;</span> &lt;&lt; umap.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 当前存在的键值对: &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 初始负载因子: &quot;</span> &lt;&lt; umap.<span class="built_in">load_factor</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 最大负载因子: &quot;</span> &lt;&lt; umap.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;—————————————————————————————————————&quot;</span>  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 umap 使用最适合存储 9 个键值对的桶数</span></span><br><span class="line">    umap.<span class="built_in">reserve</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printUmapInfo</span>(umap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 umap 容器添加 3 个键值对</span></span><br><span class="line">    umap[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">    umap[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;25&quot;</span>;</span><br><span class="line">    umap[<span class="string">&quot;university&quot;</span>] = <span class="string">&quot;chongqingU&quot;</span>;</span><br><span class="line">    <span class="built_in">printUmapInfo</span>(umap);</span><br><span class="line">    <span class="comment">// 调用 bucket() 获取指定键值对位于桶的编号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;“age”存储在第：&quot;</span> &lt;&lt; umap.<span class="built_in">bucket</span>(<span class="string">&quot;age&quot;</span>) &lt;&lt;<span class="string">&quot;个桶&quot;</span>&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自行计算某键值对位于哪个桶</span></span><br><span class="line">    <span class="keyword">auto</span> fn = umap.<span class="built_in">hash_function</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hash(age)%n，计算“age”存储在第：&quot;</span> &lt;&lt; <span class="built_in">fn</span>(<span class="string">&quot;age&quot;</span>) % (umap.<span class="built_in">bucket_count</span>())  &lt;&lt;<span class="string">&quot;个桶&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">umap 初始桶数: 11</span><br><span class="line">umap 最大可使用桶数: 576460752303423487</span><br><span class="line">umap 当前存在的键值对: 0</span><br><span class="line">umap 初始负载因子: 0</span><br><span class="line">umap 最大负载因子: 1</span><br><span class="line">—————————————————————————————————————</span><br><span class="line">umap 初始桶数: 11</span><br><span class="line">umap 最大可使用桶数: 576460752303423487</span><br><span class="line">umap 当前存在的键值对: 3</span><br><span class="line">umap 初始负载因子: 0.272727</span><br><span class="line">umap 最大负载因子: 1</span><br><span class="line">—————————————————————————————————————</span><br><span class="line">“age”存储在第：5个桶</span><br><span class="line"><span class="meta">hash(age)%</span><span class="bash">n，计算“age”存储在第：5个桶</span></span><br></pre></td></tr></table></figure>
<h5 id="底层实现-7">底层实现</h5>
<p>unordered_map底层实现主要就是哈希表：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220219131831129.png" alt="image-20220219131831129"></p>
<p>具体逻辑暂略。</p>
<h4 id="unordered-multimap">unordered_multimap</h4>
<p>回忆map和multimap的区别：</p>
<blockquote>
<p>map和multimap主要的不同体现在：</p>
<ul>
<li>multimap 可以同时<u>存储多个键相同的键值对</u>；</li>
<li>multimap 除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code> 等<u>直接按key获取value的方式</u>（很好理解，multimap会存在多个重复的键）。</li>
</ul>
<p>multimap 也定义在 <code>&lt;map&gt;</code> 头文件，…</p>
</blockquote>
<p>unordered_map和unordered_multimap的<u>区别同上</u>：</p>
<ul>
<li>
<p>unordered_multimap可以同时<u>存储多个键相同的键值对</u>；</p>
</li>
<li>
<p>unordered_multimap除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code> 等<u>直接按key获取value的方式</u> 。</p>
</li>
</ul>
<p>unordered_multimap也定义在 <code>&lt;unordered_map&gt;</code> 头文件中，使用起来基本和unordered_map没差，不再重复介绍了。</p>
<h4 id="unordered-set">unordered_set</h4>
<p>回忆set和map的区别：</p>
<blockquote>
<p>主要区别在于：</p>
<ul>
<li><strong>set容器存储的键值对（key-value）的key、value完全相同。在底层实现上，map底层区别也主要是修改红黑树存储的key、value保存一致</strong> ;</li>
<li>set容器除了<code>find(key)</code>，不能使用<code>at(key)</code> 或 <code>operator[key]</code>获取value ，虽然在底层实现上set的key等于value，<u>但是不允许获取value</u>。</li>
</ul>
</blockquote>
<p>unordered_set和unordered_map的区别同上。</p>
<h4 id="unordered-multiset">unordered_multiset</h4>
<p>回忆multiset和map的区别：</p>
<blockquote>
<p>multiset和map的主要区别在于：</p>
<ul>
<li>
<p><strong>multiset可以存储相同的键值</strong>；</p>
</li>
<li>
<p>multiset键值对相同；</p>
</li>
<li>
<p>除了map/unordered_map，multiset和set、multimap一样，也不能使用<code>at(key)</code> 或 <code>operator[key]</code>，但可以使用<code>find(key)</code> 。</p>
</li>
</ul>
</blockquote>
<p>unordered_map和unordered_multiset的区别同上。</p>
<h3 id="9-2-4-容器适配器">9.2.4 容器适配器</h3>
<p>本节主要介绍以下容器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">stack</td>
<td style="text-align:center">（默认）deque</td>
<td style="text-align:center">元素“先进后出”</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">queue</td>
<td style="text-align:center">（默认）deque</td>
<td style="text-align:center">元素“先进先出”</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">priority_queue</td>
<td style="text-align:center">（默认）vector</td>
<td style="text-align:center">元素“先进优先级高先出”</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
<p>或许你和第一次接触“容器适配器”这个名词的我，都会感到纳闷：这词听起来有些古怪，它是什么意思呢？它也是容器吗？</p>
<p><strong>“容器适配器”是什么意思</strong>？</p>
<p>在栈（stack）这种数据结构中，必须要满足“先进后出”这种特性。而我们之前的容器，如deque、list都无法满足这种特性。</p>
<p>但我们可以，比如对<u>基础容器</u>deque，进行一层封装：禁止头部进出只允许尾部进出，这样就<u>适配了栈“先进后出”的特性</u>。这种通过，<strong>封装某个序列式容器，并重新组合该容器中包含的成员函数来实现“需要的特性”的容器（必要时也可以自创新函数），就称为容器适配器</strong>。</p>
<p>所以，容器适配器自然也是容器。特别的，STL中的容器适配器，基础容器并不是固定的，还允许我们选择满足条件的基础容器。采用的底层基础容器不同，其执行效率也不尽相同，一般来说使用默认的就行。</p>
<h4 id="stack">stack</h4>
<p>stack 栈适配器是一种单端开口的容器，该容器模拟的就是栈存储结构，<u>只能在栈顶插入、删除</u>。</p>
<p>下图展示了stack的简单使用。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220219135504605.png" alt="image-20220219135504605"></p>
<p>stack 容器以类模板的形式定义在 <code>&lt;stack&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class stack</span><br></pre></td></tr></table></figure>
<p>在 <code>stack&lt;_Tp,_Sequence&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Sequence</code>，指定底层使用的基础容器。</li>
</ul>
<p>简单使用实例。</p>
<p>在这个例子中，我们没有使用默认的deque作为基础容器，而是使用list。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建 stack 容器适配器</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 基础容器list</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">my_stack</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 my_stack 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_stack: &quot;</span> &lt;&lt; my_stack.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    my_stack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_stack: &quot;</span> &lt;&lt; my_stack.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; my_stack.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        my_stack.<span class="built_in">pop</span>();  <span class="comment">// 将栈顶元素弹栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="底层实现-8">底层实现</h5>
<p>stack底层就是封装了基础容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class stack</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//  See queue::c for notes on this name.</span></span><br><span class="line">    _Sequence c;  <span class="comment">// 底层基础容器，模板参数指定</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>查看经典的<code>stack::push()</code>、<code>stack::pop()</code> 实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> value_type&amp; __x)  <span class="comment">// 引用</span></span><br><span class="line">&#123; </span><br><span class="line">	c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x));  <span class="comment">// 就是基础容器的push_back方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(value_type&amp;&amp; __x)  <span class="comment">// 右值引用</span></span><br><span class="line">&#123; </span><br><span class="line">	c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	c.<span class="built_in">pop_back</span>();  <span class="comment">// 基础容器的pop_back方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实主要还是借助基础容器的成员和方法实现。</p>
<h5 id="成员函数-8">成员函数</h5>
<p>相比其它序列或关联式容器，stack 是一类存储机制简单、<u>提供成员函数较少</u>的容器。</p>
<ul>
<li>特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">empty()</td>
<td style="text-align:center">当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center">返回 stack 栈中存储元素的个数</td>
</tr>
<tr>
<td style="text-align:center">top()</td>
<td style="text-align:center">返回一个栈顶元素的引用，类型为 T&amp;，<strong>如果栈为空，程序会报错</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><strong>push(const T&amp; val</strong>)</td>
<td style="text-align:center">先复制 val，再将 val 副本压入栈顶，这是通过调用底层容器的 push_back() 函数完成的</td>
</tr>
<tr>
<td style="text-align:center"><strong>push(T&amp;&amp; obj</strong>)</td>
<td style="text-align:center">以移动元素的方式将其压入栈顶，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop</strong>()</td>
<td style="text-align:center">弹出栈顶元素</td>
</tr>
<tr>
<td style="text-align:center">emplace(arg…)</td>
<td style="text-align:center">arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素</td>
</tr>
<tr>
<td style="text-align:center">swap(stack<T> &amp; other_stack)</td>
<td style="text-align:center">将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的<u>元素类型以及底层采用的基础容器类型，都必须相同</u></td>
</tr>
</tbody>
</table>
<h4 id="queue">queue</h4>
<p>和 stack 栈容器适配器不同，queue 容器适配器有 2 个开口，一个开口（尾部）专门用来加入元素，另一个开头（头部）专门用来移除元素。</p>
<p>这种存储结构最大的特点是，最先进入 queue 的元素，也可以最先从 queue 中出来，即“先进先出”。</p>
<p>下图展示了queue这种结构。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220219145411589.png" alt="image-20220219145411589"></p>
<p>stack 容器以类模板的形式定义在 <code>&lt;stack&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class stack</span><br></pre></td></tr></table></figure>
<p>在 <code>stack&lt;_Tp,_Sequence&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Sequence</code>，指定底层使用的基础容器。</li>
</ul>
<p>简单使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建 stack 容器适配器</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 基础容器list</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">my_queue</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 my_stack 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    my_queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; my_queue.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//将栈顶元素弹栈</span></span><br><span class="line">        my_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size of my_queue: 3</span><br><span class="line">size of my_queue: 4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="底层实现-9">底层实现</h5>
<p>同stack，queue底层就是封装了基础容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = deque&lt;_Tp&gt; &gt;</span><br><span class="line">class queue</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//  See queue::c for notes on this name.</span></span><br><span class="line">    _Sequence c;  <span class="comment">// 底层基础容器，模板参数指定</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><code>queue::push</code>、<code>queue::pop</code>方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> value_type&amp; __x)  <span class="comment">// 引用</span></span><br><span class="line">&#123; </span><br><span class="line">	c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x));  <span class="comment">// 就是基础容器的push_back方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>(value_type&amp;&amp; __x)  <span class="comment">// 右值引用</span></span><br><span class="line">&#123; </span><br><span class="line">	c.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(__x)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	c.<span class="built_in">pop_front</span>();  <span class="comment">// 基础容器的pop_front方法，stack这里是pop_back，所以是尾部弹出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="成员函数-9">成员函数</h5>
<p>queue 容器适配器拥有stack 成员函数基本所有函数（除了<code>top()</code>、<code>emplace()</code>）。</p>
<ul>
<li>特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">empty()</td>
<td style="text-align:center">当 queue中没有元素时，该成员函数返回 true；反之，返回 false</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center">返回 queue中存储元素的个数</td>
</tr>
<tr>
<td style="text-align:center"><s>top</s>()</td>
<td style="text-align:center"><s>queue没有</s></td>
</tr>
<tr>
<td style="text-align:center"><strong>push(const T&amp; val</strong>)</td>
<td style="text-align:center">先复制 val，再将 val 副本压入队尾，这是通过调用底层容器的 push_back() 函数完成的</td>
</tr>
<tr>
<td style="text-align:center"><strong>push(T&amp;&amp; obj</strong>)</td>
<td style="text-align:center">以移动元素的方式将其压入队尾，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop</strong>()</td>
<td style="text-align:center">弹出队头（第一个）元素</td>
</tr>
<tr>
<td style="text-align:center"><s>emplace(arg</s>…)</td>
<td style="text-align:center"><s>queue没有</s></td>
</tr>
<tr>
<td style="text-align:center">swap(queue<T> &amp; other_stack)</td>
<td style="text-align:center">将两个 queue适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue适配器中存储的<u>元素类型以及底层采用的基础容器类型，都必须相同</u></td>
</tr>
</tbody>
</table>
<p>queue 独有的函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">front()</td>
<td style="text-align:center">返回 queue 中第一个元素的引用</td>
</tr>
<tr>
<td style="text-align:center">back()</td>
<td style="text-align:center">返回 queue 中最后一个元素的引用</td>
</tr>
</tbody>
</table>
<h4 id="priority-queue">priority_queue</h4>
<p>priority_queue 容器适配器中元素的进出，遵循“先进优先级高的先出”原则。</p>
<p><strong>那priority_queue 中元素优先级是如何评定</strong>？</p>
<p>每个 priority_queue 容器适配器在创建时，都制定了一种“排序规则”。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。</p>
<p>比如这种“排序规则”，可以是：元素值从大到小或从小到大。</p>
<p>priority_queue中元素进出和queue有些不同：</p>
<ul>
<li>进：不直接插到队尾，找到优先级最高的元素，并将其移动到队列的队头；</li>
<li>出：直接移出队头，然后找到当前优先级最高的元素，并将其移动到队头。</li>
</ul>
<p>优先队列可以使用<u>数组</u>、<u>二叉搜索树</u>、<u>链表</u>和<u>堆</u>数据结构来实现。但是，最好的选择是堆数据结构，因为它有助于相对更快、更有效地实现优先级队列。</p>
<p>priority_queue容器以类模板的形式定义在 <code>&lt;queue&gt;</code> 头文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, </span><br><span class="line">		  <span class="keyword">typename</span> _Sequence = vector&lt;_Tp&gt;,</span><br><span class="line">	      <span class="keyword">typename</span> _Compare  = less&lt;typename_Sequence::value_type&gt; &gt;</span><br><span class="line">class priority_queue</span><br></pre></td></tr></table></figure>
<p>在 <code>priority_queue&lt;_Tp,_Sequence,_Compare&gt;</code> 模板中：</p>
<ul>
<li><code>_Tp</code>，用于指明容器中元素数据类型；</li>
<li><code>_Sequence</code>，指定底层使用的基础容器；</li>
<li><code>_Compare</code> ，指定排序规则。</li>
</ul>
<p>简单使用例子。</p>
<p>注意priority_queue的初始化有些不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建 stack 容器适配器</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;  <span class="comment">// 此时是无序的list</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;int, deque&lt;int&gt;&gt; my_priority_queue(values); // error,不能使用这种方式初始化</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, deque&lt;<span class="keyword">int</span>&gt;&gt; my_priority_queue&#123;values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>()&#125; ; <span class="comment">// 初始化指定两个迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 my_priority_queue 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_priority_queue: &quot;</span> &lt;&lt; my_priority_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    my_priority_queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_priority_queue: &quot;</span> &lt;&lt; my_priority_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_priority_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; my_priority_queue.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 输出有序</span></span><br><span class="line">        <span class="comment">// 队头元素（最高优先级出栈）</span></span><br><span class="line">        my_priority_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出（有序）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roy-cpp test]# ./test.out </span><br><span class="line">size of my_priority_queue: 3</span><br><span class="line">size of my_priority_queue: 4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="成员函数-10">成员函数</h5>
<p>priority_queue 拥有的成员函数和tack更像（基本一致）：</p>
<ul>
<li>
<p>有<code>top()</code> 方法，没有queue独有的<code>front()</code> 或<code>back()</code> 方法；</p>
</li>
<li>
<p>特别的，容器适配器都没有迭代器，所以遍历元素：只能不断移除元素，去访问下一个元素。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">成员函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">empty()</td>
<td style="text-align:center">当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false</td>
</tr>
<tr>
<td style="text-align:center"><strong>size</strong>()</td>
<td style="text-align:center">返回 stack 栈中存储元素的个数</td>
</tr>
<tr>
<td style="text-align:center">top()</td>
<td style="text-align:center">返回一个栈顶元素的引用，类型为 T&amp;，<strong>如果栈为空，程序会报错</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><strong>push(const T&amp; val</strong>)</td>
<td style="text-align:center">先复制 val，再将 val 副本压入栈顶，这是通过调用底层容器的 push_back() 函数完成的</td>
</tr>
<tr>
<td style="text-align:center"><strong>push(T&amp;&amp; obj</strong>)</td>
<td style="text-align:center">以移动元素的方式将其压入栈顶，这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td>
</tr>
<tr>
<td style="text-align:center"><strong>pop</strong>()</td>
<td style="text-align:center">弹出栈顶元素</td>
</tr>
<tr>
<td style="text-align:center">emplace(arg…)</td>
<td style="text-align:center">arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素</td>
</tr>
<tr>
<td style="text-align:center">swap(stack<T> &amp; other_stack)</td>
<td style="text-align:center">将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的<u>元素类型以及底层采用的基础容器类型，都必须相同</u></td>
</tr>
</tbody>
</table>
<h3 id="9-2-5-容器最佳实践">9.2.5 容器最佳实践</h3>
<p>在本节我们从<u>基本使用</u>、<u>底层实现</u>、<u>常用函数</u>等方面介绍了众多容器，它们可分为：</p>
<ol>
<li>序列式容器：array、vector、deque、list 和 forward_list；</li>
<li>关联式容器：map、multimap、set 和 multiset；</li>
<li>无序关联式容器：unordered_map、unordered_multimap、unordered_set 和 unordered_multiset；</li>
<li>容器适配器：stack、queue 和 priority_queue。</li>
</ol>
<p><strong>这么多容器，实际编码该选择哪一个呢</strong>？</p>
<p>回忆各个数据结构的特点。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">特点</th>
<th style="text-align:center">对应容器</th>
<th style="text-align:center">对应迭代器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数组</strong></td>
<td style="text-align:center">查找效率高且可随机查找、（除尾部）插入删除效率低</td>
<td style="text-align:center">array/vector/deque</td>
<td style="text-align:center">随机迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>链表</strong></td>
<td style="text-align:center">空间利用率高，插入删除效率高，查找较数组低</td>
<td style="text-align:center">list/forwar_list</td>
<td style="text-align:center">双向或前向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>红黑树</strong></td>
<td style="text-align:center">在STL中存储键值对，增删查改效率均高，还会排序</td>
<td style="text-align:center">map/set/…</td>
<td style="text-align:center">双向迭代器</td>
</tr>
<tr>
<td style="text-align:center"><strong>哈希表</strong></td>
<td style="text-align:center">在STL中存储键值对，不会排序，但比红黑树效率更高</td>
<td style="text-align:center">unordered_map/ unordered_set/…</td>
<td style="text-align:center">前向迭代器</td>
</tr>
</tbody>
</table>
<p>首先，一般来说除非需要键值有序，在无序关联式容器/关联式容器中，优先考虑无序关联式容器。现在，我们再从<u>时间效率角度</u> 出发考虑各种容器的选择：</p>
<ul>
<li><strong>如果查找元素效率要求高</strong> ：选择unordered_map/unordered_set或array/vector/deque
<ul>
<li><strong>如果数据可按键值对存储</strong>：选择unordered_map/unordered_set，O(1)常数级别查找键值；</li>
<li><strong>如果只能顺序存储</strong> ：选择array/vector/deque
<ul>
<li><strong>如果存储的是静态数据</strong>：选array；</li>
<li><strong>如果存储的是动态数据</strong>：只在尾部增、删选vector；头、尾均需要增、删选deque。</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果插入、删除效率要求高</strong>：
<ul>
<li><strong>如果插入、删除位置有要求</strong> ：list/forwar_list
<ul>
<li><strong>如果只在头部插入、删除数据</strong>：选forwar_list；</li>
<li><strong>如果头、尾均需插入、删除数据</strong>：选list。</li>
</ul>
</li>
<li><strong>如果插入、删除位置没要求</strong>：选择unordered_map/unordered_set，O(lgn)级别复杂度。</li>
</ul>
</li>
</ul>
<p>至于stack、queue 和 priority_queue则一般是在你需要：“先进后出”、“先进先出”或“按优先级别出队”，这种特殊情况才考虑。</p>
<h2 id="9-3-算法">9.3 算法</h2>
<p>STL提供了许多算法，供我们来对容器（或数组）中数据进行操作，通常可分两类：</p>
<ul>
<li>会改变它们所应用的序列的算法</li>
<li>不改变它们所应用的序列的算法</li>
</ul>
<p>可通过引入于<code>&lt;algorithm&gt;</code>头文件来使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>不过在本文中，主要还是按算法功能来进行介绍。而且本文不会对各种算法进行具体介绍，通常只是<u>对常用算法进行简单概况</u>。</p>
<p><strong>为什么不详细介绍各类算法</strong>？</p>
<p>主要原因如下：</p>
<ul>
<li>本文已经足够长（~3W字），每个算法详细介绍的话，篇幅长度难以估计把控；</li>
<li>一般情况下我们只需对大致函数功能有所了解就行，实际编码可查看具体的API接口，再深入理解即可。</li>
</ul>
<p>另外，作者在实际工作中如果对一些算法有“踩坑和理解”，还会补充到本文中。</p>
<h3 id="9-3-1-sort">9.3.1 sort</h3>
<p>C++ STL 标准库提供很多实用的排序函数，通过调用它们，我们可以很轻松地实现对<u>普通数组或者容器</u>中指定范围内的元素进行排序。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>sort (first, last)</strong></td>
<td style="text-align:center">对容器或普通数组中 <strong>[first, last)</strong> 范围内的元素进行排序，<strong>默认进行升序排序</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>stable_sort (first, last)</strong></td>
<td style="text-align:center">和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置</td>
</tr>
<tr>
<td style="text-align:center">partial_sort (first, middle, last)</td>
<td style="text-align:center">从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中</td>
</tr>
<tr>
<td style="text-align:center">partial_sort_copy (first, last, result_first, result_last)</td>
<td style="text-align:center">从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中</td>
</tr>
<tr>
<td style="text-align:center"><strong>is_sorted</strong> (first, last)</td>
<td style="text-align:center">检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序</td>
</tr>
<tr>
<td style="text-align:center">is_sorted_until (first, last)</td>
<td style="text-align:center">和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器</td>
</tr>
</tbody>
</table>
<h3 id="9-3-2-merge">9.3.2 merge</h3>
<p>有些场景中，我们需要将 2 个<u>有序序列</u>合并为 1 个有序序列，这时就可以借助 merge() 实现。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>merge (first1, last1,  first2, last2,  result</strong>)</td>
<td style="text-align:center">first1、last1、first2 以及 last2 都为输入迭代器，[first1, last1) 和 [first2, last2) 各用来指定一个有序序列；result 为输出迭代器，指定存储位置</td>
</tr>
<tr>
<td style="text-align:center"><strong>merge (first1, last1,  first2, last2,                  result,  comp</strong>)</td>
<td style="text-align:center">同上，不过多了comp 用于自定义排序规则</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::merge</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// first 和 second 数组中各存有 1 个有序序列</span></span><br><span class="line">    <span class="keyword">int</span> first[] = &#123; <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> second[] = &#123; <span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">57</span> &#125;;</span><br><span class="line">    <span class="comment">// 用于存储新的有序序列</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">myvector</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将 [first,first+5) 和 [second,second+6) 合并为 1 个有序序列，并存储到 myvector 容器中</span></span><br><span class="line">    <span class="built_in">merge</span>(first, first + <span class="number">5</span>, second, second + <span class="number">6</span>, myvector.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-find">9.3.3 find</h3>
<p>find() 函数本质上是一个模板函数，用于在指定范围内查找和<strong>目标元素值相等的第一个元素</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>find(first, last,  const T&amp; val</strong>)</td>
<td style="text-align:center">该函数会返回一个输入迭代器，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。</td>
</tr>
</tbody>
</table>
<p>其它的“find”函数：</p>
<ul>
<li><strong>find_if() 或 find_not_if</strong>()， 和find唯一不同的是，前者需要明确指定要查找的元素的值，而后者则允许自定义查找规则；</li>
<li><strong>find_end() 或 search</strong>()，用于在序列 A 中查找序列 B， 最后一次或第一次出现的位置；</li>
<li><strong>find_first_of</strong>()：在 A 序列中查找和 B 序列中，<strong>和B中任意元素相匹配的第一个元素</strong>。</li>
</ul>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find() 函数作用于普通数组</span></span><br><span class="line">    <span class="keyword">char</span> stl[] =<span class="string">&quot;royhuang&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用 find() 查找第一个字符 &#x27;r&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> * p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    <span class="comment">// 判断是否查找成功</span></span><br><span class="line">    <span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl)) </span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find() 函数作用于容器</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; myvector&#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-reverse">9.3.4 reverse</h3>
<p>reverse函数可以反转一个容器中的元素。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>reverse(_first, last</strong>)</td>
<td style="text-align:center">reverse函数反转的范围是[first,last)，不包括last指向的元素</td>
</tr>
</tbody>
</table>
<p>简单实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>      </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; myvector &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">reverse</span>(myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">end</span>());    <span class="comment">// 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-5-copy-n">9.3.5 copy_n</h3>
<p>copy_n() 算法，可以从源容器复制指定个数的元素到目标容器中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>copy_n(source_first, size, target_start</strong>)</td>
<td style="text-align:center">source_first 是指向源容器的起始位置的迭代器，size是要复制的元素总数， target_start是目标容器的开始迭代器</td>
</tr>
</tbody>
</table>
<p>简单实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 复制arr中5个元素到v1中</span></span><br><span class="line">    <span class="built_in">copy_n</span>(arr, <span class="number">5</span>, v1.<span class="built_in">begin</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-6-fill和fill-n">9.3.6 fill和fill_n</h3>
<p>fill() 和 fill_n() 算法提供了一种为元素序列填入指定值的简单方式，fill() 会填充整个序列； fill_n() 则以给定的迭代器为起始位置，<u>为指定个数</u>的元素设置值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>fill(first, last, value</strong>)</td>
<td style="text-align:center">给容器在位置[first,last)，填充指定值value</td>
</tr>
<tr>
<td style="text-align:center"><strong>fill_n(first, 10, value</strong>)</td>
<td style="text-align:center">从指定位置first开始，填充n个value</td>
</tr>
</tbody>
</table>
<h2 id="9-4-总结">9.4 总结</h2>
<p>本文是《C++从零开始之C++篇》最后一篇博客，因此除了STL总结部分，还特意补充了《C++篇》的总结。</p>
<h3 id="9-4-1-STL总结">9.4.1  STL总结</h3>
<p>在这篇博客中，作者主要从：STL迭代器、STL容器、STL算法对STL进行了全面介绍，其中STL容器是重点阐述内容。</p>
<ul>
<li>迭代器：本质是指针的一层封装，具体实现为模板类，每个容器都有自己的迭代器类。迭代器主要功能是，提供了统一访问各种容器的方式，同时也使得算法和容器得于解耦，必要时可以作为“粘合剂”将二者联系起来。</li>
<li>容器：容器用来组织存储数据，具体实现也是模板类，本质是对数组、链表、红黑树、哈希表等基本数据结构的封装。最后作者还对实践中各种容器的选择，进行了简单总结。</li>
<li>算法：STL中提供了大量的算法供我们使用，具体实现是模板函数。理论上如果能使用STL中算法就尽量使用，本文主要对：sort、merge、find、reverse、copy_n、fill等<u>常用算法</u>进行了简略介绍。</li>
</ul>
<p>不过在本文成型中，也发现了一些不足：</p>
<ul>
<li>博文过长~3W字，放在一篇文章中显得过长，不利于阅读；</li>
<li>作者水平有限，对STL底层分析及STL算法等尚缺乏相关知识或经验，写作中难免部分描述不清。</li>
</ul>
<p>针对上述问题或未发现的一些问题，后期作者会尽量进行完善，并将更新记录同步在文后。</p>
<h3 id="9-4-2-C-总结">9.4.2  C++总结</h3>
<p>在重庆今天这个让人有点昏昏欲睡的下午，STL篇终于完结，不禁舒了一口气，长达2.7w的总结既是《C++篇》最后一篇博客，也应该是目前我写的最长的一篇博客。</p>
<p>也终于可以回过神来，做一个小结。</p>
<p>时间回到~3个月前，大约是11.20号，也就是9月结束找工作痛快玩了2个月后，我感到空虚过于无所事事，开始折腾起了自己的网站。在个人网站总结完自己实习和秋招笔记后，也萌发了学习C++的想法——主要是想到自己在腾讯实习从Java转到C++的痛苦经历，就还是在工作前提前学习一遍C++吧（菜是原罪）。</p>
<p>于是便有了<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 这个系列。</p>
<p>这是我第一次尝试写框架这么大的系列文章（光C++篇已经~13W+字），整个系列完成估计至少有40W字。当然字数多少并不重要，在这个过程中学习到很多，比如明确了一个很重要的原则：“<strong>写的文章不是给自己看的笔记，而是给别人看的博客”</strong>。秉着这个原则，每篇博客写完，我都会代入一个“旁观者”视角，自己读几遍，看逻辑是否清晰、文章是否有错误等。所以，每篇博客甚至整个系列其实一直在完善中。但限于自己的水平，错误和描述不清晰的地方依旧不少，比如每次我自己重读时依旧能发现（好消息是越来越少了）。</p>
<p>whatever，相信不断进步&amp;完善，总能达到满意的效果。</p>
<p><a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 接下来将主要专注于Linux/C++开发方面的知识，所以接下来的内容分为两大篇章：</p>
<ul>
<li>《C++从零开始之Linux/C++系统编程》</li>
<li>《C++从零开始之网络编程》</li>
</ul>
<p>和《C++从零开始之C++》互为《C++从零开始》的三部曲。</p>
<p>敬请期待！</p>
<h1>更新记录</h1>
<div class="timeline">
<div class="timenode"><div class="meta"><p><p>2022-02-19：更新笔记</p>
</p></div><div class="body"><ol><li>第一次更新</li></ol></div></div>
</div>
<h1>参考资料</h1>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">嗨课网-STL教程：https://haicoder.net/stl/stl-data-structure.html<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">迭代器（iterator）和指针（pointer）区别在哪？https://www.zhihu.com/question/54047747<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">STL 源码剖析：https://www.kancloud.cn/digest/stl-sources/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ STL: 容器vector源码分析：https://blog.csdn.net/Z_Stand/article/details/106866871<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">stl源码分析之vector：https://www.cnblogs.com/coderkian/p/3888429.html<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://favtutor.com/blogs/priority-queue-cpp">Priority Queue - Insertion, Deletion and Implementation in C++</a><a href="#fnref:6" rev="footnote"> ↩</a></span></li></ol></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/17467/">https://hwh.zone/p/17467/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/C-%E8%BF%9B%E9%98%B6/">C++进阶</a><a class="post-meta__tags" href="/tags/STL/">STL</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/p/51012/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++从零开始（十）：C++进阶（上）模板</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211214212828.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（一）：环境搭建（上）VSCode远程开发</div></div></a></div><div><a href="/p/17506/" title="C++从零开始（七）：面对对象（上）快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-24</div><div class="title">C++从零开始（七）：面对对象（上）快速入门</div></div></a></div><div><a href="/p/60158/" title="C++从零开始（九）：面对对象（下）继承和虚函数"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">C++从零开始（九）：面对对象（下）继承和虚函数</div></div></a></div><div><a href="/p/2834/" title="C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211215040434.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</div></div></a></div><div><a href="/p/43924/" title="C++从零开始（八）：面对对象（中）运算符重载"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-27</div><div class="title">C++从零开始（八）：面对对象（中）运算符重载</div></div></a></div><div><a href="/p/6587/" title="C++从零开始（六）：务实基础（下）复合类型及转换"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">C++从零开始（六）：务实基础（下）复合类型及转换</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">九、STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">9.1 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E8%AE%A4%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">9.1.1 认识迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9Aiterator"><span class="toc-text">容器迭代器：iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%85%B6%E5%AE%83%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">容器其它迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">9.1.2  迭代器和指针？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%AE%B9%E5%99%A8"><span class="toc-text">9.2 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">9.2.1 序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#array"><span class="toc-text">array</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-2"><span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-3"><span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list"><span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-4"><span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list"><span class="toc-text">forward_list</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-5"><span class="toc-text">成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">9.2.2 关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pair"><span class="toc-text">pair</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-6"><span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-6"><span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multimap"><span class="toc-text">multimap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-text">set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multiset"><span class="toc-text">multiset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">9.2.3 无序关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-map"><span class="toc-text">unordered_map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-7"><span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-7"><span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multimap"><span class="toc-text">unordered_multimap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-set"><span class="toc-text">unordered_set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multiset"><span class="toc-text">unordered_multiset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">9.2.4 容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-8"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-8"><span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue"><span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-9"><span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-9"><span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue"><span class="toc-text">priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-10"><span class="toc-text">成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-%E5%AE%B9%E5%99%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">9.2.5 容器最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E7%AE%97%E6%B3%95"><span class="toc-text">9.3 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-sort"><span class="toc-text">9.3.1 sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-merge"><span class="toc-text">9.3.2 merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-find"><span class="toc-text">9.3.3 find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-reverse"><span class="toc-text">9.3.4 reverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-copy-n"><span class="toc-text">9.3.5 copy_n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-6-fill%E5%92%8Cfill-n"><span class="toc-text">9.3.6 fill和fill_n</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E6%80%BB%E7%BB%93"><span class="toc-text">9.4 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-1-STL%E6%80%BB%E7%BB%93"><span class="toc-text">9.4.1  STL总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-2-C-%E6%80%BB%E7%BB%93"><span class="toc-text">9.4.2  C++总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">更新记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/17467/" title="C++从零开始（十一）：C++进阶（下）STL">C++从零开始（十一）：C++进阶（下）STL</a><time datetime="2022-02-14T09:55:49.585Z" title="发表于 2022-02-14 17:55:49">2022-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/51012/" title="C++从零开始（十）：C++进阶（上）模板">C++从零开始（十）：C++进阶（上）模板</a><time datetime="2022-02-11T08:17:22.936Z" title="发表于 2022-02-11 16:17:22">2022-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/60158/" title="C++从零开始（九）：面对对象（下）继承和虚函数">C++从零开始（九）：面对对象（下）继承和虚函数</a><time datetime="2022-02-08T08:24:59.978Z" title="发表于 2022-02-08 16:24:59">2022-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43924/" title="C++从零开始（八）：面对对象（中）运算符重载">C++从零开始（八）：面对对象（中）运算符重载</a><time datetime="2022-01-27T06:47:34.826Z" title="发表于 2022-01-27 14:47:34">2022-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <h1 id="tree-toc-title" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/categories/">目 录 </a> </h1>
      <h5 id="tree-toc-subtitle" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/">royhuang's blog</a> </h5>
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/6587/" title="C++从零开始（六）：务实基础（下）复合类型及转换"><i class="post-icon gg-file-document"></i>C++从零开始（六）：务实基础（下）复合类型及转换</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/26224/" title="C++从零开始（三）：务实基础（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（三）：务实基础（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51595/" title="C++从零开始（五）：务实基础（下）函数"><i class="post-icon gg-file-document"></i>C++从零开始（五）：务实基础（下）函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/24237/" title="C++从零开始（四）：务实基础（中）指针和引用"><i class="post-icon gg-file-document"></i>C++从零开始（四）：务实基础（中）指针和引用</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/">
          C++进阶
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51012/" title="C++从零开始（十）：C++进阶（上）模板"><i class="post-icon gg-file-document"></i>C++从零开始（十）：C++进阶（上）模板</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17467/" title="C++从零开始（十一）：C++进阶（下）STL"><i class="post-icon gg-file-document"></i>C++从零开始（十一）：C++进阶（下）STL</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
          C++环境搭建
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）VSCode远程开发</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/">
          C++面对对象
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17506/" title="C++从零开始（七）：面对对象（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（七）：面对对象（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/60158/" title="C++从零开始（九）：面对对象（下）继承和虚函数"><i class="post-icon gg-file-document"></i>C++从零开始（九）：面对对象（下）继承和虚函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43924/" title="C++从零开始（八）：面对对象（中）运算符重载"><i class="post-icon gg-file-document"></i>C++从零开始（八）：面对对象（中）运算符重载</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记（初步整理）"><i class="post-icon gg-file-document"></i>Git基础笔记（初步整理）</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>