<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>校招笔记（一）_Java_面对对象 | royhuang's blog</title><meta name="keywords" content="JAVA,校招"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:type" content="article">
<meta property="og:title" content="校招笔记（一）_Java_面对对象">
<meta property="og:url" content="https://hwh.zone/p/7257/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="我的校招记录：校招笔记（零）_写在前面 ，以下是校招笔记总目录。       备注     算法能力（“刷题”） 这部分就是耗时间多练习，Leetcode-Top100 是很好的选择。 补充练习：codeTop   计算机基础(上)（“八股”） 校招笔记（一）__Java_Java入门 C++后端后续更新    校招笔记（一）__Java_面对对象     校招笔记（一）__Java_集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2021-11-26T11:57:22.483Z">
<meta property="article:modified_time" content="2021-12-03T03:57:17.880Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="校招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/7257/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校招笔记（一）_Java_面对对象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:57:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">校招笔记（一）_Java_面对对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-26T11:57:22.483Z" title="发表于 2021-11-26 19:57:22">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:57:17.880Z" title="更新于 2021-12-03 11:57:17">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">校招笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="校招笔记（一）_Java_面对对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>我的校招记录：<a target="_blank" rel="noopener" href="https://www.hwh.zone/p/29708/">校招笔记（零）_写在前面</a> ，以下是校招笔记总目录。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>算法能力（“刷题”）</strong></td>
<td style="text-align:center">这部分就是耗时间多练习，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/2cktkvj/">Leetcode-Top100</a> 是很好的选择。</td>
<td style="text-align:center">补充练习：<a target="_blank" rel="noopener" href="https://codetop.cc/">codeTop</a></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(上)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/51787/">校招笔记（一）__Java_Java入门</a></td>
<td style="text-align:center">C++后端后续更新</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/7257/">校招笔记（一）__Java_面对对象</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/21069/">校招笔记（一）__Java_集合</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/8959/">校招笔记（一）__Java_多线程</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/45493/">校招笔记（一）__Java_锁</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/42516/">校招笔记（一）__Java_JVM</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>计算机基础(下)（“八股”）</strong></td>
<td style="text-align:center"><a href="http://hwh.zone/p/44980/">校招笔记（二）__计算机基础_Linux&amp;Git</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/46361/">校招笔记（三）__计算机基础_计算机网络</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/15646/">校招笔记（四）__计算机基础_操作系统</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/56848/">校招笔记（五）__计算机基础_MySQL</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/31215/">校招笔记（六）__计算机基础_Redis</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/61434/">校招笔记（七）__计算机基础_数据结构</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="https://hwh.zone/p/31667/">校招笔记（八）__计算机基础_场景&amp;智力题</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://hwh.zone/p/5582/">校招笔记（九）__计算机基础_相关补充</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>项目&amp;实习</strong></td>
<td style="text-align:center">主要是怎么准备项目，后续更新</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="1-2-面对对象">1.2 面对对象</h2>
<h3 id="1-2-1-基本问题">1.2.1 基本问题</h3>
<h4 id="1-介绍一下面对对象七大原则？三大特性？">1.<strong>介绍一下面对对象七大原则？三大特性</strong>？</h4>
<h5 id="七大原则">七大原则</h5>
<ul>
<li>
<p><strong>单一职责原则</strong>： 就一个类来说，应该仅有一个引起它变化的原因。也就是说，<strong>一个类应该只有一个职责</strong>。</p>
<blockquote>
<p>如果有多个职责，那么就相当于把这些指责耦合在起，一个职责的变化就可能削弱或抑制了这个类完成其他职责的能力，引起类的变化的原因就会有多个。所以在构造一个类时， 将类的不同职责分离至两个或多个类中(或者接口中)，确保引起该类变化的原因只有一个。</p>
</blockquote>
</li>
<li>
<p><strong>开闭原则(OCP)</strong>： 软件组成实体应该是可扩展的，但是不可修改。开放-封闭原则认为应该试图设计永远也不需要改变的模块。可以添加新代码来打展系统的行为，不能对已有的代码进行修改。</p>
<blockquote>
<p>这个原则很好的实现了面向对象的封装性和可重用性。</p>
</blockquote>
</li>
<li>
<p><strong>李氏替换原则(LSP)</strong>： 子类应当可以替换父类并出现在父类能够出现的任何地方。</p>
<blockquote>
<p>以圆和椭圆为例，圆是椭圆的一一个特殊子类。因此任何出现椭圆的地方，圆均可以出现。</p>
</blockquote>
</li>
<li>
<p><strong>依赖倒置原则(DIP)</strong>： 在进行业务设计时，与<u>特定业务有关的依赖</u>关系应该尽量依赖<strong>接口和抽象类</strong>，<strong>而不是依赖于具体类</strong>。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。</p>
<blockquote>
<p>为此，在进行业务设计时，应尽量在接口或抽象类中定义业务方法的原型，并通过具体的实现类(子类)来实现该业务方法，业务方法内容的修改将不会影响到运行时业务方法的调用。</p>
</blockquote>
</li>
<li>
<p><strong>接口分离原则(ISP)</strong>：  <u>采用多个与特定客户类有关的接口</u> 比采用一个通用的涵盖多个业务方法的接口要好。</p>
<blockquote>
<p>举例：如果拥有一个针对多个客户的类，为每一个客户创建特定业务接口，然后使该客户类继承多个特定业务接口将<u>比直接加载客户所需所有方法有效</u>。</p>
</blockquote>
</li>
<li>
<p><strong>组合重用原则</strong> ：能用组合实现的地方，<strong>尽量用组合来</strong>实现，而<strong>不要使用继承</strong>来扩展功能。</p>
<blockquote>
<p>097因为组合能更好地实现封装，比继承具有更大的灵活性和更稳定的结构。</p>
</blockquote>
</li>
<li>
<p><strong>迪米特原则 :</strong> <u>一个对象应该对于其他对象有最少的了解</u>，这样做的好处就是可以有效地降低类之间的耦合要求。</p>
</li>
</ul>
<h5 id="三大特性">三大特性</h5>
<ul>
<li>
<p><strong>封装</strong>。<u>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的方法</u>，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果⼀个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
</li>
<li>
<p><strong>继承</strong>。 <u>继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能</u>，也可以用⽗类的功能，但不能选择性地继承⽗类。通过使用继承我们能够非常方便地<strong>复用</strong>以前的代码。</p>
<blockquote>
<ol>
<li>子类拥有⽗类对象所有的属性和方法（包括私有属性和私有方法），但是⽗类中的私有属性和方法子类是无法访问，只是拥有。</li>
<li>子类可以拥有⾃⼰属性和方法，即子类可以对⽗类进行扩展。</li>
<li>子类可以用⾃⼰的方式实现⽗类的方法。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>多态</strong>。（1）<strong>静态多态：重载</strong> （2）<strong>动态多态</strong>：所谓多态就是指程序中定义的<strong>引用变量所指向的具体类型</strong>和&lt;通过该<strong>引用变量发出的方法调用</strong>在<strong>编程时并不确定</strong>，而是在【<strong>程序运行期间才确定</strong>】。即⼀个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<blockquote>
<p>在 Java 中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同⼀方法的重写）和<strong>接口</strong>（实现接口并覆盖接口中同⼀方法）。</p>
</blockquote>
</li>
</ul>
<h5 id="1-1-java多态的原理？【阿里-待重写】">1.1 java多态的原理？【阿里&amp;待重写】</h5>
<p>多态分两种：（1）【编译】时多态（静态多态）（2）运行时多态（动态多态）。</p>
<ol>
<li>
<p><strong>静态多态</strong></p>
<p><strong>重载</strong>（overload）就是编译时多态的一个例子，<strong>编译时</strong>多态在编译时就已经<strong>确定</strong>。</p>
<p>运行时运行的时候调用的是确定的方法。</p>
</li>
<li>
<p><strong>动态多态</strong></p>
<blockquote>
<p>我们通常所说的多态指的都是运行时多态，也就是<strong>编译时不确定究竟调用哪个具体方法</strong>，一直延迟到运行时（<strong>链接过程</strong>）才能确定。</p>
</blockquote>
<p>通常动态多态的实现方法：</p>
<ol>
<li>子类继承父类（extends）</li>
<li>类实现接口（implements）</li>
</ol>
<p>核心之处就在于<strong>对父类方法的改写或对接口方法的实现</strong>，以取得在运行时不同的执行效果。</p>
</li>
<li>
<p><strong>多态运行的原理</strong></p>
<blockquote>
<p>详细建议查看：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94086109">深入理解Java多态的实现原理</a></p>
</blockquote>
<ul>
<li>
<p><strong>背景介绍</strong></p>
<p><img src="https://i.loli.net/2021/04/21/m1Ot3nQcMGq2YfW.jpg" alt="img"></p>
<p><u>类加载</u> 时会将<strong>类的元数据信息</strong>（<strong>类的方法代码、类变量、成员变量的定义</strong>等等）保存到方法区，<strong>方法区</strong>主要分为两部分：</p>
<ol>
<li><strong>常量池</strong>：Java 类引用的一些常量信息，比如<strong>类的符号引用信息</strong></li>
<li><strong>方法区其它部分</strong>： 保存<strong>方法表</strong>等</li>
</ol>
<p><u>链接过程</u> <strong>类的多态就发生在 <u>链接的解析</u></strong> 过程，将 <u>符号引用替换为直接引用</u>。</p>
</li>
<li>
<p><strong>原理简述（子类方法继承</strong>）</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html">https://www.huaweicloud.com/articles/9b805c24ab31a65f5883c0dfeaf5a39b.html</a></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="2-请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？">2.<strong>请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数</strong>？</h4>
<ul>
<li><strong>构造函数</strong>： 每一个类都有构造函数，程序员没有创建时，编译器会默认创建一个构造函数；<strong>对象被创建时，构造函数被调用</strong>；</li>
<li><strong>构造函数重载</strong>： 和方法重载类似，一个类可以创建多个构造函数，每个构造函数都有<strong>唯一参数列表</strong>；</li>
<li><strong>复制构造函数</strong>： Java不支持像C++中那样的复制构造函数。</li>
</ul>
<h4 id="3-请说明Java中的方法重写-Overriding-和方法重载-Overloading-是什么意思？构造函数能否被重写？">3.<strong>请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写</strong>？</h4>
<ul>
<li>
<p>Overriding ： 方法重写是说<u>子类重新定义了父类的方法</u>，有<u>相同的方法名，参数列表和返回类型</u> ；</p>
</li>
<li>
<p>Overloading： 同一个类里面两个或者是多个方法<u>同名</u> ，但 <u>参数列表不同</u>不同。</p>
<blockquote>
<p>特别的重写要求返回类型一致，但<strong>重载不要求返回类型一致</strong>！</p>
</blockquote>
</li>
</ul>
<p><strong>构造函数不能被 override（重写）</strong>！但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。</p>
<h5 id="3-1-f（List-String-l）-f（List-Integer-l）是重载么？">3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</h5>
<p>不是重载。</p>
<p>静态类型一致，并<strong>不会因为泛型而改变</strong>。因为<strong>编译</strong>期间，会对泛型进行<strong>擦除</strong>。</p>
<h4 id="4-介绍一下接口和抽象类的区别？">4.<strong>介绍一下接口和抽象类的区别</strong>？</h4>
<ul>
<li>
<p><strong>设计层面</strong></p>
<p>接口，是对类的行为进行约束，<strong>强制要求</strong>不同类实现相同行为 ； 抽象类，既 1.<strong>非抽象类实现代码复用</strong> 2.又同时有<strong>抽象方法使得被继承类各自实现</strong>。</p>
</li>
<li>
<p><strong>方法实现</strong></p>
<p>抽象类可以<strong>有非抽象方法，有方法体</strong> ； 接口不能有。</p>
<blockquote>
<p><strong>抽象类中添加新的方法，你可以给它提供默认的实现</strong>。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
</blockquote>
</li>
<li>
<p><strong>构造函数</strong></p>
<p>抽象类有；接口没有。</p>
</li>
<li>
<p><strong>修饰符</strong></p>
<p>抽象类除private 都有（抽象类目的是被继承，所以<strong>抽象方法是为被重写，不能私有</strong>）；接口<strong>默认public</strong>。</p>
</li>
<li>
<p><strong>继承个数 [接口优]</strong></p>
<p>抽象类只能被继承一次；接口可以有多个。</p>
</li>
</ul>
<h4 id="5-Java的四种引用？强软弱虚-？">5. <strong>Java的四种引用？强软弱虚</strong> ？</h4>
<ul>
<li>
<p><strong>强引用</strong> ：强引用是平常中使用最多的引用，强引用<strong>在程序内存不足（OOM</strong>）的时候也不会被回收，使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>软引用</strong>： 软引用<strong>在程序内存不足时，会被回收（“软”，没钱用了第一个被打劫</strong>），使用方式：</p>
<blockquote>
<p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收<u>早先创建的对象</u>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>弱引用</strong>：是<strong>只要<u>JVM垃圾回收器发现了弱引用</u>，就会将之回收</strong>，使用方式：</p>
<blockquote>
<p><strong>可用场景</strong>：  Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用。一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>虚引用：无法通过虚引用来获取对一个对象的真实引用</strong>； 虚引用必须与ReferenceQueue一起使用，当GC准备回收一个<strong>对象</strong>，如果发现<strong>它还有虚引用</strong>，就会在回收之前，把这个虚引用加入到与之关联的ReferenceQueue中。</p>
<blockquote>
<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>),</span><br><span class="line"><span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-JAVA创建对象的机制？">6. <strong>JAVA创建对象的机制</strong>？</h4>
<ul>
<li>
<p>new创建新对象</p>
</li>
<li>
<p>通过反射机制</p>
</li>
<li>
<p>采用clone机制</p>
</li>
<li>
<p>通过序列化机制</p>
</li>
</ul>
<h4 id="7-简述Java的对象结构？">7.<strong>简述Java的对象结构</strong>？</h4>
<p>Java对象由三个部分组成：对象头、实例数据、<u>对齐填充</u>。</p>
<ol>
<li>
<p><strong>对象头</strong>。 在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：<strong>mark word和类型指针</strong>。 如果是数组对象，还有数组长度。</p>
<ol>
<li>
<p><u><code>mark word(32位)</code></u></p>
<p><img src="https://i.loli.net/2021/05/16/PjXkchreF9sSEKG.png" alt="image-20210516131559341"></p>
<ul>
<li>具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记（分代年龄）、偏向锁线程ID、偏向锁时间戳。</li>
<li>当对象状态为偏向锁时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；<strong>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针</strong>。</li>
</ul>
</li>
<li>
<p><u>存储类型指针</u>，也就是指向类的元数据的指针，通过这个指针才能确定对象是<strong>属于哪个类的实例</strong>；</p>
</li>
<li>
<p><u>数组长度：</u>另外对于数组而言还会有一份记录数组长度的数据。</p>
</li>
</ol>
</li>
<li>
<p><strong>实例数据</strong>。 来存储对象真正的有效信息（包括父类继承下来的和自己定义的）；</p>
</li>
<li>
<p><strong>对齐填充</strong>。JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。</p>
</li>
</ol>
<h4 id="8-Object有哪些常用方法？">8. Object有哪些常用方法？</h4>
<ul>
<li><em>equals方法</em></li>
<li>hashCode方法</li>
<li>wait方法</li>
<li>notify方法</li>
<li>notifyAll方法</li>
</ul>
<h3 id="1-2-2-反射">1.2.2 反射</h3>
<h4 id="1-请说明一下JAVA中反射的实现过程和作用分别是什么？-（快手）优缺点？">1.<strong>请说明一下JAVA中反射的实现过程和作用分别是什么</strong>？ （快手）优缺点？</h4>
<ul>
<li>
<p><strong>定义</strong></p>
<p>反射机制是<strong>在运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<blockquote>
<p>jdbc就是典型的反射 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载MySQL的驱动类</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p><strong>实现和作用</strong></p>
<p>JAVA语言编译之后会生成一个<code>.class</code>文件，反射就是通过<strong>字节码</strong>文件<strong>找到某一个类、类中的方法以及属性</strong>等。</p>
<ul>
<li>
<p><strong>实现</strong>： （1）<strong>代码会编译成一个.class文件</strong> （2）<strong>类加载器加载进JVM的内存中，在方法区创建了Object类的Class对象</strong></p>
<blockquote>
<p>不是new出来的对象，而是类的类型对象，每个类都只有一个Class对象，作为方法区类的数据结构的接口。</p>
</blockquote>
<p>我们便是通过这个class对象来进行反射获取类的信息。</p>
</li>
<li>
<p><strong>作用</strong>：</p>
<ol>
<li>反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，<strong><u>只要给定类的名字</u></strong>，那么就可以通过反射机制来获取类的所有信息。</li>
<li>根据类名在<strong>运行时创建实例</strong>（类名可以从配置文件读取，不用new）</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>反射优缺点</strong></p>
<ul>
<li><strong>优点</strong>：（1）对于任意一个类，都能够知道这个类的所有属性和方法；（2）对于任意一个对象，都能够调用它的任意一个方法</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>性能降低</strong> ： 反射包括了一些<strong>动态类型</strong>，所以JVM<strong>无法对这些代码进行优化</strong></li>
<li><strong>安全限制</strong>： 使用反射技术要求程序必须在一个<strong>没有安全限制的环境</strong>中运行</li>
<li><strong>内部暴露</strong>：由于反射允许代码执行一些在正常情况下不被允许的操作（比如<strong>访问私有的属性和方法</strong>），所以使用反射可能会导致意料之外的副作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-解释一下JAVA代理模式？动态代理的原理？">2. 解释一下JAVA代理模式？动态代理的原理？</h4>
<blockquote>
<p>参考这个：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54733692">JAVA面试50讲之9：动态代理的原理是什么？</a></p>
</blockquote>
<p>代理模式是给某一个对象提供一个代理，并由【<strong>代理对象】控制对【原对象】的引用(使用)</strong>。</p>
<ul>
<li><strong>优点</strong>：代理模式能够协调调用者和被调用者，<u>在一定程度上降低了系统的<strong>耦合度</strong></u>；可以<u>灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务</u>。</li>
<li><strong>缺点</strong>：由于使用了代理模式，因此程序的性能<u>没有直接调用性能高</u>；使用代理模式<u>提高了代码的复杂度</u>。</li>
</ul>
<p>根据代理模式又可以分为：静态代理和动态代理。</p>
<h5 id="2-1-静态代理">2.1 静态代理</h5>
<blockquote>
<p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在<strong>编译时</strong>就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p>
</blockquote>
<p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。</p>
<ul>
<li>
<p>一个班的同学（Student）要向老师交班费，但是都是通过班长（StudentProxy）把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。</p>
</li>
<li>
<p><strong>公共Person接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Student实现Person接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>StudentsProxy实现Person接口</strong></p>
<p>实现了Peson接口，<strong>同时持有一个Student对象</strong>，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p>
<blockquote>
<p>⚠️ 自己实现的giveMoney，调用的是<strong>被代理的学生对象.giveMoney()</strong> 方法！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被【代理学生的上交班费】行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用实例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> StudentsProxy(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//班长代理上交班费，实际上是调用被代理对象的giveMoney方法</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用实例2</strong>：扩充增强原对象方法</p>
<p>班长在帮张三上交班费之前，想要先反映一下<strong>张三最近学习有很大进步</strong>，通过代理模式很轻松就能办到 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三最近学习有进步！&quot;</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-2-动态代理">2.2 动态代理</h5>
<blockquote>
<p>上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就<strong>已经编译</strong>完成 。</p>
</blockquote>
<p>然而动态代理，代理类<strong>并不是在Java代码中定义</strong>的，而是在运行时根据我们在Java代码中的“指示”<strong>动态生成</strong>“的 。</p>
<ul>
<li>
<p><strong>优点</strong>： 可以很方便的对代理类的函数进行统一的处理，<strong>而不用修改每个代理类中的方法</strong>。 比如说，想要在每个代理的方法前<u>都加上</u>一个处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理类其它方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveHomework</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveHomework();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>除了giveMonney还有很多其他的方法（giveHomework），那就需要写很多次beforeMethod方法，麻烦。</p>
</li>
<li>
<p><strong>简单实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>公共Person接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Student实现Person接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>增加一个计算方法执行时间的检测方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">&quot;方法耗时&quot;</span> + (finishTime - tl.get()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>StuInvocationHandler 实现 InvocationHandler接口</strong></p>
<blockquote>
<p>并没有像之前一样：用一个代理类 StudentsProxy实现公共<strong>Person</strong>接口，而是代理类StuInvocationHandler 实现<strong>InvocationHandler</strong>接口。</p>
<p>但二者<strong>都是持有被代理的对象Student引用</strong>。</p>
</blockquote>
<p>InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p>
<ul>
<li>通过<strong>反射</strong>，可以执行被代理对象Student的相应方法giveMoney()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="comment">// 原来的代理对象Student中的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>具体实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/26/bIVRJdO5vKX36nQ.jpg" alt="img"></p>
</li>
</ul>
<h5 id="2-3-动态代理的原理">2.3 动态代理的原理</h5>
<p>从 JVM 角度来说，动态代理是在运行时<u>，通过<strong>反射</strong>动态生成类<strong>字节码</strong>，</u>并加载到 JVM 中的。</p>
<h4 id="3-如何利用反射创建一个对象？">3. 如何利用反射创建一个对象？</h4>
<p>过程如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 得到Stu类的运行时Class描述符</span></span><br><span class="line">            <span class="comment">//简单理解为你现在有了这个类，可以调用相应的方法进行实例化了</span></span><br><span class="line">            Class&lt;?&gt; stu = Class.forName(<span class="string">&quot;Stu&quot;</span>);</span><br><span class="line">            <span class="comment">//2.从getDeclaredConstructor()的字面意思就能理解，得到所有声明的构造器</span></span><br><span class="line">            <span class="comment">//这里得到的是所有声明的构造器，getConstructor()则只能得到被public修饰的构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = stu.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">            <span class="comment">//3. 使用newInstance()方法创建对象并传入参数</span></span><br><span class="line">            <span class="comment">//简单的理解为Stu o = new Stu(&quot;zhangsan&quot;, 01)</span></span><br><span class="line">            Stu o = (Stu) declaredConstructor.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">01</span>&#125;);</span><br><span class="line">            <span class="comment">//4.调用Stu这个类里面的方法</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod()方法能调用到所有声明的方法</span></span><br><span class="line">            Method method = stu.getDeclaredMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">            <span class="comment">//5. 简单的理解为o.toStirng()</span></span><br><span class="line">            String invoke = (String)method.invoke(o, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">            System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/7257/">https://hwh.zone/p/7257/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E6%A0%A1%E6%8B%9B/">校招</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/51787/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">校招笔记（一）_Java_Java入门</div></div></a></div><div class="next-post pull-right"><a href="/p/21069/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（一）_Java_集合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/51787/" title="校招笔记（一）_Java_Java入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_Java入门</div></div></a></div><div><a href="/p/42516/" title="校招笔记（一）_Java_JVM"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_JVM</div></div></a></div><div><a href="/p/8959/" title="校招笔记（一）_Java_多线程"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_多线程</div></div></a></div><div><a href="/p/45493/" title="校招笔记（一）_Java_锁"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_锁</div></div></a></div><div><a href="/p/21069/" title="校招笔记（一）_Java_集合"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（一）_Java_集合</div></div></a></div><div><a href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">校招笔记（七）_计算机基础_数据结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royHuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.2 面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-text">1.2.1 基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9F%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">1.介绍一下面对对象七大原则？三大特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">七大原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">三大特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-java%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E3%80%90%E9%98%BF%E9%87%8C-%E5%BE%85%E9%87%8D%E5%86%99%E3%80%91"><span class="toc-text">1.1 java多态的原理？【阿里&amp;待重写】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E8%A7%A3%E9%87%8AJava%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">2.请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%B7%E8%AF%B4%E6%98%8EJava%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-Overriding-%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-Overloading-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-text">3.请说明Java中的方法重写(Overriding)和方法重载(Overloading)是什么意思？构造函数能否被重写？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-f%EF%BC%88List-String-l%EF%BC%89-f%EF%BC%88List-Integer-l%EF%BC%89%E6%98%AF%E9%87%8D%E8%BD%BD%E4%B9%88%EF%BC%9F"><span class="toc-text">3.1 f（List&lt;String&gt; l） f（List&lt;Integer&gt; l）是重载么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.介绍一下接口和抽象类的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9F%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A-%EF%BC%9F"><span class="toc-text">5. Java的四种引用？强软弱虚 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-JAVA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">6. JAVA创建对象的机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%AE%80%E8%BF%B0Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">7.简述Java的对象结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Object%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">8. Object有哪些常用方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%8F%8D%E5%B0%84"><span class="toc-text">1.2.2 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8BJAVA%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E5%92%8C%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%EF%BC%88%E5%BF%AB%E6%89%8B%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">1.请说明一下JAVA中反射的实现过程和作用分别是什么？ （快手）优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJAVA%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">2. 解释一下JAVA代理模式？动态代理的原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.1 静态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.2 动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">2.3 动态代理的原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">3. 如何利用反射创建一个对象？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/52463/" title="C++从零开始（二）：基础语法（上）之快速入门">C++从零开始（二）：基础语法（上）之快速入门</a><time datetime="2021-12-09T05:31:37.851Z" title="发表于 2021-12-09 13:31:37">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a><time datetime="2021-12-05T08:28:39.054Z" title="发表于 2021-12-05 16:28:39">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a><time datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/62712/" title="C++从零开始（零）">C++从零开始（零）</a><time datetime="2021-12-05T08:22:28.029Z" title="发表于 2021-12-05 16:22:28">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站">Hexo+Github Pages快速打造属于自己的网站</a><time datetime="2021-11-29T12:10:54.202Z" title="发表于 2021-11-29 20:10:54">2021-11-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>