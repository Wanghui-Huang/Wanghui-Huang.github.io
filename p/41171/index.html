<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端基础（一）JavaScript基础笔记(上) | royhuang's blog</title><meta name="keywords" content="JavaScript"><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章：快速入门 1.1 hello javaScript! 我们编写一个简单 test.js 文件，里面有一行代码输出 “hello javaScript!” ： 1alert(&quot;hello javaScript!&quot;); 然后在准备好的 .html 文件head 标签内引入test.js 文件： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础（一）JavaScript基础笔记(上)">
<meta property="og:url" content="https://hwh.zone/p/41171/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="第一章：快速入门 1.1 hello javaScript! 我们编写一个简单 test.js 文件，里面有一行代码输出 “hello javaScript!” ： 1alert(&quot;hello javaScript!&quot;); 然后在准备好的 .html 文件head 标签内引入test.js 文件： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2021-11-25T12:37:58.119Z">
<meta property="article:modified_time" content="2021-12-03T03:41:02.898Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/41171/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"XVCM04DNZ4","apiKey":"137b0bbc59574cb11c2e8fed36fb30fb","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端基础（一）JavaScript基础笔记(上)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 11:41:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">前端基础（一）JavaScript基础笔记(上)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T12:37:58.119Z" title="发表于 2021-11-25 20:37:58">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T03:41:02.898Z" title="更新于 2021-12-03 11:41:02">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端基础（一）JavaScript基础笔记(上)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>第一章：快速入门</h1>
<h2 id="1-1-hello-javaScript">1.1 <em>hello javaScript!</em></h2>
<p>我们编写一个简单 <em>test.js</em> 文件，里面有一行代码输出 <em>“hello javaScript!”</em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;hello javaScript!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后在准备好的 <em>.html</em> 文件<em>head</em> 标签内引入<em>test.js</em> 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里默认当前路径是index.html所在目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>注意区分引入 <em>.js</em>文件 和 <em>css</em>文件区别：</p>
<ul>
<li>
<p><em>.js</em>文件 用一对 <u><em>&lt;script&gt;&lt;/script&gt;</em></u> 标签包围引用 ；<em>.css</em> 文件用 <u><em><link></em></u> 标签指向：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span>  <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>.js</em>文件 用 <em>src</em> 属性指向 ；<em>.css</em> 文件用 <em>href</em> 属性指向。</p>
</li>
</ul>
</li>
</ul>
<h4 id="引入-js-css文件不成功？">引入 js / css文件不成功？</h4>
<ol>
<li>
<p>没有保存文件</p>
<p>默认 <em>VSCode</em> 不会自动保存文件，如果不自己 <code>ctrl+s</code> ，打开浏览器 <em>F12</em>  --&gt; <em>Source</em> 发现 <em>mian.css</em>文件为空。</p>
<p>可以设置自动保存文件，或者自己手动保存解决。</p>
</li>
<li>
<p>错用 <em>href</em> 属性 引用 <em>js</em>文件</p>
<p>见前。</p>
</li>
</ol>
<h2 id="1-2-安装-codeRunner-插件">1.2 安装 <em>codeRunner</em> 插件</h2>
<p>我们肯定不希望，每次输出一些信息，都要打开浏览器去查看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;我想输出一些信息&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果可以直接在 <em>VSCoder</em> 中就打印出信息多好啊！但是直接写在<em>js</em> 文件中，只能在浏览器控制台查看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我想输出一些信息&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="如何直接打印信息？">如何直接打印信息？</h4>
<blockquote>
<p><em>JavaScript</em> 可以直接打印：<u>数组</u>、<u>对象</u>、字符串、数值类型等</p>
</blockquote>
<p>第一种方式只能在浏览器中查看，后来两种可以直接在VS中查看。</p>
<ul>
<li>
<p>在浏览器控制台中</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563360135726.png" alt="1563360135726"></p>
</li>
<li>
<p>使用VS自带终端</p>
<p>我们可以用vs自带终端，如果已经安装好 <em>node.js</em> 便可以直接在VS中输出：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563360509909.png" alt="1563360509909"></p>
<p>其实，这就实现相当于在 <em>cmd</em> 中执行这段代码。</p>
</li>
<li>
<p>利用 <em>CodeRunner</em> 插件</p>
<p>下载好 <em>CodeRunner</em> 插件，也可以直接运行 <em>js</em> 文件：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563360768328.png" alt="1563360768328"></p>
</li>
</ul>
<h4 id="CodeRunner-运行乱码-报错"><em>CodeRunner</em> 运行乱码/报错</h4>
<ol>
<li><em>Node.js</em> 是否安装</li>
</ol>
<p><em>CodeRunner</em>  还是通过  <em>Node.js</em> 来运行 <em>js</em> 文件，如果没有安装自然出错。</p>
<p>特别的，安装 <em>Node.js</em> 会自动配置好环境变量，所以基本可以排除环境变量配置错误导致该问题。</p>
<ol start="2">
<li>
<p>终端是否能输出</p>
<p>首先在 <em>cmd</em> 尝试运行 <em>js</em>文件 ，如果能正确输出 ；但是在 <em>VS</em>终端中还是运行报错/乱码。可以排除是<em>Node.js</em> 相关配置问题。</p>
<p>如果<em>cmd</em> 中也无法运行，尝试重新配置 <em>node.js</em> 环境变量或者直接卸载重新安装。</p>
</li>
<li>
<p>尝试以管理员身份运行<em>VSCoder</em></p>
<blockquote>
<p>我出现的乱码/无法执行问题以管理员身份运行成功解决。</p>
</blockquote>
<p><strong>1、2</strong> 均无问题， 可以尝试以管理员身份运行 <em>VSCoder</em> 。也可以设置每次打开都是以管理员身份：</p>
<p>右键 <em>VSCoder</em> 图标 —&gt; 属性 --&gt; 兼容性 —&gt; 以管理员身份运行此程序 --&gt; 应用。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563361391550.png" alt="1563361391550"></p>
</li>
</ol>
<h2 id="1-3-基本语法">1.3 基本语法</h2>
<h3 id="1-变量和注释">1. 变量和注释</h3>
<p><em>javsScript</em> 注释有单行注释 &amp; 多行注释两种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alert(&quot;我不想被执行&quot;);   </span></span><br><span class="line"><span class="comment">/* alert(&quot;我不想被执行&quot;); */</span> </span><br></pre></td></tr></table></figure>
<p><em>javsScript</em> 是弱类型语言，所有变量都可用 <code>var &lt;变量名&gt;</code> 形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.javsScript不区分整数和浮点型，统称Number</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3.5</span>; <span class="keyword">var</span> num1 = <span class="number">3</span>; <span class="keyword">var</span> num2 = <span class="number">1.234</span>*e3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;我是单引号包围字符串&#x27;</span>; <span class="keyword">var</span> str1 = <span class="string">&#x27;&#x27;</span>我是双引号包围字符串<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.布尔类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.比较运算符</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="literal">false</span> == <span class="number">0</span>;  <span class="keyword">var</span> b2 = <span class="literal">false</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b3 = <span class="number">2</span> &gt; <span class="number">4</span>? ; <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.常量</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;  <span class="comment">// const&amp;let修饰都是块级作用域（见后）</span></span><br></pre></td></tr></table></figure>
<h4 id="小心！-、NaN、浮点数">小心！== 、NaN、浮点数</h4>
<ul>
<li>
<p>不推荐<code>==</code>比较运算符</p>
<p>不推荐使用 <code>==</code> 运算符，这是 <em>JavaScript</em> 语言设计缺陷，会出现难以意料的错误，推荐使用 <code>===</code>来替换。</p>
</li>
<li>
<p>判断浮点数相等</p>
<p>由于计算机不能精确表示浮点数，所以判断两个浮点数是否相等，比较它们差值是否小于某个足够小值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断是否<em>NaN</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="literal">NaN</span>;</span><br><span class="line">alert(num === <span class="literal">NaN</span>); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>
<p>为什么输出 <em>false</em> ？这是因为 <em>NaN</em>和所有其它值都判断不相等，包括它自己，唯一判断方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN); // true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断 <em>null</em> ： <code>变量 === null；</code></p>
</li>
<li>
<p>判断 <em>Array</em>：<code>Array.isArray(arr);</code></p>
</li>
<li>
<p><em>typeof</em> 可以判断出 <em>Number、Boolean、String、function &amp; undefined</em> 类型，例如：</p>
<ul>
<li>判断全局变量是否存在：<code>typeof window.myVar === 'undefined'</code></li>
<li>判断局部变量是否存在：<code>typeof myVar === 'undefined'</code> 。</li>
</ul>
</li>
</ul>
<h4 id="全局变量">全局变量</h4>
<p>我们知道，常规定义全局变量，把变量不定义在任何嵌套{}中即可。</p>
<p>事实上，变量定义可<u>不用 <em>var</em> 关键字</u>，此时定义的也是全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3.5</span>; </span><br><span class="line">str = <span class="string">&#x27;我是字符串&#x27;</span>; </span><br><span class="line">b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;num = &#x27;</span>+num + <span class="string">&#x27; , str = &#x27;</span>+ str + <span class="string">&#x27;, b = &#x27;</span>+b);</span><br></pre></td></tr></table></figure>
<p>如何理解此时定义的是全局变量？请看下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不用var关键字声明函数内部变量</span></span><br><span class="line">    a = <span class="number">1</span> ;   </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; <span class="number">3</span> ; i++);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 可访问，输出：1</span></span><br><span class="line"><span class="built_in">console</span>.log(i);   <span class="comment">// 可访问，输出：3</span></span><br></pre></td></tr></table></figure>
<p><em>a、i</em> 看似是函数内部局部变量，实际已是全局变量，可以访问。</p>
<h4 id="类型转换">类型转换</h4>
<p>由于 <em>JavaScript</em> 没有那么复杂类型，比如数值类型之间转换（<em>int --&gt; double</em> …）。</p>
<p>常用的有如 <em>Number 、 String 、Boolean、object</em>类型之间转换 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="comment">// 1.任何类型转换为String类型： String()转换 OR .toString</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123.45</span> , b = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString());   <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString());     <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(num));      <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(b));        <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.任意类型转换成Number类型：用Number() OR parseInt()、parseFloat()</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123.45&#x27;</span> , b = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(str));   <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(b));     <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseInt()、parseFloat()</span></span><br><span class="line"><span class="comment">// 转换不了boolean类型！</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(str)); <span class="comment">// 输出：123.45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(b));   <span class="comment">// 输出：NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.任意类型转换为Boolean类型：用Boolean()</span></span><br><span class="line"><span class="comment">// 注意：只有 0、&#x27;&#x27;转换为：false ；其余全部转换为ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都转换为ture</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>));    <span class="comment">// 也是ture！只有数字0、&#x27;&#x27;会转换为false！！</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;123.45&#x27;</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">123.45</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下都转换为false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>));   </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别的，具体的值也可以调用 <em>.toString()</em> 方法，转换为 <em>Sting</em> 类型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 注意1.toString()出错，两个.. OR (1).toString()</span></span><br><span class="line"><span class="number">1.</span>.toString();      <span class="comment">// 1</span></span><br><span class="line"><span class="literal">false</span>.toString();   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-字符串">2. 字符串</h3>
<h4 id="如何优雅表示字符串">如何优雅表示字符串</h4>
<p>除了前面介绍用 <code>’ ‘</code> 或者 <code>“ ”</code> 包围，还可以用最新ES6标准，反引号 <strong>``</strong> 包围多行字符串。</p>
<p>⚠️ 反引号是左上角 <kbd>ESC</kbd> 正下方对应键 <kbd>~</kbd> ，切换到英文状态下可以打出**`**</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">`我是</span></span><br><span class="line"><span class="string">多行字符串</span></span><br><span class="line"><span class="string">酷不酷`</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">`我是\n多行字符串\n酷不酷`</span>) <span class="comment">// 和上面写法等价</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串拼接">字符串拼接</h4>
<p>除了常见用 <code>+</code> 号进行拼接，还可以用ES6新增的模板字符串进行拼接。</p>
<p>⚠️ 模板字符一定要使用反引号 <strong>`</strong> ，否则${…}当字符串输出了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;hwh&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// var message = &#x27;我是&#x27;+ name + &#x27;,今年&#x27;+ age+&#x27;岁啦！&#x27;;</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁啦！`</span>; <span class="comment">// 一定要使用反引号 `,否则$&#123;..&#125;当字符串输出</span></span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<h4 id="常用字符串操作">常用字符串操作</h4>
<ul>
<li>
<p>获取字符串指定位置字符</p>
<p>直接把字符串当做数组进行索引即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">alert(s[<span class="number">0</span>]);  <span class="comment">// 输出：h</span></span><br></pre></td></tr></table></figure>
<p>但是字符串是不可变的，不能对其某个字符索引赋值，不会有任何效果（但不报错）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">alert(s); <span class="comment">// 还是输出：hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用字符串方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.转换字符串大小写</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> upper = s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.返回字符在字符串中位置</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello javaScript!&quot;</span>;</span><br><span class="line">alert(str.indexOf(<span class="string">&#x27;java&#x27;</span>)); <span class="comment">// 输出6：j是第6个字符，从0计数。前面有6字符： hello + 空格 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.字符串截取</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-数组">3. 数组</h3>
<p>定义一个简单数组，通常有 <u>直接定义</u> &amp; <em><u>new</u></em> 两种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = [];  </span><br><span class="line"><span class="comment">// var s = new Array();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">// var s1 = new Array(1,2);</span></span><br></pre></td></tr></table></figure>
<h4 id="奇妙数组">奇妙数组</h4>
<p><em>JavaScript</em> 和其它语言数组有很多不同，这里一一说道。</p>
<ol>
<li>
<p>数组不限制类型</p>
<p>下面是一个长度 = 6，包含多种类型的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>]; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>改变数组大小很简单</p>
<p>以往语言要扩展数组总是一件复杂的事，比如 <em>java</em> 用集合 <em>ArrayList</em> 来实现。</p>
<p><em>JavaScript</em> 直接改变数组 <em>length</em> 属性即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 扩大数组</span></span><br><span class="line">arr.length = <span class="number">6</span>; <span class="comment">// arr数组变为：[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line"><span class="comment">// 缩小数组</span></span><br><span class="line">arr.length = <span class="number">1</span>; <span class="comment">// arr数组变为：[1]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以越界赋值</p>
<p>很多编程语言是不允许越界赋值数组，但<em>JavaScript</em> 允许，它会自动扩大数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">6</span>] = <span class="number">6</span>; <span class="comment">// arr数组变为：[1, 2, 3, undefined, undefined, 6]</span></span><br></pre></td></tr></table></figure>
<p>但是，这种做法不被推荐，尽量保证索引不会越界！</p>
</li>
</ol>
<h4 id="常用数组操作">常用数组操作</h4>
<p>以下是常用数组操作的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.数组转为字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">String</span>(arr);</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// 输出：1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.indexOf：返回指定元素位置</span></span><br><span class="line"><span class="keyword">var</span> i = arr.indexOf(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);   <span class="comment">// 输出：0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.slice：左开右闭截取元素, 对应String的substring()方法</span></span><br><span class="line"><span class="comment">// 不指定第二个参数，会截取第一个参数位置以后所有元素</span></span><br><span class="line"><span class="keyword">var</span> sub03 = arr.slice(<span class="number">0</span>,<span class="number">3</span>) </span><br><span class="line"><span class="keyword">var</span> sub3 = arr.slice(<span class="number">0</span>)    </span><br><span class="line"><span class="built_in">console</span>.log(sub03);  <span class="comment">// 输出：[ 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(sub3);   <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.push 和 pop 尾部增减元素</span></span><br><span class="line">arr.push(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;js&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6, &#x27;hello&#x27;, &#x27;js&#x27; ]</span></span><br><span class="line">arr.pop() ; arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.unshift 和 shift 头部增减元素</span></span><br><span class="line">arr.unshift(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ &#x27;A&#x27;, &#x27;B&#x27;, 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line">arr.shift(); arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.反转和排序</span></span><br><span class="line">arr.reverse();  </span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ 6, 5, 4, 3, 2, 1 ]</span></span><br><span class="line">arr.sort();       </span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.splice：从指定位置删除若干元素，再从该位置添加若干元素</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;c#&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;javascript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除&amp;添加：从索引1开始删除2个元素，然后再从原索引位置添加两个元素</span></span><br><span class="line"><span class="keyword">var</span> delElem = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>); <span class="comment">// 返回被删除的元素:[&quot;c&quot;,&quot;c++&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ &#x27;c#&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除：不设定2个参数以上就行</span></span><br><span class="line"><span class="keyword">var</span> delElem1 = arr.splice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// 输出：[ &#x27;c#&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加：设置第二个参数为0，即删除0个元素</span></span><br><span class="line"><span class="keyword">var</span> delElem2 = arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c++&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// 输出：[ &#x27;c#&#x27;, &#x27;c&#x27;, &#x27;c++&#x27;, &#x27;python&#x27;, &#x27;java&#x27;, &#x27;javascript&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.concat：连接两个数组,但不改变原数组，只是返回一个新数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.concat(<span class="string">&quot;hwh&quot;</span>,[<span class="string">&quot;上&quot;</span>,<span class="string">&quot;山&quot;</span>,<span class="string">&quot;打&quot;</span>,<span class="string">&quot;老&quot;</span>,<span class="string">&quot;虎&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// 输出：[ 1, 2, 3, 4, 5, &#x27;hwh&#x27;, &#x27;上&#x27;, &#x27;山&#x27;, &#x27;打&#x27;, &#x27;老&#x27;, &#x27;虎&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.join：将数组转为字符串，可指定连接字符</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.join(<span class="string">&#x27;~&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);  <span class="comment">// 输出：1~2~3~4~5</span></span><br></pre></td></tr></table></figure>
<h4 id="多维数组">多维数组</h4>
<p>多维数组：如果某个元素是多维数组，那么就可以形成多维数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">var</span> darr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(darr[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 输出：500</span></span><br></pre></td></tr></table></figure>
<h3 id="4-对象">4. 对象</h3>
<blockquote>
<p>注意：在 <em>JavaScript</em> 中没有类这个概率，通过原型链来实现类作为模板概念，在后详述。下面都是具体对象！</p>
</blockquote>
<p>例如下面创建一个<em>hwh</em>对象，类似于 <em>python</em> 使用键值对定义 <em>map</em> 。</p>
<p>当然，还可以给对象增添方法（注意，此时不叫函数！），<u><em>详见 第二章：函数  2.3节</em></u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;huangwanghui&quot;</span>,</span><br><span class="line">    <span class="attr">school</span>:<span class="string">&quot;chongqingU&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;stu-num&#x27;</span>: <span class="number">123456</span>    <span class="comment">// 注意：最后一行代码不要加逗号，否则在低版本IE可能会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="访问对象属性">访问对象属性</h4>
<p>访问对象属性有两种办法：</p>
<ol>
<li>
<p>通过<code>&lt;对象名.属性名&gt;</code> 形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.name);     <span class="comment">// 输出：huangwanghui</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.school);   <span class="comment">// 输出：chongqingU</span></span><br></pre></td></tr></table></figure>
<p>特别的，访问不存在属性不会报错，但是会返回 <em><u>undefined</u></em> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.school);       <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过<code>&lt;对象名['属性名']&gt;</code> 形式</p>
<p>理论上，所有访问对象属性都可通过该方式，特别以下两种情况只能使用<code>&lt;对象名['属性名']&gt;</code>这种方式。</p>
<ul>
<li>
<p>属性名不是标准变量名</p>
<p>如 <em><u>‘stu-num’</u></em> 含变量定义非法字符 <code>-</code> ，所以要用 <code>’‘</code> 包围，只能通过 <code>&lt;对象名['属性名']&gt;</code> 访问该属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hwh.stu-num);     <span class="comment">// 输出：NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh[<span class="string">&#x27;stu-num&#x27;</span>]);  <span class="comment">// 输出：123456</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>循环遍历属性时</p>
<blockquote>
<p>在下面遍历对象属性，为什么都是输出 <em>undefined</em>？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历属性</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> hwh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);       <span class="comment">// 输出：name  shcool   &#x27;stu-num&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(hwh.a);   <span class="comment">// 输出：undefined undefined undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为，此时 hwh.a 相当于访问的是hwh对象一个属性名为a的属性，这自然是不存在的。</p>
<p>正确做法使用<code>对象名['属性名']</code>便可正常输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> a <span class="keyword">in</span> hwh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(hwh[a]);  <span class="comment">// 输出：huangwanghui chongqingU 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="给对象增删属性">给对象增删属性</h4>
<p>给对象增减属性较为简单，增加属性类似于数组增加元素，删除属性要利用 <em>delete</em> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增删属性</span></span><br><span class="line">hwh.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hwh.age);  <span class="comment">// 输出：23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> hwh.age;</span><br><span class="line"><span class="built_in">console</span>.log(hwh.age);  <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="判断对象是否拥有某属性">判断对象是否拥有某属性</h4>
<p>判断对象是否用于某属性也有两种办法。</p>
<ul>
<li>
<p>利用 <em>in</em> 判断一个属性是否存在</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> hwh);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> hwh);</span><br></pre></td></tr></table></figure>
<p>但是这种方法有一个问题，<em>in</em> 判断属性不一定属于 <em>hwh</em>，还可能是 <em>hwh</em> 继承得到的。</p>
<p>比如原型链中，<em>hwh</em> 肯定会指向所有属性都指向的 <em>Object</em>， <em>Object</em> 含有一个<em>toString</em> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> hwh); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用<code>hasOwnProperty()</code>方法</p>
<p>这种方法可以不会判断继承得到的属性属于对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> hwh); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-条件判断-循环">5. 条件判断 &amp; 循环</h3>
<h4 id="条件判断">条件判断</h4>
<p><em>JavaScript</em> 把<em>null、undefined、0、NaN</em>  &amp; 空字符串<code>''</code>视为<code>false</code>，其他值一概视为<code>true</code>，因此下面代码条件判断的结果是<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length) <span class="comment">// 条件计算结果为3</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环">循环</h4>
<p>在 <em>JavaScript</em> 循环和 <em>java</em> 等高级语言循环没有太大区别。</p>
<p>特别的，在 <em>JavaScript</em> 中数组也被看作是对象，它的索引则被视为一个属性。然而遍历数组时，如果使用 <em>for…in</em>循环时，如给数组增加一个属性，将导致一个难以意料的结果。</p>
<p>这个问题可以用 <em>for…of</em> 循环解决，它还可以专用于遍历集合类型，详见 <u>7. <em>iterable</em> 类型</u> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&quot;上山打老虎&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; num.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num[i]);  <span class="comment">// 输出： 1 2 3 4 5 上山打老虎</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.for..in 循环</span></span><br><span class="line"><span class="comment">// 除了前面用来遍历对象属性，遍历数组也类似</span></span><br><span class="line"><span class="comment">// for..in 循环的到时 String 而不是 Number，for循环呢？</span></span><br><span class="line"><span class="comment">// 直接输出i是数组序号：0 1 2 3 4 5  ，可理解为把数组当对象，序号是它“属性名”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// 输出： 0 1 2 3 4 5 </span></span><br><span class="line">    <span class="built_in">console</span>.log(num[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.while 循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num[i]);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.do...while 循环</span></span><br><span class="line"><span class="comment">// 注意：do...while 循环至少会执行一次！</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num[j]);</span><br><span class="line">    j++;</span><br><span class="line">&#125;<span class="keyword">while</span>(j&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6-Map-Set">6. <em>Map &amp; Set</em></h3>
<p>在前面 <em>JavaScript</em> 中 <u>4.对象</u>  中<code>&#123;&#125;</code> 表达方式可以视作其它语言 <em>Map</em> 或 <em>Dictionary</em> 数据结构键值对表达方式。</p>
<p>BUT，<em>JavaScript</em> 中 <u>对象中键只能是字符串</u> ，而在本讲 <em>Map &amp; Set</em> 将不局限于这点，还可以是 <em>Number</em>等类型。</p>
<h4 id="MAP"><em>MAP</em></h4>
<p><em>MAP</em> 基本创建、增 == 改、删操作，和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="comment">// 1.创建：注意是([[..],[..],[..]])形式外侧还有一个[]</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;hwh&quot;</span>],[<span class="number">2</span>,<span class="string">&#x27;liuting&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;xiaoming&#x27;</span>]]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.增加(修改)键值对</span></span><br><span class="line">m.set(<span class="number">4</span>,<span class="string">&#x27;xiaobai&#x27;</span>);   <span class="comment">// 不存在该键4，则是创建新键值对</span></span><br><span class="line">m.set(<span class="number">4</span>,<span class="string">&#x27;xiaohei&#x27;</span>);   <span class="comment">// 存在键值4，那么是修改键4对应键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除键值对</span></span><br><span class="line">m.delete(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断是否存在键值</span></span><br><span class="line"><span class="keyword">var</span> b = m.has(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 由于被删除所以是：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.获取键值对</span></span><br><span class="line"><span class="keyword">var</span> a = m.get(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 输出：liuting</span></span><br></pre></td></tr></table></figure>
<p>注意，当<em>map</em> 键是<em>String</em> 类型一定要加<u>引号</u>（对象如果变量名符合规范可以不加），而且访问也要加引号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&quot;b&quot;</span>,<span class="number">2</span>]]);  </span><br><span class="line"><span class="comment">// m.get(a); // 出错</span></span><br><span class="line">m.get(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>MAP</em> 和对象有什么区别？</p>
</blockquote>
<p><em>MAP</em> 和对象都是利用 <u>键值对</u> 形式构造，但是也有以下区别：</p>
<ol>
<li>删除、添加元素方式不同</li>
<li>访问形式不同：MAP通过<em>get()</em> 方法，对象通过 <u>对象.属性名</u> 或者 <u>对象[属性名]</u>形式</li>
<li>访问速度不同：MAP 拥有极快的访问速度</li>
<li>支持key类型不同：MAP支持多种类型作为key，对象只支持字符串<em>String</em> 类型</li>
</ol>
<h4 id="Set"><em>Set</em></h4>
<p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储<em>value</em>。</p>
<p>由于<em>key</em>不能重复，所以，在<code>Set</code>中，没有重复的key。如，创建时出现重复<em>key</em>，只会保留一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="comment">// 1.创建：出现重复键值被过滤</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// 实际集合中数据：&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 类似的：map也只会保存最后插入的重复键值</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>],[<span class="string">&quot;b&quot;</span>,<span class="number">2</span>]]);  <span class="comment">// 实际集合中数据：&#123;[&#x27;a&#x27;,2],[&quot;b&quot;,2]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.增加</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除</span></span><br><span class="line">s.delete(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>Set</em> 和数组 <em>Array</em> 区别？</p>
</blockquote>
<ol>
<li>删除、添加元素方法不同</li>
<li><em>Set</em> 可以去重，而且可以 <u>快速查找</u> ，但无法实现按下标查找等操作</li>
</ol>
<h3 id="7-如何优雅遍历集合">7. 如何优雅遍历集合</h3>
<h4 id="for-…-in-遍历集合"><em>for … in</em> 遍历集合</h4>
<blockquote>
<p>遍历数组 <em>Array</em> 可以用下标循环，如何遍历集合类型如 <em>Map &amp; Set</em> 类型？能用 <em>for … in</em> 循环吗？</p>
</blockquote>
<p>我们尝试用 <em>for…in</em> 循环遍历集合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;hwh&quot;</span>],[<span class="number">2</span>,<span class="string">&#x27;liuting&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;xiaoming&#x27;</span>]]); </span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in 遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 什么都没输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不幸，什么都没输出。</p>
<p>事实上，<u><em>Array、Map &amp; Set</em> 都属于<em>iterable</em> 类型</u>。对于 <em>iterable</em> 类型可以用 <em>for…of</em> 循环输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for...of 遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 输出：[ 1, &#x27;hwh&#x27; ]   [ 2, &#x27;liuting&#x27; ]  [ 3, &#x27;xiaoming&#x27; ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 输出：1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forEach-遍历集合"><em>forEach()</em> 遍历集合</h4>
<p>遍历集合更加优雅安全的方式是通过 <em>iterable</em>内置的<em>forEach()</em> 方法，<u>它接受一个函数，每次迭代自动回调该函数</u>。</p>
<blockquote>
<p><em>forEach()</em> 是一个高级方法，接收一个函数，用来遍历数组。详见 <u>2.4 高阶函数 – <em>forEach(</em>)</u></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach() 遍历集合</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">&quot;hwh&quot;</span>],[<span class="number">2</span>,<span class="string">&#x27;liuting&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;xiaoming&#x27;</span>]]); </span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历Map</span></span><br><span class="line">m.forEach</span><br><span class="line">(</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);    <span class="comment">// 输出：hwh   liuting   xiaoming</span></span><br><span class="line">   &#125;</span><br><span class="line">); </span><br><span class="line"><span class="comment">// 遍历Set</span></span><br><span class="line">s.forEach</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);    <span class="comment">// 输出：1   2   3</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 遍历Array</span></span><br><span class="line">arr.forEach</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);    <span class="comment">// 输出：A   B   C</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象：注意不能遍历对象！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="for-…-in-循环的弊端：数组长度不一致"><em>for … in</em> 循环的弊端：数组长度不一致</h4>
<p>我们已经知道 ，<em>Array</em> 都属于<em>iterable</em> 类型 ，但我们用 <em>for … in</em> 可以遍历输出<em>Array</em> 。</p>
<p>但是，我们在前也知道，数组也是对象，它的下标就是属性名。如果我们给一个数组增加属性名，然后遍历：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="comment">// 类似对象一般，给数组增加属性</span></span><br><span class="line">arr.name = <span class="string">&#x27;alpha&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// 输出属性名：0  1  2  name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次输出的是数组的属性名，好吧，这没什么不正常。</p>
<p>但是我们再尝试打印此时的数组大小：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure>
<p>噢…不忍直视，数组长度竟然是3，而不是4！</p>
<blockquote>
<p>为什么说<em>for… of</em> 循环可以避免这个问题呢？</p>
</blockquote>
<p>因为<em>for… of</em>  循环只会遍历，集合内的元素，这种不正当通过 <code>数组名.属性 </code> 赋值方式不会被输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);       <span class="comment">// 输出元素而非属性名：A  B  C  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure>
<p>这样循环遍历数组元素个数 === 数组长度，保证了一致性。</p>
<p>而且，你应该还注意到一个细节，此时<u>输出的是元素，而非是属性名</u>。</p>
<h1>第二章 ：函数</h1>
<h2 id="2-1-函数基本入门">2.1 函数基本入门</h2>
<h3 id="函数定义">函数定义</h3>
<p>在 <em>JavaScript</em> 中，定义函数有两种方式：一种类似于其它高级语言，但没有返回值类型；一种匿名函数方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">// 1.第一种类似其它高级语言定义函数，但没有返回值类型，js也不需要定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.第二种匿名函数，其实函数也是对象，把函数名max1视作指向该函数的变量</span></span><br><span class="line"><span class="keyword">var</span> max1 = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <em>JavaScript</em> 中，这两种方式是完全等价的，自然调用方式也是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>,<span class="number">2</span>));   <span class="comment">// 输出：2</span></span><br><span class="line"><span class="built_in">console</span>.log(max1(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure>
<p>⚠️ 不加()，直接调用函数不会报错，只会输出函数名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(max);       <span class="comment">// [Function: max]</span></span><br></pre></td></tr></table></figure>
<p>但是可以把函数作为变量传递给另外一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my_max = max;</span><br><span class="line">my_max(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="小心你的-return-语句">小心你的 <em>return</em> 语句</h4>
<p><em>JavaScript</em> 引擎 <u>会在行末自动添加分号</u>，这可能会导致使用 <em>return</em> 产生意料之外的错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用max</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// 输出：什么都没有输出</span></span><br></pre></td></tr></table></figure>
<p>你会惊喜的发现，什么都没有输出！这是因为，由于自动添加分号，函数实际已经变成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ;  <span class="comment">// 这里被添加了分号，函数执行到这结束了</span></span><br><span class="line">    a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，细心的你一定会避过这个坑吧？</p>
<h3 id="奇妙的函数参数">奇妙的函数参数</h3>
<h4 id="传递参数个数任意？">传递参数个数任意？</h4>
<p>如果是第一次接触 <em>JavaScript</em> ，在上面定义<em>max</em> 函数我们可以惊讶的发现，可以传递不止两个参数！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个参数调用</span></span><br><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>));   <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure>
<p>而且它还计算出了正确结果！</p>
<p>事实上，<em>JavaScript</em> 允许传递任意个参数，如果函数内部不使用多余的参数自然也就不会影响到结果。</p>
<blockquote>
<p>那么传递参数比实际定义少呢？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>));            <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="怎么处理所有参数？">怎么处理所有参数？</h4>
<blockquote>
<p>在上面虽然我们调用 <em>max()</em> 函数输入了多余参数，但是我还是想把多余参数给输出来，该如何处理？</p>
</blockquote>
<p>在函数内部利用 <em>arguments</em> ，可以获取所有参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) <span class="comment">// 输出超过定义个数的参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span> ; i &lt; <span class="built_in">arguments</span>.length ; i++ )</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用max</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hhh不许笑！&quot;</span>);    <span class="comment">// 输出：hhh不许笑！</span></span><br></pre></td></tr></table></figure>
<p>一般常用的也就是：<em>arguments.length</em>  &amp; <em>arguments[i]</em>  用来获取参数长度和指定索引参数。</p>
<h4 id="优雅的处理多余参数">优雅的处理多余参数</h4>
<p>上面虽然用<em>arguments</em> 获取到所有参数，然后输出多余参数，但是总感觉很变扭。</p>
<blockquote>
<p>但是有没有一种方式，让我们直接处理多余参数 ，而不是要从索引 <strong>2</strong> 先排除前两个参数？</p>
</blockquote>
<p>可以使用 <em>rest</em> 来达到这个目的，<u>多余参数会以数组形式</u> 交给 <em>rest</em> 变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest</span></span><br><span class="line"><span class="comment">// 函数定义的时候要以：...rest来标识[从哪里开始算是多余参数]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">a,b,...rest</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest);  <span class="comment">// 会以[数组]形式输出</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用max</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hhh不许笑！&quot;</span>);    <span class="comment">// 输出：[ &#x27;hhh不许笑！&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-变量作用域与解构赋值">2.2 变量作用域与解构赋值</h2>
<h3 id="1-快速了解变量作用域">1. 快速了解变量作用域</h3>
<p>变量作用域块{}知识基本和其它语言没有太大区别，但是有几个 <em>JavaScript</em> 所特有特性。</p>
<h4 id="变量提升">变量提升</h4>
<blockquote>
<p>执行下面函数会报错吗？如果不会，那么输出什么？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">console</span>.log( x + y);  </span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>执行这段代码，我们发现：编译器没有报错，但是输出 <em>NaN</em> 。</p>
<p>这是因为<em>javascript</em> 有一个很奇怪的特性：它会自动提升 <u>变量的声明</u> 到<strong>函数</strong>顶端，但是又不会提升 <u>变量的赋值</u>。</p>
<p>在编译器眼里，它看到的代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">var</span> y ; <span class="comment">// 提升了定义</span></span><br><span class="line">    <span class="built_in">console</span>.log( x + y);  <span class="comment">// 执行后也并没有报错    </span></span><br><span class="line">    y = <span class="number">2</span>;  <span class="comment">// 没有提升赋值</span></span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>所以虽然可以使用变量 <em>y</em> 但是又不能使用它的值，所以输出：<em>NaN</em> 。</p>
<h4 id="避免错误">避免错误</h4>
<blockquote>
<p>😋 对于这种怪异特性，我们最好提前用 <em>var</em> 声明所有要使用的变量。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line">        y = <span class="number">2</span>,</span><br><span class="line">        z;</span><br><span class="line">   <span class="comment">// do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>😋 用 <em>let</em> 关键字来限定变量范围，申明一个块级作用域。</p>
</blockquote>
<p>由于这种变量提升特性，导致<u>变量实际作用域是函数内部</u>，会使得<em>for</em> 等循环语块无法定义具有局部作用域变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 不报错可以使用i，但是输出：undefined</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 可以使用i值，输出：3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <em>let</em> 关键字来达到，限定 <em><strong>i</strong></em> 为局部变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i);   <span class="comment">//  会报错，不能使用局部变量i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 会报错，不能使用局部变量i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<h3 id="2-全局作用域">2. 全局作用域</h3>
<p>不在任何函数内定义的变量就具有全局作用域。</p>
<p>特别的，顶层函数也是全局变量。虽然乍看有点难以理解，但是回想它的匿名函数写法，便一目了然。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> author = <span class="string">&#x27;hwh&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;顶层函数也是全局变量&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量任意嵌套块中都可以调用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(author);</span><br><span class="line">    <span class="built_in">console</span>.log(f2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="window-对象"><em>window</em> 对象</h4>
<p><em>window</em> 是<em>javascript</em>  <u>默认全局对象</u> ，<u>所有全局变量</u> 都被绑定到 <em>window</em> 上作为一个<u>属性</u>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// 调用window对象：console.log 会报错，用alert打开网页可正常输出？</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  console.log(window.author);  // 出错</span></span><br><span class="line">    alert(<span class="built_in">window</span>.author);        <span class="comment">// 打开网页输出：hwh</span></span><br><span class="line">    alert(<span class="built_in">window</span>.f2());          <span class="comment">// 打开网页输出：顶层函数也是全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，全局变量可以作为它的属性一样被调用。事实上 <em>alert()</em> 也是一个全局变量。</p>
<blockquote>
<p>下面尝试给 <u>函数变量</u> <em>alert</em> 赋值一个新的函数，使得它不能执行 <em>alert()</em> 原本输出功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.alert(<span class="string">&#x27;调用window.alert()&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量保存函数（函数也是变量）</span></span><br><span class="line"><span class="keyword">var</span> old_alert = <span class="built_in">window</span>.alert;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给alert赋一个新函数:</span></span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用alert()</span></span><br><span class="line">alert(<span class="string">&#x27;我还能输出吗？&#x27;</span>); <span class="comment">// 打开网页发现这句话不会被输出</span></span><br></pre></td></tr></table></figure>
<h4 id="更好的定义全局变量">更好的定义全局变量</h4>
<p>全局变量会绑定到对象<em>window</em>上，不同的 <em>JavaScript</em> 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量<span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="keyword">var</span> NOTE = &#123;&#125;;  <span class="comment">// 对象？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">NOTE.author = <span class="string">&#x27;hwh&#x27;</span>;</span><br><span class="line">NOTE.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">NOTE.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-解析构值">3. 解析构值</h3>
<p>什么是解析构值？简单来说，可以 <u>同时对一组变量进行赋值</u>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析构值</span></span><br><span class="line"><span class="comment">// 注意：解析构值涉及多个变量赋值，两边都要用[]包围</span></span><br><span class="line"><span class="keyword">var</span> x,y,z,rest;</span><br><span class="line">[x,y,z] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];   </span><br></pre></td></tr></table></figure>
<p>还可以像前一样，用<code>...</code> 标识<em>rest</em> ，以数组形式接收指定位置之后所有赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.解析赋值：...rest</span></span><br><span class="line">[x,y,z,...rest] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(rest);      <span class="comment">// 输出：[ 4, 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="解构数组">解构数组</h4>
<p>除了上述基本特点，解构数组还有以下特点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析数组  </span></span><br><span class="line"><span class="keyword">var</span> x,y,z,rest;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>允许待赋值变量个数 ≠ 右侧变量数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 允许待赋值变量个数 ≠ 右侧变量数</span></span><br><span class="line"><span class="comment">// 待赋值变量 &gt; 右侧，剩余未赋值变量赋undefined </span></span><br><span class="line">[x,y,z] = [<span class="number">1</span>,<span class="number">2</span>];                       <span class="comment">// 等价于：[x,y,z] = [1,2,undefined];</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);  <span class="comment">// 输出 ：x=1,y=2,z=undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 待赋值变量 &lt; 右侧，只会对应依次将待赋值变量赋值完毕</span></span><br><span class="line">[x,y,z] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];                  <span class="comment">// 等价于：[x,y,z] = [1,2,3]; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);   <span class="comment">// 输出：x = 1,y = 2,z = 3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置默认值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.可以设置默认值</span></span><br><span class="line">[x,y,z = <span class="number">666</span>] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);    <span class="comment">// 输出：x=1,y=2,z=666</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>忽略某些值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.忽略值</span></span><br><span class="line"><span class="keyword">var</span> a,b;</span><br><span class="line">[a, ,b ] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span>+ a + <span class="string">&#x27;,b = &#x27;</span>+ b);     <span class="comment">// 输出：a = 1,b = 3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="解构对象">解构对象</h4>
<p>前面都是解构数组，对象由一对对键值组成，和解构数组自然有些不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象解构赋值</span></span><br><span class="line"><span class="keyword">var</span> o =  &#123;<span class="attr">x</span>:<span class="string">&#x27;one&#x27;</span> , <span class="attr">y</span>:<span class="string">&#x27;two&#x27;</span>,<span class="attr">z</span>:<span class="string">&#x27;three&#x27;</span>,<span class="attr">a</span>:<span class="string">&#x27;four&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;five&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;x,y,z,a,b&#125; = o;</span><br></pre></td></tr></table></figure>
<p>特别的，如果不是对一个已存在对象解构，而是进行无声明赋值，赋值语句有所不同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种无声明赋值，要求赋值语句周围有 (...)</span></span><br><span class="line"><span class="keyword">var</span> x,y,z;</span><br><span class="line">( &#123;x,y,...rest&#125; = &#123;<span class="attr">x</span>:<span class="string">&#x27;one&#x27;</span> , <span class="attr">y</span>:<span class="string">&#x27;two&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;three&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;four&#x27;</span>,<span class="number">5</span>:<span class="string">&#x27;five&#x27;</span>&#125; );</span><br><span class="line"><span class="built_in">console</span>.log(x);        <span class="comment">// 输出：one</span></span><br><span class="line"><span class="built_in">console</span>.log(rest);     <span class="comment">// 输出：&#123; &#x27;3&#x27;: &#x27;three&#x27;, &#x27;4&#x27;: &#x27;four&#x27;, &#x27;5&#x27;: &#x27;five&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>对象解构还有以下一些基本特点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o =  &#123;<span class="attr">x</span>:<span class="string">&#x27;one&#x27;</span> , <span class="attr">y</span>:<span class="string">&#x27;two&#x27;</span>,<span class="attr">z</span>:<span class="string">&#x27;three&#x27;</span>,<span class="attr">a</span>:<span class="string">&#x27;four&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;five&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>允许待赋值变量个数 ≠ 右侧变量数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.待赋值变量 &lt; 右侧，按对应键值赋值完毕,[顺序不影响]</span></span><br><span class="line"><span class="keyword">var</span> &#123;x,b,a&#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x=&#x27;</span>+x+<span class="string">&#x27;,y=&#x27;</span>+y+<span class="string">&#x27;,z =&#x27;</span>+z);  <span class="comment">// 输出：x=one ,a=four ,b=five</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>左右两侧键值要对应</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.左右两侧键值要对应</span></span><br><span class="line"><span class="keyword">var</span> &#123;x,Y,z,a,b&#125; = o;   <span class="comment">// 左侧Y和右侧键值y，不对应</span></span><br><span class="line"><span class="built_in">console</span>.log(Y);        <span class="comment">// 无法解构成功，输出：undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给新变量提供默认值和参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.给新变量提供默认值和参数</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:xx = <span class="number">10</span>, <span class="attr">y</span>:yy = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(xx); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(yy); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="解构嵌套对象和数组">解构嵌套对象和数组</h4>
<p>解构嵌套对象和数组，具有的基本特点和上面是一致的。主要不同在于：</p>
<p>解构嵌套对象要保证层次一致；解构嵌套数组，不仅要保证层次一致还要保证位置一致。</p>
<h5 id="嵌套数组">嵌套数组</h5>
<p>数组本身有嵌套，解构赋值要保证嵌套位置和层次一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.数组嵌套</span></span><br><span class="line"><span class="keyword">let</span> [x,[y,z]] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> [[y,z],x] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];   <span class="comment">// 出错位置不一致</span></span><br></pre></td></tr></table></figure>
<h5 id="嵌套对象">嵌套对象</h5>
<p>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，保证层次一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hwh&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;FUZHOU&#x27;</span>,</span><br><span class="line">        <span class="attr">street</span>: <span class="string">&#x27;No.1 Road&#x27;</span>,</span><br><span class="line">        <span class="attr">zipcode</span>: <span class="string">&#x27;341000&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需保证层次一致：赋值时按键值赋值，顺序位置可以调换</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zipcode&#125;&#125; = person;</span><br></pre></td></tr></table></figure>
<p>注意，<em>address</em> 并不是变量名，尝试输出会报错。它只是为了<em>city、zipcode</em>获取对象属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试输出</span></span><br><span class="line"> <span class="built_in">console</span>.log(address); <span class="comment">// 报错，address不是变量</span></span><br><span class="line"> <span class="built_in">console</span>.log(person.address); <span class="comment">// 输出： &#123; city: &#x27;FUZHOU&#x27;, street: &#x27;No.1 Road&#x27;, zipcode: &#x27;341000&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：name:hwh,city:FUZHOU ,zipcode:341000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>+name+<span class="string">&#x27;,city:&#x27;</span>+ city,<span class="string">&#x27;,zipcode:&#x27;</span>+ zipcode);</span><br></pre></td></tr></table></figure>
<h4 id="使用场景">使用场景</h4>
<ol>
<li>
<p>交换两个变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.交换变量x y</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>快速获取页面域名 &amp; 路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.快速获取页面域名和路径</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>减化函数参数定义</p>
<p>如下面可以方便快速创建一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDate</span>(<span class="params">&#123;year, mon, day, hour=<span class="number">0</span>, min=<span class="number">0</span>, sec=<span class="number">0</span>&#125;</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + minute + <span class="string">&#x27;:&#x27;</span> + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面函数接收一个对象作为参数，而不是去定义6个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDate</span>(<span class="params">year,mon,day,hour=<span class="number">0</span>,min=<span class="number">0</span>,sec=<span class="number">0</span></span>) </span></span><br></pre></td></tr></table></figure>
<p>在调用函数的时候，根据解析构值，<u>形参对象给实参对象赋值</u> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDate(&#123;<span class="number">2019</span>,<span class="number">07</span>,<span class="number">19</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-3-方法与this大坑">2.3 方法与<em>this</em>大坑</h2>
<p>在一个对象中绑定函数，称为这个对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age);     <span class="comment">// 输出：[Function: age]</span></span><br></pre></td></tr></table></figure>
<p>我们知道，<em>this</em> 关键字是用来指向当前对象。在<em>JavaScript</em> 没有类这个概念，<em>this</em> 在上述代码指向的是 <em>hwh</em> 这个对象。<em>this.birth</em> 因此可以拿到 <em>hwh</em> 的 <em>birth</em> 属性。</p>
<p>在这里，我们也看到 <em>JavaScript</em> 中 <em>this</em> 关键字和常用高级语言第一个不同点：</p>
<ul>
<li>即使是在对象内部，调用对象属性也要 <em>this.属性名</em> 进行调用，否则会出错。</li>
</ul>
<p>但是，由于<em>js</em>本身设计缺陷，<u><em>this</em> 在函数内部不一定指向当前对象，也可能指向全局对象 <em>window</em></u>  。</p>
<h3 id="1-小心使用你的-this">1. 小心使用你的 <em>this</em></h3>
<h4 id="新变量指向方法">新变量指向方法</h4>
<p>如果你尝试用一个新变量 <em>my_age</em> 指向函数内部方法 <em>age()</em> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新变量指向对象方法</span></span><br><span class="line"><span class="keyword">var</span> my_age = hwh.age;</span><br><span class="line"><span class="built_in">console</span>.log(my_age());    <span class="comment">// 输出： NaN</span></span><br></pre></td></tr></table></figure>
<p>why？？为什么突然报错？</p>
<p>这是因为，以 <u>对象名.方法名()</u> 调用 <em>this</em> 指向当前对象 ；但是 <u>单独调用函数</u> ，<em>this</em> 指向全局对象 <em>window</em> ！</p>
<h4 id="多层函数内部用-this">多层函数内部用 <em>this</em></h4>
<p>喜欢重构的你，又闲得蛋疼，突发奇想，在<em>age</em>方法内部再定义一个函数来返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：NaN</span></span><br></pre></td></tr></table></figure>
<p>又出错了！虽然 <em>this</em> 关键字在 <u>对象<em>age</em>方法内部</u> 指向当前对象，但在 <u><em>age</em>方法内函数内</u> 指向全局对象 <em>window</em> ！</p>
<p>聪明的你也许会想，既然在 <em>age</em>方法内部还是指向当前对象，那我可以捕获此时<em>this</em> ，再在方法内部函数使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 捕获this</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更优雅解决<em>this</em> 错误指向：改写为箭头函数，详见：<em><u>2.6 箭头函数</u></em> 。</p>
</blockquote>
<h4 id="提醒不要犯错：strict-模式">提醒不要犯错：<em>strict</em> 模式</h4>
<p>上述两种情况，还可以在 <em>strict</em> 模式下让函数的<em>this</em> 指向 <em>undefined</em> ，而不是<em>window</em> ，这样编译器会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面函数写法...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh1.age());  <span class="comment">//抛出错误： Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="2-apply-方法">2. <em>apply</em> 方法</h3>
<p>在前面，我们可以用 <em>strict</em> 模式，使得<em>this</em> 指向 <em>undefined</em> 让编译器提醒我们不要让 <em>this</em> 错误指向。</p>
<p>但是，可以控制 <em>this</em> 正确指向我们所期望的吗？ 每个函数本身拥有的<em>apply()</em> 方法，可以做到这点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:getAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让getAge() 中this从指向 undefined (严格模式下不是window） --&gt; hwh</span></span><br><span class="line"><span class="comment">// 参数1：表示方法要指向的对象</span></span><br><span class="line"><span class="comment">// 参数2：表示方法需要的参数，用数组封装好。这里[]表示为空</span></span><br><span class="line"></span><br><span class="line">getAge.apply(hwh,[]);    </span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());  <span class="comment">// 输出23</span></span><br></pre></td></tr></table></figure>
<h4 id="call-方法"><em>call</em> 方法</h4>
<p><em>call</em> 方法和 <em>apply</em> 方法很类似，能达到相同效果，它们唯一区别是传递参数不同。</p>
<p>比如，调用 <code>Math.max(3, 5, 4)</code>，分别用 <em>apply()</em> 和 <em>call()</em> 实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<em>apply()</em> 需要把参数封装好 <em>Araay</em> 数组再传入 ； <em>call()</em> 则需逐个传入参数。</p>
<h4 id="新的问题">新的问题</h4>
<p>在 <u>新变量指向方法</u> 小节中，我们尝试用 <em>apply</em> 来改变新变量函数指向：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新变量指向对象方法</span></span><br><span class="line"><span class="keyword">var</span> my_age = hwh.age;</span><br><span class="line">my_age.apply(hwh,[]);    <span class="comment">// 改变this指向不成功？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(my_age());    <span class="comment">// 输出： NaN</span></span><br></pre></td></tr></table></figure>
<p>却发现，<em>my_age</em> 方法指向并没有被改变，还是输出 <em>NaN</em> ?</p>
<blockquote>
<p>之所以不尝试，<u>多层函数内部用 <em>this</em></u> 一节用<em>apply</em> 改变，是因为无法取里层函数名。而直接尝试在里层函数里使用函数名，那就变成递归了！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 只能在这里可以取到getAge函数名，可是变成了递归</span></span><br><span class="line">            <span class="comment">// getAge.apply(hwh,[]);   // 报错：无限递归</span></span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="装饰器">装饰器</h4>
<p>利用 <em>apply()</em>，我们还可以动态改变函数的行为。</p>
<p><em>JavaScript</em> 的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。（ <u>覆写？？</u>）</p>
<blockquote>
<p>增加统计调用多少次方法 <em>parseInt()</em> ，在不改变原有功能基础上。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器 </span></span><br><span class="line"><span class="comment">// 下面代码在 VSCode + codeRunner报错：window is not defined</span></span><br><span class="line"><span class="comment">// 在浏览器中控制台可正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     count++;</span><br><span class="line">     <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>); <span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>); <span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count);    <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是下面方法也能调用原函数，无法说明装饰器作用？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     count++;     </span><br><span class="line"><span class="comment">//   return oldParseInt(null,arguments);     // 报错：parseInt是函数变量，这里返回的是函数值</span></span><br><span class="line">     <span class="keyword">return</span> oldParseInt;                     <span class="comment">// 成功输出 ：函数之间的赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-高阶函数">2.4 高阶函数</h2>
<p>在 <em>JavaScript</em> 中 ，变量可以指向函数，函数参数能接收变量，那么自然可以把 <u>函数当做另一个函数参数传递</u> 。</p>
<blockquote>
<p>高阶函数，简单来说就是把函数当参数，类似于C/C++中函数指针和C#中委托。</p>
</blockquote>
<p>下面是四个基本四则运算函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 乘、减..</span></span><br></pre></td></tr></table></figure>
<p>我们可以把它们当做参数，实现一个函数就可以计算四种不同运算：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfuc</span>(<span class="params">a,b,f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = myfuc(<span class="number">1</span>,<span class="number">3</span>,div);   <span class="comment">// 0.3333333..</span></span><br></pre></td></tr></table></figure>
<h3 id="映射：map-reduce">映射：<em>map / reduce</em></h3>
<h4 id="map"><em>map()</em></h4>
<p>这里的<em>map()</em> 和前面集合<em>map</em> 不同，它是一个方法，表现对数组每个元素进行某种映射关系。</p>
<p>假设存在一个数组：<em>arr</em> = [<em>x1</em>,<em>x2</em>,<em>x3</em>…]  ，和<u>回调函数</u> <em>f(x)</em>。</p>
<blockquote>
<p><em>arr.map()</em> 把函数 <em>f(x)</em> 作为参数 ，会返回一个新数组 [<em>f(x1)</em>, <em>f(x2)</em>, <em>f(x3)</em> …]</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, 4, 9, 16, 25 ]</span></span><br></pre></td></tr></table></figure>
<p>❔ 数组的元素会自动作为回调函数<em>f(x)</em> 第一个形参的实参进行赋值，如果<em>f(x)</em> 没有参数呢？或者不止一个参数呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有参数，每一次pow函数返回值 1 作为新数组元素</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(pow);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, 1, 1, 1, 1 ]</span></span><br></pre></td></tr></table></figure>
<p>事实上回调函数 <em>f(x)</em> 有三个参数，通常我们只使用第一个参数，表示 <em>Array</em> 某个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">element,index,self</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);   <span class="comment">// 依次打印: 1,2,3,4,5</span></span><br><span class="line">        <span class="built_in">console</span>.log(index);     <span class="comment">// 依次打印: 0,1,2,3,4</span></span><br><span class="line">        <span class="built_in">console</span>.log(self);      <span class="comment">// self就是变量arr,每次都打印arr:[ 1, 2, 3, 4, 5 ]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> element*element;                       </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, 4, 9, 16, 25 ]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>试分析：把<em>parseInt</em>函数作为参数，为什么得到意料之外的结果？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);    <span class="comment">// 输出：[ 1, NaN, NaN, NaN, NaN ]</span></span><br></pre></td></tr></table></figure>
<p>🙂 查看MDN文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><em>MDN-Array.map()</em></a></p>
<h4 id="reduce"><em>reduce()</em></h4>
<p><em>reduce()</em> 和 <em>map()</em> 类似：传入的参数函数<strong>f</strong> 循环每次对数组前两个元素运算，运算结果r作为数组首元素插入头部。</p>
<p>假设存在一个数组：<em>arr</em> = [<em>x1</em>,<em>x2</em>,<em>x3</em>,<em>x4</em>…]  ，和某个函数 <em>f(x,y)</em>。</p>
<blockquote>
<p><em>arr.map()</em> 把函数 <em>f(x,y)</em> 作为参数 ，会返回一个值：<em>f(f(x1,x2),x3)</em></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x1,x2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1+x2;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = arr2.reduce(sum);</span><br><span class="line"><span class="built_in">console</span>.log(s);    <span class="comment">// 输出：15</span></span><br></pre></td></tr></table></figure>
<p>当然无论是 <em>map / reduce</em> 传递参数都可以用 <em>lambada</em> 表达式进行简化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = arr2.reduce(<span class="function">(<span class="params">x1,x2</span>) =&gt;</span> x1+x2);</span><br><span class="line"><span class="built_in">console</span>.log(s);    <span class="comment">// 输出：15</span></span><br></pre></td></tr></table></figure>
<h3 id="自定规则：filter-sort-…">自定规则：<em>filter / sort …</em></h3>
<p>下列高级函数都有以下特点：</p>
<ul>
<li>根据传递的回调函数 <u>自定义某种判断规则</u></li>
<li>对数组每个元素进行判断，根据返回结果 <em>ture / false</em> 决定对元素进行不同操作</li>
</ul>
<h4 id="filter"><em>filter()</em></h4>
<p><em>filter</em>也是常用高级函数，它用于把<em>Array</em> 某些元素过滤掉，然后返回剩下的元素。</p>
<p>具体过程：*filter()*把传入的回调函数依次作用于每个元素 ，回调函数返回值为 <em>ture</em> 则该元素保留，否则删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = arr.filter</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// 只返回偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// 输出：[ 2, 4 ]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定数组<em>Array</em> ，去除里面重复的元素。（没看太明白）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  r,</span><br><span class="line">     arr = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"></span><br><span class="line">r = arr.filter</span><br><span class="line">(</span><br><span class="line">    <span class="comment">// 数组当前元素、数组当前元素索引、数组本身分别作为回调函数3形参的实参值</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.indexOf(element) === index;  <span class="comment">// 这里没太明白</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r.toString());   <span class="comment">// 输出：apple,strawberry,banana,pear,orange</span></span><br></pre></td></tr></table></figure>
<h4 id="sort"><em>sort()</em></h4>
<p><em>JavaScript</em> 中的 <em>sort()</em> 高级排序函数，<u>无传递回调函数情况下</u>，排序的操作顺序如下：</p>
<ol>
<li>先将数组的所有元素转换成 <em>String</em> 字符串</li>
<li><em>sort()</em> 根据每个字符串  <u>首字符 <em>ASCII</em>值</u>  来从小到大排序</li>
</ol>
<p>所以看起来会有下面&quot;奇怪&quot;结果：10 排在 2 前面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure>
<p>这是因为数组元素先转换成 <em>String</em> 类型，按 <u>首字符 <em>ASCII</em>值</u> 排序规则： ‘1’ &gt; ‘2’  ==&gt; ‘10’ &gt; ‘2’。</p>
<h5 id="定义自己的排序规则">定义自己的排序规则</h5>
<p>我们来定义数字从小到大排序规则回调函数，使得能正常输出我们期望的数字排序结果。</p>
<blockquote>
<p>排序规则：类比冒泡排序，判断两个元素大小，决定是否交换位置？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">arr1 = arr.sort</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)   <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// 输出：[ 1, 2, 10, 20 ]</span></span><br></pre></td></tr></table></figure>
<p>对应，冒泡排序写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)   <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = arr.length -<span class="number">1</span> ; j -i &gt; <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cmp作为排序规则，决定是否交换两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(cmp(s[j],s[j-<span class="number">1</span>]) == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = s[j];   </span><br><span class="line">            s[j] = s[j-<span class="number">1</span>];   </span><br><span class="line">            s[j-<span class="number">1</span>] = temp; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(s[i]);    <span class="comment">// 依次输出：1  2  10  20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果，要求从小到大输出呢？</p>
</blockquote>
<p>重新定义下 <u>何为大</u> 即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">arr1 = arr.sort</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)   <span class="keyword">return</span> -<span class="number">1</span>;    <span class="comment">// 改成返回 -1</span></span><br><span class="line">        <span class="keyword">else</span>      <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">// 改成返回  1</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// 输出：[ 20, 10, 2, 1 ]</span></span><br></pre></td></tr></table></figure>
<p>同理，对应冒泡排序改换<em>cmp</em>排序规则（交换<em>if / else</em>返回值）。已测试成功输出，这里不再赘述。</p>
<h4 id="every"><em>every()</em></h4>
<p><em>every()</em> 自定<u>回调函数</u>判断规则，对所有数组元素进行判断，如果回调函数<u>都</u> 返回<em>ture</em> ，说明所有元素都满足判断条件，那么*<u>every()</u>* 返回 <em>ture</em>，否则返回<em>false</em> 。</p>
<blockquote>
<p>给定一个包含指定字符串数组，判断字符串是否满足指定测试条件。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b = arr.every</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> s.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// true, 因为每个元素都满足 s.length&gt;0</span></span><br></pre></td></tr></table></figure>
<h4 id="find"><em>find()</em></h4>
<p>同上自定 <u>回调函数</u>判断规则，对所有元素进行判断。如果回调函数返回 <em>ture</em> ，则找到第一个元素， <u><em>find()</em></u> 返回该元素；如果所有元素都遍历完毕，没有返回 <em>ture</em> ，则说明未找到元素，<em>find()</em> 返回 <em>undefined</em>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> tmp = arr.find</span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s.toLowerCase() === s;  <span class="comment">// 找到第一个全是小写字母的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"><span class="built_in">console</span>.log(tmp);<span class="comment">// 输出：pear</span></span><br></pre></td></tr></table></figure>
<h4 id="findIndex"><em>findIndex()</em></h4>
<p>和 <em>find()</em> 类型，不同在于 <em>findIndex()</em> 找到元素返回该索引而非返回元素；如果没找到元素则返回 -1。</p>
<h3 id="特别：forEach">特别：<em>forEach()</em></h3>
<p>同前 <em>forEach</em>  循环，它可用来遍历 <u>数组</u>、<u>集合</u> 。只单纯传递数组元素等信息，具体对数组元素等进行什么操作由传递的回调函数决定。</p>
<blockquote>
<p>利用<em>forEach()</em> 尝试遍历一个数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>
<p>由于回调函数默认有三个参数：<em>element、index、self</em> ，<em>console.log</em> 接收这三个实参依次打印它们信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple 0 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]</span><br><span class="line">pear 1 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]</span><br><span class="line">orange 2 [ &#x27;Apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27; ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>forEach()</em> 遍历一个数组，只打印出数组元素。</p>
</blockquote>
<p>我们可以重写 <em>console.log</em> 方法，让它只接收一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> old_console_log = <span class="built_in">console</span>.log;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) // 重写</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_console_log(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="built_in">console</span>.log);    <span class="comment">// 依次输出：Apple   pear    orange</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>forEach()</em> 还可以遍历集合，如 <em>Set</em>、<em>Map</em> 等。注：不能遍历对象！遍历对象直接<em>for</em> 循环就行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); </span><br><span class="line">arr2.forEach</span><br><span class="line">(</span><br><span class="line">    <span class="built_in">console</span>.log    <span class="comment">// 依次输出：1  2  3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-闭包">2.5 闭包</h2>
<h4 id="什么是闭包？">什么是闭包？</h4>
<p>前面我们了解到，函数可以作为 <u>参数</u>，那么函数自然也可作为 <u>返回值</u>。</p>
<p>闭包，简单来说就是携带状态的函数，其返回值是一个也是函数，而且它的状态可以完全对外隐藏起来。</p>
<p>它的作用有：</p>
<ul>
<li>可创建函数工厂、减少函数参数</li>
<li>实现携带状态的闭包，获取函数内部局部变量且变量一直在内存中</li>
</ul>
<h4 id="函数工厂">函数工厂</h4>
<blockquote>
<p>计算指定 <em>x</em> 值的 2次方 / 3次方。</p>
</blockquote>
<p>也许聪明的你，很快想到利用系统自带 <em>API</em> 计算<em>x</em> 次方：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;   <span class="comment">// x值任意</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(x,<span class="number">2</span>);   <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">Math</span>.pow(x,<span class="number">3</span>);   <span class="comment">// 125</span></span><br></pre></td></tr></table></figure>
<p>但是，如果计算指定 <em>x</em> 值的 2次方 / 3次方是 <u>常用</u> 的，你觉得没必要每次都指定参数 <u>幂次</u> ，干脆直接自定义 <em>pow2 / pow3</em> 函数，只接收参数 <u>x</u> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow2</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow3</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pow2(<span class="number">5</span>);</span><br><span class="line">pow3(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>但是，如果计算 <em>x</em> 值的 4次方 / 5次方也 <u>常用</u>  ，定义4个函数显然不太简洁。</p>
<p>这里，可以用闭包创建一个函数工厂，返回同类我们需要的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat_pow</span>(<span class="params">n</span>)    // 创建<span class="title">pow</span>函数工程，参数为指定幂次</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)   // 返回函数，参数为变量<span class="title">x</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow2 = creat_pow(<span class="number">2</span>);   <span class="comment">// 注意这里参数是：幂次，返回计算指定幂次函数</span></span><br><span class="line"><span class="keyword">var</span> pow3 = creat_pow(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">pow2(<span class="number">5</span>);   <span class="comment">// 25        注意这里参数是：变量x，即闭包里隐藏的局部变量x，计算它的指定幂次</span></span><br><span class="line">pow3(<span class="number">5</span>);   <span class="comment">// 125</span></span><br></pre></td></tr></table></figure>
<p>在这里我们还可以看到，闭包函数<em>pow</em> 隐藏一个状态：变量<em>x</em> ，即<em>pow</em> 内部返回的匿名函数局部变量参数<em>x</em> 。从而把一个多参数函数，变为单参数函数。</p>
<blockquote>
<p>又有，利用闭包快速生成不同类似函数，给Web进行事件绑定。</p>
</blockquote>
<p>参照：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjvae/p/9786598.html">闭包的应用 – 应用于web开发</a></p>
<h4 id="更深入理解-“闭包”">更深入理解 “闭包”</h4>
<p>难道闭包只是为了返回函数进而创建函数工厂 OR 减少函数参数吗？怎么理解闭包是携带状态的函数？请看下例：</p>
<p>我们知道，函数内部的局部变量，在函数退出后便自动消亡：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat_counter</span>(<span class="params">initial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = initial;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = creat_counter(<span class="number">0</span>);  <span class="comment">// 返回的是函数，故带上()是为了执行然后返回函数</span></span><br><span class="line"><span class="built_in">console</span>.log(c());    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c());    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c());    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>非常奇怪的是，为什么这里的局部变量 <em>n</em> 实现了递增呢？变量<em>n</em> 不是应该在执行：<code>var c = creat_counter(0);</code> 后就已经消亡了吗？</p>
<p>其实：在返回的函数中，<u>实现了一个闭包环境，该闭包携带了外部无法访问的局部变量x</u> 。</p>
<p>这是由于 <em>creat_counter</em> 是内部匿名子函数的父函数，而<em>creat_counter</em> 被赋值给全局变量 <em>c</em>，因此其内部变量<em>n</em> 、匿名子函数都在内存中，没有被垃圾回收机制回收。</p>
<p>这样父函数内部，子函数外部的局部变量<em>n</em>，在 <em>JavaScript</em> 类似类的私有变量。我们还可以返回一个对象，看起来更像是 <u>类对象调用方法</u>。</p>
<blockquote>
<p>实现类似<em>class</em>机制封装私有变量的一个简单计数器。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat_counter</span>(<span class="params">initial</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = initial;     <span class="comment">// 看起来就是一个私有变量，外部无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个对象，里面有inc属性，这样调用起来像是对象调用方法。</span></span><br><span class="line">    <span class="comment">// 注意 inc:f2() 错误，带()是执行函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">inc</span>:increase&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = creat_counter(<span class="number">0</span>);  <span class="comment">// 返回的是对象，带上()是为了执行函数后返回对象</span></span><br><span class="line"><span class="comment">// 看起来像是对象调用方法</span></span><br><span class="line">c.inc();   <span class="comment">// 1</span></span><br><span class="line">c.inc();   <span class="comment">// 2</span></span><br><span class="line">c.inc();   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="小心！返回函数不立即执行">小心！返回函数不立即执行</h4>
<p>我们需要注意一个问题，闭包返回的 <u>函数fun</u> 并不会立即执行，而是直到调用 <u>函数fun()</u> 才会执行。</p>
<p>这样，在我们返回函数引用任何后续会发生的变量都会产生意料之外结果，比如循环变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> arr = [];   <span class="comment">// 定义一个数组，用于压入三个函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)   <span class="comment">// 循环压入一个匿名函数计算当前i^2：用箭头函数简写     </span></span><br><span class="line">        arr.push( <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> i * i &#125;);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>]; <span class="keyword">var</span> f2 = results[<span class="number">1</span>];  <span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>当我们尝试执行 <em>f1()</em>、 <em>f2()</em>、 <em>f3()</em> 会发现一个出人意料的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1(); // 16</span><br><span class="line">f2(); // 16</span><br><span class="line">f3(); // 16</span><br></pre></td></tr></table></figure>
<p>全都是16！这是因为，由于变量提升，循环局部变量 <strong>i</strong> 已经是函数内部全局变量了。</p>
<p>同时，<em>arr.push()</em> 压入函数时，函数并未立即执行。等到 <em>return  arr</em> 时，此时引用的变量<strong>i</strong> 已经执行完<strong>3</strong>次循环后变为 <strong>4</strong> 了。</p>
<p>我们有两种解决办法：</p>
<ol>
<li>
<p>循环内部变量用 <em>let</em> 关键字声明，这样等到 <em>return  arr</em> 时，函数引用的变量是对应循环次数局部变量 <strong>i</strong> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)   <span class="comment">// let</span></span><br><span class="line">        arr.push( <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> i * i &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再创建一个函数 <u>立即执行</u>，用该函数的参数绑定循环变量当前的值，参照：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021250770016">廖雪峰教程–闭包</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) </span><br><span class="line">    arr.push(</span><br><span class="line">        (</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n * n;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )(i)   <span class="comment">// 当前i赋值给函数形参n立即执行</span></span><br><span class="line">            );</span><br></pre></td></tr></table></figure>
<p>为什么直接压入匿名函数，而是要内部再返回一个函数，否则会报错？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> arr = [];   <span class="comment">// 定义一个数组，用于压入三个函数   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) </span><br><span class="line">        arr.push(</span><br><span class="line">            (</span><br><span class="line">                <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> n * n;   <span class="comment">// 直接返回出错？？</span></span><br><span class="line">                &#125;</span><br><span class="line">            )(i)</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1());  <span class="comment">// 报错： f1 is not a function</span></span><br></pre></td></tr></table></figure>
<p>这是因为表面看<em>arr.push()</em> 压入的是一个函数，但由于立即执行，实际上压入的是函数返回值！所以才必须设计压入函数返回值是一个函数。</p>
</li>
</ol>
<h2 id="2-6-箭头函数">2.6 箭头函数</h2>
<p>箭头函数和 <em>Lambda</em> 表达式都用于简写匿名函数，其语法也基本相同：<code>(parameters) =&gt; &#123; statements; &#125;</code>。</p>
<p>同时在满足一定条件下，还可以进一步简写：</p>
<ul>
<li><em>参数类型可选</em> ：不需要声明参数类型，编译器可以统一识别参数值；</li>
<li><em>只有一个参数</em> ： 参数 ()可选</li>
<li><em>主体{}只有一条语句</em> ：此时 <em>return</em> 关键字 &amp; {} ，可不写。注意 ！
<ul>
<li>主体{} 不省略时，哪怕只有一条语句，函数有返回值<em>return</em>关键字不可省！</li>
<li>主体{} 省略时，<em>return</em> 也必须省略！</li>
</ul>
</li>
</ul>
<blockquote>
<p>利用箭头函数，实现给指定数组排序。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// arr.sort( (x, y) =&gt; x &gt; y ? 1: -1;);  // 错误：函数作为参数不要加分号！</span></span><br><span class="line">arr.sort( <span class="function">(<span class="params">x, y</span>) =&gt;</span> x &gt; y ? <span class="number">1</span>: -<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 试着指出下列箭头函数为什么不对？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort( <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;  x &gt; y ? <span class="number">1</span>: -<span class="number">1</span>; &#125;);    <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure>
<p>主体{}只有一条语句，不省略{}时，语句要有分号 &amp; <em>return</em>不可省！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort( <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x &gt; y ? <span class="number">1</span>: -<span class="number">1</span>; &#125;);  <span class="comment">// 正确写法</span></span><br></pre></td></tr></table></figure>
<h4 id="优雅的解决-this-错误指向">优雅的解决 <em>this</em> 错误指向</h4>
<p>在前面，我们提到 <em>JavaScript</em> 一个设计错误，在嵌套函数内部 <em>this</em> 会指向全局对象<em>window</em> (严格模式下指向 <em>undefined</em>) 而非调用函数的对象！为此我们提出一种解决办法：在嵌套函数里捕获<em>this</em>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 捕获this，此时this不在嵌套函数内部还是指向调用对象</span></span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> nowYear - <span class="built_in">this</span>.birth;    <span class="comment">// 调用对象里属性，不用this会报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAge();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以箭头函数更加优雅的解决<em>this</em> 指向错误问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 无需捕获this，此时this也能正确指向调用方法的对象</span></span><br><span class="line">        <span class="keyword">var</span> getAge = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth;  </span><br><span class="line">        <span class="keyword">return</span> getAge();   <span class="comment">// 注意：返回不是函数，而是调用后函数值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());   <span class="comment">// 输出：23</span></span><br></pre></td></tr></table></figure>
<p>我的理解是，此时已经不是在嵌套函数内部调用<em>this</em> ，而在外层函数内调用<em>this</em>，不会出现<em>this</em> 错误指向问题。</p>
<p>因为在外层函数使用<em>this</em> 是可以自动绑定到当前调用函数的对象，但直接在对象内部调用<em>this</em> 还是会出错。</p>
<blockquote>
<p>试分析：为什么对象内部直接<em>this</em> 调用属性出错。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">my_birth</span>: <span class="built_in">this</span>.birth,</span><br><span class="line">    <span class="attr">age</span>:<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.my_birth);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>比如调用 <em>hwh.my_birth</em> 相当于以下过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwh = <span class="keyword">new</span> hwh();            </span><br><span class="line">hwh.my_birth = <span class="built_in">this</span>.birth;   <span class="comment">// 此时this指向了全局对象！</span></span><br></pre></td></tr></table></figure>
<p><em>hwh.age()</em> 调用错误同理。那么如何解决这个问题？</p>
<p>目前除了<em>apply、call</em> 改变 <em>this</em> 指向（没试过），可声明一个函数在里面<em>this</em> 调用可以绑定到正确对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwh = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1996</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;chongqingU&#x27;</span>,</span><br><span class="line">    <span class="attr">my_birth</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="built_in">this</span>.birth; &#125;,</span><br><span class="line">    <span class="attr">age</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hwh.my_birth);  <span class="comment">// 1996</span></span><br><span class="line"><span class="built_in">console</span>.log(hwh.age());     <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>
<h2 id="2-7-generator">2.7 <em>generator</em></h2>
<p><em>generator</em> 即生成器，是<em>ES6</em> 新引入数据类型，看上去像一个函数，但可以返回多次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myGenerator =  f(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> x1 = myGenerator.next();   <span class="built_in">console</span>.log(x1);  <span class="comment">// 输出：&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> x2 = myGenerator.next();   <span class="built_in">console</span>.log(x2);  <span class="comment">// 输出：&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> x3 = myGenerator.next();   <span class="built_in">console</span>.log(x3);  <span class="comment">// 输出：&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> x4 = myGenerator.next();   <span class="built_in">console</span>.log(x4);  <span class="comment">// 输出：&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>它多个返回值可以 <u>记录函数不同时刻的执行状态</u>，从语法上看和函数有以下几个区别：</p>
<ul>
<li>基本定义：函数是<em>function f(x)</em> ，而生成器要多出一个<code>*</code> ，<em>function* f(x)</em></li>
<li>返回值：<em>generator</em> 生成器可以有多个返回值，记录函数不同时刻状态</li>
<li>使用：直接调用 <em>generator</em> 不是返回值，而是返回 <u>一个生成器对象</u> ，可调用它的 <em>next()</em> 函数来输出返回值。
<ul>
<li>生成器不同返回值以对象形式保存：<u>{<em>value</em> : 当前返回值，<em>done</em>: 判断是否已经输出完毕}</u></li>
</ul>
</li>
</ul>
<p>我们还可以更简洁用 <em>for…of</em> 循环来遍历<em>generator</em> 输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面在浏览器里如是输出：如果直接在VSCode打印，还会在第一行输出：</span></span><br><span class="line"><span class="comment">// Object [Generator] &#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> myGenerator)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 依次输出：1  2  3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，<em>generator</em> 这种可以返回多个值，记录不同时刻执行状态的&quot;函数&quot;有什么作用呢？请看下例：</p>
<blockquote>
<p>试着编写一个以 <code>0、1</code> 开头的斐波那契数列：0 1 1 2 3 5 8 13 21 34 …</p>
</blockquote>
<p>按照以前思路，我们若要返回该斐波那契数列，必须要用 <u>数组保存多个值</u> ，且看更优雅的<em>generator</em> 如何做到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> a;   <span class="comment">// 返回 0</span></span><br><span class="line">    <span class="keyword">yield</span> b;   <span class="comment">// 返回 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &lt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        [a,b] = [b,c];  </span><br><span class="line">        <span class="keyword">yield</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myGenerator =  fib(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> myGenerator)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 依次输出：0  1  1  2  3  5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>generator</em> 不用数组来保存每次循环计算的值，而是直接将当前计算值的值 <em>yield</em> 返回即可。</p>
<h3 id="generator-简化-AJAX-（待）"><em>generator</em> 简化 <em>AJAX</em> （待）</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/41171/">https://hwh.zone/p/41171/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/20680/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端基础（一）JavaScript基础笔记(中)</div></div></a></div><div class="next-post pull-right"><a href="/p/29708/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211224211608.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">校招笔记（零）_写在前面</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/11812/" title="前端基础（一）JavaScript基础笔记（下）"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">前端基础（一）JavaScript基础笔记（下）</div></div></a></div><div><a href="/p/20680/" title="前端基础（一）JavaScript基础笔记(中)"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">前端基础（一）JavaScript基础笔记(中)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第一章：快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-hello-javaScript"><span class="toc-text">1.1 hello javaScript!</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-js-css%E6%96%87%E4%BB%B6%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%9F"><span class="toc-text">引入 js &#x2F; css文件不成功？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AE%89%E8%A3%85-codeRunner-%E6%8F%92%E4%BB%B6"><span class="toc-text">1.2 安装 codeRunner 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-text">如何直接打印信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CodeRunner-%E8%BF%90%E8%A1%8C%E4%B9%B1%E7%A0%81-%E6%8A%A5%E9%94%99"><span class="toc-text">CodeRunner 运行乱码&#x2F;报错</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1.3 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E5%92%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">1. 变量和注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%BF%83%EF%BC%81-%E3%80%81NaN%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">小心！&#x3D;&#x3D; 、NaN、浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2. 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">如何优雅表示字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-text">常用字符串操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84"><span class="toc-text">3. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E5%A6%99%E6%95%B0%E7%BB%84"><span class="toc-text">奇妙数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-text">常用数组操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">访问对象属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%88%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">给对象增删属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%8B%A5%E6%9C%89%E6%9F%90%E5%B1%9E%E6%80%A7"><span class="toc-text">判断对象是否拥有某属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-%E5%BE%AA%E7%8E%AF"><span class="toc-text">5. 条件判断 &amp; 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-text">循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Map-Set"><span class="toc-text">6. Map &amp; Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MAP"><span class="toc-text">MAP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">7. 如何优雅遍历集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E2%80%A6-in-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">for … in 遍历集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">forEach() 遍历集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E2%80%A6-in-%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-text">for … in 循环的弊端：数组长度不一致</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章 ：函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8"><span class="toc-text">2.1 函数基本入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%BF%83%E4%BD%A0%E7%9A%84-return-%E8%AF%AD%E5%8F%A5"><span class="toc-text">小心你的 return 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%A6%99%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">奇妙的函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%BB%BB%E6%84%8F%EF%BC%9F"><span class="toc-text">传递参数个数任意？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">怎么处理所有参数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%A4%9A%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">优雅的处理多余参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">2.2 变量作用域与解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">1. 快速了解变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%94%99%E8%AF%AF"><span class="toc-text">避免错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2. 全局作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window-%E5%AF%B9%E8%B1%A1"><span class="toc-text">window 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">更好的定义全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%90%E6%9E%84%E5%80%BC"><span class="toc-text">3. 解析构值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-text">解构数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">解构对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">解构嵌套对象和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-text">嵌套数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1"><span class="toc-text">嵌套对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%96%B9%E6%B3%95%E4%B8%8Ethis%E5%A4%A7%E5%9D%91"><span class="toc-text">2.3 方法与this大坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B0%8F%E5%BF%83%E4%BD%BF%E7%94%A8%E4%BD%A0%E7%9A%84-this"><span class="toc-text">1. 小心使用你的 this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E6%96%B9%E6%B3%95"><span class="toc-text">新变量指向方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%94%A8-this"><span class="toc-text">多层函数内部用 this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%86%92%E4%B8%8D%E8%A6%81%E7%8A%AF%E9%94%99%EF%BC%9Astrict-%E6%A8%A1%E5%BC%8F"><span class="toc-text">提醒不要犯错：strict 模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-apply-%E6%96%B9%E6%B3%95"><span class="toc-text">2. apply 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-%E6%96%B9%E6%B3%95"><span class="toc-text">call 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">新的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">装饰器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">2.4 高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%EF%BC%9Amap-reduce"><span class="toc-text">映射：map &#x2F; reduce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-text">map()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce"><span class="toc-text">reduce()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E8%A7%84%E5%88%99%EF%BC%9Afilter-sort-%E2%80%A6"><span class="toc-text">自定规则：filter &#x2F; sort …</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-text">filter()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-text">sort()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-text">定义自己的排序规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#every"><span class="toc-text">every()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-text">find()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findIndex"><span class="toc-text">findIndex()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%EF%BC%9AforEach"><span class="toc-text">特别：forEach()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E9%97%AD%E5%8C%85"><span class="toc-text">2.5 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-text">什么是闭包？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B7%A5%E5%8E%82"><span class="toc-text">函数工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E2%80%9C%E9%97%AD%E5%8C%85%E2%80%9D"><span class="toc-text">更深入理解 “闭包”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%BF%83%EF%BC%81%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%8D%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C"><span class="toc-text">小心！返回函数不立即执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">2.6 箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3-this-%E9%94%99%E8%AF%AF%E6%8C%87%E5%90%91"><span class="toc-text">优雅的解决 this 错误指向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-generator"><span class="toc-text">2.7 generator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#generator-%E7%AE%80%E5%8C%96-AJAX-%EF%BC%88%E5%BE%85%EF%BC%89"><span class="toc-text">generator 简化 AJAX （待）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/52463/" title="C++从零开始（二）：基础语法（上）之快速入门">C++从零开始（二）：基础语法（上）之快速入门</a><time datetime="2021-12-09T05:31:37.851Z" title="发表于 2021-12-09 13:31:37">2021-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a><time datetime="2021-12-05T08:28:39.054Z" title="发表于 2021-12-05 16:28:39">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a><time datetime="2021-12-05T08:24:40.924Z" title="发表于 2021-12-05 16:24:40">2021-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/62712/" title="C++从零开始（零）">C++从零开始（零）</a><time datetime="2021-12-05T08:22:28.029Z" title="发表于 2021-12-05 16:22:28">2021-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <h1 id="tree-toc-title" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/categories/">目 录 </a> </h1>
      <h5 id="tree-toc-subtitle" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/">royhuang's blog</a> </h5>
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/52463/" title="C++从零开始（二）：基础语法（上）之快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：基础语法（上）之快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）之VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）之VSCode远程开发</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记"><i class="post-icon gg-file-document"></i>Git基础笔记</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Python/">
          Python
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7160/" title="Python 基础笔记"><i class="post-icon gg-file-document"></i>Python 基础笔记</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">
          前端
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">
          JavaScript
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/41171/" title="前端基础（一）JavaScript基础笔记(上)"><i class="post-icon gg-file-document"></i>前端基础（一）JavaScript基础笔记(上)</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/11812/" title="前端基础（一）JavaScript基础笔记（下）"><i class="post-icon gg-file-document"></i>前端基础（一）JavaScript基础笔记（下）</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/20680/" title="前端基础（一）JavaScript基础笔记(中)"><i class="post-icon gg-file-document"></i>前端基础（一）JavaScript基础笔记(中)</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">
          CSS
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/30504/" title="前端基础（二）CSS基础笔记"><i class="post-icon gg-file-document"></i>前端基础（二）CSS基础笔记</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Java/">
          Java
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Java/Java%E5%9F%BA%E7%A1%80/">
          Java基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44149/" title="Java基础笔记"><i class="post-icon gg-file-document"></i>Java基础笔记</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
          数据库
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">
          Redis
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/9336/" title="数据库（二）Redis基础"><i class="post-icon gg-file-document"></i>数据库（二）Redis基础</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">
          MySQL
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/39784/" title="数据库（一）MySQL基础笔记"><i class="post-icon gg-file-document"></i>数据库（一）MySQL基础笔记</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">
          深度学习
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Numpy/">
          Numpy
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/64865/" title="深度学习基础（一）Numpy"><i class="post-icon gg-file-document"></i>深度学习基础（一）Numpy</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Pytorch/">
          Pytorch
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/33170/" title="深度学习基础（二）Pytorch"><i class="post-icon gg-file-document"></i>深度学习基础（二）Pytorch</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/OpenCV/">
          OpenCV
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61137/" title="深度学习基础（三）OpenCV"><i class="post-icon gg-file-document"></i>深度学习基础（三）OpenCV</a></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>