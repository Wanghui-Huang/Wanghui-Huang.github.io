<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++从零开始（二）：务实基础（下）函数 | royhuang's blog</title><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 三、函数 3.1 基本概念  怎么定义函数？  以前，我比较倾向将函数定义为顺序执行的语句集合。现在我认为更恰当的说法应该是：函数是一个可重用的语句序列，旨在完成特定的工作。 C++ 中函数一般形式如下： 1234return_type function_name( parameter_">
<meta property="og:type" content="article">
<meta property="og:title" content="C++从零开始（二）：务实基础（下）函数">
<meta property="og:url" content="https://hwh.zone/p/51595/index.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="🌟《C++从零开始》 系列，开始更新中…  C++从零开始https:&#x2F;&#x2F;hwh.zone&#x2F;p&#x2F;62712 三、函数 3.1 基本概念  怎么定义函数？  以前，我比较倾向将函数定义为顺序执行的语句集合。现在我认为更恰当的说法应该是：函数是一个可重用的语句序列，旨在完成特定的工作。 C++ 中函数一般形式如下： 1234return_type function_name( parameter_">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2021-12-09T05:31:37.851Z">
<meta property="article:modified_time" content="2022-01-29T10:15:44.898Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="C++基础">
<meta property="article:tag" content="函数">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/p/51595/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"XVCM04DNZ4","apiKey":"137b0bbc59574cb11c2e8fed36fb30fb","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++从零开始（二）：务实基础（下）函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-29 18:15:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++从零开始（二）：务实基础（下）函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-09T05:31:37.851Z" title="发表于 2021-12-09 13:31:37">2021-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-29T10:15:44.898Z" title="更新于 2022-01-29 18:15:44">2022-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">从零开始</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">C++基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++从零开始（二）：务实基础（下）函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>🌟<a href="https://hwh.zone/p/62712/">《C++从零开始》</a> 系列，开始更新中…</p>
</blockquote>
<div class="tag link"><a class="link-card" title="C++从零开始" href="https://hwh.zone/p/62712"><div class="left"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"/></div><div class="right"><p class="text">C++从零开始</p><p class="url">https://hwh.zone/p/62712</p></div></a></div>
<h2 id="三、函数">三、函数</h2>
<h3 id="3-1-基本概念">3.1 基本概念</h3>
<blockquote>
<p>怎么定义函数？</p>
</blockquote>
<p>以前，我比较倾向将函数定义为<strong>顺序执行的语句集合</strong>。现在我认为更恰当的说法应该是：<strong>函数是一个<u>可重用</u>的语句序列，旨在完成特定的工作</strong>。<br>
C++ 中函数一般形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter_list )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// body of the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面包含一个函数的所有组成部分：</p>
<ul>
<li><strong>返回类型(return_type)</strong>：一个函数可以返回一个值，<strong>return_type</strong> 是函数返回的值的数据类型。不需要返回值，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称(function_name)</strong>：函数的实际名称，<strong>函数名和参数列表一起构成了函数签名</strong>。
<ul>
<li>所谓”签名“则意味着这可以唯一标识一个函数。</li>
</ul>
</li>
<li><strong>参数列表(parameter_list)</strong>：参数就像是占位符。当函数被调用时，可向参数传递一个值，这个值被称为实际参数，参数列表包括函数参数的<strong>类型、顺序、数量</strong>。
<ul>
<li>参数列表的顺序、类型、数量不完全一致的话，形成不同函数签名，即是不同函数。</li>
</ul>
</li>
<li><strong>函数主体(boby)</strong>：函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p>特别的，C++是不支持嵌套函数的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译出错</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max1</span><span class="params">(<span class="keyword">int</span> num1=<span class="number">0</span>, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-前向声明🌟">3.1.1 前向声明🌟</h4>
<h5 id="前向声明初识">前向声明初识</h5>
<p>在很多IDE中，如果你尝试在main函数使用未在之前定义的函数，会出现编译错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 编译错误</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为<strong>max函数定义在main函数之后，顺序编译到代码第6行max(1,2)时找不到max的定义</strong>，所以main不知道max是什么（是的怎么这么笨？）。</p>
<p>解决这个问题，可以：</p>
<ul>
<li>
<p><strong>将max函数整体定义在main函数前</strong>；</p>
</li>
<li>
<p><strong>前向声明</strong>。</p>
<p>前向声明告诉编译器标识符在实际定义之前就已经存在，这样编译器会<u>在链接时进行符号链接寻找标识符的定义</u>。</p>
<blockquote>
<p>感觉和extern关键字很像？请见下节对比。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 编译正确</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果max定义在其它文件（max.cpp）中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*max.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1&gt;num2?num1:num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你在main中（定义在main.cpp）中，可以不通过include “main.cpp”而使用前置声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>; <span class="comment">// 前向声明,会在链接的时候寻找max的定义，编译器时不报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 编译正确</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译（一切正常）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp max.cpp -o main.out</span><br><span class="line">./main.out</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但经过我的实践，在很多编译器中进行了优化。<strong>同一个文件的函数</strong>即使不进行前向声明，上面的代码也不会报错。</p>
<p>而且，在<a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/?highlight=%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E#forward-declarations">Google code style</a> 也明确指出尽量不要使用前置声明：</p>
<blockquote>
<p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220116163129065.png" alt="image-20220116163129065"></p>
</blockquote>
<p><strong>那么，前向声明还存在的意义是什么</strong>？</p>
<ol>
<li>减少编译时间。使用include也可以使用别的的文件中定义的变量，但是也会把头文件其它不需要的变量引入。如果只是需要使用很少的外部变量，使用前向声明能减少编译的头文件展开。</li>
<li>打破循环引用。</li>
</ol>
<h5 id="循环引用">循环引用</h5>
<p>前置声明现在<strong>用来解决多文件中循环引用的问题</strong>。</p>
<p>以类循环引用为例。</p>
<p><strong>想象这么一个情况：A.h定义了Class A，它需要引用B.h定义的Class B，也就是要写入#include “B.h” ；类似的情况，B.h也需要写入#include “A.h”</strong>。</p>
<p>这就造成了两个类互相引用，但由于C++蛋疼顺序编译的规则。如果是先编译A.h，引用的类B则找不到实现的定义；如果是先编译B.h，则找不到类A的定义。形成“先有鸡还有先有蛋”的世纪难题。</p>
<p>我们举一个具体的例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* B.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      A *a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*test.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;B.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   A a;</span><br><span class="line">   B b;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试编译一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  test.cpp -o test.out</span><br></pre></td></tr></table></figure>
<p>显示在<code>B.h</code>中找不到<code>A</code>的定义：<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227163519959.png" alt="image-20211227163519959"></p>
<p><strong>现在我们从底层编译过程探讨下这个循环引用出现的原因和解决方案</strong>。</p>
<p>我们知道编译四大流程为：预编译→编译→汇编→链接，先看看预编译源文件test.cpp产生的test.i。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E  test.cpp  -o test.i</span><br></pre></td></tr></table></figure>
<p>预编译后内容如下：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227171957061.png" alt="image-20211227171957061"></p>
<p>下面是<code>test.i</code>中具体内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      A *a;  <span class="comment">// 前面没有A的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"># <span class="number">4</span> <span class="string">&quot;A.h&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      B *b;</span><br><span class="line">&#125;;</span><br><span class="line"># <span class="number">10</span> <span class="string">&quot;test.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   A a;</span><br><span class="line">   B b;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，test.i中<strong>第6行代码<code>A* a</code>，在类B中引用了<code>A</code> ，但是前面没有关于<code>A</code> 的定义</strong>。这为后面编译出错埋下了伏笔。</p>
<p>预编译后完成后，我们进行第2个阶段：编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.cpp -o  test.s</span><br></pre></td></tr></table></figure>
<p>Error！出现了最开始的“未定义”错误：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211227210145942.png" alt="image-20211227210145942"></p>
<p>也就是说这个错误在编译阶段就产生了：当C++<strong>按顺序编译</strong>到 <code>A *a</code> 这行时，编译器进行语法检查，发现<strong>在前面找不到<code>A</code>相关的定义</strong>，于是报错。</p>
<p><strong>怎么解决这个问题</strong>？</p>
<p>我们可以在<code>B.h</code> 中进行前向声明，解决这个错误。</p>
<ul>
<li><strong>类似于全局变量，这样<code>A</code>作用范围就到本文件结尾：即编译器还会在<code>test.i</code> 中其它位置寻找<code>A</code>的定义</strong>；</li>
<li><strong>不仅如此，即使<code>test.i</code>中不存在，编译器还会在链接时符号解析时寻找A的定义，而不是在编译时就报错</strong>。</li>
</ul>
<p>这样编译器就不会在编译阶段报错了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>  <span class="comment">// 前向声明，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>新的预编译文件<code>test.i</code>文件也在相应位置多了一行<code>Class A;</code>（其余无变化）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>如果不使用#ifndef 、#define 和#endif</strong>？</p>
<p>#ifndef 、#define 和#endif，即条件编译：只有满足要求代码才参与编译，否则不参与编译。基本用法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符  </span></span><br><span class="line">程序段<span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">程序段<span class="number">2</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在本节中，对B.h和A.h都使用了条件编译：<strong>防止头文件被重复定义，在链接时出现大量重定义错误</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A_H <span class="comment">// 或B_H</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_H <span class="comment">// 或B_H</span></span></span><br><span class="line"><span class="comment">// A_H或B_H中的代码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>以<code>A.h</code>为例：</p>
<ol>
<li>如果<code>A.h</code>被<u>第一个文件</u>引入时，会定义标识符<code>A_H</code> ，这个时候<code>A.h</code>其后的代码会被预编译插入到文件中；</li>
<li>如果<u>其它文件</u>存在代码<code>#include “A.h”</code> ，尝试预编译替换为<code>A.h</code>中内容；</li>
<li>因为<code>A_H</code> 已被定义，直接跳转到<code>#endif</code>结束，<strong>避免了头文件重复引入</strong>。</li>
</ol>
<p>在本节中，如果对B.h和A.h都<u>不使用</u>条件编译，<strong>预编译时不但会出现重定义错误还会出现无限嵌套</strong>：</p>
<ol>
<li>main.cpp中：#include “A.h” 被替换为A.h中具体内容；</li>
<li>A.h中： 由于在头文件引入了 #include “B.h” ，所以 #include “B.h”也会被替换为B.h中具体内容；</li>
<li>B.h中： 重复引入了 #include “A.h”，重复替换头文件A.h，跳转到步骤2发生无限嵌套。</li>
</ol>
<h5 id="extern和前向声明">extern和前向声明</h5>
<p>extern和前向声明作用非常相似：<strong>都可以用来声明<u>函数/结构体/类</u>等是在外部定义的，这样在编译时不出错，在链接时会在其它<code>.o</code>寻找相关定义</strong>。</p>
<p>但是extern关键字和前向声明也有些不同：</p>
<ol>
<li><strong>extern可以作用于变量</strong>，前向声明无法声明变量（变量会默认初始化），只能声明函数/结构体/类等；</li>
<li><strong>extern还有extern “C”相关用法</strong>；</li>
<li><strong>extern是一个关键字</strong>，前向声明是种声明方式（使用前声明）。</li>
</ol>
<h5 id="最佳实践：extern-前向声明-include">最佳实践：extern/前向声明/include</h5>
<ul>
<li>
<p><strong>如果只是<u>少量</u>地要使用别的文件中定义的变量/函数/结构体/类等</strong>：请使用extern关键字，它可以减少编译时间；</p>
<p>虽然函数/结构体/类等使用前向声明也可以但不推荐，使用extern更好。</p>
</li>
<li>
<p><strong>打破循环引用</strong>。前向声明。</p>
</li>
<li>
<p><strong>其余情况使用include更好</strong>，代码逻辑更清晰。</p>
</li>
</ul>
<h4 id="3-1-2-最佳实践：什么时候使用函数">3.1.2 最佳实践：什么时候使用函数</h4>
<p>作为曾经稚嫩的（现在不那么稚嫩的）程序员，什么时候使用函数是一个挺纠结的问题。参考<a href="learncpp.com">learncpp</a> 中建议：</p>
<ul>
<li><strong>多次出现的语句应该组成一个函数</strong>。例如，如果我们以相同的方式多次读取用户的输入，那么这是一个很好的函数候选。</li>
<li><strong>具有明确定义的输入和输出目标的代码</strong>。例如，如果我们有一个要排序的项目列表，那么进行排序的代码将是一个很好的功能，<u>即使它只完成了一次</u>。输入是未排序的列表，输出是排序的列表。</li>
<li><strong>一个函数应该执行有且只有一项任务</strong>。</li>
<li><strong>当一个函数变得太长、太复杂或难以理解时</strong>。可以将其拆分为多个子函数，也就是重构。</li>
</ul>
<h3 id="3-2-函数重载">3.2 函数重载</h3>
<p>在前面我们提到：函数通过函数签名来唯一确定一个函数，而函数签名由 <u>函数名&amp;参数列表</u> 组成。</p>
<p>比如，<strong>两个函数函数名相同而参数列表不同，这个时候是同一函数吗</strong>？</p>
<p>显然不是，因为函数签名中的参数列表不同，因此是两个函数，这也就是<strong>函数重载</strong>。</p>
<h4 id="3-2-1-为什么需要函数重载？">3.2.1 为什么需要函数重载？</h4>
<p>重载函数通常用来命名一组功能相似的函数。这样做的好处：</p>
<ol>
<li>减少了函数名的数量；</li>
<li>避免了名字空间的污染，对于程序的可读性有很大的好处。</li>
</ol>
<p>请看下例。</p>
<p>我们有两个函数：一个返回两个整数相加的值，一个返回两个浮点数相加的值。我们<strong>定义了多个名称但极其相似（功能、名字etc.）的函数</strong>。它们核心功能虽然都是add，但却对应多个不同的函数名，增加了记忆负担。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addInteger</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">addDouble</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优雅的做法应该是：<strong>每个函数同名，编译器靠参数<u>类型</u>、<u>数量</u>、<u>顺序</u>来自动匹配调用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 匹配第一个add</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 匹配第二个add</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">3.4</span>,<span class="number">5</span>); <span class="comment">// 匹配第三个add</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-二义性匹配">3.2.2 二义性匹配</h4>
<p>前面介绍的都是传递的参数和定义函数参数完全匹配的简单情况。但实际上，还会出现<strong>函数调用中的参数类型与任何重载函数中的参数类型不完全匹配</strong> 。</p>
<p>这会发生什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print int : &quot;</span>&lt;&lt; x &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print double : &quot;</span>&lt;&lt; d &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print int : 97</span><br></pre></td></tr></table></figure>
<p>发生了什么？<code>print('a')</code> 匹配了 <code>print(int)</code>? <code>97</code>又是什么？</p>
<p>这是因为编译器如果找不到完全匹配的函数，<strong>会自动进行隐式转换将某些窄整数和浮点类型自动提升为更宽类型</strong>。所有这里的<code>char('a')</code> 自动提升为<code>int</code> ，匹配到了<code>print(int)</code> , <code>97</code>是<code>a</code> 的ASCII编码。</p>
<p>特别的，由于匹配到了<code>print(int)</code> ，便不会自动继续提升类型去匹配<code>print(double)</code>。</p>
<p>关于<u>类型转换</u> 会在第十章统一总结，这里先简单了解下即可。</p>
<blockquote>
<p>特别的，<strong>如果上述过程（数字转换找不到）未找到匹配项，编译器将尝试通过任何用户定义的转换找到匹配项</strong>。</p>
</blockquote>
<p>这涉及到<u>类型重载</u>，会在下篇文章<u>面对对象</u> 进行讲解。这里只要了解这个例子即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">// 用户自定义从X转换int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x; </span><br><span class="line">    <span class="built_in">print</span>(x);  <span class="comment">// 匹配print(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里例子中（也是一般函数参数匹配流程总结）：</p>
<ol>
<li>编译器寻找是否存在<code>print(X)</code> ，不存在转至第2步；</li>
<li>编译器检查<code>x</code>是否可以类型提升，不能进行第3步；</li>
<li>编译器将查找任何用户定义的转换，存在，进行转换。</li>
</ol>
<h3 id="3-3-函数模板">3.3 函数模板</h3>
<p>在前面<u>函数重载</u>中，我们通过将两个<u>功能相似仅参数列表不同</u>的函数，<u>改为同名函数</u>让编译器通过函数签名来区分，减少了思维负担。</p>
<p>但是考虑一种更特殊的情况，<u>两个函数不仅功能极其相似，连参数列表的个数都相同</u>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">3.0</span>,<span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总感觉哪里不对，似乎造成了很多代码重复？它们只是参数类型不同啊，函数体、名字什么都一样？</p>
<p>在C++中提供了函数模板，用来优雅地应对这种情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// template和typename是关键字，T是类型名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">3.0</span>,<span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不错，一切顺眼了很多。</p>
<h4 id="3-3-1-模板函数是如何工作的？">3.3.1 模板函数是如何工作的？</h4>
<p>在前文我们介绍了函数模板，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但函数模板实际上并不是函数——它们的代码不是直接编译或执行的。函数模板只有一个功能：<strong>为每个具有一组唯一参数类型的函数，调用创建（并编译）一个函数</strong>。</p>
<p>让我们看一个简单的例子，展示了一个不同以往的模板函数调用方式<code>funName&lt;actual_type&gt;(arg1, arg2)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print result : &quot;</span>&lt;&lt; x+y &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// print(1,2);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但相比<code>funName(arg1, arg2)</code> 这种方式，上面的才是更接近本质的调用方式。</p>
<p>因为<code>print(1,2)</code>，本质就是编译器克隆了函数模板<code>void print(T x, T y)</code>，将模板类型<code>T</code>替换为我们指定的实际类型<code>&lt;int&gt;</code>，最终生成指定类型的函数<code>void print&lt;int&gt;(int x, int y)</code> 。</p>
<blockquote>
<p>亲眼看一看：实例化完成后编译的内容。</p>
</blockquote>
<p>由于直接使用 <code>g++ -S</code> 生成的是汇编代码，不太直观，我们借助https://cppinsights.io/ 观察模板实例化后的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">print&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220111224749061.png" alt="image-20220111224749061"></p>
<p>实例化后，编译器确实生成了两个函数：<code>void print&lt;int&gt;(int x, int y)</code>、<code>void print&lt;double&gt;(double x, double y)</code>供我们调用。</p>
<p>上述<strong>从函数模板创建指定类型的函数的过程，称为函数模板实例化</strong>。如果这个过程是因为函数调用而产生的，则称为<strong>隐式实例化</strong>。</p>
<ul>
<li>
<p><strong>实例化函数每次调用都会发生吗</strong>？仅在<strong>第一次</strong>函数调用时实例化，对该函数的进一步调用将路由（指向）到已实例化的函数。</p>
</li>
<li>
<p><strong>最佳实践</strong>：优先使用普通函数调用方式，即<code>print(1,2)</code> 。</p>
</li>
</ul>
<h4 id="3-3-2-多个函数模板类型">3.3.2 多个函数模板类型</h4>
<p>多个函数模板类型适用于函数拥有多个不同类型参数的情况。</p>
<p>请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下阅读前，请思考：为什么编译会出错？有什么好的解决办法吗？</p>
<ul>
<li>
<p><strong>为什么编译出错</strong>？</p>
<ol>
<li>根据调用的函数<code>max(2, 3.5)</code> ，编译器会尝试寻找匹配的函数，没找到转下一步；</li>
<li>编译器尝试根据函数模板<code>max(T,T)</code>，生成函数<code>max(int,double)</code> 。显然这是不可能生成<strong>不同类型</strong>的参数。</li>
<li>函数调用解析出错。</li>
</ol>
<p>当然你可能还会问：<strong>为什么编译器不会生成函数<code>max(double,double)</code>，这调用时<code>max(int,double)</code> 中<code>int</code>可以隐式转换为<code>double</code>呢</strong>?</p>
<p>因此，类型转换仅在解析函数重载时进行，而不是在执行模板参数推导时进行。</p>
</li>
<li>
<p><strong>有什么好的解决办法吗</strong>？</p>
<p>当然，最简单办法是传参时便进行类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">max</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>), <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这样函数模板就可以生成函数<code>max(double,double)</code>，从而正确被调用了。但这很不cool。</p>
<p>或者你又想到了，我们不是新学会一种调用函数模板的方法吗，它可以<u>显示指定转换类型，编译器就不用自己去推导了</u>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; max&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br></pre></td></tr></table></figure>
<p>这也是ok的。</p>
<p>但最佳的解决办法，还是从根源解决：既然是调用参数类型有多个，而模板函数参数类型只有一个导致出现上面的问题。</p>
<p>那为什么不直接定义模板函数时也定义为多个类型呢？</p>
</li>
<li>
<p><strong>多个模板类型参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, U y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">3.5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，一切看起来挺不错，让我们输出一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>啊？大惊失色。为什么输出结果是3而不是3.5？</p>
<p>因为函数内部结果<code>3.5</code>为<code>double</code> 类型，返回的是<code>T</code>类型，已经被编译器自动推断（根据传的参数<code>2</code>）替换为<code>int</code> 类型。因此将3.5强制转换为3。</p>
<p>那我们直接指定返回类型<code>T</code> 变为<code>U</code> 不就行了吗？很可惜，不行。<strong>因为T、U的实际类型都是根据调用时传的参数进行推断的，而调用时传递参数的位置可以随意换动</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cout &lt;&lt; max(2, 3.5) &lt;&lt; &#x27;\n&#x27;; </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3.5</span>, <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br></pre></td></tr></table></figure>
<p>此时<code>U</code>被推断为<code>int</code> 类型。更好的做法是使用<code>auto</code>关键字，<strong>自动推导函数的返回类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(T x, U y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.5</span><br></pre></td></tr></table></figure>
<p>好了，一切都好起来了。关于<code>auto</code>关键字还会在后面做更详细的总结，希望你有了个初步的认识。</p>
</li>
</ul>
<h3 id="3-4-函数参数🌟">3.4 函数参数🌟</h3>
<blockquote>
<p>⚠️ 本节知识设计到较多指针和引用相关内容，此前无基础建议先阅读：<u>第二章：指针和引用</u>。</p>
</blockquote>
<p>在正式探讨函数参数前，我们先了解下函数中的两种参数：</p>
<ul>
<li><strong>形式参数</strong>：函数声明时表示的变量，函数调用时才分配内存。</li>
<li><strong>实际参数</strong>：调用函数数实际传递的参数值，必须是确定的值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// x,y 是形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 6,7 是实参，被赋值给形参x,y</span></span><br></pre></td></tr></table></figure>
<p>它们更多的区别会在3.4.6节中进行对比。</p>
<p>本节核心：按值传递、按引用传递和按指针传递，这 3 种向函数传递参数的主要方式。我们一起了解下吧。</p>
<h4 id="3-4-1-按值传递">3.4.1 按值传递</h4>
<ul>
<li>
<p><strong>什么是按值传递</strong>？</p>
<p>一般来说，<strong>C++ 中的非指针参数都是按值传递：实参的值被复制到相应函数形参中</strong>。</p>
<p>按值传递既然是复制，即只是将实参的副本传递给函数，那么函数修改副本（形参）的值是不能影响到实参值。请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">foo</span>(x); <span class="comment">// 实参x复制一份给y</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 5</span><br><span class="line">x = 5</span><br></pre></td></tr></table></figure>
<p><code>x</code>的值并没有被改变，虽然<code>foo</code> 函数内容修改了传递过来的值，但那只是<code>x</code>的副本。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211231000603042.png" alt="image-20211231000603042" style="zoom:80%;" />
<p>上图对这一过程进行形象说明，注意到实参x、形参y对应的是不同内存区域（地址都不一样）。</p>
</li>
<li>
<p><strong>什么时候用值传递</strong>？</p>
<p>按值传递通常用于需要传递的参数不希望被修改的时候，实参可以是：<u>变量（例如 x）、数字（例如 6）、表达式（例如 x+1）、结构和类以及枚举数</u>。</p>
<p>但是按值传递也有明显的缺点，应该避免以下几种情况使用：</p>
<ol>
<li>复制结构和类。复制结构和类开销过大，导致明显性能损失；</li>
<li>希望参数被改变；</li>
<li>返回多个值。</li>
</ol>
<p>其它情况优先考虑值传递。</p>
</li>
</ul>
<h4 id="3-4-2-按引用传递">3.4.2 按引用传递</h4>
<ul>
<li>
<p><strong>为什么需要引用传递</strong>？</p>
<p>在前面我们说到值传递的几个缺点：复制结构和类开销大、无法改变参数、只能返回一个值。</p>
<p>对应，如果你不希望以上发生，请使用引用传递。</p>
<p><strong>引用就相当于变量别名，操作引用等价于直接操作本体变量</strong>。请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> x_add_1, <span class="keyword">int</span>&amp; y_add_2,<span class="keyword">int</span>&amp; z_add_3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x_add_1 += <span class="number">1</span>;</span><br><span class="line">    y_add_2 += <span class="number">2</span>;</span><br><span class="line">    z_add_3 += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print(1.2,2);</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ,y = <span class="number">0</span> , z =<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getAdd</span>(x,y,z);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>上述过程简略分析。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211231160958522.png" alt="image-20211231160958522" style="zoom:80%;" />
<ul>
<li>引用传递变量 <code>y</code> 、<code>z</code> 均被修改（<code>x</code>值传递未被修改）。</li>
</ul>
<p>类似值传递。例如，引用传递中的<code>y_add_2</code> 也是被调函数栈上的一个局部变量，它保存了<code>y</code>的地址。对于引用参数的<strong>任何处理都会通过间接寻址，等价直接操作实参<code>y</code>本体</strong>。</p>
<p>特别的，引用还有几个特点（2.2节）：</p>
<ul>
<li>引用必须使用右值进行初始化，除非是执行常量的引用；</li>
<li>引用传递值必须被初始化，所以不必担心空值。</li>
</ul>
</li>
<li>
<p><strong>这么棒了你后面还讲指针传递干嘛</strong>？</p>
<blockquote>
<p>一般来说，我们确实推荐尽量使用引用传递参数，但是地址传递参数还是有它的用武之地。</p>
</blockquote>
<p>比如，引用传递值可以使得函数“返回”多个值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> x_add_1, <span class="keyword">int</span>&amp; y_add_2,<span class="keyword">int</span>&amp; z_add_3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是观察这个表达式，输入参数<code>x_add_1</code> ，和输出参数（返回值）<code>y_add_2</code>、<code>z_add_3</code> 放在一块，无法很好的区分哪些是要被修改的（输出参数）。毕竟，<strong>它们连调用都是这么相似</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span> ,y = <span class="number">0</span> , z =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">getAdd</span>(x,y,z);</span><br></pre></td></tr></table></figure>
<p>你能区分哪些是<code>x、y、z</code>哪些输出参数吗？</p>
</li>
</ul>
<h4 id="3-4-3-按指针传递">3.4.3 按指针传递</h4>
<ul>
<li>
<p><strong>为什么要需要指针传递值</strong>?</p>
<p>前面说到，引用传值用来“返回”多个参数时，很难区分哪些参数是输出参数，连调用时都过分相似（多胞胎搞人心态是吧？）。</p>
<p>上面代码修改为指针传值后，函数形参由<code>&amp;</code>变为<code>*</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAdd</span><span class="params">(<span class="keyword">int</span> x_add_1, <span class="keyword">int</span>* y_add_2,<span class="keyword">int</span>* z_add_3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     x_add_1 += <span class="number">1</span>;</span><br><span class="line">    *y_add_2 += <span class="number">2</span>;  <span class="comment">// y_add_2存的是y的地址，使用*操作符取值</span></span><br><span class="line">    *z_add_3 += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时（<strong>y、z可以很好的认出是输出参数</strong>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span> ,y = <span class="number">0</span> , z =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">getAdd</span>(x,&amp;y,&amp;z);  <span class="comment">// &amp;--取地址运算符</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>上面，<code>y_add_2</code> 获取了形参<code>&amp;y</code>保存的值，即变量<code>y</code>的内存地址。通过取值运算符<code>*y_add_2</code> ，可以获取变量<code>y</code>的内存区域操作权，即可以修改<code>y</code>的值了（+2）。因此变量<code>y</code>的值被修，<code>z</code>同理。</p>
</li>
<li>
<p><strong>惊讶！指针其实值传递</strong>？</p>
<p>这就是说我们像值传递一样将<strong>实参的值（一般是某个变量的地址）复制了一份给形参</strong>，形参<u>也作为局部变量在栈中开辟了内存空间</u>。</p>
<p>换句话说，指针是按值传递的！当然，这其实没多大惊讶（除非你和作者一样是个惊讶怪），因为我们早在<u>2.1节</u>分析过，指针本质就是一个变量，它有自己的值（其它变量的地址）和自己的地址。</p>
<p>请看下例，试分析：<strong>为什么<code>pfive</code>值没有被修改成功？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 ptr保存了p_five的值（five的地址）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNull</span><span class="params">(<span class="keyword">int</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;&amp;five&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span>* pfive = &amp;five; <span class="comment">// p_five = &amp;five = 0x7ffdb136b8e4</span></span><br><span class="line">    cout&lt;&lt;&amp;pfive&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">setNull</span>(pfive); <span class="comment">// 将p_five指向null</span></span><br><span class="line">    cout&lt;&lt;pfive&lt;&lt;endl; <span class="comment">// 输出此时p_five内存地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffd037a0ecc</span><br><span class="line">0x7ffd037a0ec0</span><br><span class="line">0x7ffd037a0ea8</span><br><span class="line">0x7ffd037a0ecc</span><br></pre></td></tr></table></figure>
<p>显然<code>pfive</code>没有修改成功（NULL）。整个过程如图所示：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220109145535610.png" alt="image-20220109145535610"></p>
</li>
</ul>
<ol>
<li>
<p>局部变量<code>pfive</code> 保存了<code>&amp;five</code>的值，即<code>five</code> 的地址；</p>
</li>
<li>
<p>随后<code>pfive</code>作为实参，其值（<code>five</code>地址）复制给形参<code>ptr</code>，编译器给形参<code>ptr</code>开辟了空间专门保存<code>five</code>地址；</p>
</li>
<li>
<p>随后<code>ptr=NULL</code>，但是影响不到<code>pfive</code>，二者是不同的变量拥有各自独立的空间。</p>
</li>
</ol>
<p>这验证了我们之前的结论：<strong>指针传值只是复制了实参值给形参，只不过这个实参值一般是某个变量的地址</strong>。</p>
<p><strong>那如果我们想在指针传值时修改形参就可以影响实参</strong>？</p>
<p>显然这就是引用的做法，对形参的任何修改直接等价操作实参本体。不过为了更好的讲解，我们先总结一下前面引用、指针传值的用法。</p>
<p>我们知道引用相当于变量的别名，使用引用时可以认为就是在使用变量本身。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a_ref = a;  <span class="comment">// 使用a_ref和使用a没什么区别</span></span><br></pre></td></tr></table></figure>
<p>又如之前的引用传值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// var = ...;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时形参是<code>int&amp; var</code> ，实参<code>tmp</code> ，实参值初始化形参<code>var</code>，就相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; var = tmp;</span><br></pre></td></tr></table></figure>
<p>也可以推广到函数其余参数传递情况：</p>
<ul>
<li>
<p>值传递</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// var = ...;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实参值初始化形参<code>var</code>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = tmp;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针传递</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>* var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// *var = ...;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(&amp;tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实参值初始化形参<code>var</code>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* var = &amp;tmp;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>好了，接受了上面的概念，我们再来说说<strong>怎么修改形参<code>ptr</code> 等价于修改实参<code>pfive</code></strong>？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 ptr保存了p_five的值（five的地址）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNull</span><span class="params">(<span class="keyword">int</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> five = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>* pfive = &amp;five; </span><br><span class="line">    <span class="built_in">setNull</span>(pfive); <span class="comment">// 将p_five指向null</span></span><br><span class="line">    cout&lt;&lt;p_five&lt;&lt;endl; <span class="comment">// 输出此时p_five内存地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，<strong>引用</strong>可以做到这点：将<code>ptr</code> 视为<code>pfive</code>的别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>*&amp; ptr = pfive;</span><br></pre></td></tr></table></figure>
<p>只需将第5行修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNull</span><span class="params">(<span class="keyword">int</span>*&amp; ptr)</span></span></span><br></pre></td></tr></table></figure>
<p>我们再尝试输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="comment">// 表示指针指向NULL</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-最佳实践">3.4.4 最佳实践</h4>
<h5 id="传引用快还是传指针快？">传引用快还是传指针快？</h5>
<p>虽然前面的分析，你对引用和指针传递有一定的了解、区分。</p>
<p><strong>但如果要你回答这么一个问题：是传引用快还是传指针快</strong>？</p>
<p>先上结论：一样快。</p>
<p><strong>因为引用就是特殊的指针，它底层实现和指针是一致的</strong>。</p>
<p>准备一段地址传参代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">func</span>(&amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>对应汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        # 保存main栈帧信息</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        subq    $16, %rsp </span><br><span class="line">        # 用0初始化x（对应地址为-4(%rbp)，并将x压栈</span><br><span class="line">        movl    $0, -4(%rbp)</span><br><span class="line">        # 将x地址保存到寄存器rax中，然后保存在rdi中</span><br><span class="line">        leaq    -4(%rbp), %rax </span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        # 调用函数func</span><br><span class="line">        call    _Z4funcPi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到<code>main</code>中最终将实参<code>&amp;x</code>（变量<code>x</code>的地址）保存在寄存器<code>rdi</code>中 。</p>
<p>接着我们开始重头戏<code>func</code>函数：<strong>指针通过保存变量地址到寄存器中，实现对变量所在内存区域进行修改</strong>，因此修改指针就是直接影响变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_Z4funcPi:</span><br><span class="line">        # 保存func栈帧相关信息</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        # 进行地址复制：将寄存器rdi的值（实参&amp;x）复制给形参y（对应地址-8(%rbp)），并将y压栈</span><br><span class="line">        movq    %rdi, -8(%rbp)</span><br><span class="line">        # 进行赋值运算：先用寄存器rax保存形参y的的值（x的地址），然后将2复制给x</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    $2, (%rax)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        # 返回main</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>现在我们将上述代码从地址传递改为引用传递：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">func</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看其汇编代码：不能说毫不相干，只能说和之前指针传值的汇编代码完全<strong>一模一样</strong>。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220109193419428.png" alt="image-20220109193419428"></p>
<p>也就是说，<strong>引用本质和指针一样，都是通过保存变量对应内存区域地址，来实现操作变量</strong>。对引用的任何操作，都会通过间接寻址直接操作变量本身，只不过相比指针隐藏了一些细节（编译器对使用引用会自动加上<code>*</code>，<u>2.2.1节</u>）。</p>
<h5 id="参数传递选择规则">参数传递选择规则</h5>
<blockquote>
<p>有引选引。</p>
</blockquote>
<p><strong>优先选用引用传递（引用：拜托了</strong>），除非：</p>
<ol>
<li><strong>希望参数不被修改</strong>，选择按值传递，否则转下一步；</li>
<li><u><strong>需要返回空指针、or返回局部变量内存、OR数组</strong></u>，选择按指针传递，否则转下一步。</li>
</ol>
<h5 id="数组怎么使用引用传参？">数组怎么使用引用传参？</h5>
<p>这是个很有意思的问题。</p>
<p>先看看数组的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;arr)[<span class="number">5</span>] = array;</span><br></pre></td></tr></table></figure>
<p>此时数组的类型可以认为是<code>int [5]</code> ，<code>&amp;arr</code> 便是声明一个<code>array</code>的别名。</p>
<p>因此，我们如此使用数组的引用作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_array</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="built_in">modify_array</span>(array);</span><br><span class="line">   cout&lt;&lt;array[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p>可以看到，确实被成功修改了。但<code>int (&amp;arr)[5]</code> 编译器<u>要检查数组实参和形参的大小</u>，扩展性太差！</p>
<p>为此，我们使用模板进行改进（其余不变）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_array</span><span class="params">(T (&amp;arr)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="built_in">modify_array</span>(array);</span><br><span class="line">   cout&lt;&lt;array[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完美！</p>
<h4 id="3-4-5-参数传递总结">3.4.5 参数传递总结</h4>
<blockquote>
<p>一些面试常考题对前面所学进行总结和验证。</p>
</blockquote>
<ul>
<li>
<p><strong>形参和实参的区别</strong>？</p>
<ul>
<li><strong>何时分配内存</strong>：<strong>形参变量只有在被调用时才分配内存单元</strong>，在调用结束时， 即刻释放所分配的内存单元（这一部分内容还会在<u>8.6函数返回值</u> 详细举例）；实参在调用前就已经分配了内存。</li>
<li><strong>参数类型</strong>： 实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们<strong>都必须具有确定的值</strong>；实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</li>
<li><strong>单向传递</strong>。只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。</li>
</ul>
</li>
<li>
<p><strong>值传递、指针传递、引用传递的区别</strong>？</p>
<p>请看下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">值传递</th>
<th style="text-align:center">引用传递</th>
<th style="text-align:center">指针（地址）传递</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>拷贝内容</strong></td>
<td style="text-align:center">实参的副本（数组例外，会退化为指针）</td>
<td style="text-align:center">给实参起个别名</td>
<td style="text-align:center">指针（4字节或8字节）</td>
</tr>
<tr>
<td style="text-align:center"><strong>效率</strong></td>
<td style="text-align:center">低，特别是拷贝结构体或类对象时</td>
<td style="text-align:center">高（推荐），起个别名即可</td>
<td style="text-align:center">高，拷贝指针即可</td>
</tr>
<tr>
<td style="text-align:center"><strong>是否修改</strong></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">不能修改为其它对象的引用</td>
</tr>
<tr>
<td style="text-align:center"><strong>初始化</strong></td>
<td style="text-align:center">不必要</td>
<td style="text-align:center">一定要</td>
<td style="text-align:center">不必要</td>
</tr>
<tr>
<td style="text-align:center"><strong>何时使用</strong></td>
<td style="text-align:center">参数不希望被修改时</td>
<td style="text-align:center"><strong>优先选用引用</strong>、传递<strong>结构或类对象</strong>、希望参数被修改</td>
<td style="text-align:center">返回多个值、需传递空指针（引传递用不允许空值）、返回<strong>局部变量内存（3.5中详述）</strong></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>指针传递、引用传递底层区别</strong>？</p>
<ul>
<li>
<p><strong>指针传递本质是值传递</strong>。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的<strong>实参值</strong>，从而形成了实参的一个副本（替身）。</p>
<p>所以形参指针（内容）变了（保存了其它变量地址），实参指针不会变。</p>
</li>
<li>
<p><strong>引出传递本质是间接寻址</strong>。引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的<strong>实参的地址</strong>。被调函数对形参（本体）的任何操作都被处理成<strong>间接寻址</strong>，通过栈中存放的地址访问主调函数中的实参变量。</p>
</li>
<li>
<p><strong>符号表不同</strong>。程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的<u>地址值</u>为<strong>指针变量的地址值</strong>，而引用在符号表上对应的<u>地址值</u>为<strong>引用对象的地址值</strong>（与实参名字不同，地址相同，编译器直接处理为操作引用对象）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-6-特殊参数">3.4.6 特殊参数</h4>
<p>在这一小节将来认识下比较特殊的两类参数。</p>
<ul>
<li>
<p><strong>命令行参数</strong></p>
<p>如果你运行过一些开源代码/库，经常会要求你输入指定参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ program arg1 arg2</span><br></pre></td></tr></table></figure>
<p>这为我们提供了一个<strong>可以向其他函数输入参数的方法</strong>，特别是<u>你无法修改源码或程序需要用户提供参数时</u>。当然，还可以通过配置文件实现，这里暂不表。</p>
<p>下面形式的main函数可以接受命令行参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>argc</code>：传递的参数量个数，至少为1，因为至少存在<code>argv[0]</code> 指向函数本身名称；</li>
<li><code>argv</code>： C风格二维数组，存储参数。例如，<code>argv[0][0]</code>指向第一个数组第一个字符，<code>argv[0]</code>是第一个数组第一个字符的地址。</li>
</ul>
<p>一个简单的程序，打印用户输入的姓名和年龄：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the count of paramters: &quot;</span>&lt;&lt; argc&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the name of program: &quot;</span>&lt;&lt; argv[<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;your name: &quot;</span>&lt;&lt; argv[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;your age: &quot;</span>&lt;&lt; argv[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220102165327119.png" alt="image-20220102165327119"></p>
<p>特别的，操作系统对如何处理特殊字符（<strong>如双引号和反斜杠</strong>）有特殊的规则。</p>
<ul>
<li>
<p><strong>双引号</strong>：以双引号传递的字符串被认为是同一字符串的一部分（即使它们之间存在空格）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out <span class="string">&quot;royhuang cqu&quot;</span>  <span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>斜杠</strong>：如果要包含文字双引号，则必须反斜杠双引号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out \<span class="string">&quot;royhuang\&quot;  25</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>省略号（可变参数</strong>）</p>
<p>到目前为止，在我们看到的所有函数中，函数将采用的参数数量必须事先知道。但是，在某些情况下，能够将<u>可变数量</u>的参数传递给函数会很有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">(argument_list, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如：我们要编写一个函数来计算一组整数的平均值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span> <span class="comment">// needed to use ellipsis</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过预定义宏va_list获取参数列表</span></span><br><span class="line">    va_list list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过宏va_start对va_list初始化</span></span><br><span class="line">    <span class="built_in">va_start</span>(list, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg&#123; <span class="number">0</span> &#125;; arg &lt; count; ++arg)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 通过宏va_arg获取具体参数</span></span><br><span class="line">         sum += <span class="built_in">va_arg</span>(list, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完后通过宏va_end清理va_list</span></span><br><span class="line">    <span class="built_in">va_end</span>(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum / count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3.5</span><br></pre></td></tr></table></figure>
<p>看起来这很棒。但是我们并不推荐使用省略号：</p>
<ol>
<li>
<p><strong>省略号很危险：无法判断传递的参数个数是正确</strong></p>
<p>假设你只传递了5个参数，而实际要求是6个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findAverage</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在作者的机器上，这产生了奇怪的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">699773</span><br></pre></td></tr></table></figure>
<p><code>va_arg(list, int)</code> 返回的前5个值是我们传入的值。它返回的第 6 个值（<strong>没有报错</strong>）是一个垃圾值堆栈。结果，我们得到了一个垃圾答案。</p>
</li>
<li>
<p><strong>省略号很危险：类型检查被暂停</strong></p>
<p>如果你尝试传递一个浮点数（<code>1.0</code>）作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findAverage</span>(<span class="number">6</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>结果一定让你大吃一惊（这是什么？这么大的数字？）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.78782e+008</span><br></pre></td></tr></table></figure>
<p>这是因为<code>va_arg(list, int)</code> 指定预期类型是<code>int</code> ，但是我们又传递double类型参数。这导致：</p>
<ul>
<li>va_arg 的第一次调用将只读取 double 的前 4 个字节（产生垃圾结果）；</li>
<li>va_arg 的第二次调用将读取 double 的后 4 个字节（产生另一个垃圾结果）；</li>
<li>因此，我们的总体结果是垃圾。</li>
</ul>
</li>
<li>
<p><strong>限定省略号：参数数量和类型</strong></p>
<p>幸运的是，我们可以人为的传递一个“解码器字符串”，它告诉程序如何解释参数（限定了数量和类型）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span> <span class="comment">// needed to use ellipsis</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(std::string decoder, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> sum&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	va_list list;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">va_start</span>(list, decoder);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> codetype&#123; decoder[count] &#125;;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (codetype)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">			<span class="built_in">va_end</span>(list);</span><br><span class="line">			<span class="keyword">return</span> sum / count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">			sum += <span class="built_in">va_arg</span>(list, <span class="keyword">int</span>);</span><br><span class="line">			++count;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">			sum += <span class="built_in">va_arg</span>(list, <span class="keyword">double</span>);</span><br><span class="line">			++count;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="string">&quot;iiiii&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="string">&quot;iiiiii&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">findAverage</span>(<span class="string">&quot;iiddi&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.5</span>, <span class="number">4.5</span>, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来很好，但是一般情况我们完全有其它合理的解决方案。比如：<strong>为什么不将<code>...</code> 换成一个数组</strong>？</p>
</li>
<li>
<p><strong>换成其它方案：动态数组</strong></p>
<p>一般情况，我们都要避免使用省略号，选择其它的方案。比如这里我们完全可以传递一个数组作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findAverage</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span>* nums)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="3-5-函数返回值">3.5 函数返回值</h3>
<p>在前面我们学习了<u>按值、引用和地址</u>向函数<strong>传递参数</strong>，如果作为函数<strong>返回值</strong>会有什么不同呢？</p>
<ul>
<li>按值返回的是<code>value</code>的副本？</li>
<li>按指针返回的是<code>value</code>的地址？局部变量在退出函数被销毁时，它的地址不是没有了吗？</li>
<li>按引用返回的是<code>value</code>的别名？局部变量在退出函数被销毁时，别名还有用吗？</li>
</ul>
<p>请看下文分解。</p>
<h4 id="3-5-1-按值返回">3.5.1 按值返回</h4>
<p>和按值传参一样，按值返回很安全，因为它<strong>只返回<code>value</code>的副本，不用担心返回之后<code>value</code>发生什么变化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value&#123; x * <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">doubleValue</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，它的缺点也和按值传参一致，返回大型结构或类时很慢。一般希望值不被修改或者返回局部变量时使用值传递。</p>
<p><strong>返回局部变量？函数调用结束时局部变量不就被销毁了，为什么还能返回</strong>？</p>
<p>在函数调用过程中是局部变量被压到栈中，当函数退出时，临时变量出栈，确实已经被销毁。</p>
<p><strong>但局部变量作为返回值时在函数调用时，有些特别的变化</strong>。</p>
<ul>
<li>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。</p>
</li>
<li>
<p>由此可见，函数调用结束后，<strong>返回值被临时存储到寄存器中</strong>，并没有放到堆或栈中，也就是说与内存没有关系了。</p>
<p>下图的汇编代码也表明了这一点：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112002905629.png" alt="image-20220112002905629"></p>
</li>
</ul>
<p>这也就是为啥：上述代码value虽然作为返回值但也是局部变量，函数调用结束时，依旧正确返回了其值。</p>
<p>现在让我们来特别关注一下按地址/引用返回局部变量的情况。</p>
<h4 id="3-5-2-按指针返回">3.5.2 按指针返回</h4>
<p>和按指针传递参数类似，按指针返回的只是<strong>将<code>value</code> 的地址复制一份返回</strong>，所以速度很快。</p>
<ul>
<li>
<p><strong>危险：返回局部变量地址</strong></p>
<p>局部变量在函数退出时就会被销毁，如果尝试返回局部变量的地址，这种行为非常的危险（地址对应的内存可能已被释放）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> d_value = i*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> &amp;d_value; <span class="comment">// 返回局部变量地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="built_in">doubleValue</span>(value);</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220103143317023.png" alt="image-20220103143317023"></p>
<p>编译器（VSCode）给出了警告，虽然输出值很幸运是正确的。但这是因为局部变量<code>d_value</code>对应栈空间还存在没有被重新分配使用，通过地址获取到了正确的值。</p>
<p>很显然这种做法很危险，你并不知道什么时候就返回的是一个垃圾值，因此不建议你去尝试。</p>
</li>
<li>
<p><strong>那按指针返回还有什么用途吗</strong>？</p>
<p><strong>按指针返回常用于将动态内存返回给调用者</strong>，因为动态分配的内存不会在函数退出时被销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">allocateArray</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[size]; <span class="comment">// 动态分配空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* array&#123; <span class="built_in">allocateArray</span>(<span class="number">25</span>) &#125;;</span><br><span class="line">    <span class="keyword">delete</span>[] array;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，分配空间（new[]）和删除空间（delete[]）在代码不同的函数中，使得谁负责删除资源和是否需要删除资源变得有点难以理解。</p>
<p>这里更好的做法是使用智能指针，第二章有相关介绍。</p>
<p><strong>另外一个用途就是返回按地址传递的参数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span>* p_i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     *p_i = (*p_i)*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> p_i; <span class="comment">// 返回指针参数p_i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="built_in">doubleValue</span>(&amp;value);</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>不说说返回地址其它用途吗</strong>？</p>
<p>既然提到返回地址很快，那用来返回结构体、类不应该很好吗？然而并不是。道理同参数传递中尽量建议使用引用一样：</p>
<ol>
<li>引用更安全。引用一定会被初始化，不能为空。</li>
<li>引用效率更好。比如它不用管理指针析构释放之类的问题。</li>
</ol>
</li>
</ul>
<h4 id="3-5-3-按引用返回">3.5.3 按引用返回</h4>
<p>与按指针返回类似，按引用返回的值不能是局部变量。</p>
<ul>
<li>
<p><strong>危险：不要返回局部引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> d_value = i*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> d_value;  <span class="comment">// 返回局部引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref = <span class="built_in">doubleValue</span>(value);</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>道理同上按指针返回，除非你想哪天收到一个对垃圾的引用。</p>
</li>
<li>
<p><strong>什么时候按引用返回</strong></p>
<p>除了上述说的按值返回、按指针返回的情况，其它时候一般都建议按引用返回。</p>
<p><strong>比如返回大型数据结构、类等，以及返回按引用传递参数时</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     i = i*<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> i;    <span class="comment">// 返回按引用传递的参数i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ref = <span class="built_in">doubleValue</span>(value);</span><br><span class="line">    cout&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-5-4-小结">3.5.4 小结</h4>
<p><strong>编码时选择何种方式返回参数</strong>？</p>
<p>和选择何种方式传递参数很像：</p>
<ol>
<li>不想修改<code>value</code>就是想返回<code>value</code>一个副本，or返回局部变量（见下节述）用值传递，否则转下一步；</li>
<li>需要动态内存分配时、返回按地址传递的参数，选择地址传递，否则转下一步；</li>
<li>其它情况，一般选用引用传递（返大型结构体、类、按引用传递的参数）。</li>
</ol>
<h4 id="3-5-5-返回多个值">3.5.5 返回多个值</h4>
<p>在<u>3.4.3</u> 介绍了使用地址传递参数，达到类似返回多个参数的效果。但是这种做法比较别扭，也不够优雅。C++有两种比较好的方式：</p>
<ol>
<li>
<p><strong>使用结构体</strong></p>
<p>将要返回的多个参数定义为一个结构体，最后直接返回结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_x;</span><br><span class="line">	<span class="keyword">double</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">S <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S s;</span><br><span class="line">	s.m_x++;</span><br><span class="line">	s.m_y++;</span><br><span class="line">	<span class="keyword">return</span> s;  <span class="comment">// 值传递，复制一个s的副本返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S s = <span class="built_in">add</span>();</span><br><span class="line">	cout &lt;&lt; s.m_x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.m_y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比返回数组，结构体允许定义更多类型的值，显然更灵活。元组 <code>std::tuple</code> 也可以定义不同类型元素序列。</p>
</li>
<li>
<p><strong>使用元组</strong></p>
<p>见下例，使用元组返回多个不同类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; <span class="title">returnTuple</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">5</span>, <span class="number">6.7</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tuple s&#123; <span class="built_in">returnTuple</span>() &#125;; </span><br><span class="line">	cout &lt;&lt; get&lt;<span class="number">0</span>&gt;(s) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(s) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-6-内联函数">3.6 内联函数</h3>
<p>函数给我们提供了非常多有用的功能：</p>
<ul>
<li>代码可以重复使用；</li>
<li>提供类型检查，确保参数类型匹配（类似函数的宏不会）；</li>
<li>便于阅读、调试；</li>
<li>…</li>
</ul>
<h4 id="3-6-1-那函数有什么缺点吗？">3.6.1 那函数有什么缺点吗？</h4>
<p>函数的一个主要缺点是每次<strong>调用函数</strong>时，都会发生一定量的性能开销（中断等），比如：</p>
<ol>
<li>CPU 必须存储它正在执行的当前指令的地址（因此它知道稍后返回到哪里）以及其他寄存器；</li>
<li>必须创建所有函数参数并赋值，并且程序必须跳转到新位置；</li>
<li>…</li>
</ol>
<p>当然，<strong>对于大型复杂的函数，函数调用时间相比函数运行时间微不足道。但是对于比较轻巧的函数，若是频繁调用，函数调用的时间便很可观了</strong>。</p>
<p>此时，我们希望这些轻巧又被经常调用的函数，最好不好进行这些复杂调用、返回操作。</p>
<p>如何做到这一点？类似于预编译头文件的替换，直接把<strong>函数体嵌入到每一个调用了它的地方，重复地嵌入</strong>。</p>
<p>请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? y : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">6</span>) ;</span><br><span class="line">    <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>min(int,int)</code> 被声明为内联函数。在编译时，相当直接在相应调用位置替换为实际<code>min(int,int)</code>函数体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span> &gt; <span class="number">6</span> ? <span class="number">6</span> : <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> &gt; <span class="number">2</span> ? <span class="number">2</span> : <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小问题：内联函数这么棒，那把所有的函数写成内联函数?</p>
</blockquote>
<p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。</p>
<ul>
<li><strong>只适合比较简单的函数</strong>。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；</li>
<li><strong>占用内存空间多</strong>。另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间。</li>
</ul>
<p>典型的空间换时间策略。</p>
<h4 id="3-6-2-内联函数什么时候被替换？">3.6.2 内联函数什么时候被替换？</h4>
<p>在前面我们知道，宏会由预处理器对宏进行替代（预编译阶段）。而内联函数也会通过编译器来实现展开替换（编译阶段）。</p>
<blockquote>
<p>为了更好地验证所学，我们通过反汇编来对比加上<code>inline</code>前后代码的不同之处对比。</p>
</blockquote>
<p>准备一个更简单的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">add</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成可执行文件后进行反汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -save-temps -fverbose-asm -g  test.cpp -o test.out</span><br><span class="line">objdump -S --disassemble test.out</span><br></pre></td></tr></table></figure>
<p>关键性代码截图如下：</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220103183107580.png" alt="image-20220103183107580" style="zoom:80%;" />
<p>可以看到<code>main</code> <strong>函数体内</strong>被直接插入了<code>add</code>函数的代码（绿色框）。</p>
<p>但是如果<code>add</code>函数是非内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止编译器自己优化，强制声明为非内联函数</span></span><br><span class="line"><span class="keyword">int</span> __attribute__ ((noinline)) <span class="built_in">add</span>(<span class="keyword">int</span> y)</span><br></pre></td></tr></table></figure>
<p>反汇编结果如图所示，<code>add</code>函数代码并没有插入到<code>main</code>函数体内。</p>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220103183933062.png" alt="image-20220103183933062" style="zoom:80%;" />
<h4 id="3-6-3-内联函数和宏对比">3.6.3 内联函数和宏对比</h4>
<p>一个常考的面试题，加深下印象。</p>
<ol>
<li><strong>替换时机</strong>。宏在预编译时被替换，内联函数是在运行时（至少不是预编译时）；</li>
<li><strong>调试</strong>。内联函数在运行时可调试，而宏定义不可以;</li>
<li><strong>安全</strong>。编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；</li>
<li><strong>访问</strong>。内联函数可以访问类的成员变量，宏定义则不能。</li>
</ol>
<h3 id="3-7-函数指针">3.7 函数指针</h3>
<h4 id="3-7-1-函数和指针">3.7.1 函数和指针</h4>
<p>在前一节，通过反汇编，你也看到了（在<code>main</code>函数中）调用（<code>add</code>）函数是通过一个地址，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callq 40052d&lt;_Z3addi&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>40052d</code> 便是函数<code>add</code> 的地址。让我们尝试打印一下函数地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 如果你的编译器打印出来的地址是1</span></span><br><span class="line">   <span class="comment">// 需要转换为空指针，强制编译器打印出地址：(void*)func</span></span><br><span class="line">   cout&lt;&lt;func&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x4007ad</span><br></pre></td></tr></table></figure>
<p>可以看到，就像指针一样，<code>func</code> 保存的也是一个地址，只不过它保存的是函数地址。<strong>有函数地址就可以调用函数，此时可将函数压入栈</strong>（3.8节详述）。</p>
<p>像指针一样？那么可以像下面这样，使用<code>int*</code>指针保存函数指针吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p_func = func;</span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>很不幸报错了：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220104223733205.png" alt="image-20220104223733205"></p>
<p>主要原因是因为：虽然<code>func</code> 和<code>p_func</code>都是指针，但它们类型是不一样的。函数<code>func</code> 类型是<code>int(*)()</code> ,而我们给出的指针<code>p_func</code>类型是<code>int*</code> ，无法赋值。就像你不能将<code>string*</code> 类型指针赋值给<code>int*</code> 类型指针。</p>
<p>所以，我们至少还得让他们参数类型一致：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)() = func;</span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>依旧报错了：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220104224700403.png" alt="image-20220104224700403"></p>
<p>这是因为<u>函数指针<code>p_func</code>的类型参数和函数<code>func</code>不一致</u>，编译器类型检查时出错。</p>
<blockquote>
<p>题外话：为什么是在运行时报错，而不在编译代码时报错？</p>
<p>因为函数指针是在运行时才会进行解析。</p>
</blockquote>
<p>我们还应该指定其参数类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = func;</span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>一切到此就好起来了。<code>p_func</code>此时获得了函数的地址，就可以像<code>func</code>一样使用了。</p>
<p>特别的下面这种方式也是正确的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = &amp;func; <span class="comment">// 函数名多了个&amp;，func和&amp;func打印出来其实是一样的，都是函数地址</span></span><br><span class="line"><span class="built_in">p_func</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="3-7-2-为什么需要函数指针：回调函数">3.7.2 为什么需要函数指针：回调函数</h4>
<p>虽然，前面我们了解了怎么定义和使用函数指针。但不禁还是有疑惑：<strong>使用函数指针<code>p_func</code> 调用函数<code>func</code>不是多此一举？直接使用<code>func</code>不就好了</strong>？</p>
<p>想象这么一种情况：</p>
<ul>
<li>你有一个函数假定为<code>funcA</code> , 但你的功能需要外部自定义一些规则，这些规则用户自定义的；</li>
<li>所以你需要一个“参数”来保存这些特定的规则，而这个规则显然是一个逻辑集合——换句话，它应该是个函数。</li>
</ul>
<p>那么这个“参数”是不是应该是函数类型？某个函数如果作为参数传递给另一个函数，就是<strong>回调函数</strong>。</p>
<p>我们举一个更具体的例子：</p>
<ul>
<li>我们定义一个排序函数，将数字进行排序：但排序的规则由用户自定义，它可能是从大到小排列，也可能是从小到大或者其它——总之它取决于用户怎么定义“规则”。</li>
</ul>
<p>我们给定一个排序函数如下，它有一个参数<code>bool (*comparisonFcn)(int, int)</code>用来定义排序规则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[idx_i];</span><br><span class="line">    arr[idx_i] = arr[idx_j];</span><br><span class="line">    arr[idx_j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span> (*compare)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">        <span class="comment">// * j=0,每次都是从头开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; len-i<span class="number">-1</span>; j++ ) <span class="comment">// 内轮=余下乱序数-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(arr[j],arr[j+<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">swap</span>(arr,j,j+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(array)/<span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">bubbleSort</span>(array,len,myCompare);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len  ;i++)</span><br><span class="line">       cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>显然这种方式，优雅且灵活，<u>除了定义的函数指针实在过于丑陋</u>。当然在上述<code>myCompare</code> 函数中，你甚至可以定义一些奇怪的规则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ((a % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; !(b % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以尝试输出试一试。</p>
<h4 id="3-7-3-更优雅地使用函数指针">3.7.3 更优雅地使用函数指针</h4>
<p>前面我们提到，函数指针的声明实在过于丑陋：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*compare)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*)(<span class="keyword">int</span>,<span class="keyword">int</span>) compare;</span><br></pre></td></tr></table></figure>
<p>好消息你现在有两种方式让它看起来顺眼很多：</p>
<h5 id="1-类型别名">1. 类型别名</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">using</span>  bool_compare = <span class="built_in"><span class="keyword">bool</span></span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数中使用：就行使用普通的类型一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, bool_compare compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-function">2. function</h5>
<p>std::function是标准库 <code>&lt;functional&gt;</code> 头文件的一部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们将之前的排序函数，重新定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, std::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;)</span></span></span><br></pre></td></tr></table></figure>
<p>在主函数中，如此调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其余函数代码同前，略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(array)/<span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line">   std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; compare = myCompare;</span><br><span class="line">   <span class="built_in">bubbleSort</span>(array,len,compare);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len  ;i++)</span><br><span class="line">       cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h5 id="3-function是什么？">3. function是什么？</h5>
<p>有一个很有意思的事情，函数定义必须要和主函数中传递的参数类型一致（都是<code>std::function</code>），不能定义为指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>) compare)</span></span></span><br></pre></td></tr></table></figure>
<p>如果你这个时候这样调用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main中</span></span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; compare = myCompare;</span><br><span class="line"><span class="built_in">bubbleSort</span>(array,len,compare);</span><br></pre></td></tr></table></figure>
<p>会报错：<code>error: cannot convert ‘std::function&lt;bool(int, int)&gt;’ to ‘bool (*)(int, int)’</code>。</p>
<p>因为<code>std::function</code>本质是一种<strong>类模板，不是函数</strong>，是对通用、多态的函数封装。</p>
<ul>
<li>通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个std::function对象。让我们不再纠结那么多的可调用实体，一切变的简单粗暴。</li>
<li>换句话说，<code>std::function</code><strong>就是函数的容器，它自己是个类对象</strong>。当我们有了函数的容器之后便能够<strong>更加方便的将函数、函数指针作为对象进行处理</strong>。</li>
</ul>
<p>我们来看看它的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span><span class="built_in">R</span>(Args...)&gt;</span><br></pre></td></tr></table></figure>
<p>类为function，R是返回值类型，Args是函数的参数类型。再回想我们之前的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; compare = myCompare;</span><br></pre></td></tr></table></figure>
<p>很显然，<strong>此时<code>compare</code> 本质是一个function类对象，只不过重载了其函数调用操作符()，所以使用的时候可以直接像函数一样调用</strong>。</p>
<p>特别的，<strong>function类还重载了赋值操作符=，这样可以将可调用的函数实体赋值给它</strong>。其函数调用操作符重载函数里间接的调用赋值时传进来的调用实体。</p>
<h5 id="4-使用auto">4. 使用auto</h5>
<p>使用auto关键字自动推断类型，可更简便地使用函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compare = myCompare;</span><br></pre></td></tr></table></figure>
<p>但是这个时候<code>compare</code>隐藏了类型具体定义，如果希望读者更了解这段代码意义，使用<code>typedef</code> 应该是个更好的做法。</p>
<h4 id="3-7-4-CPU眼中的函数指针：变量">3.7.4  CPU眼中的函数指针：变量</h4>
<p>去繁归真，我们来看看CPU眼中的函数指针是什么？</p>
<p>答案可能会让你惊奇：它在CPU眼中不过是一个过度包装的变量而已，就像指针一样也只是变量。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/zvideo/1433792635044048898">CPU眼里的“函数指针”：过度包装的“变量” - 阿布的视频 - 知乎 </a></p>
<h4 id="3-7-5-小结">3.7.5 小结</h4>
<ul>
<li>
<p><strong>什么是函数指针</strong>？</p>
<p>函数指针是指向特殊的数据类型（即函数）的指针变量。</p>
<ul>
<li>函数的名字也可视为是函数的指针；</li>
<li>使用重载后的<code>()</code> 即<code>函数名()</code> 便是调用一个函数。</li>
</ul>
<p>它在CPU眼中不过是过度包装的“变量”。</p>
</li>
<li>
<p><strong>函数指针的声明&amp;赋值方式</strong>？</p>
<p>以下为例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = func </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>) = &amp;func</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>函数指针的用途</strong>？</p>
<p>函数指针还允许将函数作为参数传递给其他函数，即回调函数。</p>
</li>
</ul>
<h3 id="3-8-栈和堆🌟">3.8 栈和堆🌟</h3>
<p>在这一节中，我们来了解程序运行时，函数调用更底层的过程。不过在这之前，我们先了解下内存布局。</p>
<h4 id="3-8-1-内存布局">3.8.1 内存布局</h4>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span>位系统4GB（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>）。</p>
</blockquote>
<p>下图展示了一个虚拟进程（程序）内存空间<u>运行时</u>分布布局，注意到此时还<u>多了堆&amp;栈用来给程序运行时进行空间分配</u>。</p>
<ul>
<li>
<p><strong>一个程序（比如hello.out）本质是由数据段、代码段、.bss段（图中和数据段合并了）三个组成的。</strong></p>
</li>
<li>
<p>另外，高地址的1GB（Windows默认2GB）空间分配给内核，也称为<strong>内核空间</strong>；剩下的3GB分给用户，也称<strong>用户空间</strong>（程序使用的）。</p>
</li>
</ul>
<img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5e8d39d19a216fd03392d36081e70b7e.jpg" alt="你确定你理解内存分配吗？" style="zoom:80%;" />
<p>作为程序员，我们更关注的是用户空间中的内容，也就是：</p>
<ul>
<li>
<p><strong>栈（Stack</strong>）：存储代码中调用函数、定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；</p>
<ul>
<li>
<p><strong>特点</strong>：存放的数据从<strong>栈顶（低地址</strong>）压入，也是从<strong>栈顶（低地址</strong>）弹出，所以有人说栈是<strong>向下生长</strong>的。函数退出时，所有数据会自动释放内存（出栈）。</p>
<img src="https://pic1.zhimg.com/v2-4a47248b485bc764430e802f87ee950c_b.webp" alt="img" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p><strong>文件映射区域 ：</strong> 栈和堆中间那个空白区域。动态库、共享内存等映射物理空间的内存，一般是 <code>mmap</code> 函数所分配的虚拟地址空间。</p>
</li>
<li>
<p><strong>堆（Heap</strong>）：存储那些生存期<u>与函数调用无关的数据</u>，如动态分配的内存。堆（动态）分配的接口通常有malloc()、calloc()、realloc()、new等。</p>
<ul>
<li><strong>特点</strong>：相对于栈，堆是<strong>向上生长</strong>的；堆空间需要主动释放，否则会依然存在。</li>
</ul>
</li>
<li>
<p><strong>.bss段</strong>：全称Block Started by Symbol，也就是未被初始化的<strong>全局</strong>变量、<strong>静态</strong>变量的内容的一块内存区域。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">int</span> a;  <span class="comment">// 保存.bss段</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// 全局变量，保存在.bss段</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>数据段（.data</strong>）：保存<strong>全局</strong>变量、<strong>常量</strong>、静态变量的内容的一块内存区域，区别.bss段在于变量已经被初始化。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 保存在.data段中静态区</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;  <span class="comment">// 保存在.data段中全局区</span></span><br><span class="line"><span class="keyword">char</span>* str =  <span class="string">&quot;royhuang&quot;</span>; <span class="comment">// &quot;royhuang&quot;是文字常量，保存在常量区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;   <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>代码段（.text &amp; .init</strong>）： <code>.text</code> 用于存放整个程序中的代码； <code>.init</code> 用于存放系统中用来初始化启动你的程序的一段代码 。</p>
</li>
</ul>
<p><strong>一个程序本质其实都是由.bss段、数据段、代码段三个组成的。</strong></p>
<h4 id="3-8-2-函数调用过程">3.8.2 函数调用过程</h4>
<p>在这一小节我们来深入探讨下函数调用时的原理和过程。</p>
<h5 id="栈帧">栈帧</h5>
<p>前面我们说到，栈是位于进程的高地址位置，且栈顶是向下增长的。在<u>函数调用</u>时，<strong>栈会专门使用一个独立的栈帧保存函数调用需要的所有信息</strong>。这对后面理解函数执行过程很关键。</p>
<p>一个典型的栈帧如下：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/stack1.png" alt="img"></p>
<ul>
<li><strong>栈帧保存的内容</strong>：每一次函数调用需要的函数返回地址、参数、临时变量、保存的上下文等；</li>
<li><strong><code>esp</code>和<code>ebp</code></strong> ：非常重要的两个寄存器，记录了当前<strong>栈帧</strong>的<strong>栈顶位置和栈底位置</strong>（对于<code>X86-64</code>平台上来说，对应的寄存器则为<code>rsp</code>及<code>rbp</code>） 。
<ul>
<li>可以看到在上图压栈（push）会使得esp向下移动（地址变小）。</li>
</ul>
</li>
</ul>
<h5 id="汇编分析">汇编分析</h5>
<p>我们准备的验证代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> sp1, <span class="keyword">int</span> sp2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = sp1 + sp2;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res =  <span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编的代码及分析如下。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220109134057556.png" alt="image-20220109134057556"></p>
<ul>
<li>
<p>main函数汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp   # 寄存器rbp保存上一个栈帧栈底位置 </span><br><span class="line">        movq    %rsp, %rbp # 寄存器rsp指向栈顶位置，用rsp内容初始化寄存器rbq</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movl    $2, %esi # 立即数寻址，将foo第二个参数存入寄存器esi中</span><br><span class="line">        movl    $1, %edi # 将foo的第一个参数存入寄存器edi中</span><br><span class="line">        call    _Z3fooii # 调用foo，转到分析foo函数汇编代码，此时call还将下一条指令当做返回地址压入到栈中</span><br><span class="line">        movl    %eax, -4(%rbp) # 返回函数结果给res，它的地址是-4(%rbp)</span><br><span class="line">        movl    $0, %eax # eax被置为0，主函数退出</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>foo函数汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_Z3fooii:</span><br><span class="line">        pushq   %rbp  # 保存main的栈底地址rbp，用于返回</span><br><span class="line">        movq    %rsp, %rbp # 重置foo函数的栈帧</span><br><span class="line">        movl    %edi, -20(%rbp) # 参数1入栈</span><br><span class="line">        movl    %esi, -24(%rbp) # 参数2入栈</span><br><span class="line">        movl    -20(%rbp), %edx # 参数1存入edx</span><br><span class="line">        movl    -24(%rbp), %eax # 参数2存入eax</span><br><span class="line">        addl    %edx, %eax      # 加法运算，结果保存在eax中</span><br><span class="line">        movl    %eax, -4(%rbp)  # 将运算结果赋值给result,它的位置为rbp-4 </span><br><span class="line">        movl    -4(%rbp), %eax  # 将result赋值给eax，eax为函数返回值</span><br><span class="line">        popq    %rbp # 跳转到main函数（栈底），然后还需要跳到返回地址</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>栈压入顺序</strong>：当前栈帧状态信息（如rbp）—&gt; 当前函数的参数（逆序）—&gt;当前函数的局部变量等—&gt;…—&gt;退出。</p>
</blockquote>
<ul>
<li><strong>在调用函数（main）函数中</strong>
<ol>
<li><strong>保存上一个栈帧的rbp，重置main栈帧的rbp</strong>；</li>
<li>按照与被调函数foo的<strong>形参顺序相反的顺序</strong>压入栈中（在本例是直接存入寄存器中，因为直接传入常量foo(1,2)）；</li>
<li><strong>call指令调用</strong>： 调用者函数（main）使用call指令调用被调函数（foo），为foo函数分配栈帧空间，<strong>并把call指令的下一条指令的地址当成返回地址</strong>压入栈中（这个压栈操作是隐含的）</li>
</ol>
</li>
<li><strong>在被调用函数（foo）函数中</strong>
<ol>
<li>保存main栈帧的rbp，重置foo栈帧的rbp；</li>
<li>被调参数sp1、sp2压入栈中；</li>
<li>执行foo函数体中代码，返回值res入栈，<strong>然后保存在寄存器eax中</strong> ；</li>
<li>执行完毕，栈帧所有数据出栈；</li>
<li><code> popq %rbp 和 ret</code> 跳转main中call指令的下一条指令地址继续执行。</li>
</ol>
</li>
<li><strong>回到调用函数（main）函数中</strong>
<ol>
<li>返回值res（寄存器eax中内容）压入栈；</li>
<li>继续main函数中后续代码执行；</li>
<li>main函数退出。</li>
</ol>
</li>
</ul>
<h4 id="3-8-3-malloc-free-原理">3.8.3 malloc/free 原理</h4>
<h5 id="从静态分配说起">从静态分配说起</h5>
<p>我们之前接触数据通常保存在：</p>
<ol>
<li><strong>栈</strong>，比如函数内部局部变量；</li>
<li><strong>数据段</strong>，静态区、全局区、常量区；</li>
<li><strong>.bss段</strong>，未初始化的数据。</li>
</ol>
<p>上面的数据有两个共同点：</p>
<ul>
<li><strong>变量/数组的大小必须在编译时知道</strong>。</li>
<li><strong>内存分配和释放自动发生（当变量被实例化/销毁时</strong>）。</li>
</ul>
<p>大多数时候，这很好。那什么时候在<strong>堆</strong>上分配内存？</p>
<p>很多时候，我们需要<u>在堆上动态申请/释放内存</u>。</p>
<ol>
<li><strong>不知道分配对象的大小</strong>。比如我们想创建声明一个数组，但是事先并不知道数组的大小（稍后才能知道）。这个时候<u>无法使用静态数组分配</u>，因为它必须指定数组的大小；</li>
<li><strong>分配的对象太大</strong>。栈等空间不够。</li>
</ol>
<p>在C中，我们常常使用malloc/free在堆上分配和释放内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配：大小为4的int数组</span></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> ;</span><br><span class="line"><span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure>
<p><strong>malloc和free函数底层是如何去实现的，如何在堆上分配内存的</strong>？</p>
<h5 id="从堆块说起">从堆块说起</h5>
<blockquote>
<p>主要参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57863097">malloc 的实现原理 内存池 mmap sbrk 链表</a></p>
</blockquote>
<p><strong>什么是堆</strong>？</p>
<p>C++使用动态内存分配器（下简称分配器）进行动态内存分配，它维护一个<u>进程的虚拟内存区域</u>，也就是堆。</p>
<p><strong>分配器眼里的堆是什么？如何进行管理</strong>？</p>
<p>分配器将堆视为<strong>一组不同大小的块（block）<strong>的集合来维护。每个块就是</strong>一个连续的虚拟内存片（chunk）</strong>,要么是已分配的，要么是空闲的。</p>
<p>chunk结构图：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-ce8d3eeabf100d45.png" alt="img"></p>
<ul>
<li>正在使用的chunk标识意义
<ul>
<li><code>prev_size</code>： 表示前一个 chunk 的 size,程序可以使用这个值来找到前一个 chunk 的开始地址（<code>P=0</code>才有效）；</li>
<li><code>size</code>： 表示当前chunk的size大小；</li>
<li><code>A</code>：为1表示属于主分配区（已分配），否则属于非主分配区（未分配）；</li>
<li><code>M</code>：为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的；</li>
<li><code>P</code>：为1表示前一个chunk在使用中，为0表示空闲。</li>
</ul>
</li>
<li>空闲chunk标识意义
<ul>
<li><code>fd、bk</code> ：分别指向前、后的空闲chunk，通过这种方式将将大小相近的chunk连成一个双向链表；</li>
</ul>
</li>
</ul>
<p>具体来说，<strong>分配器通过bins+空闲链表（非常类似哈希表），对堆块进行管理</strong>。</p>
<p>一个典型的堆整体结构：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-9c09c94096413f83.png" alt="img"></p>
<p>可以看到，内存分成了大小不同的chunk，然后通过<strong>bins</strong>来组织起来；相似大小的chunk用<strong>双向链表</strong>链接起来，一个链表被称为<strong>bin</strong>。</p>
<ul>
<li><strong>unsorted bin</strong>：即bin[1]（bin[0]没有被使用），用于<u>维护free释放的chunk</u>；</li>
<li><strong>small_bins</strong>：即bins[2,63)，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为<code>index*8</code>；</li>
<li><strong>large_bins</strong>：即bins[64,127)，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大；</li>
</ul>
<p>在堆中，还有一个很特殊的top chunk。</p>
<ul>
<li><strong>产生时机</strong>：程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk，所以它不属于任何一个 bin；</li>
<li><strong>作用</strong>：在于当所有的 bin 都无法满足用户请求的大小时，就使用top chunk进行分配，并将剩下的部分作为新的 top chunk。堆顶指针brk位于top chunk的顶部，移动brk指针，即可扩充top chunk的大小。</li>
</ul>
<p>现在我们再来探讨malloc分配的过程。</p>
<h5 id="malloc原理">malloc原理</h5>
<p>glibc在内存池中查找合适的chunk时，采用了<strong>最佳适应</strong>的伙伴算法。</p>
<p><strong>第一次分配内存时会进行堆初始化</strong>：</p>
<ol>
<li>一开始时，brk和start_brk是相等的，这时实际heap大小为0；</li>
<li>如果第一次用户请求的内存大小&lt; <strong>mmap分配阈值</strong>，则（<strong>通过移动brk指针扩展堆大小</strong>）malloc会申请(chunk_size+128kb) align 4kb大小的空间作为初始的heap。</li>
</ol>
<p><strong>往后会按照顺序：bins查找分配–&gt;brk扩展堆分配—&gt;mmap分配</strong>：</p>
<ol>
<li>
<p><strong>如果分配内存&lt;max_fast=默认64B</strong>，在fast bins 中查找相应的空闲块；</p>
</li>
<li>
<p><strong>如果分配内存&lt;512字节</strong>，则通过内存大小定位到smallbins对应的index上：</p>
<ul>
<li>如果smallbins[index]为空，进入步骤3；</li>
<li>如果smallbins[index]非空，直接返回第一个chunk。</li>
</ul>
</li>
<li>
<p><strong>如果分配内存&gt;512字节</strong>，定位到largebins对应的index上：</p>
<ul>
<li>如果largebins[index]为空，进入步骤3；</li>
<li>如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size=12.5K，则使用chunk B，<u>剩下的0.5k释放并放入unsorted_list中</u>。</li>
</ul>
</li>
<li>
<p><strong>遍历unsorted_list</strong>：</p>
<ul>
<li>查找合适size的chunk，如果找到则返回；</li>
<li>否则，将这些chunk都归类放到smallbins和largebins里面。</li>
</ul>
</li>
<li>
<p><strong>在bin更大的链表寻找</strong>：从index++更大的链表继续寻找：</p>
<ul>
<li>查找合适size的chunk，如果找到则返回，<u>同时还会将chunk拆分</u>，并将<u>剩余的加入到unsorted_list中</u>。</li>
<li>找不到则通过top chunk。</li>
</ul>
</li>
<li>
<p><strong>通过top chunk分配</strong>：默认top chunk分配的最大大小为128K（也是mmap分配的阈值）：</p>
<ul>
<li>
<p>top chunk大小&gt;分配的内存，则返回合适大小chunk，剩余的作为新的 top chunk；</p>
</li>
<li>
<p>top chunk大小&lt;分配的内存&lt;128K，<u>移动brk指针</u>扩展top chunk大小，满足分配；</p>
</li>
<li>
<p>分配的内存&gt;128K，通过mmap分配内存。</p>
</li>
</ul>
</li>
<li>
<p><strong>通过mmap分配</strong>。在进程的虚拟地址空间中（堆和栈中间的文件映射区域）找一块空闲的虚拟内存返回地址。</p>
</li>
</ol>
<p>总结以上，内存分配（malloc）主要由两种系统调用完成：brk和mmap（不考虑共享内存）。</p>
<ul>
<li><strong>brk</strong>：分配内存 &lt; DEFAULT_MMAP_THRESHOLD，走<code>__brk</code>，将数据段(.data)的最高地址指针<code>_edata</code>，往高地址推；</li>
<li><strong>mmap</strong>：分配内存 &gt; DEFAULT_MMAP_THRESHOLD，走<code>__mmap</code>，直接调用mmap系统调用。在进程的虚拟地址空间中（堆和栈中间的文件映射区域）找一块空闲的虚拟内存。</li>
</ul>
<p>其中，DEFAULT_MMAP_THRESHOLD是mmap分配阈值，默认为128K。</p>
<p>值得注意的是，这两种方式分配的<strong>都是虚拟内存</strong>，没有分配物理内存。只有实际调用发生缺页中断时，才会建立虚拟内存和物理内存之间的映射关系。</p>
<blockquote>
<p>不过这里有个小问题，<strong>既然<code>brk、mmap</code>提供了内存分配的功能，直接使用<code>brk、mmap</code>进行内存管理不是更简单吗，为什么需要glibc呢</strong>？</p>
</blockquote>
<p>因为系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，<strong>如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中</strong>。</p>
<p>因此，为了减少系统调用带来的性能损耗，glibc采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。</p>
<h5 id="free原理">free原理</h5>
<p>前面我们说到，C++将对视为堆视为一个个chunk（block）的集合，每个chunk的结构如下：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-ce8d3eeabf100d45.png" alt="img"></p>
<p>malloc分配好内存，返回的是<strong>User data的起始地址</strong>，<strong>header</strong>则保存了当前chunk的一些信息。</p>
<p>但free并非真的直接将相应内存区域返回操作系统：</p>
<ul>
<li>
<p><strong>如果<code>free</code> 释放<code>mmap</code> 分配内存</strong>，<code>free</code>可以很顺利就释放掉其相关的虚拟和物理内存，返回操作系统；</p>
</li>
<li>
<p><strong>如果<code>free</code> 释放 <code>brk</code>分配的内存</strong>，<strong><code>free</code>只是标记chunk可被重新分配并加入空闲链表（A=0），但没有真的删除任何数据</strong>！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a  = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 0，数据被清除，但没被操作系统回收</span></span><br><span class="line">*a=<span class="number">2</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 2，依据可以被使用，虽然这很危险</span></span><br></pre></td></tr></table></figure>
<p>具体加入到空闲链表何处，也分三种情况考虑：</p>
<ul>
<li>如果该chunk<u>和top chunk相邻，则将其和top chunk合并</u>；
<ul>
<li>特别的，如果top chunk&gt;128K，会执行内存紧缩（trim）操作移动brk指针。</li>
</ul>
</li>
<li>如果free的chunk的大小在0x20~0x80之间（fastbin的范围），<u>那么该chunk直接放到fast bin上</u>；</li>
<li>如果free的chunk的大小大于0x80（大于fast bin的范围），此时不会直接放到small bin或者large bin上面，<u>而是放到unsorted bin上面</u>；</li>
</ul>
</li>
<li>
<p><strong>最佳实践：删除一个指针时，请将指针设置为 nullptr</strong>。</p>
<p>否则的话，使用一个指向的内存已经被释放的一种指针，是使用<strong>悬空指针</strong>。</p>
<p>（区分野指针是指使用时还没被初始化）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 危，此时a是悬空指针，已经被free(a)</span></span><br><span class="line">a = <span class="literal">nullptr</span>;    <span class="comment">// 最佳实践：将已经释放的指针置空</span></span><br><span class="line">cout&lt;&lt;*a&lt;&lt;endl; <span class="comment">// 此时编译器会报错，ok</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>可以看到，如果free的chunk没有和top chunk相邻被合并，其又太小的话，可能永远不会被使用</strong>——这就是产生了内存碎片。</p>
<p>如下图：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/10681867-4b414b22810c9e9d.png" alt="img"></p>
<p>free(A)后，由于chunk A无法和top chunk合并，在堆中便产生了内存空洞，也就是内存碎片。幸运的是，它还足够大（40K），有很大概率其空间是能够被利用的。</p>
<p><strong>小细节：free如何知道释放多大空间</strong>？</p>
<p>在前面地址传递我们知道：<strong>向一个函数传递指针的时候，它的长度信息往往会被截断（如果是数组名），无法标示数组的长度</strong>。因此，在函数中我们也无法获取它的长度信息，除非显示传递一个长度参数。</p>
<p>那free如何知道释放多大的空间？</p>
<p>原因很简单，free根本不用关系chunk大小，malloc分配的时候就是分配一个合适大小chunk。chunk包含header和user data。<strong>free只是将header中的相关标记为可用，加入空闲链表中即可</strong>。</p>
<h4 id="3-8-4-new-delete-原理">3.8.4 new /delete 原理</h4>
<p>在3.8.3节介绍了C语言中的动态内存分配方式：malloc，malloc函数分配失败返回指针空值，成功返回首地址。</p>
<p>现在我们来认识一下C++中的动态内存管理方式：new和delete。</p>
<p>准备好一个公共类<code>Stu</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>                           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span>                                          </span></span><br><span class="line"><span class="class">&#123;</span>                   </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Stu</span>()           </span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;默认构造函数初始化&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;                     </span><br><span class="line">    <span class="built_in">Stu</span>(<span class="keyword">int</span> num, string name):_num(num), _name(name)</span><br><span class="line">    &#123;                         </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;自定义构造函数初始化&quot;</span> &lt;&lt; endl;   </span><br><span class="line">    &#125;                      </span><br><span class="line">    ~<span class="built_in">Stu</span>()              </span><br><span class="line">    &#123;                       </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;析构销毁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;                         </span><br><span class="line">  <span class="keyword">private</span>:   </span><br><span class="line">    <span class="keyword">int</span> _num;               </span><br><span class="line">    string _name;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h5 id="new原理">new原理</h5>
<p>无论是new还是delete，它们在<u>内置类型/自定义类型</u>上使用有些不同。</p>
<ul>
<li>
<p><strong>new底层实现（内置类型</strong>）</p>
<p>对于内置类型来说，new和malloc功能基本一致，不过new还可以进行<strong>初始化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化单个：等同于int* a = (int*)malloc(sizeof(int));</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 初始化单个：同时进行初始化</span></span><br><span class="line"><span class="keyword">int</span>* c = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>new在C++中被定义为一个<strong>运算符</strong>，它会在底层调用全局函数operator new。</p>
<p>我们可以通过查看<code>int* array = new int;</code> 对应汇编源码验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 首先在寄存器edi中存入数组大小（4，一个int大小）</span><br><span class="line">movl    $4, %edi</span><br><span class="line"># 调用operator new分配空间</span><br><span class="line">call    operator new(unsigned long)</span><br><span class="line"># 寄存器rax保存new返回的首地址给a（对应地址 -16(%rbp)）</span><br><span class="line">movq    %rax, -16(%rbp)</span><br></pre></td></tr></table></figure>
<p>operator new只是malloc的一层封装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* __CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="keyword">const</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// malloc</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span>* <span class="keyword">const</span> block = <span class="built_in">malloc</span>(size))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_array_new_length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_alloc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The new handler was successful; try to allocate again...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>执行流程：</p>
<ol>
<li>
<p>当malloc申请空间成功时直接返回<code>return (p)</code>；</p>
</li>
<li>
<p>申请空间失败，尝试执行空间不足应对措施（<strong>malloc中失败直接返回空指针</strong>）；</p>
</li>
<li>
<p>如果改应对措施用户设置了，则继续申请，否则抛异常。</p>
</li>
</ol>
</li>
<li>
<p>从源码中能看出的是<strong>operator new</strong>在底层是利用malloc分配内存，因此可以说<strong>new其实只是malloc一层封装</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>new底层实现（自定义类型</strong>）</p>
<p>但对于自定义类型，new还会调用构造函数初始化：</p>
<ol>
<li>调用operator new为对象分配空间（内置类型）；</li>
<li><strong>调用对象的构造函数</strong>对对象进行初始化。</li>
</ol>
<p>我们举一个具体的例子分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">// malloc分配对象  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line">  <span class="comment">// new分配对象</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* b = <span class="keyword">new</span> <span class="built_in">Stu</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">自定义构造函数初始化</span><br></pre></td></tr></table></figure>
<p>可以看到malloc分配的方式不会调用构造函数，但是new还会调用构造函数。</p>
<p>因此也可以理解为<strong>malloc分配出来的只不过是一个和类一样大小的空间（在前面我们称为chunk），并不能称作是一个对象</strong>，而new和delete分配出来的才能被成为对象。</p>
</li>
<li>
<p><strong>new与new[]</strong></p>
<p>new[]和new有些细微区别：</p>
<ul>
<li>
<p>new[]是调用operator new[]对多个对象进行分配，<strong>operator new[]本质还是多次调用operator new</strong>；</p>
<p>但operator new[]还会多申请4个字节的空间保存此次对象个数。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220110001617014.png" alt="image-20220110001617014"></p>
<p><strong>为什么要这么做</strong>？</p>
<p>使用delete[] 释放空间时可以知道被释放的对象个数。</p>
</li>
<li>
<p>当然，<strong>对于自定义类型</strong>，类似new，还会调用N次构造函数对N个对象进行初始化。</p>
<blockquote>
<p>举例说明。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc分配对象  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line"><span class="comment">// new分配对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">Stu* b = <span class="keyword">new</span> Stu[<span class="number">3</span>];  </span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">new:</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="delete原理">delete原理</h5>
<p>delete也分两种情况讨论：</p>
<ul>
<li>对于内置类型：底层调用free实现，和free无多大区别（也没有异常处理）；</li>
<li>对于自定义类型：除了调用free释放对象空间，在此之前还会调用对象的析构函数。</li>
</ul>
<p>下面我们通过具体例子来看看。</p>
<ul>
<li>
<p><strong>delete底层实现（内置类型</strong>）</p>
<p>先看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>
<p>查看对应的汇编源码，核心是调用operator delete：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*int* a = new int;*/</span><br><span class="line"># 首先在寄存器edi中存入数组大小（4，一个int大小）</span><br><span class="line">movl    $4, %edi</span><br><span class="line"># 调用operator new分配空间</span><br><span class="line">call    operator new(unsigned long)</span><br><span class="line"># 寄存器rax保存new返回的首地址给a（对应地址 -16(%rbp)）</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line"></span><br><span class="line">/*delete a*/</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">testq   %rax, %rax</span><br><span class="line">je      .L2</span><br><span class="line">movl    $4, %esi</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line"># 核心是调用operator delete</span><br><span class="line"># 前面在干什么？暂不清楚。</span><br><span class="line">call    operator delete(void*, unsigned long)</span><br></pre></td></tr></table></figure>
<p>operator delete也只是free的一层封装（没有异常处理）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __CRTDECL <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">const</span> block)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    _free_dbg(block, _UNKNOWN_BLOCK);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">free</span>(block);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>delete底层实现（自定义类型</strong>）</p>
<p>但对于自定义类型，delete还会调用析构函数：</p>
<ol>
<li><strong>调用对象的析构函数</strong>清理对象；</li>
<li>调用operator delete清理内存；</li>
</ol>
<p>一个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">// malloc分配对象  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;free:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="comment">// new分配对象</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* b = <span class="keyword">new</span> Stu;  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">free:</span><br><span class="line">new:</span><br><span class="line">默认构造函数初始化</span><br><span class="line">delete:</span><br><span class="line">析构销毁</span><br></pre></td></tr></table></figure>
<p>可见free不会调用析构函数，但delete会。</p>
</li>
<li>
<p><strong>delete与delte[]</strong></p>
<p>delete[]用来删除多个对象（和new[]成对出现），本质是对每个对象调用delete清理。</p>
<p>大致流程如下：</p>
<ol>
<li>
<p>首先根据对象数组前4个字节，获取对象个数N；</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220110001617014.png" alt="image-20220110001617014"></p>
</li>
<li>
<p>对后续每个对象使用delete删除。</p>
</li>
</ol>
<p>同样的，对于自定义类型还会调用对象的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">// malloc分配多个对象  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;malloc:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* a = (Stu*)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(Stu));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;free:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// free释放内存</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="comment">// new[]分配对象</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Stu* b = <span class="keyword">new</span> Stu[<span class="number">3</span>];  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// delete[] 释放内存</span></span><br><span class="line">  <span class="keyword">delete</span>[] b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">free:</span><br><span class="line">new:</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br><span class="line">默认构造函数初始化</span><br><span class="line">delete:</span><br><span class="line">析构销毁</span><br><span class="line">析构销毁</span><br><span class="line">析构销毁</span><br></pre></td></tr></table></figure>
<p>这里有两个有意思的小细节：</p>
<ul>
<li>
<p><code>malloc</code>出的对象不会调用析构函数；</p>
</li>
<li>
<p>我们只用了一次<code>free(a)</code> 释放了分配对象数组<code>a</code> ，而对象数组<code>b</code>实际通过<code>delete[]</code> 调用了多次<code>delete</code>。</p>
</li>
</ul>
<p>这个细节也验证了我们之前结论：</p>
<ul>
<li><code>malloc</code>分配出来的只不过是一个我们需要的大小（这里是3个<code>stu</code>）的内存空间，它并没有真的分配了3个<code>stu</code>对象，所以<code>free</code>一次就可以释放这块内存。</li>
<li>但<code>new[]</code>是真正分配了3个<code>stu</code>对象内存空间，所以要<code>delete</code>多次且会执行析构函数。</li>
</ul>
</li>
</ul>
<h5 id="plain-nothrow-placement-new">plain/nothrow/placement new</h5>
<p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new。</p>
<p><strong>plain new</strong></p>
<p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plain new原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="comment">// plain new对应delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>可见<code>plain new</code>在空间分配失败的情况下，抛出异常<code>std::bad_alloc</code>而不是返回NULL。</p>
<p>因此通过判断返回值是否为NULL是徒劳的，请使用<code>try-catch</code>捕获异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10e11</span>];</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::bad_alloc &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bad allocation</span><br></pre></td></tr></table></figure>
<p><strong>nothrow new</strong></p>
<p>nothrow new在空间分配失败的情况下不抛出异常，而是返回NULL，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nothrow new原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>,<span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 对应delete原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in"><span class="keyword">new</span></span>(nothrow) <span class="keyword">char</span>[<span class="number">10e11</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc failed</span><br></pre></td></tr></table></figure>
<p><strong>placement new</strong></p>
<p><code>placement new</code>允许在一块<u>已经分配成功的内存</u>上重新构造对象或对象数组。</p>
<p><code>placement new</code>不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// placement new原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="comment">// 对应delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>主要用途</strong>：反复使用一块较大的动态分配的内存，来构造不同类型的对象或者他们的数组；</li>
<li><strong>使用析构函数删除而不是delete</strong>：placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存）。这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        j = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,j=&quot;</span>&lt;&lt;j &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ADT</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in"><span class="keyword">new</span></span>(nothrow) <span class="keyword">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用指针p申请的内存来构建类ADT对象adt</span></span><br><span class="line">    <span class="comment">// placement new：不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line">    ADT *adt = <span class="built_in"><span class="keyword">new</span></span>(p) ADT;  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    delete adt; // error，不能在此处调用delete</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 调用析构函数删除adt</span></span><br><span class="line">    adt-&gt;ADT::~<span class="built_in">ADT</span>(); </span><br><span class="line">    <span class="comment">// delete删除p</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADT construct i=10,j=100</span><br><span class="line">ADT destruct</span><br></pre></td></tr></table></figure>
<h5 id="小结">小结</h5>
<ol>
<li>new和delete分别是malloc和free的一层封装，对于自定义类型还会分别调用构造函数初始化/析构函数清理内存。<strong>不过new相比malloc还会有一层申请空间失败应对措施，以及可以初始化</strong>。</li>
<li>new[]/delete[]，是分别用来分配对象数组/清理对象数组的，本质是多次调用了new/free。值得注意的是，<strong>new[]分配的对象数组，还会多分配4个字节标识对象的个数</strong>。</li>
<li>在C++中有plain new，nothrow new和placement new。plain new就是最普通的new，分配错误返回bad alloc异常；nothrow new分配失败返回NULL异常；placement new不分配内存，请只调用析构函数进行释放，否则可能会导致double free。</li>
</ol>
<h4 id="3-8-5-问答测验">3.8.5 问答测验</h4>
<p>本节是八股重灾区，因为特地准备一些常见面试问题来巩固所学。</p>
<ol>
<li>
<p><strong>堆栈的区别</strong>？</p>
<p>主要的区别如下：</p>
<ul>
<li>
<p><strong>申请方式</strong>：<strong>栈由系统自动分配</strong>，比如函数中的局部变量<code>int a</code> ，调用函数时会自动为<code>a</code>开辟空间；<strong>堆是程序员申请并负责释放</strong>，并指明大小，例如 <code>int* array= new int[LEN]&#123;1,2,3&#125;;</code> ，但指针<code>array</code>本身是存于栈中。</p>
</li>
<li>
<p><strong>存储内容</strong>：栈存放和函数相关的数据，如定义<u><strong>局部</strong>变量</u>(但不包含static修饰的变量)、保存的上下文等；堆存放函数无关的数据，如动态分配的内存。</p>
</li>
<li>
<p><strong>大小限制</strong>：栈空间默认是4M，连续的 ；堆是不连续的内存区域，一般是 1G - 4G，大小受限于计算机系统中有效的虚拟内存。</p>
</li>
<li>
<p><strong>申请效率</strong>：栈由系统自动分配，计算机在底层对栈提供支持，速度快；堆是由程序员new分配的内存，一般速度比较慢，但更灵活。</p>
</li>
<li>
<p><strong>存储效率</strong>：栈的存取效率更高。请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = arr1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> b = arr2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转成汇编语言分析：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220108202348644.png" alt="image-20220108202348644"></p>
</li>
</ul>
</li>
<li>
<p><strong>new / malloc 的异同</strong>？</p>
<p>都可用于内存的动态申请，返回用户分配使用空间的首地址。</p>
<ul>
<li>
<p><strong>本质</strong>：new是关键字，malloc是函数，所以malloc还需要引入库文件，new不用；</p>
</li>
<li>
<p><strong>返回值类型</strong>：malloc返回的是void类型指针（必须进行类型转换），new返回的是具体类型指针；</p>
</li>
<li>
<p><strong>空间计算</strong>：new会自动分配空间大小，编译器会根据类型信息自行计算，malloc需要手工计算；</p>
</li>
<li>
<p><strong>类型安全</strong>：new是类型安全的，malloc不是；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">// 编译错误</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));<span class="comment">// 编译无错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>构造函数</strong>： new调用名为<strong>operator new</strong>的标准库函数分配足够空间，如果是自定义类型还会调用相关对象的构造函数，malloc则不会；</p>
</li>
<li>
<p><strong>分配失败措施</strong>：new是malloc的一层封装，如果分配失败还会有相应措施执行，抛出bac_alloc异常；malloc返回null。</p>
</li>
</ul>
</li>
<li>
<p><strong>free / delete 的异同</strong>？</p>
<p>都可用于内存的动态释放。</p>
<ul>
<li><strong>本质</strong>：delete 是关键字，free 是函数，所以free 还需要引入库文件，delete 不用；</li>
<li><strong>返回值类型</strong>：free返回的是void类型指针（必须进行类型转换），delete 返回的是具体类型指针；</li>
<li><strong>析构函数</strong>： delete 调用名为<strong>operator delete</strong>的标准库函数分配足够空间，如果是自定义类型还会调用相关对象的析构函数，free 则不会。</li>
</ul>
</li>
<li>
<p><strong>new实现原理？delete实现原理</strong>？</p>
<ul>
<li><strong>new原理</strong>：operator new分配内存 （底层是malloc实现）—&gt; （自定义类型）分配的内存上调用构造函数初始化—&gt;返回指向该对象的指针；</li>
<li><strong>delete原理</strong>：operator delete清理内存 （底层是free实现）—&gt; （自定义类型）删除内存前还会调用析构函数；</li>
</ul>
</li>
<li>
<p><strong>malloc/free底层原理</strong>？</p>
<p>参考前文。这里只简略说明：</p>
<ul>
<li>malloc：brk初始化分配–&gt;后续分配通过内存池：bins+双向链表实现—&gt;太大则top chunk 和mmap分配；</li>
<li>free：将chunk标记可使用，并加入空闲链表。在上一个步骤free的时候，发现最高地址空闲内存超过128K，还会内存紧缩。</li>
</ul>
</li>
<li>
<p><strong>被free回收的内存是立即返还给操作系统吗</strong>？</p>
<p>如前，free回收只是标识这块内存空闲，同时会加入空闲链表中等待下一次分配。</p>
</li>
<li>
<p><strong>delete和free可以混用吗</strong>?</p>
<p>我们知道delete也只是free一种封装，只有自定义类型时delete会调用析构函数。new和malloc同理。</p>
<p>所以在以下情况是<strong>可以free/delete混用</strong>：</p>
<ol>
<li>
<p><strong>对象是基本类型时</strong>。</p>
<p>free掉new申请的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a  = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// delete a;</span></span><br><span class="line"><span class="built_in">free</span>(a); </span><br></pre></td></tr></table></figure>
<p>delete掉malloc申请的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span>* a  = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>
<p>上面也适用于new/malloc混用。</p>
</li>
<li>
<p><strong>自定义的类型，但没有显示定义析构函数</strong>。</p>
<p>delete和free混用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>()&#123;a = <span class="number">0</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    test* t1 = (test*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(test));</span><br><span class="line">  <span class="built_in"><span class="keyword">delete</span></span>(t1);</span><br><span class="line">    </span><br><span class="line">  test* t2 = <span class="keyword">new</span> <span class="built_in">test</span>();</span><br><span class="line">  <span class="built_in">free</span>(t2);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果是自定义类型，<strong>malloc混用new需要显示调用构造函数的逻辑实现（或者该类不会有构造函数作用）</strong>。</p>
</li>
<li>
<p><strong>malloc、realloc、calloc的区别</strong>？</p>
<ul>
<li>
<p>malloc</p>
<p>malloc申请20个int类型的空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void* malloc(unsigned int num_size);</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>realloc</p>
<p>malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void* calloc(size_t n,size_t size);</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>realloc</p>
</li>
</ul>
<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void realloc(void *p, size_t new_size);</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>为什么C++没有垃圾回收机制？这点跟Java不太一样</strong>。</p>
<ul>
<li><strong>资源消耗</strong>。实现一个垃圾回收器会带来额外的空间和时间开销；
<ul>
<li>你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark；</li>
<li>然后需要单独开辟一个线程在空闲的时候进行free操作。</li>
</ul>
</li>
<li><strong>C++本身原因</strong>。垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
</li>
</ol>
<h3 id="3-9-Lambda表达式">3.9 Lambda表达式</h3>
<p>很多时候我们常常需要定义一个<strong>简单、甚至只被使用一次</strong>的函数，额外地定义了一个函数调用既浪费了空间，甚至未必有<strong>简化成一行代码</strong>好理解。</p>
<p>另外，前面的学习我们了解到C++是不允许函数嵌套的，但lambda可以被函数嵌套（lambda并不是函数，下文细说）。</p>
<p>lambda表达式就为我们做了这么一件事：<strong>将一个简单函数简化为一行，还允许我们在一个函数进行嵌套lambda</strong>。</p>
<h4 id="3-9-1-lambda初识">3.9.1 lambda初识</h4>
<h5 id="第一个lambda">第一个lambda</h5>
<p>C++中lambda表达式格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ captureClause ] ( parameters ) -&gt; returnType</span><br><span class="line">&#123;</span><br><span class="line">    Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>captureClause</code>：允许我们使用lambda外部的变量，这一点在3.9.5中详述，这里先略过；</li>
<li><code>parameters</code>：传递的参数，可空；</li>
<li><code>returnType</code>：返回类型，编译器会自动推断，可空；</li>
<li><code>Statement</code>：代码体，一般就一行，当然多行也行。</li>
</ul>
<p>一个最简单的lambda表达式可定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>现在举例说明用法。</p>
<p>我们之前写过一个冒泡函数<code>bubbleSort</code>：它有一个参数，允许我们传递定义排序规则，即<code>myCompare</code>函数来实现排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> idx_i,<span class="keyword">int</span> idx_j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[idx_i];</span><br><span class="line">    arr[idx_i] = arr[idx_j];</span><br><span class="line">    arr[idx_j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span> (*compare)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)   <span class="comment">// 外轮=n-1</span></span><br><span class="line">        <span class="comment">// * j=0,每次都是从头开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; len-i<span class="number">-1</span>; j++ ) <span class="comment">// 内轮=余下乱序数-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(arr[j],arr[j+<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">swap</span>(arr,j,j+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> array[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(array)/<span class="built_in"><span class="keyword">sizeof</span></span>(array[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">bubbleSort</span>(array,len,myCompare);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len  ;i++)</span><br><span class="line">       cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将这个<code>myCompare</code>函数改为更简洁<code>lambda</code>表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们如此调用bubbleSort函数：代码更加的紧凑，上下文更清晰，一眼明白我们排序的规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bubbleSort(array,len,myCompare);</span></span><br><span class="line"><span class="built_in">bubbleSort</span>(array,len,[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h5 id="lambda本质探讨🌟">lambda本质探讨🌟</h5>
<p>虽然3.9.2节（下节）的名字叫做“lambda与函数指针”，但值得提前声明的一点是：<strong>lambda并不是函数，它是一种特殊的对象，称为函数对象（也称为函数子）。函数不能嵌套，但lambda可以</strong>。</p>
<p><strong>怎么理解函数对象</strong>？</p>
<p><strong>C++函数对象实质上是实现了对()操作符的重载</strong>。C++函数对象不是函数指针，但它的调用方式与函数指针一样，后面加个括号就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// addFunction的Add类对象，此也是函数对象</span></span><br><span class="line">    Add addFunction;</span><br><span class="line">    <span class="comment">// 像函数（指针）一样调用</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">addFunction</span>(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">    cout&lt;&lt;addFunction.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;    <span class="comment">// 5</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Add</span>()(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;endl;   <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数对象相比普通函数有什么好处吗</strong>？</p>
<ul>
<li>
<p><strong>函数对象带有状态</strong>：函数对象相对于普通函数是“智能函数”，这就如同智能指针相较于传统指针。因为函数对象除了提供函数调用符方法，还可以拥有其他方法和数据成员。所以函数对象有状态。即使同一个类实例化的不同的函数对象其状态也不相同，这是普通函数所无法做到的。而且函数对象是可以在运行时创建。</p>
</li>
<li>
<p><strong>每个函数对象有自己的类型</strong>：对于普通函数来说，只要签名一致，其类型就是相同的。但是这并不适用于函数对象，因为函数对象的类型是其类的类型。这样，函数对象有自己的类型，这意味着函数对象可以用于模板参数，这对泛型编程有很大提升。</p>
</li>
<li>
<p><strong>函数对象一般快于普通函数</strong>：因为函数对象一般用于模板参数，模板一般会在编译时会做一些优化。</p>
</li>
</ul>
<p>回到lambda表达式。</p>
<p><strong>我们看看一个lambda表达式是如何被转换成函数对象</strong>。</p>
<p>准备代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧是https://cppinsights.io/，观察编译过程变化：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112200056709.png" alt="image-20220112200056709"></p>
<p>编译器如何将我们写的lambda表达式转换为函数对象便一目了然：</p>
<ol>
<li>首先为我们生成类<code>__lambda_3_16</code> （①处），它有一个内联函数（②处），重载了符号<code>()</code>；</li>
<li>代码30行处，为我们生成了lambda函数对象<code>add</code>，也就是我们定义的lambda表达式名；</li>
<li>随后调用了函数对象<code>add</code> （③处），完成整个转换过程。</li>
</ol>
<h5 id="存储lambda">存储lambda</h5>
<p>虽然一般来说我们不需要像函数一样给lambda表达式一个名字，但是有时候也需要能将lambda表达式（作为右值）存储起来，供以后使用。</p>
<p>在C++中提供三种方式：</p>
<ol>
<li><strong>使用函数指针方式存储</strong>：只有在<code>capture clause</code>为空时；</li>
<li><strong>使用function方式存储</strong>：<code>capture clause</code>不为空时，也可以使用；</li>
</ol>
<p>先来看看函数指针方式。</p>
<p>函数指针指向不仅限于函数，只要是函数对象都可以指向。lambda作为函数对象，自然是可以被其存储的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*myCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>用 <code>auto</code> 关键字可简化函数指针类型书写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myCompare = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>再来关注下<code>std::function</code>方式。</p>
<p>前面我们提到过：<code>std::function</code>本质就是类模板，也就是函数容器，可以将<strong>函数指针/函数转换成（函数）对象</strong>进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; myCompare = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="lambda参数">lambda参数</h5>
<p>Lambda表达式的参数和普通函数的参数相比有些限制（C++11）：</p>
<ol>
<li>
<p>参数列表中不能有默认参数；</p>
</li>
<li>
<p>不支持可变参数（比如使用auto关键字）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11:编译出错，参数类型无法使用auto</span></span><br><span class="line"><span class="keyword">auto</span> myCompare = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所有参数必须有参数名。</p>
</li>
</ol>
<p>关于第2点，从<code>C++14</code>开始，<code>lambda</code>表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。</p>
<p>具体介绍参考3.9.2节。</p>
<h4 id="3-9-2-泛型lambda（C-14）">3.9.2 泛型lambda（C++14）</h4>
<h5 id="什么是泛型lambda？">什么是泛型lambda？</h5>
<p>从 C++14 开始，我们被允许<code>auto</code>用于参数。当 lambda 具有一个或多个<code>auto</code>参数时，编译器将从对 lambda 的调用中推断出需要哪些参数类型。</p>
<p>这使得<strong>具有一个或多个<code>auto</code>参数的lambda可适用于多种类型，<strong>它们也被称为</strong>泛型 lambda</strong>。</p>
<p>看一个小例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.4</span>);  <span class="comment">// 5.9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是非常像模板函数？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.4</span>);  <span class="comment">// 5.9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add(2, 3)</code> 、<code>add(2.5, 3.4)</code> 分别让函数模板生成了函数实例<code> add(int, int)</code>、<code> add(double, double)。</code></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112193845733.png" alt="image-20220112193845733"></p>
<p><strong>auto关键字自动推断lambda参数类型</strong>，让lambda表达式起到了和模板函数相同的效果。前面我们说到，<strong>模板函数会为每种不同类型生成实例函数：那泛型lambda也会为不同类型生成一个lambda表达式吗</strong>？</p>
<p>答案是肯定的。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220112194112575.png" alt="image-20220112194112575"></p>
<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> __<span class="title">lambda_3_16</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type_parameter_0_0</span>, <span class="keyword">class</span> <span class="title">type_parameter_0_1</span>&gt;</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(type_parameter_0_0 x, type_parameter_0_1 y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type_parameter_0_0</span>, <span class="keyword">class</span> <span class="title">type_parameter_0_1</span>&gt;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">auto</span> __invoke(type_parameter_0_0 x, type_parameter_0_1 y)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_3_16 add = __lambda_3_16&#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> x = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">double</span> y = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2.5</span>, <span class="number">3.3999999999999999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面代码中：</p>
<ol>
<li>
<p>编译器自动生成了lambda类<code>__lambda_3_16</code></p>
</li>
<li>
<p>类<code>__lambda_3_16</code> ，根据40、41行函数调用的不同参数类型，分别生成了两个成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<p>注意到，两个函数都重载了操作符<code>()</code> 。</p>
</li>
<li>
<p>代码39行，生成了类<code>__lambda_3_16</code> 对象<code>add</code>，<code>add</code>就是我们定义的泛型lambda名，显然此时<code>add</code>也是函数对象，可以用<code>名字()</code>方式调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__lambda_3_16 add = __lambda_3_16&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>代码40、41行调用了不同的类<code>__lambda_3_16</code> 不同重载函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">double</span> y = add.<span class="built_in"><span class="keyword">operator</span></span>()(<span class="number">2.5</span>, <span class="number">3.3999999999999999</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="更好地理解泛型闭包行为🌟">更好地理解泛型闭包行为🌟</h5>
<p>前面已经说到，泛型lambda会为每种不同类型生成成员函数 。</p>
<p>同时，我们也了解局部静态变量同样具有全局的生命周期，下面这个例子展示了这种特性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myCount</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the type of your input:&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(value).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">0</span>)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the type of your input:i</span><br><span class="line">1</span><br><span class="line">the type of your input:d</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>count</code> 虽然是局部变量，但是由于是静态变量函数存储在全局数据段，和堆栈无关，退出也不会销毁。<strong>所以被myCount函数共享，可进行计数</strong>。</p>
<p><strong>但是如果我们<code>myCount</code>替换成泛型函数，即允许参数类型为auto，一切开始变得不一样了</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20支持参数类型为auto</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myCount</span><span class="params">(<span class="keyword">auto</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the type of your input:&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(value).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1.2</span>)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the type of your input:i</span><br><span class="line">1</span><br><span class="line">the type of your input:d</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>此时静态变量<code>count</code>没有被<code>myCount</code>函数共享？这是因为此时<code>myCount</code>函数已经是泛型函数。</p>
<ul>
<li>执行代码第13行，推断出<code>value</code>为<code>int</code>类型，编译器生成函数<code>int myCount&lt;int&gt;(int value)</code>，它拥有自己作用范围的静态变量<code>count</code>；</li>
<li>执行代码第14行，类似的，<strong>无法匹配上一次生成函数<code>int myCount&lt;int&gt;(int value)</code></strong>。所以编译器还需生成函数<code>int myCount&lt;double&gt;(double value)</code>，它也拥有自己作用范围的静态变量<code>count</code>。</li>
</ul>
<p>两个<code>myCount</code> 是重载函数，但它们并不一样，自然无法共享各自的局部静态变量<code>count</code>。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113000047727.png" alt="image-20220113000047727"></p>
<p><strong>类似的结果也出现在泛型lambda、函数模板中</strong>。</p>
<p>下面以泛型lambda为例进行展示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myCount</span><br><span class="line">&#123;</span><br><span class="line">   [](<span class="keyword">auto</span> value)</span><br><span class="line">   &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;the type of your input:&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(value).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> count++; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">myCount</span>(<span class="number">1.2</span>)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the type of your input:i</span><br><span class="line">1</span><br><span class="line">the type of your input:d</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>查看编译转换后的代码验证：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113000753408.png" alt="image-20220113000753408"></p>
<h4 id="3-9-3-使用标准库函数">3.9.3 使用标准库函数</h4>
<p>和array配合时，lambda表达式会接受数组两个元素，定义它们的比较规则</p>
<p>lambda表达式常配合标准库函数使用，简洁优雅。</p>
<p>下面展示了几个排序用例。</p>
<ul>
<li>
<p><strong>例1：<code>std::sort</code>和lambda配合用在<code>std::array</code>上</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span> <span class="comment">// for std::greater</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::array&lt;<span class="keyword">int</span>,6&gt; arr = &#123; <span class="number">13</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">80</span> &#125;;</span><br><span class="line">  <span class="comment">// 此时lambda参数接受数组两个元素，返回它们的比较规则（bool类型）</span></span><br><span class="line">  <span class="comment">// 可以结合之前我们写的冒泡排序自定义规则理解，此时是在双重for循环中接受数组相邻两个元素进行比较</span></span><br><span class="line">  std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a,<span class="keyword">int</span> b )&#123;<span class="keyword">return</span> a&gt;b;&#125;); </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">  &#123;</span><br><span class="line">     std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 90 80 40 13 5</span><br></pre></td></tr></table></figure>
<p>对于常见的操作（例如加法、求反或比较），标准库附带了许多可直接使用的函数对象。</p>
<p>比如这个例子可用<code>std::greater</code>替代我们写的lambda表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), std::greater);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>例2：排序对象是结构数组、类数组、RDD等</strong></p>
<p><code>struct Student</code>用来存储学生姓名和分数的，将下面<code>Student</code>数组按成绩进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> points&#123;&#125;;</span><br><span class="line">    <span class="comment">// 需要初始化函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">const</span> <span class="keyword">char</span> my_name[],<span class="keyword">const</span> <span class="keyword">int</span> my_points)  </span><br><span class="line">    &#123;</span><br><span class="line">         name = std::<span class="built_in">string</span>(my_name);</span><br><span class="line">         points = my_points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::array&lt;Student, 8&gt; arr</span><br><span class="line">&#123;</span><br><span class="line">    &#123; </span><br><span class="line">        &#123; <span class="string">&quot;Albert&quot;</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Ben&quot;</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Christine&quot;</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Dan&quot;</span>, <span class="number">8</span> &#125;, </span><br><span class="line">        &#123; <span class="string">&quot;Enchilada&quot;</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Francis&quot;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Greg&quot;</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;Hagrid&quot;</span>, <span class="number">5</span> &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现流程如下：</p>
<ol>
<li>明确lambda接受的参数是数组两个元素，这里元素是结构体<code>Student</code>对象；</li>
<li>假设两个<code>Student</code>对象分别是stu1、stu2，它们比较的规则应该是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>u</mi><mn>1.</mn><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>&gt;</mo><mi>s</mi><mi>t</mi><mi>u</mi><mn>2.</mn><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">stu1.points&gt;stu2.points</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord">1.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord">2.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span> 。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[](Student s1,Student s2)&#123;<span class="keyword">return</span> s1.points&gt;s2.points;&#125;);</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),[](Student s)&#123;std::cout&lt;&lt;s.name&lt;&lt;std::endl;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-9-4-捕获">3.9.4 捕获</h4>
<h5 id="为什么需要捕获">为什么需要捕获</h5>
<p>前面我们说过lambda表达式原理：</p>
<ol>
<li>每定一个lambda表达式，会生成一个匿名类，这个类重载了<code>()</code>运算符；</li>
<li>使用lambda表达式，其实就是返回一个闭包类实例。</li>
</ol>
<p>既然是闭包，当然无法使用外部的变量，请看下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    []()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  <span class="comment">// 无法使用外部变量a</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过捕获可以让我们使用外部变量<code>a</code>。</p>
<h5 id="按值捕获">按值捕获</h5>
<p>下面展示了按值捕获方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    [a]()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值捕获只是将变量<code>a</code> 复制一份，而且由于lambda匿名生成了重载函数<code>()</code> 被<code>const</code>修饰，所以不能在lambda表达式内部修改数据成员<code>a</code>的值。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113145733566.png" alt="image-20220113145733566"></p>
<p>要想修改<code>a</code>的值，需要声明为<code>mutable</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a]()<span class="keyword">mutable</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时重载函数的<code>const</code>关键字不会被声明。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20220113150219048.png" alt="image-20220113150219048"></p>
<p>但<code>mutable</code>这种方式，我们依旧无法修改lambda外部变量<code>a</code>的值，毕竟lambda内部变量<code>a</code>只是值复制了一份。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> print = [a]() <span class="keyword">mutable</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>要想能修改lambda外部的变量，有两种方式：</p>
<ol>
<li>
<p>声明外部变量为<code>a</code>为static：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> print = []() </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>();  <span class="comment">// 1</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到此时，不用mutable也可以捕获外部静态变量<code>a</code>，因为此时<code>a</code>具有全局生命周期，可被<strong>隐式捕获</strong>（下个小节详细列出）。</p>
</li>
<li>
<p>用引用捕获的方式。</p>
</li>
</ol>
<h5 id="按引用捕获">按引用捕获</h5>
<p>引用捕获方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> print = [&amp;a]() <span class="comment">// 引用捕获</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a++&lt;&lt;endl;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>原因很简单，修改引用时会通过间接寻址到本体外部的变量<code>a</code>，然后进行修改的。</p>
<h5 id="混合捕获">混合捕获</h5>
<p>上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">捕获形式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">不捕获任何外部变量</td>
</tr>
<tr>
<td style="text-align:center"><strong>[变量名, …]</strong></td>
<td style="text-align:center">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr>
<td style="text-align:center">[this]</td>
<td style="text-align:center">以值的形式捕获this指针</td>
</tr>
<tr>
<td style="text-align:center">[=]</td>
<td style="text-align:center">以值的形式捕获<strong>所有</strong>外部变量</td>
</tr>
<tr>
<td style="text-align:center">[&amp;]</td>
<td style="text-align:center">以引用形式捕获<strong>所有</strong>外部变量</td>
</tr>
<tr>
<td style="text-align:center">[=, &amp;x]</td>
<td style="text-align:center">变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td style="text-align:center">[&amp;, x]</td>
<td style="text-align:center">变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h5 id="隐式捕获">隐式捕获</h5>
<p>前面介绍的都是显示捕获，在C++中，如果变量被声明为static或者const，其实是可以隐式捕获使用的。</p>
<p>请回答：下面变量哪些可以在<code>main</code>不显式捕获它们的情况下使用？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i&#123;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a&#123;&#125;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> b&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> d&#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> e&#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> f&#123; <span class="built_in">getValue</span>() &#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> g&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> h&#123; <span class="built_in">getValue</span>() &#125;;</span><br><span class="line"></span><br><span class="line">  []()</span><br><span class="line">  &#123;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    e;</span><br><span class="line">    f;</span><br><span class="line">    g;</span><br><span class="line">    h;</span><br><span class="line">    i;</span><br><span class="line">    j;</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了a、f，其余都是被static或者const修饰，可以隐式被lambda捕获。</p>
<h3 id="3-X-再谈-auto">3.X 再谈 auto</h3>
<p>前面我们或多或少了使用了auto关键字，它的作用也很明显：<strong>自动类型推断</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() <span class="comment">// i</span></span><br></pre></td></tr></table></figure>
<p>但像这种<strong>简单类型变量声明不建议使用auto关键字</strong>，直接写出变量的类型更加清晰易懂。</p>
<p>现在进行常见场景下auto总结&amp;使用。</p>
<h4 id="auto用法总结">auto用法总结</h4>
<ol>
<li>
<p><strong>代替冗长复杂、变量使用范围专一的变量声明</strong></p>
<p>比如：存储函数指针或lambda表达式、模板对象声明等。</p>
<blockquote>
<p>STL标准库将在后续进行总结。</p>
</blockquote>
<p>想象一下在没有auto的时候，我们操作标准库时经常需要这样（难受啊兄弟）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); i != vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用auto能简化代码（舒服了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vs.<span class="built_in">begin</span>(); i != vs.<span class="built_in">end</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又如函数指针声明比较复杂，存储时不好书写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p_func)(<span class="keyword">int</span>,<span class="keyword">int</span>) = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有lambda表达式，类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*myCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>auto优化后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">auto</span></span> (*myCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b? <span class="literal">false</span>: <span class="literal">true</span>;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>在定义模板函数时，用于声明依赖模板参数的变量类型</strong></p>
<p>若不使用auto变量来声明<code>v</code>，则无法进行定义，因为其类型无法确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx,<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(_Tx x, _Ty y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = x*y;</span><br><span class="line">    std::cout &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++11中如果<code>v</code>作为返回值，还需要在尾部指定返回类型（否则会发出警告）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(_Tx x, _Ty y)</span>-&gt;<span class="title">decltype</span><span class="params">(x*y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decltype用于计算出表达式<code>x*y</code>的类型。</p>
</li>
</ol>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>
<p><strong>auto关键字必须初始化</strong></p>
<p>需要在声明时auto就可以推断出变量类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> b;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>auto会自动去除右值的引用、const语义，需要显示声明</strong></p>
<p>右值引用语义被去除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = b; <span class="comment">// 此时c的类型是int不是int&amp;</span></span><br></pre></td></tr></table></figure>
<p>需要显示声明为引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; c = b; <span class="comment">// 此时c的类型才是int&amp;</span></span><br></pre></td></tr></table></figure>
<p>auto还会去除const语义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// 此时b为int类型，而不是const int</span></span><br><span class="line">b = <span class="number">100</span>;  <span class="comment">// b可以被修改</span></span><br></pre></td></tr></table></figure>
<p>需要显示声明为const常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> b = a;</span><br><span class="line">b = <span class="number">100</span>; <span class="comment">// 非法，无法被修改</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有个有意思的问题：如果auto&amp; 还会去除const语义吗？理论上来说，此时引用是某种意义上等价本体的，自然类型也应该是一致的。</p>
</blockquote>
<p>答案是不会的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; b = a; <span class="comment">// 此时b为const int，const语义未被去除</span></span><br><span class="line">b = <span class="number">100</span>;     <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>auto关键字不去除指针的语义</strong></p>
<p>请看下例，auto正确推导除了变量的类型为指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = &amp;a;  <span class="comment">// b是int*类型</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;*b&lt;&lt;endl; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>auto不能作为函数形参</strong></p>
<p>这样做的话，声明的函数实际上就是个函数模板了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种做法在C++20中已被支持。</p>
</li>
</ol>
<h2 id="更新记录">更新记录</h2>
<div class="timeline">
<div class="timenode"><div class="meta"><p><p>2021-01-16 ：更新笔记</p>
</p></div><div class="body"><ol><li>第一次更新</li></ol></div></div>
</div>
<h2 id="参考资料">参考资料</h2>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++中引用传递与指针传递的区别：https://blog.csdn.net/u013130743/article/details/80806179<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C/C++ 程序的内存布局：https://blog.csdn.net/m0_45047300/article/details/118389444<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">内存分配的原理--molloc/brk/mmap：http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ lambda表达式与函数对象：https://www.jianshu.com/p/d686ad9de817<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">C++ auto 关键字的使用：https://cloud.tencent.com/developer/article/1660750<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wanghui Huang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hwh.zone/p/51595/">https://hwh.zone/p/51595/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hwh.zone" target="_blank">royhuang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/C-%E5%9F%BA%E7%A1%80/">C++基础</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0/">函数</a></div><div class="post_share"><div class="social-share" data-image="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wechatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/18652/"><img class="prev-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211214212828.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++从零开始（一）：环境搭建（上）VSCode远程开发</div></div></a></div><div class="next-post pull-right"><a href="/p/24237/"><img class="next-cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++从零开始（二）：务实基础（中）指针和引用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211214212828.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（一）：环境搭建（上）VSCode远程开发</div></div></a></div><div><a href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211211215040434.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</div></div></a></div><div><a href="/p/43924/" title="C++从零开始（三）：面对对象（中）运算符重载"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-27</div><div class="title">C++从零开始（三）：面对对象（中）运算符重载</div></div></a></div><div><a href="/p/26224/" title="C++从零开始（二）：务实基础（上）快速入门"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">C++从零开始（二）：务实基础（上）快速入门</div></div></a></div><div><a href="/p/6587/" title="C++从零开始（二）：务实基础（下）复合类型及转换"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">C++从零开始（二）：务实基础（下）复合类型及转换</div></div></a></div><div><a href="/p/24237/" title="C++从零开始（二）：务实基础（中）指针和引用"><img class="cover" src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">C++从零开始（二）：务实基础（中）指针和引用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">三、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%F0%9F%8C%9F"><span class="toc-text">3.1.1 前向声明🌟</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E5%88%9D%E8%AF%86"><span class="toc-text">前向声明初识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#extern%E5%92%8C%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-text">extern和前向声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9Aextern-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E-include"><span class="toc-text">最佳实践：extern&#x2F;前向声明&#x2F;include</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3.1.2 最佳实践：什么时候使用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">3.2 函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%9F"><span class="toc-text">3.2.1 为什么需要函数重载？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E4%BA%8C%E4%B9%89%E6%80%A7%E5%8C%B9%E9%85%8D"><span class="toc-text">3.2.2 二义性匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">3.3 函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">3.3.1 模板函数是如何工作的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.3.2 多个函数模板类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%F0%9F%8C%9F"><span class="toc-text">3.4 函数参数🌟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">3.4.1 按值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">3.4.2 按引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E6%8C%89%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-text">3.4.3 按指针传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">3.4.4 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E5%BC%95%E7%94%A8%E5%BF%AB%E8%BF%98%E6%98%AF%E4%BC%A0%E6%8C%87%E9%92%88%E5%BF%AB%EF%BC%9F"><span class="toc-text">传引用快还是传指针快？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E9%80%89%E6%8B%A9%E8%A7%84%E5%88%99"><span class="toc-text">参数传递选择规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%EF%BC%9F"><span class="toc-text">数组怎么使用引用传参？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%80%BB%E7%BB%93"><span class="toc-text">3.4.5 参数传递总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0"><span class="toc-text">3.4.6 特殊参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">3.5 函数返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E6%8C%89%E5%80%BC%E8%BF%94%E5%9B%9E"><span class="toc-text">3.5.1 按值返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E6%8C%89%E6%8C%87%E9%92%88%E8%BF%94%E5%9B%9E"><span class="toc-text">3.5.2 按指针返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%8C%89%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E"><span class="toc-text">3.5.3 按引用返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.5.4 小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5-%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-text">3.5.5 返回多个值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">3.6 内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E9%82%A3%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-text">3.6.1 那函数有什么缺点吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E6%9B%BF%E6%8D%A2%EF%BC%9F"><span class="toc-text">3.6.2 内联函数什么时候被替换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AF%B9%E6%AF%94"><span class="toc-text">3.6.3 内联函数和宏对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">3.7 函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">3.7.1 函数和指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.2 为什么需要函数指针：回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-3-%E6%9B%B4%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">3.7.3 更优雅地使用函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">1. 类型别名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-function"><span class="toc-text">2. function</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-function%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3. function是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8auto"><span class="toc-text">4. 使用auto</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-4-CPU%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9A%E5%8F%98%E9%87%8F"><span class="toc-text">3.7.4  CPU眼中的函数指针：变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.7.5 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E6%A0%88%E5%92%8C%E5%A0%86%F0%9F%8C%9F"><span class="toc-text">3.8 栈和堆🌟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">3.8.1 内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">3.8.2 函数调用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7"><span class="toc-text">栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90"><span class="toc-text">汇编分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-3-malloc-free-%E5%8E%9F%E7%90%86"><span class="toc-text">3.8.3 malloc&#x2F;free 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E8%AF%B4%E8%B5%B7"><span class="toc-text">从静态分配说起</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%A0%86%E5%9D%97%E8%AF%B4%E8%B5%B7"><span class="toc-text">从堆块说起</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc%E5%8E%9F%E7%90%86"><span class="toc-text">malloc原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#free%E5%8E%9F%E7%90%86"><span class="toc-text">free原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-4-new-delete-%E5%8E%9F%E7%90%86"><span class="toc-text">3.8.4 new &#x2F;delete 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new%E5%8E%9F%E7%90%86"><span class="toc-text">new原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete%E5%8E%9F%E7%90%86"><span class="toc-text">delete原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#plain-nothrow-placement-new"><span class="toc-text">plain&#x2F;nothrow&#x2F;placement new</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-5-%E9%97%AE%E7%AD%94%E6%B5%8B%E9%AA%8C"><span class="toc-text">3.8.5 问答测验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.9 Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1-lambda%E5%88%9D%E8%AF%86"><span class="toc-text">3.9.1 lambda初识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAlambda"><span class="toc-text">第一个lambda</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lambda%E6%9C%AC%E8%B4%A8%E6%8E%A2%E8%AE%A8%F0%9F%8C%9F"><span class="toc-text">lambda本质探讨🌟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8lambda"><span class="toc-text">存储lambda</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lambda%E5%8F%82%E6%95%B0"><span class="toc-text">lambda参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2-%E6%B3%9B%E5%9E%8Blambda%EF%BC%88C-14%EF%BC%89"><span class="toc-text">3.9.2 泛型lambda（C++14）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8Blambda%EF%BC%9F"><span class="toc-text">什么是泛型lambda？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E9%97%AD%E5%8C%85%E8%A1%8C%E4%B8%BA%F0%9F%8C%9F"><span class="toc-text">更好地理解泛型闭包行为🌟</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-3-%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">3.9.3 使用标准库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-4-%E6%8D%95%E8%8E%B7"><span class="toc-text">3.9.4 捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8D%95%E8%8E%B7"><span class="toc-text">为什么需要捕获</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%8D%95%E8%8E%B7"><span class="toc-text">按值捕获</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7"><span class="toc-text">按引用捕获</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8D%95%E8%8E%B7"><span class="toc-text">混合捕获</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7"><span class="toc-text">隐式捕获</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-X-%E5%86%8D%E8%B0%88-auto"><span class="toc-text">3.X 再谈 auto</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">auto用法总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-text">更新记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43924/" title="C++从零开始（三）：面对对象（中）运算符重载">C++从零开始（三）：面对对象（中）运算符重载</a><time datetime="2022-01-27T06:47:34.826Z" title="发表于 2022-01-27 14:47:34">2022-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/17506/" title="C++从零开始（三）：面对对象（上）快速入门">C++从零开始（三）：面对对象（上）快速入门</a><time datetime="2022-01-24T07:37:07.955Z" title="发表于 2022-01-24 15:37:07">2022-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/6587/" title="C++从零开始（二）：务实基础（下）复合类型及转换">C++从零开始（二）：务实基础（下）复合类型及转换</a><time datetime="2022-01-16T13:04:18.006Z" title="发表于 2022-01-16 21:04:18">2022-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/26224/" title="C++从零开始（二）：务实基础（上）快速入门">C++从零开始（二）：务实基础（上）快速入门</a><time datetime="2022-01-16T12:56:08.897Z" title="发表于 2022-01-16 20:56:08">2022-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <h1 id="tree-toc-title" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/categories/">目 录 </a> </h1>
      <h5 id="tree-toc-subtitle" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/">royhuang's blog</a> </h5>
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/">
          C++进阶
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17506/" title="C++从零开始（三）：面对对象（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（三）：面对对象（上）快速入门</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）VSCode远程开发</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（下）g++/Makefile/CMake快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43924/" title="C++从零开始（三）：面对对象（中）运算符重载"><i class="post-icon gg-file-document"></i>C++从零开始（三）：面对对象（中）运算符重载</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/26224/" title="C++从零开始（二）：务实基础（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/6587/" title="C++从零开始（二）：务实基础（下）复合类型及转换"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（下）复合类型及转换</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51595/" title="C++从零开始（二）：务实基础（下）函数"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（下）函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/24237/" title="C++从零开始（二）：务实基础（中）指针和引用"><i class="post-icon gg-file-document"></i>C++从零开始（二）：务实基础（中）指针和引用</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记（初步整理）"><i class="post-icon gg-file-document"></i>Git基础笔记（初步整理）</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>