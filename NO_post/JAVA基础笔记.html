<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础笔记 | royhuang's blog</title><meta name="author" content="Wanghui Huang"><meta name="copyright" content="Wanghui Huang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章：初识java 1.0 快捷键  Alt + \ : 查看本来所有方法，变量  Ctrl+Alt ： 跳出虚拟机  1.1 JDK安装与配置   JDK下载 下载地址：官网JDK下载  下载完毕后：  下载是exe文件，安装 到 D:&#x2F;JDK 文件夹下（没有自己新建JDK文件夹） 下载是压缩包，解压到相应 D:&#x2F;JDK 文件夹下即可。    配置环境变量（win10） 首先打开 系统属性—&amp;">
<meta property="og:type" content="website">
<meta property="og:title" content="Java基础笔记">
<meta property="og:url" content="https://hwh.zone/NO_post/JAVA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="royhuang&#39;s blog">
<meta property="og:description" content="第一章：初识java 1.0 快捷键  Alt + \ : 查看本来所有方法，变量  Ctrl+Alt ： 跳出虚拟机  1.1 JDK安装与配置   JDK下载 下载地址：官网JDK下载  下载完毕后：  下载是exe文件，安装 到 D:&#x2F;JDK 文件夹下（没有自己新建JDK文件夹） 下载是压缩包，解压到相应 D:&#x2F;JDK 文件夹下即可。    配置环境变量（win10） 首先打开 系统属性—&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg">
<meta property="article:published_time" content="2022-01-02T11:54:25.531Z">
<meta property="article:modified_time" content="2021-12-03T03:41:02.893Z">
<meta property="article:author" content="Wanghui Huang">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/about-bg.jpg"><link rel="shortcut icon" href="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat-modified.png"><link rel="canonical" href="https://hwh.zone/NO_post/JAVA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":"true# copy button","highlightLang":false,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: Wanghui Huang","link":"链接: ","source":"来源: royhuang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础笔记',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-12-03 11:41:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="google-site-verification" content="uO6C17u7YuZfMWvThEQ9nOGQS4GIN2zAM6hC4tH-RiM" /><meta name="baidu-site-verification" content="code-nRnoDyQJPT" /><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?13a4aefcbad9616a1f5859538d0d882e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">royhuang's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-fw fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> aboutME</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h1 class="page-title">Java基础笔记</h1><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>第一章：初识<em>java</em></h1>
<h2 id="1-0-快捷键">1.0 快捷键</h2>
<ul>
<li><code>Alt</code> + <code>\</code> : 查看本来所有方法，变量</li>
<li><code> Ctrl</code>+<code>Alt</code> ： 跳出虚拟机</li>
</ul>
<h2 id="1-1-JDK安装与配置">1.1 JDK安装与配置</h2>
<ol>
<li>
<p>JDK下载</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">官网JDK下载</a></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561340917555.png" alt="1561340917555"></p>
<p>下载完毕后：</p>
<ul>
<li>下载是<code>exe</code>文件，<strong>安装</strong> 到 <code>D:/JDK</code> 文件夹下（没有自己新建JDK文件夹）</li>
<li>下载是压缩包，<strong>解压</strong>到相应 <code>D:/JDK</code> 文件夹下即可。</li>
</ul>
</li>
<li>
<p>配置环境变量（win10）</p>
<p>首先打开 系统属性—&gt;高级----&gt;环境变量：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341247893.png" alt="1561341247893"></p>
<p>如上图所示，新建一个系统变量JAVA_HOME:</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341341032.png" alt="1561341341032"></p>
<p>接着选择编辑PATH变量：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341548289.png" alt="1561341548289"></p>
<p>选择新建一个<code>%JAVA_HOME%\bin</code> ，并移动到最上方：</p>
<blockquote>
<p><em>%JAVA_HOME%</em> : 表示引入的 前一个 系统变量 <em>JAVA_HOME</em> 路径</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341636843.png" alt="1561341636843"></p>
<p>记得依次点击确定保存，关闭环境变量设置。</p>
</li>
<li>
<p>验证是否成功</p>
<p><code>win + r ---&gt; cmd ----&gt; java -version</code> 查看，显示版本号则按照成功：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561341770850.png" alt="1561341770850"></p>
</li>
</ol>
<h2 id="1-2-IDE-intelliJ-IDEA">1.2 IDE : intelliJ IDEA</h2>
<ol>
<li>
<p>下载 &amp; 安装</p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/download/#section=windows">官网下载IDEA</a></p>
<p>傻瓜似安装，注意安装过程选择64位。</p>
</li>
<li>
<p>注册激活</p>
<p>第一次打开IDEA时会要求你注册激活，选择输入激活代码，博客激活码地址：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zixiao217/article/details/82942476">激活地址，第二个可用</a></p>
</li>
</ol>
<h2 id="1-3-第一个项目-HELLOJAVA">1.3 第一个项目:HELLOJAVA</h2>
<ol>
<li>
<p>创建项目</p>
<p>选择 File–&gt;New–&gt;Project ,SDK 选择 安装 JDK 所在目录（同上）：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561346657818.png" alt="1561346657818"></p>
<p>下一步选择 <em>Project</em> 所在文件夹：</p>
<p>⚠️ 先创建一个文件夹用来保存项目，该步<strong>不会自动创建一个<em>Projiect</em>对应文件夹</strong>！</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561348405542.png" alt="1561348405542"></p>
</li>
<li>
<p>第一个 <em>JAVA</em> 文件</p>
<p>为了方便管理，可以先创建一个 <em>Package</em>（类似 <em>C#</em> 命令空间）。</p>
<p>右键选择 <code>src---&gt; new ---&gt; package</code> ，比如新建 <em>package</em> 名为：<em>HELLOJAVA</em>；</p>
<p>右键选中 <em>HELLOJAVA</em> 包，<code>HELLOJAVA--&gt; new --&gt; class</code> ，新建类名为 <code>hello</code>：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561347064145.png" alt="1561347064145"></p>
</li>
<li>
<p>编辑<code>hello.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span>   //选择创建<span class="title">class</span>，会自动创建同名类名</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="comment">//里面参数不能少</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello JAVA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置</p>
<p>这个时候直接运行是运行不了的，还要设置一些东西，点击下图按钮添加配置信息：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561349225085.png" alt="1561349225085"></p>
<p>选择模板 &amp; 主函数位置：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561349369104.png" alt="1561349369104"></p>
</li>
<li>
<p>运行</p>
<p>选择 <code>hello.java</code>文件，右键选择 <code>run “hello.main()”</code> 即可。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561349534573.png" alt="1561349534573"></p>
</li>
</ol>
<h1>第二章 ：JAVA基本知识</h1>
<h2 id="2-1-面对对象">2.1 面对对象</h2>
<h3 id="实战">实战</h3>
<p>设计一个<em>Hero</em> 类对象VN，有一些属性；有加血函数等。</p>
<ul>
<li>
<p>在<code>Hero</code>类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//设计一些属性</span></span><br><span class="line">    String name; <span class="comment">//String 第一个S是大写</span></span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line">    <span class="keyword">int</span> moveSpeed;</span><br><span class="line">    <span class="comment">//函数：加血</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addHP</span><span class="params">(<span class="keyword">int</span> blood)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HP += blood;</span><br><span class="line">        System.out.println(<span class="string">&quot;加血!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>Hello</code>类中</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello JAVA&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用item类，实例出一个对象</span></span><br><span class="line">        Hero i = <span class="keyword">new</span> Hero();</span><br><span class="line">        i.name = <span class="string">&quot;vn&quot;</span>;</span><br><span class="line">        i.HP = <span class="number">2000</span>;</span><br><span class="line">        i.addHP(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 输出结果：</span></span><br><span class="line"><span class="comment"> Hello JAVA</span></span><br><span class="line"><span class="comment"> 加血!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p><em>java</em> 面对对象和 <em>C#</em> 目前有以下区别：</p>
<ul>
<li><em>java</em> 每次 <em>new --&gt; class</em> ，在这个新类中只能写一个类，有多个类会报错</li>
<li><code>System.out.println</code> 还不太熟，官方文档语焉不详的，待摸索怎么读官方文档。</li>
</ul>
<h2 id="2-2-变量">2.2 变量</h2>
<h3 id="变量类型">变量类型</h3>
<ol>
<li>
<p>整型 <em>int</em>（4种）</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th>缺省值</th>
<th>长度</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td>0</td>
<td>8</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td>0</td>
<td>16</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td>0</td>
<td>32</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td>0</td>
<td>65</td>
<td>-9223372036854775808  ~ 9223372036854775807</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>即使声明 <em>long</em> 类型，也要以 L或者l结尾，否则是int类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> val = <span class="number">1234567890</span>;  <span class="comment">// 报错，被当成int类型超出范围</span></span><br><span class="line"><span class="keyword">long</span> val = <span class="number">1234567890L</span>;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>int</em> 类型 也可以表示 4种进制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> decVal = <span class="number">26</span>;       <span class="comment">//默认int型</span></span><br><span class="line"><span class="keyword">int</span> hexVal = <span class="number">0x1a</span>;     <span class="comment">//16进制</span></span><br><span class="line"><span class="keyword">int</span> oxVal = <span class="number">032</span>;       <span class="comment">//8进制</span></span><br><span class="line"><span class="keyword">int</span> binVal = <span class="number">0b11010</span>;  <span class="comment">//2进制</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>字符型 <em>char</em></p>
<p>可以用<em>char</em> 类型表示一些转义字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是转义字符</span></span><br><span class="line"><span class="keyword">char</span> tab = <span class="string">&#x27;\t&#x27;</span>;               <span class="comment">// 制表符</span></span><br><span class="line"><span class="keyword">char</span> carriageReturn = <span class="string">&#x27;\r&#x27;</span>;    <span class="comment">// 回车</span></span><br><span class="line"><span class="keyword">char</span> newLine = <span class="string">&#x27;\n&#x27;</span>;           <span class="comment">// 换行</span></span><br><span class="line"><span class="keyword">char</span> doubleQuote = <span class="string">&#x27;\&quot;&#x27;</span>;       <span class="comment">// 双引号</span></span><br><span class="line"><span class="keyword">char</span> singleQuote = <span class="string">&#x27;\&#x27;&#x27;</span>;       <span class="comment">// 单引号</span></span><br><span class="line"><span class="keyword">char</span> backslash = <span class="string">&#x27;\\&#x27;</span>;         <span class="comment">// 反斜杠</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>浮点型 <em>float、double</em></p>
<p><em>float</em> 类型表示浮点数（整数时不报错）时要加f ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">123.456</span>;    <span class="comment">//报错，一定要加f</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">123.456f</span>;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p><em>double</em> 类型表示浮点数不用加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">123.456</span>;   <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">1.23456e2</span> <span class="comment">// 科学技术法 = 1.23456 * 10^2</span></span><br></pre></td></tr></table></figure>
<p><u><em>2020-12-30 总结：</em></u> 在java中，long、float（double不用）类型，变量值还要+前/后缀对应，才能正确定义。</p>
</li>
<li>
<p>布尔型 <em>boolean</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串 <em>String</em></p>
<blockquote>
<p><em>String</em> 类型其实<strong>并不是基本类型</strong> , 而是 <em>lmmutable</em> 类型 ；而且一旦创建不能别改变。</p>
</blockquote>
<p>这里一旦创建不能被改变，不能改变<strong>内容</strong>但是可以改变<strong>引用</strong>指向，比如下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;hello world&quot;</span>;  <span class="comment">//改变成功，改变了引用</span></span><br></pre></td></tr></table></figure>
<p>实际上又成功改变了，因为改变了<em>str</em> 原来指向“<em>hello</em>”  —&gt; 转为指向 “<em>hello world</em>”</p>
</li>
</ol>
<h3 id="类型转换">类型转换</h3>
<ul>
<li>
<p>低精度向高精度转换</p>
<p>这种转换是不需要强制转换的，默认转换就可以。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561429988665.png" alt="1561429988665"></p>
</li>
<li>
<p>高精度向低精度转换</p>
<p>和以前学的无太大区别，注意以下几点：</p>
<ul>
<li>
<p><em>short &amp; char</em> 转换</p>
<p>虽然二者位数相同但是还是要强制转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">80</span>;</span><br><span class="line">c = (<span class="keyword">char</span>) s;  <span class="comment">// 强制转换</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>int</em> 以下数据相加</p>
<p>在 java 世界里，如果<code>精度 &lt; int</code> 进行 数值运算会被自动提升到int类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">2</span>;</span><br><span class="line">System.out.println(getType(a+b)); <span class="comment">// int类型</span></span><br></pre></td></tr></table></figure>
<p>也就是说下面必须要强制转换 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> c = (<span class="keyword">short</span>)(a + b);  <span class="comment">// ※ ※ ※ 注意理解 ※ ※ ※</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="变量修饰-final">变量修饰 <em>final</em></h3>
<p>当一个变量被 <em>final</em> 修饰的时候，该变量<strong>只有一次赋值的机会</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = <span class="number">5</span>  <span class="comment">// 出错，i已经被赋值过来</span></span><br></pre></td></tr></table></figure>
<p>特别的注意，当 <em>final</em> 修饰参数时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        j = <span class="number">5</span>; <span class="comment">//这个能否执行？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时是不能执行的，因为调用方法是 实参<strong>赋值</strong>给形参，j = 5 不能再赋值了。</p>
<h2 id="2-3-输入、输出">2.3 输入、输出</h2>
<h3 id="输出">输出</h3>
<ul>
<li>
<p><em>Println</em></p>
<p>字符串直接可以**+**连接，涉及到复杂一般还是 <em>format</em> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>+<span class="string">&quot; world &quot;</span>); <span class="comment">// 输出：hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>format</em></p>
<ul>
<li>
<p>%s ：表示字符串</p>
</li>
<li>
<p>%n：表示换行符</p>
</li>
<li>
<p>%d：表示整数</p>
<ul>
<li>
<p><strong>%8d</strong>，（默认）右对齐，占8长度 ；<strong>%-8d</strong>，左对齐，8长度；<strong>%08d</strong>，长度8不够补0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">&quot;%08d，%n&quot;</span>,<span class="number">123</span>); <span class="comment">// 输出 00000123</span></span><br><span class="line">System.out.format(<span class="string">&quot;%08d&quot;</span>,<span class="number">123.45</span>); <span class="comment">// 出错，不能是浮点数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>%f：表示浮点数</p>
<ul>
<li>
<p><strong>%.2f</strong>，表示保留两位小数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.format(<span class="string">&quot;%.1f&quot;</span>,<span class="number">123.456</span>);  <span class="comment">// 四舍五入，保留一位小数：123.5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="输入">输入</h3>
<p>输入一般是用 <em>Scanner</em>类 来捕捉用户输入。</p>
<ul>
<li>
<p>基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">// 1. 引用Scanner类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);  <span class="comment">// 2. 实例化 Scanner对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> a = s.nextInt();  <span class="comment">// 读入整数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入整数为 ：&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一行字符串&quot;</span>);</span><br><span class="line">        String str1 = s.nextLine();  <span class="comment">// 3.读取回车键</span></span><br><span class="line">        String str1 = s.nextLine();  <span class="comment">//读入字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入字符串为 ：&quot;</span> + str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读入输入数据首先需要引用 Scanner类 ，且实例化</li>
<li>整数、浮点数、字符串…都有对应 nextInt() 、nextFloat() 、nextLine()  等方法</li>
<li>特别注意 nextLine() 方法，前面有如 ：<strong>nextInt()读入数据 + 回车 ， 会读入回车~</strong></li>
</ul>
</li>
</ul>
<h2 id="2-4-控制流程">2.4 控制流程</h2>
<h3 id="switch"><em>switch</em></h3>
<p><em>switch</em> 可以使用 <em>byte,short,int,char,String,enum</em></p>
<h2 id="2-5-数组">2.5 数组</h2>
<h3 id="声明-创建">声明 &amp; 创建</h3>
<ul>
<li>
<p>一维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个引用</span></span><br><span class="line"><span class="keyword">int</span> a[]; <span class="keyword">int</span>[] a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.分配空间</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.分配空间 &amp; 赋值</span></span><br><span class="line">a = <span class="keyword">new</span>  <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">a = <span class="keyword">new</span>  <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// 省略：(1) [数组大小]</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;           <span class="comment">// 省略：(1) [数组大小] (2) new 分配符</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个引用</span></span><br><span class="line"><span class="keyword">int</span>[][] a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.分配空间</span></span><br><span class="line"><span class="keyword">int</span>[][] a  = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];   <span class="comment">// 虽然一维数组长度被省略，但是要访问必须指定一维数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.分配空间 &amp; 赋值</span></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] a = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;; <span class="comment">// 省略：(1) [][] (2) new 分配符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增强型for循环">增强型for循环</h3>
<ul>
<li>
<p>举例</p>
<blockquote>
<p>循环打印数组内容。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> item : arr)   <span class="comment">// 类比C#：foreach(int item in arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//输出</span><br><span class="line">  1</span><br><span class="line">  2</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常用数组操作">常用数组操作</h3>
<ul>
<li>
<p>复制</p>
<p>用 <em>Arrays 类</em> 实现：</p>
<blockquote>
<p>首先注意，需要引用：<code>import</code> <code>java.util.Arrays;</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  复制数组 :  Arrays.copyOfRange(int[] original, int from, int to)</span></span><br><span class="line"><span class="comment">            - original : 被复制的数组</span></span><br><span class="line"><span class="comment">            - from：复制起始位置</span></span><br><span class="line"><span class="comment">            - to： 复制结束位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] srcArr  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] destArr ; <span class="comment">// 下面复制：自动给目标数组分配空间</span></span><br><span class="line">destArr = Arrays.copyOfRange(srcArr, <span class="number">0</span>, arr.length); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : b)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.print(item + <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>合并</p>
<p>以下利用<em>系统方法</em> 复制实现<em>合并两个数组</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  复制数组  : System.arraycopy(src, srcPos, dest, destPos, length)</span></span><br><span class="line"><span class="comment">            - src : 被复制的数组</span></span><br><span class="line"><span class="comment">            - srcPos：被复制数组起始位置</span></span><br><span class="line"><span class="comment">            - dest：目标数组</span></span><br><span class="line"><span class="comment">            - destPos：复制到目标数组的起始位置</span></span><br><span class="line"><span class="comment">            - length ：复制的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];</span><br><span class="line">System.arraycopy(arr1, <span class="number">0</span>, arr3,<span class="number">0</span> ,arr1.length); <span class="comment">// 必须新数组长度容下前2个数组</span></span><br><span class="line">System.arraycopy(arr2, <span class="number">0</span>, arr3,arr1.length ,arr2.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr3)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(item + <span class="string">&quot;&quot;</span>);  <span class="comment">// 最终输出： 1 2 3 4 5 6 7 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>转换成字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  转字符串  :Arrays.toString(src);</span></span><br><span class="line"><span class="comment">            - src : 被转换的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] srcArr  = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String content = Arrays.toString(srcArr);</span><br><span class="line">System.out.println(content); <span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  排序  : Arrays.sort(src);</span></span><br><span class="line"><span class="comment">         - src : 被排序的数组</span></span><br><span class="line"><span class="comment">  返回值  : 无返回值！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>[] srcArr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"> Arrays.sort(srcArr);  <span class="comment">// 无返回值</span></span><br><span class="line"> System.out.println(Arrays.toString(srcArr)); <span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二分查找（必须先<em>sort</em>排序！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  查找  : Arrays.binarySearch(src,elem);</span></span><br><span class="line"><span class="comment">         - src : 被搜索的数组</span></span><br><span class="line"><span class="comment">         - elem : 被搜索的元素</span></span><br><span class="line"><span class="comment">  返回值  : 被搜索元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>[] srcArr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"> Arrays.sort(srcArr);  <span class="comment">// 无返回值</span></span><br><span class="line"> System.out.println(Arrays.binarySearch(srcArr, <span class="number">3</span>)); <span class="comment">// 输出：2（从0计数）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断是否相同</p>
<p><code>System.out.println(Arrays.equals(a, b));</code></p>
</li>
<li>
<p>填充</p>
<p>使用指定元素值，填充数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">Arrays.fill(a, <span class="number">6</span>);  </span><br><span class="line">System.out.println(Arrays.toString(a)); <span class="comment">// 输出：[6,6,6]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>第三章：类和对象</h1>
<h2 id="3-1-基本概念">3.1 基本概念</h2>
<h3 id="引用">引用</h3>
<blockquote>
<p>区分 <code>引用 与 =</code>  ?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h = <span class="number">5</span>; <span class="comment">// 此时 = 表示赋值 ，h 是变量</span></span><br><span class="line">Hero h1 = <span class="keyword">new</span> Hero(); <span class="comment">// 此时 = 表示指向，h1 是引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>一个对象，有多个引用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hero h1 = <span class="keyword">new</span> Hero();</span><br><span class="line">Hero h2 = h1;  <span class="comment">//h2指向h1所指向的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>一个引用，有多个对象</strong></p>
<p>下面 两次 <code>new Hero()</code> 产生了<strong>两</strong>个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hero garen =  <span class="keyword">new</span> Hero(); <span class="comment">// garen 指向Hero对象1</span></span><br><span class="line">garen =  <span class="keyword">new</span> Hero();     <span class="comment">// garen 指向Hero对象2</span></span><br></pre></td></tr></table></figure>
<p>但是，<strong>同一时间只能指向同一个对象</strong>，所以对象1没有引用指向。</p>
</li>
</ul>
<h3 id="继承">继承</h3>
<p>使用 <code>extends</code> 关键字来实现继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 草鞋类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shone</span> <span class="keyword">extends</span> <span class="title">Item</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3>
<ul>
<li>
<p>this参数</p>
<p><code>this</code> 代表当前对象。</p>
<ul>
<li>类函数参数 和  属性重名，<code>this.属性名</code> 访问属性</li>
<li>构造方法中调用另一个构造方法 ，<code>this(参数)</code></li>
</ul>
</li>
<li>
<p>传参（引用类型传参）</p>
<blockquote>
<p>尝试写出下面程序输出结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写出下面输出结果 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span></span><br><span class="line"><span class="class"></span>&#123;      </span><br><span class="line">    String name; <span class="comment">//姓名    </span></span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量       </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name,<span class="keyword">float</span> hp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//复活</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">(Hero h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        h = <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero teemo =  <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">        teemo.hp = teemo.hp - <span class="number">400</span>;  <span class="comment">// 受到400伤害，挂了</span></span><br><span class="line">        teemo.revive(teemo);        <span class="comment">// 复活</span></span><br><span class="line">        System.out.println(teemo.hp);         </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>-17 , 即原来死去teemo血量</p>
</blockquote>
<ul>
<li>
<p>虽然是传递引用，但是在 <em>revive</em> 方法中，此时 hp = 383 ; 退出方法后，h 指向的临时对象被销毁。</p>
</li>
<li>
<p>执行<em>revive</em>方法前，引用<em>teemo</em>指向 死去teemo对象 ；</p>
</li>
<li>
<p>执行<em>revive</em>方法时，引用<em>teemo</em> 复制一份给形参 <em>h</em> ，<em>teemo</em>  和 <em>h</em> 都是指向同一个对象；但是，形参引用<em>h</em>  又new了份新内存，现在它指向的是新<em>Hero</em>对象(无名) 。</p>
<blockquote>
<p>参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangwanpeng/article/details/52454479">对象传参</a></p>
</blockquote>
</li>
<li>
<p>执行<em>revive</em>方法后，引用<em>h</em> 指向对象被销毁，引用<em>teemo</em> 始终指向死去teemo对象。</p>
</li>
</ul>
</li>
</ul>
<h3 id="访问修饰符">访问修饰符</h3>
<p>似乎没有说，对象访问权限？</p>
<blockquote>
<p>下图，是类中属性、方法被修饰后各种情况访问权限。绿色表示可以访问；红色表示不可以。</p>
</blockquote>
<p><img src="http://stepimagewm.how2j.cn/612.png" alt="æ»ç»"></p>
<h3 id="静态方法和属性">静态方法和属性</h3>
<ul>
<li>
<p>静态属性<em>static</em></p>
<ul>
<li>什么时候使用？
<ul>
<li>如果一个属性，每个英雄都不一样，比如<em>name</em>，这样的属性就应该设计为对象属性，因为它是<strong>跟着对象走的</strong>，每个对象的<em>name</em>都是不同的。</li>
<li>如果一个属性，<strong>所有的英雄都共享</strong>，都是一样的，那么就应该设计为<em>类属性</em> = <em>静态属性</em>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态方法<em>static</em></p>
<ul>
<li>
<p>什么时候使用？</p>
<ul>
<li>
<p>如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法；</p>
</li>
<li>
<p>如果一个方法，没有调用<em>任何对象属性</em>，那么就可以考虑设计为类方法。</p>
<blockquote>
<p>比如取随机数 ：<em>Math.random()</em></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>其它特性</p>
<ul>
<li>
<p>静态方法不能调用非静态方法、成员 ；反之却可以。</p>
<blockquote>
<p>实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。所以，不允许，静态方法调用实例成员变量。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象属性初始化">对象属性初始化</h3>
<ul>
<li>
<p>初始化方法</p>
<blockquote>
<p>注：静态属性初始化，除了第三种：不能在构造函数（*非静态函数不能调用静态属性？*可以！见前。）初始化，其余都可以！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明属性时</span></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;first&quot;</span>; </span><br><span class="line">    <span class="comment">// 2.初始化块时</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 3.构造函数时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;third&quot;</span>;      </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化顺序</p>
<p>那么问题来了，上述代码 <em>name 最终被初始化</em> ？</p>
<blockquote>
<p>初始化属性： 静态变量 --&gt; 静态初始化块 --&gt; 变量 --&gt; 初始化块 --&gt; 构造器</p>
</blockquote>
<p>所以，答案是 ： <em>third</em>。</p>
</li>
</ul>
<h2 id="3-2-单例模式">3.2 单例模式</h2>
<blockquote>
<p><em><u>2020-12-23 总结：</u></em>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/BlackPlus28/article/details/82794376">单例模式应用场景 &amp; 特点</a></p>
<p>【场景】</p>
<ul>
<li><strong>例1：回收站</strong>。在windows桌面上打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。也就是说，在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</li>
<li><strong>例2：网站计数器</strong>。 网站的计数器，一般采用单例模式实现。如果存在多个计数器，每一个用户访问都刷新计数器值，计数值难以同步。</li>
<li><strong>例3：程序日志</strong>。 web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。</li>
</ul>
<p>【特点】</p>
<ul>
<li>
<p><strong>优点</strong>：实现了对唯一实例访问的可控；对于一些需要频繁创建和销毁的对象来说可以提高系统的性能。</p>
</li>
<li>
<p><strong>缺点：</strong> 不适用于变化频繁的对象；</p>
<p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p>
<p><strong>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失</strong>。</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>单例模式三元素</p>
<ol>
<li>构造方法私有化</li>
<li>静态属性指向实例</li>
<li>public static的 getInstance方法，返回第二步的静态属性</li>
</ol>
</li>
<li>
<p>饿汉单例模式</p>
<blockquote>
<p><em>饿汉式</em>  ：是立即加载的方式，无论是否会用到这个对象，都会加载</p>
<p><em>举例</em> ：数据库连接，构造立即初始化，启动时感觉会卡顿。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造方法：类外无法 new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.静态属性指向实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 3.每次获取实例都是 2. 中实例，实现单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>懒汉单例模式</p>
<blockquote>
<p><em>饿汉式</em>  ：非立即加载的方式，使用时才会加载。</p>
<p><em>举例</em> ：业务上有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 部分代码略。同饿汉单例模式 ，不过将 2. &amp; 3.中进行一些改变 */</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 2.静态属性指向实例 ： 但不new！</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3.同前：不存在才创建一次，防止创建出不同对象。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(instance == <span class="keyword">null</span>)  </span><br><span class="line">           instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> instance;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-3-枚举类型">3.3 枚举类型</h2>
<ul>
<li>
<p>枚举创建</p>
<blockquote>
<p>enum是特殊class，enum声明定义的类型就是一个类。</p>
<p><em>e.g.</em> 单独写一个颜色枚举类<em>Color.java</em>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), BLACK(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// rgb三属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> redValue; <span class="comment">// 自定义数据域，private为了封装。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> greenValue;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> blueValue;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 构造枚举值，比如RED(255,0,0)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.redValue = r;</span><br><span class="line">    <span class="keyword">this</span>.greenValue = g;</span><br><span class="line">    <span class="keyword">this</span>.blueValue = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>枚举 + <em>switch</em></p>
<p>可以更好限定范围 &amp; 指定各种类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举调用：类名.枚举颜色，创建对象</span></span><br><span class="line">Color color = Color.RED; <span class="comment">// 不用写后面参数</span></span><br><span class="line"><span class="keyword">switch</span> (color)  <span class="comment">// switch 判断是引用（或变量），switch (Season s) 是错误写法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// case break 判断代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>枚举常用方法</p>
<ol>
<li>
<p><em>ordinal</em></p>
<p>返回枚举值在枚举类种的<strong>顺序</strong>。这个顺序根据枚举值声明的顺序而定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Color.RED.ordinal();  <span class="comment">//返回结果：0</span></span><br><span class="line">Color.BLUE.ordinal();  <span class="comment">//返回结果：1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>compareTo</em></p>
<p>Enum中的compareTo返回的是两个枚举值的顺序之差。当然，前提是两个枚举值必须属于同一个枚举类，否则会抛出ClassCastException()异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.RED.compareTo(Color.BLUE);  <span class="comment">//返回结果 -1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>[静态]<em>values</em></p>
<p>静态方法，返回一个包含全部枚举值的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Color[] colors=Color.values();</span><br><span class="line"><span class="keyword">for</span>(Color c:colors)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.print(c+<span class="string">&quot;,&quot;</span>); </span><br><span class="line">&#125; <span class="comment">//返回结果：RED,BLUE,BLACK YELLOW,GREEN,</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>toString</em></p>
<p>返回枚举常量的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Color c=Color.RED;</span><br><span class="line">System.out.println(c);<span class="comment">//返回结果: RED</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>valueOf</em></p>
<p>这个方法和<em>toString</em>方法是相对应的，返回带指定名称的指定枚举类型的枚举常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.valueOf(<span class="string">&quot;BLUE&quot;</span>);   <span class="comment">//返回结果: Color.BLUE</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>equals</em></p>
<p>比较两个枚举类对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK源代码：      </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>==other;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1>第四章：接口与继承</h1>
<h2 id="4-1-接口">4.1 接口</h2>
<blockquote>
<p><em>JAVA</em>中使用接口，需要创建一个 <em>new --&gt; class —&gt; 下拉选择 Interface —&gt; IAD.java</em></p>
</blockquote>
<p>下面实现一个 <em>AD</em>英雄 <em>implements</em> <em>AD</em>接口。</p>
<ol>
<li>
<p>在 <em>IAD.java</em> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAD</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ADAttack</span><span class="params">()</span></span>;  <span class="comment">// 接口不能有体:&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <em>ADHero.java</em> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">IAD</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">// 加上这句IDE自动显示可以继承的方法；但没有这句也可自己写方法覆写。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ADAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出了物理伤害！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-2-对象转换">4.2 对象转换</h2>
<ul>
<li>
<p>基本概念</p>
<ul>
<li>
<p>引用类型 &amp; 对象类型</p>
<p>通常，引用类型 和 对象类型 是一致的，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br></pre></td></tr></table></figure>
<ul>
<li>引用<em>ad</em> 指向了<em>new</em>出的新对象，它们类型都是 <em>ADHero</em>。</li>
<li>如果 <em>引用类型 ≠ 对象类型</em>：则是下述的<em>类型转换</em>问题。</li>
</ul>
</li>
<li>
<p>向上转型 / 向下转型</p>
<p>“向上”、“向下”：是一种继承的概念，父类在子类上 ；类在继承的接口上。</p>
<p>向上转型：则指 子类转父类 ；类转为<em>继承</em>的接口。（<strong>可行</strong>）</p>
</li>
</ul>
</li>
<li>
<p>向上转型</p>
<blockquote>
<p>苹果手机 继承 手机，把苹果手机当做普通手机使用；<br>
怡宝纯净水 继承 饮品， 把怡宝纯净水当做饮品来使用。</p>
</blockquote>
<p>总结：特殊可转一般，子转父、子转接口。</p>
<ul>
<li>
<p>子类转父类</p>
<p>下面 把物理英雄转普通英雄，显然是可行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hero h;   <span class="comment">// 不new！</span></span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">// 【注意】：h指向的是ADHero对象，但只能使用 Hero 类方法属性！</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>子类转父接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">AD adi = ad;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>向下转型（强制）</p>
<blockquote>
<p>父类转子类，<em>有的时候行</em>，有的时候不行，所以必须进行强制转换。</p>
</blockquote>
<ul>
<li>
<p>父类转子类</p>
<p>下面，这种情况向下转型<strong>可行</strong>：因为第三行子类转父类，<em>h指向ADHero对象（但只能使用 Hero 类方法属性）</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">// 父类（基类）引用h 指向--&gt; ADHero对象</span></span><br><span class="line">ad = (ADHero) h;</span><br></pre></td></tr></table></figure>
<p>所以上面代码表现的好像是，父类转子类成功，其实是 <em>ADHero转换为ADHero</em>。</p>
</li>
<li>
<p>父接口转子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">AD Iad = ad; <span class="comment">// 引用Iad指向 ADHero对象</span></span><br><span class="line">ADHero adHero = (ADHero) Iad;  <span class="comment">// ADHero 转 ADHero ，可行</span></span><br><span class="line">ADAPHero adapHero = (ADAPHero) Iad; <span class="comment">// 不可行，ADHero 不能转 ADAPHero</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>没有继承关系转换</p>
<p>一定失败，不多言。</p>
</li>
<li>
<p><em>instanceof</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">Hero h1 = ad;</span><br><span class="line"><span class="comment">//判断引用h1指向的对象，是否是ADHero类型</span></span><br><span class="line">System.out.println(h1 <span class="keyword">instanceof</span> ADHero);  <span class="comment">// 输出：true</span></span><br><span class="line"><span class="comment">//判断引用h1指向的对象，是否是Hero的子类型</span></span><br><span class="line">System.out.println(h1 <span class="keyword">instanceof</span> Hero);   <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-3-重写-隐藏-重载">4.3 重写 &amp; 隐藏 &amp; 重载</h2>
<ul>
<li>
<p>重写</p>
<p>重写：是不改变父类的方法名字和参数个数和类型，简单点说就是实现跟父类不一样的功能。</p>
<p>关键字：继承、不同类，和父类方法只有方法体不一样。</p>
</li>
<li>
<p>隐藏</p>
<p>隐藏：是有一个跟父类一样的<strong>静态</strong>方法，调用的时候就直接用子类的静态方法了。</p>
<p>关键字：继承、不同类，和父类方法只有方法体不一样、<strong>静态</strong>。</p>
</li>
<li>
<p>重载</p>
<p>重载：是方法重载,方法签名完全一致,参数类型和个数不同,JVM就可以识别并调用重载方法。</p>
<p>关键字：同类、和同类同名方法参数类型、个数、方法体都不同。</p>
</li>
</ul>
<h2 id="4-4-多态">4.4 多态</h2>
<p>多态一般分为：操作符多态；类多态，由<strong>类型向上转换 + 重写/重载</strong>  实现；</p>
<h3 id="操作符多态">操作符多态</h3>
<ul>
<li>
<p>概念</p>
<p>如：<strong>+</strong>  既可以表示 <em>数字相加</em> 也可表示 <em>字符串连接</em> 等，由<em>运算符重载</em>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> str = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运算符重载</p>
</li>
</ul>
<h3 id="类多态">类多态</h3>
<p>类多态一般需满足两个条件：</p>
<ol>
<li>
<p>父类（接口）指向 子类对象</p>
<blockquote>
<p>因为所谓类多态，就是可以用 基/父类 指向子类</p>
</blockquote>
</li>
<li>
<p>调用方法有<strong>重写</strong></p>
<blockquote>
<p>同前，父类虽然在<strong>1.</strong> 指向子类对象，但只可以使用父类方法、属性；如果想调用子类方法，那么在父类和子类都声明同名方法，这样<em>父类.方法()—&gt; 执行 —&gt; 子类.方法()</em>。</p>
</blockquote>
</li>
</ol>
<ul>
<li>
<p>类多态作业1：重写 实现多态</p>
<blockquote>
<p>分别有以下两个类：</p>
<p><em>MagicPortion</em>类，*effec()*使用后回蓝；</p>
<p><em>LifePortion</em> 类，*effec()*使用后回血；</p>
<p>Hero类对象 VN，VN调用本身方法 <em>userItem(参数)</em> 即可实现回血、回蓝等物品使用。</p>
</blockquote>
<ul>
<li>
<p>实现父类接口 <em>Item</em></p>
<p>要实现多态，我们在外面使用<strong>一个父类</strong>引用指向<strong>不同子类</strong>对象，再用其调用子类方法。</p>
<p>这样，不必为不同子类对象生成不同对应引用，比如可使得<em>函数参数统一</em>等（见后）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实现 <em>MagicPortion、LifePortion</em> 类</p>
<p><em>MagicPortion</em>类，*effec()*使用后回蓝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicPortion</span> <span class="keyword">implements</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用蓝瓶回蓝100！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>LifePortion</em> 类，*effec()*使用后回血：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifePortion</span> <span class="keyword">implements</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用血瓶回血100！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>Hero</em>类表现多态</p>
<p>要表现多态，让父类指向子类对象，同时可以执行<em>子类同名</em>（重写）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">useItem</span><span class="params">(Item i)</span> <span class="comment">//父类接口Item做参数，可以接收不同子类对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，统一了函数参数，一个方法（不必重载）就可以实现各种物品使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主函数main()中</span></span><br><span class="line">Hero VN = <span class="keyword">new</span> Hero();</span><br><span class="line">Item i1 = <span class="keyword">new</span> MagicPortion();</span><br><span class="line">Item i2 = <span class="keyword">new</span> LifePortion();</span><br><span class="line">VN.useItem(i1);  <span class="comment">// 输出：使用蓝瓶回蓝100！</span></span><br><span class="line">VN.useItem(i2);  <span class="comment">// 输出：使用血瓶回血100！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>类多态作业2：隐藏<em>static</em>无法体现多态</p>
<p>如果将 <em>Item</em> 类改为以下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span>  // 1.接口--&gt;类，隐藏只支持类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">effect</span><span class="params">()</span>  <span class="comment">// 2.+static，关键字</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;物品产生一些效果&quot;</span>); <span class="comment">// 3.添加方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <em>MagicPortion &amp; LifePortion</em>  类 <em>effect()</em> 也加上<em>static</em>关键字实现同名隐藏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">effect</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这个时候主函数输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主函数main()中</span></span><br><span class="line">Hero VN = <span class="keyword">new</span> Hero();</span><br><span class="line">Item i1 = <span class="keyword">new</span> MagicPortion();</span><br><span class="line">VN.useItem(i1);  <span class="comment">// 输出：物品产生一些效果</span></span><br></pre></td></tr></table></figure>
<p>原因如下：</p>
<blockquote>
<p><em>隐藏</em> 对方法都加上了<em>static</em>关键字，无法在 <code>Item i1 = new MagicPortion();</code> ，实现引用 <em>i1</em><strong>动态绑定</strong> 静态方法，也就无法实现多态！</p>
</blockquote>
</li>
</ul>
<h2 id="4-5-super-final">4.5 <em>super &amp; final</em></h2>
<ul>
<li>
<p>利用<em>super</em>调用父类属性、方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">   <span class="comment">//在某个方法中</span></span><br><span class="line">   <span class="keyword">super</span>.moveSpeed;  <span class="comment">// 1.调用父类属性</span></span><br><span class="line">   <span class="keyword">super</span>.useItem(i); <span class="comment">// 2.调用父类方法userItem</span></span><br><span class="line">   <span class="keyword">super</span>();          <span class="comment">// 3.调用父类无参构造函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>final</em> 修饰</p>
<ul>
<li>
<p>修饰类：类无法被继承</p>
<blockquote>
<p>如，可用自定义类 <em>someString</em> 继承系统类 <em>String</em> ，结果如何？</p>
</blockquote>
<p>不能继承，因为 系统类 <em>String</em> ，是被 <em>final</em> 关键字修饰的。</p>
</li>
<li>
<p>修饰方法：方法不能被重写</p>
</li>
<li>
<p>修饰变量：只能被赋值<strong>1</strong>次</p>
<blockquote>
<p>如，可利用这点，设置一个常量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰引用：只有<strong>1</strong>次指向引用的机会</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-6-抽象类">4.6 抽象类</h2>
<ul>
<li>
<p>基本概念</p>
<ul>
<li>
<p>类带有 abstract 关键字修饰就是抽象类；</p>
</li>
<li>
<p>含有抽象方法必须是抽象类；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法attack：[1] abstract修饰 [2] 无方法体</span></span><br><span class="line">    <span class="comment">// Hero的子类会被要求实现attack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抽象类不能被实例化，专门用来继承的。</p>
</li>
</ul>
</li>
<li>
<p>抽象类 和 接口区别</p>
<ul>
<li>
<p>默认方法实现</p>
<p>抽象类可以有非抽象方法，有方法体 ； 接口不能有。</p>
<blockquote>
<p>抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
</blockquote>
<p>再精辟点总结：</p>
<blockquote>
<p>抽象类，既 1.非抽象类实现代码复用 2.又同时有抽象方法使得被继承类各自实现。</p>
<p>接口，是对类的行为进行约束，强制要求不同类实现相同行为。</p>
</blockquote>
</li>
<li>
<p>构造函数</p>
<p>抽象类有；接口没有。</p>
</li>
<li>
<p>修饰符</p>
<p>抽象类除private 都有（抽象类目的是被继承，抽象方法是为被重写）；接口only public。</p>
</li>
<li>
<p>继承个数 [<strong>接口优</strong>]</p>
<p>抽象类只能被继承一次；接口可以有多个。</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-7-内部类">4.7 内部类</h2>
<blockquote>
<p>暂时不知道什么时候用得到，先不展开：<a target="_blank" rel="noopener" href="http://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#nowhere">讲解内部类链接</a></p>
</blockquote>
<ul>
<li>非静态内部类</li>
<li>静态内部类</li>
<li>匿名类</li>
<li>本地类</li>
</ul>
<h2 id="4-8-默认方法">4.8 默认方法</h2>
<p>默认方法是指 ：接口的抽象方法，加上 <em>default</em> 关键字，可以有方法体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处：</p>
<blockquote>
<p>假设没有默认方法这种机制，那么如果要为<em>Mortal</em>增加一个新的方法<em>revive</em>,那么所有实现了<em>Mortal</em>接口的类，都需要做改动实现 <em>revive</em>。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
</blockquote>
<h2 id="4-9-UML图">4.9 UML图</h2>
<ul>
<li>
<p>类图解释</p>
<p><img src="http://stepimagewm.how2j.cn/2318.png" alt="è§£éUML-ç±»å¾"></p>
</li>
<li>
<p>接口图解释</p>
<p><img src="http://stepimagewm.how2j.cn/2319.png" alt="è§£éUML-æ¥å£å¾"></p>
</li>
<li>
<p>继承关系解释</p>
<p><em>实线</em>：表示继承类，如下图 <em>Spider</em> 类继承 <em>Animal</em> 类；</p>
<p><em>虚线</em>：表示继承接口，如下图 <em>Cat</em>类 继承 <em>Pet</em> 接口。</p>
<p><img src="http://stepimagewm.how2j.cn/2305.png" alt="UML å¾ ââ ç±»ä¹é´çå³ç³»"></p>
</li>
</ul>
<h1>第五章：数字 和 字符串</h1>
<h2 id="5-1-拆箱、装箱">5.1 拆箱、装箱</h2>
<ul>
<li>
<p>关于拆箱、装箱基本概念</p>
<blockquote>
<p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong> ，又称为<strong>封装类</strong>，也是<strong>数值与包类型转换</strong>。</p>
</blockquote>
<p>下面是所有<em>数值</em> 基本类型，对应的类型型，它们又都是抽象类 <em>Number</em> 的子类。</p>
<p><img src="http://stepimagewm.how2j.cn/672.png" alt="Numberç±»"></p>
<ul>
<li>如：基本类型 <em>int</em> --&gt; 对应封装类 <em>Integer</em> ； <em>short</em> --&gt; 对应封装类 <em>Short</em> …</li>
</ul>
</li>
<li>
<p>装箱</p>
<blockquote>
<p>装箱，即将 <em>基本类型</em><strong>自动</strong> 转换成<em>封装类型</em>，自动又是通过**=** 号实现。</p>
</blockquote>
<p>先看一个<em>非装箱</em>，自己调用构造方法实现 基本类型–&gt; 封装类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非装箱转换成封装类</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> Integer it = <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
<p>如果 用 = 号 实现自动上述过程，则称为装箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// = 自动装箱</span></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> Integer it = i; <span class="comment">// = 自动实现类型转换，无需new</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拆箱</p>
<blockquote>
<p>和装箱类似，即将 <em>封装类型</em><strong>自动</strong> 转换成 <em>基本类型</em>，自动又是通过**=** 号实现。</p>
</blockquote>
<p><em>非拆箱</em>，自己调用构造函数实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非拆箱实现转换成基本类型</span></span><br><span class="line"> Integer it = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">int</span> i = it.intValue();</span><br></pre></td></tr></table></figure>
<p>拆箱实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// = 自动拆箱</span></span><br><span class="line"> Integer it = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">int</span> i = it; <span class="comment">// = 自动实现类型转换</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拆箱、装箱之惑</p>
<ul>
<li>
<p>存在的意义？</p>
<blockquote>
<p>为什么要有装箱、拆箱，它们的作用是什么？</p>
</blockquote>
<p><em>java</em> 是 面对对象编程，而基本数据类型不是对象，所有才有封装类 引用基本数据类型。</p>
<p>比如，下面打印出<em>int</em>型数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>
<p>其实，查看源码，实际经过以下几个过程：</p>
<ul>
<li>将 <em>i</em> 自动装箱成封装类 <em>Integer</em></li>
<li>然后调用 <em>Integer</em>中 <em>toString</em>() 方法，打印出字符串输出到控制台。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-类型转换">5.2 类型转换</h2>
<h3 id="数值类型之间">数值类型之间</h3>
<ul>
<li>
<p>位数低—&gt;高</p>
<blockquote>
<p>低—&gt;高：<em>byte,char(1) --&gt; short(2)–&gt; int(4) --&gt; long(8) --&gt; float(8) --&gt; double(16)</em></p>
</blockquote>
</li>
<li>
<p>强制转换</p>
<p>如果是低位向高位转换，则自动转换；反之，则需要 <code>()</code> 强制转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = b; <span class="comment">// 可，自动转换。</span></span><br><span class="line">b = (<span class="keyword">byte</span>)s; <span class="comment">// 强制</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>表达式类型提升</p>
<p>如果，数值类型参与运算，<strong>操作符两端类型要一致</strong>，有以下几个原则：</p>
<ul>
<li>
<p><em>byte、short</em>和<em>char</em> 自动提升int型；</p>
</li>
<li>
<p>操作数含<em>long</em>型，则整个表达式类型提升为<em>long</em>型；</p>
</li>
<li>
<p>操作数含 <em>float / double</em> 型，则整个表达式提升为 <em>float /double</em>型表示；</p>
</li>
<li>
<p><em>long、float、double</em>，同时出现，提升优先：<em>double &gt; float &gt; long</em> 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="数值类型-char">数值类型 &amp; <em>char</em></h3>
<p>基本规则和数值类型直接按位数，是否强制转换很相似，但有一点不同：</p>
<ul>
<li>
<p><em>char &amp; byte  &amp; short</em>  之间, 除了 <em>byte</em> 转换成 <em>short</em> 都是强制转换；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">0</span>; <span class="keyword">char</span> c = <span class="number">1</span>; <span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">s = (<span class="keyword">short</span>) c; <span class="comment">// 虽然short位数4，但是还是要强制转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) b;</span><br><span class="line">b = (<span class="keyword">byte</span>) c;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数值类型-String">数值类型 &amp; <em>String</em></h3>
<ul>
<li>
<p>数值类型 &lt;— <em>String</em></p>
<p><em>String</em> 转为 数值类型，一般有如下三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> String str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：数值类型对应封装类.parse方法</span></span><br><span class="line"> <span class="keyword">int</span> a1 = Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：手动装箱 --&gt; 手动拆箱</span></span><br><span class="line"><span class="comment">// 等价自动拆箱：int a2 = Integer.valueOf(str);</span></span><br><span class="line"> Integer it2 = Integer.valueOf(str);</span><br><span class="line"> <span class="keyword">int</span> a2 = it2.intValue(); <span class="comment">// 可以更简单=自动拆箱：int a2 = it2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：手动装箱 --&gt; = 自动拆箱</span></span><br><span class="line"> <span class="keyword">int</span> a3 = <span class="keyword">new</span> Integer(str);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>String</em>  &lt;—  数值类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：数值类型对应封装类.toString方法</span></span><br><span class="line"> String str1 = Integer.toString(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：先装箱再拆箱：手动装箱--&gt; = 自动拆箱</span></span><br><span class="line"> String str2 = String.valueOf(i);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="int-String"><em>int[] &amp; String</em></h3>
<ul>
<li>
<p><em>int[]</em> 转换 <em>string</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.*；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用Arrays类方法</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">string s = Arrays.toString(arr)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="String-char-char"><em>String</em> &amp; <em>char</em> <em>&amp; char[]</em></h3>
<ul>
<li>
<p><em>String</em>转换为<em>char</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 和 char 之间转换</span></span><br><span class="line">String str = <span class="string">&quot;123&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> c = str.charAt(<span class="number">0</span>);         <span class="comment">// 转换成字符</span></span><br><span class="line"><span class="keyword">char</span>[] c1 = str.toCharArray();  <span class="comment">// 转换成字符数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>char</em> 转换成 <em>String</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;1&#x27;</span>; String str1 ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：利用每种基本类型对应封装类都有的.toString方法</span></span><br><span class="line">str1 = Character.toString(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：valueOf装箱 --&gt; =自动拆箱</span></span><br><span class="line">str1 = String.valueOf(c1);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>char[] 转换为string</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.直接在构造String时建立。 </span></span><br><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;k&#x27;</span>&#125;; </span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.String有方法可以直接转换。</span></span><br><span class="line"> <span class="keyword">char</span>[] cha = &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;; </span><br><span class="line">String n = String.valueOf(cha);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="String-byte"><em>String</em> &amp; <em>byte[]</em></h3>
<ul>
<li>
<p><em>String</em>转换为<em>byte[]</em></p>
<p>和转换成 <em>char</em> 类似，可以调用对象本身的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>; </span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>byte[]</em> 转换成 <em>String</em></p>
<p>也同 <em>char</em> 转 <em>String</em> 类似，利用装箱拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="引用类型之间">引用类型之间</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>向上转换，父类引用 &lt;— 子类引用，可转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = s； <span class="comment">// 子转父</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实，<strong>本质</strong> <em>p</em>指向了 <em>Student</em>对象，虽然只能使用<em>Person</em>方法，等价这种写法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> Student(); <span class="comment">// Student对象无名引用，转换成父类 Person</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向下转换，子类引用 &lt;— 父类引用，<em>抛出异常</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = (Student)p; <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果无继承关系引用转换，<strong>编译错误</strong>！</p>
</li>
</ul>
<h2 id="5-3-数学方法">5.3 数学方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.四舍五入</span></span><br><span class="line">Math.round(<span class="number">5.5</span>);    <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 2.随机数</span></span><br><span class="line">Math.random();      <span class="comment">// [0-1) 之间随机数</span></span><br><span class="line">Math.random()*<span class="number">10</span>;   <span class="comment">// [0-10) 之间随机数</span></span><br><span class="line"><span class="comment">// 3.开方</span></span><br><span class="line">Math.sqrt(<span class="number">9</span>)</span><br><span class="line"><span class="comment">// 4.次方</span></span><br><span class="line">Math.pow(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 5.常数</span></span><br><span class="line">Math.PI  <span class="comment">// π</span></span><br><span class="line">Math.E   <span class="comment">// 自然常数</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-Sting-常用方法">5.4 <em>Sting</em> 常用方法</h2>
<h3 id="单字符串操作">单字符串操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello java!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><em>常用方法见下：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.返回字符</span></span><br><span class="line">str.charAT(<span class="number">0</span>);         <span class="comment">// 返回str第一个字符</span></span><br><span class="line"><span class="comment">// 2.返回字符数组</span></span><br><span class="line">str.toCharArray();  </span><br><span class="line"><span class="comment">// 3.截取字符串</span></span><br><span class="line">str.substring(<span class="number">3</span>);    <span class="comment">// 从第3个字符开始截取</span></span><br><span class="line">str.substring(<span class="number">3</span>,<span class="number">5</span>);  <span class="comment">// [3,5):截取第3--&gt;第5字符，不含第5</span></span><br><span class="line"><span class="comment">// 4.分隔字符串</span></span><br><span class="line">str.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line"><span class="comment">// 5.去除首尾空格</span></span><br><span class="line">str.trim();  </span><br><span class="line"><span class="comment">// 6.大小写</span></span><br><span class="line">str.toLowerCase()</span><br><span class="line">str.toUpperCase()</span><br><span class="line"><span class="comment">// 7.定位</span></span><br><span class="line">str.indexOf(<span class="string">&#x27;l&#x27;</span>);     <span class="comment">// 返回l第一次出现位置：2</span></span><br><span class="line">str.lastIndexOf(<span class="string">&#x27;l&#x27;</span>);  <span class="comment">// 返回l最后一次出现位置：3</span></span><br><span class="line"><span class="comment">// 8.包含</span></span><br><span class="line">str.contains(<span class="string">&quot;java&quot;</span>);  <span class="comment">// 返回：ture</span></span><br></pre></td></tr></table></figure>
<h3 id="多字符串操作">多字符串操作</h3>
<ul>
<li>
<p>比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(str1); </span><br></pre></td></tr></table></figure>
<p><em>常用操作方法：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.是否同一对象</span></span><br><span class="line"> System.out.println( str1  ==  str2); <span class="comment">//虽然，内容相同但不是同一对象</span></span><br><span class="line"><span class="comment">// 2.是否内容相同</span></span><br><span class="line"> System.out.println(str1.equals(str2)); <span class="comment">//返回 ：ture</span></span><br><span class="line"> System.out.println(str1.equalsIgnoreCase(str3)); <span class="comment">// 忽略大小写，比较</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以特定字符结束/开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;the light&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ht&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><em>使用举例：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.判断以特定字符开始</span></span><br><span class="line">System.out.println(str1.startsWith(str2)); <span class="comment">// 返回false</span></span><br><span class="line"><span class="comment">// 2.判断以特定字符结束</span></span><br><span class="line">System.out.println(str1.endsWith(str2)); <span class="comment">// 返回ture</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-5-StringBuffer类">5.5 <em>StringBuffer</em>类</h2>
<p>比<em>String</em>基本类型，能更好操作字符串：追加、删除、插入、反转等，而且<u>性能佳</u>！</p>
<blockquote>
<p>为什么<em>StringBuffer</em>可以变长？</p>
<p>和<em>String</em> 和 <em>StringBuffer</em> 内部都维护了一个字符数组，但是<em>StringBuffer</em> 还有<strong>冗余长度</strong>。</p>
</blockquote>
<ul>
<li>
<p>声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello java!&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.追加</span></span><br><span class="line">sb.append(<span class="string">&quot;啊，我死了！&quot;</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// hello java!啊，我死了！</span></span><br><span class="line"><span class="comment">// 2.删除</span></span><br><span class="line">sb.delete(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// hello!啊，我死了！</span></span><br><span class="line"><span class="comment">// 3.插入</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// hello!!啊，我死了！</span></span><br><span class="line"><span class="comment">// 4.反转</span></span><br><span class="line">sb.reverse(); <span class="comment">//反转</span></span><br><span class="line">System.out.println(sb); <span class="comment">// ！了死我，啊!!olleh</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sb.length(); <span class="comment">//内容长度：13</span></span><br><span class="line">sb.capacity(); <span class="comment">//总容量：27（有冗余）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>第六章：日期</h1>
<h2 id="6-1-Date类">6.1 <em>Date</em>类</h2>
<blockquote>
<p>什么是时间原点？</p>
</blockquote>
<p>时间原点是：<em>1970/1/1 8:0:0</em> 。所有的日期，以此为基准，每过一毫秒，就+1。</p>
<blockquote>
<p>如何引进日期类库？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.不带参数，当前时间</span></span><br><span class="line">Date d = <span class="keyword">new</span>  Date();</span><br><span class="line">System.out.println(d);  <span class="comment">// 输出：Sat Jun 29 22:11:23 CST 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.带参数(整数)，时间：原点+整数/1000(秒)</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(<span class="number">1000</span>);</span><br><span class="line">System.out.println(d1); <span class="comment">// 输出：Thu Jan 01 08:00:01 CST 1970</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.getTime:获取 当前时间 - 原点 毫秒数</span></span><br><span class="line">System.out.println(d.getTime());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-2-SimpelDateFormat-类">6.2 <em>SimpelDateFormat</em> 类</h2>
<p><em>SimpelDateFormat</em> 类 用来格式化日期输出。</p>
<blockquote>
<p>如何引用？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>格式<em>Date</em>对象</p>
<p>⚠️注意，下面格式模式 <em>MM 、HH</em> 必须大写，否则出错！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 1.创建SimpleDateFormat对象，并指定格式模式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// 2.利用format方法，格式Date对象，并返回String类型</span></span><br><span class="line">String str = sdf.format(d); <span class="comment">// 返回String类型</span></span><br><span class="line"><span class="comment">// 3.输出测试</span></span><br><span class="line">System.out.println(str); <span class="comment">// 输出：2019/06/29 22:53:00</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>格式<em>String</em>对象</p>
<p>⚠️注意，<em>parse</em>方法，必须在一对 <em>try catch</em> 块中，否则编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;2019/01/01 00:00:00&quot;</span>;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 1.创建SimpleDateFormat对象，并指定格式模式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// 2.parse方法，格式String对象，并返回Date类型</span></span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    d = sdf.parse(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParseException e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.输出测试</span></span><br><span class="line">System.out.println(d); <span class="comment">// 输出测试：Tue Jan 01 00:00:00 CST 2019</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-3-Calendar类">6.3 <em>Calendar</em>类</h2>
<p><em>Calendar</em> 类 和 <em>Date</em>类相比，更容易进行“翻日历“，进行月份/天等修改。</p>
<blockquote>
<p>如何引用？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>创建对象</p>
<p>⚠️ 只能利用<em>Calendar.getInstance()</em> 获取单例，<em>new</em>需要重写函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.getTime(),返回Date类型对象</span></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">Date d = c.getTime()；</span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Sat Jun 29 23:08:53 CST 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.setTime(Date d),设置时间，无返回</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(<span class="number">0</span>);</span><br><span class="line">c.setTime(d1);</span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.add，在原日期(2019/6/29)上增加 年/月/日</span></span><br><span class="line">c.add(c.YEAR, <span class="number">3</span>); <span class="comment">// 3年后</span></span><br><span class="line">c.add(c.MONTH, -<span class="number">1</span>); <span class="comment">// 前1个月</span></span><br><span class="line">c.add(c.DATE, <span class="number">1</span>);  <span class="comment">// 后1天</span></span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Sun May 30 23:29:06 CST 2022</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.set，可分别设置年月日，区分setTime</span></span><br><span class="line">c.add(c.YEAR, <span class="number">2019</span>); </span><br><span class="line">c.add(c.MONTH, <span class="number">9</span>); </span><br><span class="line">c.add(c.DATE, <span class="number">1</span>);  </span><br><span class="line">System.out.println(c.getTime()); <span class="comment">// 输出：Tue Oct 01 23:34:55 CST 2019</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>第七章：异常</h1>
<h2 id="7-1-异常分类">7.1 异常分类</h2>
<p><img src="http://stepimagewm.how2j.cn/742.png" alt="Throwable"></p>
<ul>
<li>异常分为，<em>Error &amp; Exception</em>，它们都是 <em>Throwable</em> 子类；</li>
<li><em>Exception</em>，又分为运行时异常、可查异常。</li>
</ul>
<h2 id="7-2-异常处理">7.2 异常处理</h2>
<ul>
<li>
<p><em>try cacth</em></p>
<p>尝试打开 LOL，抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中：</span></span><br><span class="line">File f= <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(f);  <span class="comment">// (1) 执行到这出现异常 ---&gt; 执行catch块</span></span><br><span class="line">    System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span>(FileNotFoundException e) <span class="comment">// (2) 出现异常开始处理</span></span><br><span class="line"> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561884324970.png" alt="1561884324970"></p>
<blockquote>
<p>改进：如果不知道抛出异常类型？</p>
<p>可以用父类 <em>Exception</em>，甚至<em>Throwable</em> 进行<em>catch</em> 处理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用父类进行catch(只修改catch块)</span></span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">   System.out.println(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改进：如果有多个错误？</p>
<p>可用多个 <em>catch</em> 块进行处理。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123; // 程序代码 &#125;</span><br><span class="line">catch(异常类型1 异常的变量名1) &#123; // 处理程序 &#125;</span><br><span class="line">catch(异常类型2 异常的变量名2) &#123; // 处理程序 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>try cacth finally</em></p>
<p>有时候希望，无论是否出现异常，都希望有段代码被执行，也就是<em>finally</em>块。</p>
<p>但是有下面几个结合<em>return</em> 情况，值得深思：<a target="_blank" rel="noopener" href="http://www.blogjava.net/fancydeepin/archive/2012/07/08/java_try-catch-finally.html"><em>java</em>异常捕获</a></p>
</li>
<li>
<p><em>throw try cacth</em></p>
<blockquote>
<p>理解不深，待实际操作补充。同时可见下：[自定义异常]</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561886405277.png" alt="1561886405277"></p>
</li>
</ul>
<h2 id="7-3-自定义异常">7.3 自定义异常</h2>
<blockquote>
<p>对 <em>throws</em> 作用理解不深，待补充。</p>
</blockquote>
<ul>
<li>
<p>自定义异常类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span> <span class="keyword">extends</span> <span class="title">Exception</span> // 继承<span class="title">Exception</span>类</span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;flag = 0，发生异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>捕获异常</p>
<p>在 try中抛出异常，然后catch接住异常进行出现(不处理会编译错误)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">try</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> myException(<span class="string">&quot;flag == 0 &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">catch</span> (myException e)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">// 处理异常代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;catch中捕获到异常！&quot;</span> );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1561887319791.png" alt="1561887319791"></p>
</li>
</ul>
<h1>第八章 ： IO流</h1>
<h2 id="8-1-文件对象">8.1 文件对象</h2>
<ul>
<li>
<p>创建对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以当前项目路径(相对路径)创建对象  </span></span><br><span class="line">File f  = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对象常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.重命名文件 -- 不会改变f的name属性</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line">f.renameTo(f1); <span class="comment">// f.getName() 还是test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建文件 -- 存在不会重新创建</span></span><br><span class="line">File f2  = <span class="keyword">new</span> File(<span class="string">&quot;lt.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    f2.createNewFile(); <span class="comment">// 创建了lt.txt文件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) <span class="comment">// 必须处理异常</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建文件夹:不会覆盖</span></span><br><span class="line">File f3  = <span class="keyword">new</span> File(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">f3.mkdir();  <span class="comment">// 创建了 son 文件夹 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.返回目录下文件 &amp; 文件夹</span></span><br><span class="line"><span class="comment">// 以String数组返回</span></span><br><span class="line">String[] str = f3.list();</span><br><span class="line">System.out.println(str[<span class="number">0</span>]); <span class="comment">// 输出目录下第一个文件名字</span></span><br><span class="line"><span class="comment">// 以File数组返回</span></span><br><span class="line">File[] fs = f.listFiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.其它方法</span></span><br><span class="line">f.exists();      <span class="comment">// 判断文件是否存在</span></span><br><span class="line">f.isDirectory(); <span class="comment">// 判断是文件夹</span></span><br><span class="line">f.isFile();      <span class="comment">// 判断是文件</span></span><br><span class="line">f.length();      <span class="comment">// 文件长度</span></span><br><span class="line">f.delete();      <span class="comment">// 删除文件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="8-2-文件流">8.2 文件流</h2>
<p>当需要对文件进行 <em>读取/写入</em> 时，要建立文件 <em>输出/输入</em> 流。</p>
<p>⚠️ 字符流可以一个字符一个字符也可以一行一行读取 ；字节流不可以。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">字节流</th>
<th style="text-align:center">字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">按行读取</td>
<td style="text-align:center">× 一次读取</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">读取中文</td>
<td style="text-align:center">√  更方便</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p><img src="http://stepimagewm.how2j.cn/5678.png" alt="æµå³ç³»å¾"></p>
<h3 id="字节流读写">字节流读写</h3>
<p>以 <u>字节（ASCII）</u> 形式读取和写入数据：<em>InputStream</em>字节输入流  ；<em>OutputStream</em>字节输出流 。</p>
<p>都是 <u>抽象</u> 类，不提供具体实现，可用子类 <em>FileInputStream</em> &amp; <em>FileOutStream</em> 对文件进行读写。</p>
<blockquote>
<p>[读]文件输入流：不用 <em>try catch</em> 捕获异常会报错</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;lt.txt&quot;</span>); <span class="comment">// lt.txt 内容：lt</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">   FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.文件读出数据</span></span><br><span class="line">   <span class="keyword">byte</span>[] all =<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">   fis.read(all);</span><br><span class="line">   <span class="comment">// 打印读取到byte数组文件内容</span></span><br><span class="line">   <span class="comment">// 直接打印打印出的 ASCII码，强制转换成char字符</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">byte</span> b : all)</span><br><span class="line">       System.out.print((<span class="keyword">char</span>)b); <span class="comment">// 输出： lt</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.流关闭</span></span><br><span class="line">    fis.close();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[写]文件输出流：最后查看 <em>hwh.txt</em> 内容被写入 <u><em>hwh</em></u></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>); <span class="comment">// hwh.txt 内容为空</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">   FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.数据写入文件</span></span><br><span class="line">   <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">104</span>,<span class="number">119</span>,<span class="number">104</span>&#125;; <span class="comment">// ASCII 104——&gt;h ; ASCII 119——&gt;w</span></span><br><span class="line">   fos.write(all);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.流关闭</span></span><br><span class="line">    fos.close();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception e)</span><br><span class="line"> &#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流读写">字符流读写</h3>
<p>以 <u>字符</u> 对文件进行读写，<em>Reader</em> 字符输入流；<em>Writer</em> 字符输出流 ，同前都为 <em>抽象类</em> 。</p>
<p>用子类，<em>FileReader &amp; FileWriter</em>、对文件进行字符读写。</p>
<blockquote>
<p>[读] <em>FileReader</em> : 注意是用字符数组 char[] 进行读写，而不是 String</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;lt.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建字符流对象</span></span><br><span class="line">   FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.读取流对象内容</span></span><br><span class="line">   <span class="comment">// String str = null; // 错误，应该是char[]数组</span></span><br><span class="line">   <span class="keyword">char</span> cArr[] = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">   fr.read(cArr);</span><br><span class="line">   <span class="comment">// 打印读取到char数组文件内容</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">char</span> c : cArr)</span><br><span class="line">       System.out.print(c); <span class="comment">// 输出： lt</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 4.流关闭</span></span><br><span class="line">   fr.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[写] <em>FileWriter</em> ：同上注意char[]数组。最好 <em>hwh.txt</em> 文件内容为： <u><em>hwh is a pig</em></u></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 1.创建文件对象</span></span><br><span class="line">   File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">   FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 3.读取流对象内容</span></span><br><span class="line">   String str = <span class="string">&quot;hwh is a  pig&quot;</span>; </span><br><span class="line">   <span class="keyword">char</span> cArr[] = str.toCharArray() ;</span><br><span class="line">   fw.write(cArr);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 4.流关闭</span></span><br><span class="line">   fw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存流读写">缓存流读写</h3>
<p>缓冲流是字符流的子类 ，用于解决：字符流 &amp; 字节流 每读写1字节要IO操作。</p>
<blockquote>
<p>[读]<em>BufferedReader</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建文件对象</span></span><br><span class="line">    <span class="comment">// hwh.txt内容(空格表示换行)：黄  旺辉  不喜欢西瓜</span></span><br><span class="line">     File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建字符流对象</span></span><br><span class="line">     FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建缓存流：必须建立在一个存在流之上</span></span><br><span class="line">     BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.读取流对象内容:一次一行</span></span><br><span class="line">       <span class="comment">// 输出：黄  旺辉  不喜欢西瓜</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//一次读取一行，返回Sting类型</span></span><br><span class="line">         <span class="comment">// 比前面；设置好char[] 、byte[] ,然后f.read()有所不同</span></span><br><span class="line">         <span class="comment">// 比后面：不用考虑中文 char[] 、byte[] 转换成Sting类型</span></span><br><span class="line">         String line = br.readLine();</span><br><span class="line">         <span class="keyword">if</span>(line == <span class="keyword">null</span>)  <span class="keyword">break</span>;</span><br><span class="line">         System.out.println(line);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.流关闭</span></span><br><span class="line">     br.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[写] <em>PrintWriter</em> ，基本同上差不多步骤，简略说明下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...基本同上</span></span><br><span class="line"><span class="comment">// 写操作，pw是PrintWriter对象，调用println方法读写即可。</span></span><br><span class="line">pw.println(<span class="string">&quot;刘婷是傻子&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="数据流-对象流">数据流&amp;对象流</h3>
<p>数据流 &amp; 对象流 都是字节流子类，建立数据流 &amp; 字符流必须要在一个存在的字节流之上。</p>
<blockquote>
<p>数据流：主要可以进行格式化  <u><em>顺序</em></u>  读写，有 <em>FileInputStream 、FileOutputStream</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 1.创建文件对象</span></span><br><span class="line">     File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.创建字节流对象</span></span><br><span class="line">     FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">     FileInputStream  fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.创建数据流：必须建立在一个[字节流]之上</span></span><br><span class="line">     DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line">     DataInputStream  dis = <span class="keyword">new</span> DataInputStream(fis);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.数据流顺序写</span></span><br><span class="line">     dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">     dos.writeInt(<span class="number">1</span>);</span><br><span class="line">     dos.writeUTF(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 5.数据流顺序读</span></span><br><span class="line">     <span class="keyword">boolean</span> b = dis.readBoolean();</span><br><span class="line">     <span class="keyword">int</span> i = dis.readInt();</span><br><span class="line">     String s = dis.readUTF();</span><br><span class="line">       <span class="comment">// 输出：顺序读到：bool:true ; int：1；String：yes</span></span><br><span class="line">     System.out.format(<span class="string">&quot;顺序读到：bool:%b ; int：%d；String：%s &quot;</span>,b,i,s);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 6.流关闭</span></span><br><span class="line">     dos.close(); dis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象流：指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘 。暂时不详写用    到再说吧：<a target="_blank" rel="noopener" href="http://how2j.cn/k/io/io-objectstream/351.html#nowhere">对象流</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br></pre></td></tr></table></figure>
<h2 id="8-3-中文读写问题">8.3 中文读写问题</h2>
<ul>
<li>
<p>常用编码格式</p>
<ul>
<li><em>IS0-8859-1、ASCII</em> ：数字 &amp; 西欧字母 ，<strong>IS0-8859-1包含 ASCII</strong>，<strong>1</strong>字节。</li>
<li><em>GBK、GB2312、BIG5</em>：中文简繁；中文 ；繁体中文，<strong>2</strong>字节 。</li>
<li><em>Unicode</em> ：统一码，万国码，字母、数字、中文都为<strong>4</strong> 字节编码。</li>
<li><em>UTF-8</em>：对 Uincode 进行的一种<em>减肥子编码</em> ，字母、数字：<strong>1</strong>字节 ；中文：<strong>3</strong> 字节。</li>
</ul>
<p>特别的 <strong>ANSI</strong>  ：表示本地编码，中文OS则选用 GBK、英文 IS0。</p>
</li>
<li>
<p>中文编码读写</p>
<ul>
<li>
<p>写</p>
<ul>
<li>在记事本等中直接写中文：采用本地编码 ANSI保存。</li>
<li>在 java中写中文：执行后都会变为 Unicode（UTF-8?），然后字符流、字节流读写？</li>
</ul>
</li>
<li>
<p>读</p>
<blockquote>
<p>读：字节流 &amp; 字符流读文本中中文，字符流比较麻烦略。</p>
</blockquote>
<p>将<em>字节流</em>数组转换成 <em>Sting</em> 和对应字符编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 1.创建文件对象</span></span><br><span class="line">     File f = <span class="keyword">new</span> File(<span class="string">&quot;hwh.txt&quot;</span>); <span class="comment">// hwh.txt内容：黄</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.创建输入流对象</span></span><br><span class="line">     FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.读取流对象内容</span></span><br><span class="line">     <span class="keyword">byte</span>[] all = <span class="keyword">new</span>  <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">     fis.read(all);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// [测试] 直接输出 byte数组</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">byte</span> b : all)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            byte 1字节，直接打印对应二进制整数：-23 -69 -124(uft-8编码中文3字节)  </span></span><br><span class="line"><span class="comment">            为了打印出16进制，先转换成int --&gt; 再调用toHexString方法</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          System.out.println(b);</span><br><span class="line">          <span class="keyword">int</span> i = b;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             类型转换，输出：ffffffe9、ffffffbb、ffffff84</span></span><br><span class="line"><span class="comment">             对应-23 -69 -124 补码：e9、bb、84(int4字节，byte1字节，补码前3字节添1不看)</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          System.out.println(Integer.toHexString(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.类型转换：把字节数组转换成 Sting UTF-8编码</span></span><br><span class="line">       <span class="comment">// 类型转换第一种：new String装箱，= 自动拆箱</span></span><br><span class="line">       <span class="comment">// 第二种转换：调用对象类型都有的.toString方法：all.toString()</span></span><br><span class="line">     String str = <span class="keyword">new</span> String(all,<span class="string">&quot;UTF-8&quot;</span>); </span><br><span class="line">     System.out.println(str); <span class="comment">// 输出：黄</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 5.流关闭</span></span><br><span class="line">     fis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1>第九章：集合框架</h1>
<p>常用集合框架有： <em>ArrayList、LinkedList、HashMap、HashSet</em> 等。</p>
<p><em>Tips：</em></p>
<ol>
<li><em>System.out.println(集合类型对象)</em>：可以直接装箱成<em>String</em>类型，然后拆箱输出，如[1,2,3]。</li>
</ol>
<h2 id="9-1-ArrayList">9.1 <em>ArrayList</em></h2>
<blockquote>
<p><em>ArrayList</em> 是实现了 <em>List</em> 接口子类。相比常规数组，容量会自动增长，是一个<em>动态数组</em>（非链表）。</p>
</blockquote>
<ul>
<li>
<p>声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. add -- 未泛型指定可添加不同类型对象</span></span><br><span class="line">Hero VN = <span class="keyword">new</span> Hero();</span><br><span class="line">array.add(VN); <span class="comment">// Hero类型对象</span></span><br><span class="line">array.add(<span class="string">&quot;pentaKill&quot;</span>); <span class="comment">// Sting类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.contains：判断对象是否存在</span></span><br><span class="line">System.out.println(<span class="string">&quot;VN对象是否存在：&quot;</span> + array.contains(VN));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.get ：获取指定位置对象 -- 从0计数</span></span><br><span class="line">System.out.println(<span class="string">&quot;第1个位置对象：&quot;</span> + array.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.indexof：判断对象所处位置</span></span><br><span class="line">System.out.println(<span class="string">&quot;VN所处位置：&quot;</span> + array.indexOf(VN));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.remove：可根据位置或者对象名删除</span></span><br><span class="line">array.remove(VN);</span><br><span class="line">array.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.set: 只能替换指定位置对象,不能设置新元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;替换第1个位置对象：&quot;</span> + array.set(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.size：获取数组已存元素个数（大小）</span></span><br><span class="line">System.out.println(<span class="string">&quot;替换第1个位置对象：&quot;</span> + array.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.addAll:添加另外一个容器所有对象</span></span><br><span class="line">ArrayList array1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">array.addAll(array1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.toArray :ArrayList对象转换为数组</span></span><br><span class="line"><span class="comment">// 加了toSting无变化，因为返回Objiect数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;转换为数组：&quot;</span> + array.toArray().toString()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 10.clear：清空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562205646731.png" alt="1562205646731"></p>
</li>
</ul>
<h2 id="9-2-LinkedList">9.2 <em>LinkedList</em></h2>
<blockquote>
<p><em>LinkedList</em> &amp; <em>ArrayList</em> 都实现了 <em>List</em>接口，都有 <em>add 、remove 、contains</em> 等方法。</p>
<p>但同时，<em>LinkedList</em> 还实现了 <em>Queue</em>（队列） 、<em>Deque</em>（双向队列）接口。</p>
</blockquote>
<ul>
<li>
<p>声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkList</span></span><br><span class="line"><span class="comment">// 普通声明</span></span><br><span class="line">LinkedList l = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">// 多态：声明双端队列</span></span><br><span class="line">Deque d = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">// 多态：声明队列</span></span><br><span class="line">Queue q = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用方法</p>
<blockquote>
<p><em>Deque</em> 暂未补充。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. LinkList 在头部、尾部进行操作 */</span></span><br><span class="line"><span class="comment">// [查看]链表头尾元素</span></span><br><span class="line">l.getFirst(); l.getLast();</span><br><span class="line"><span class="comment">// [删除]链表头尾元素</span></span><br><span class="line">l.removeFirst(); l.removeLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. Queue 在头部、尾部进行操作 */</span></span><br><span class="line"><span class="comment">// [添加]队列尾元素 -- q.add?用List接口方法一样吗？</span></span><br><span class="line">q.offer(<span class="number">1</span>); q.offer(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [查看]链表头尾元素</span></span><br><span class="line">q.peek();</span><br><span class="line"><span class="comment">// [取出]链表头尾元素，取出后会被删除</span></span><br><span class="line">q.poll(); </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-3-HashMap">9.3 HashMap</h2>
<blockquote>
<p><em>HashMap</em> 可理解为一个字典，键值不能重复，不同键元素可重复（相同）。</p>
</blockquote>
<ul>
<li>
<p>声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line">HashMap dic = <span class="keyword">new</span> HashMap(); <span class="comment">// 也可泛型指定 Key ：Value 类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用方法</p>
<blockquote>
<p>未详细列出，详细需查看：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/HashSet.html">HashMap官方文档</a>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="comment">// 1.put -- 插入数据</span></span><br><span class="line">dic.put(<span class="number">1</span>, <span class="string">&quot;啊我是1&quot;</span>); dic.put(<span class="number">2</span>, <span class="string">&quot;啊我竟然是2&quot;</span>); dic.put(<span class="number">3</span>, <span class="string">&quot;啊哈哈哈我是3&quot;</span>);</span><br><span class="line"><span class="comment">// 2.get -- 获取数据</span></span><br><span class="line">System.out.println(dic.get(<span class="number">2</span>)); <span class="comment">// 输出：啊我竟然是2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-4-HashSet">9.4 HashSet</h2>
<blockquote>
<p><em>HashSet</em> 没有键值，只保存元素。且不提供 <em>get(index)</em> 方法读取指定位置元素，遍历可利用迭代器。</p>
</blockquote>
<p>类似的还有：<em>LinkedHashSet &amp; TreeSet</em> ，暂略。</p>
<ul>
<li>
<p>声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;  </span><br><span class="line"></span><br><span class="line">HashSet hs = <span class="keyword">new</span> HashSet();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="comment">// 1.add -- 插入数据</span></span><br><span class="line">hs.add(<span class="number">1</span>); hs.add(<span class="keyword">true</span>); hs.add(<span class="string">&quot;一&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.可直接打印所有数据，不是按添加顺序</span></span><br><span class="line">System.out.println(hs);  <span class="comment">// 输出：[一, 1, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.[迭代遍历] 由于未提供get方法，不能普通for循环，但可以迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(Iterator it = hs.iterator();it.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(it.next()); <span class="comment">// 输出：一 1 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-5-Collections类">9.5 Collections类</h2>
<blockquote>
<p><em>Collections</em> 类是专门用于处理集合类型的工具类，包含一系列诸如：<em>排序、反转、混淆、交换</em> 等方法。</p>
</blockquote>
<p>类似于：<em>Arrays</em> 是数组的工具类。但是，只能处理实现了 <em>List</em> 接口类。<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Collections.html"><em>Collections</em> 类官方文档</a></p>
<ul>
<li>
<p>基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line">LinkedList&lt;Integer&gt; ll = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); <span class="comment">// [注]：不是int类型</span></span><br><span class="line">ll.add(<span class="number">1</span>) ;  ll.add(<span class="number">2</span>) ;  ll.add(<span class="number">3</span>) ; ll.add(<span class="number">4</span>) ; ll.add(<span class="number">5</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法：更多查看官方文档</span></span><br><span class="line"><span class="comment">// 1.混淆</span></span><br><span class="line">Collections.shuffle(ll);  </span><br><span class="line"><span class="comment">// 2.排序</span></span><br><span class="line">Collections.sort(ll); System.out.println(ll); <span class="comment">// 输出：[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 3.反转</span></span><br><span class="line">Collections.reverse(ll);</span><br><span class="line"><span class="comment">// 4.交换</span></span><br><span class="line">Collections.swap(ll,<span class="number">0</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>比较器：<em>Comparable</em></p>
<blockquote>
<p><em>Comparable</em> 是一个接口，通过覆写实现它的 <em>compare</em> 方法，来比较非数值类型的 <em>sort</em> 排序等。</p>
</blockquote>
<p>如下，实现了通过比较 <em>Hero</em>类 <em>HP</em>属性来实现排序。</p>
<ul>
<li>
<p>在<em>Hero</em>类中</p>
<blockquote>
<p>也可在 <em>Hero</em>类中在覆写 <em>compareTo</em>方法，这样自带比较信息，而不用在主函数覆写<em>Comparator</em> 接口的 <em>compare</em>方法。</p>
</blockquote>
<p>⚠️ 在 <em>Hero</em>类中覆写了 <em>toSting</em>方法，这样打印<em>Hero</em>对象不显示：<u>Hero@十六进制地址形式</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法：构造函数</span></span><br><span class="line">    Hero(String name ,<span class="keyword">int</span> hp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.HP = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法：类中覆写函数toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;英雄名：&quot;</span> + name + <span class="string">&quot; 血量：&quot;</span> + HP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在主函数中</p>
<blockquote>
<p><em>Q : System.out.println(ll);</em> 如何实现打印出集合？</p>
<p>A:  首先，打印 <em>ll</em> 会将集合每个<em>Hero</em>对象装箱成<em>Sting</em>，然后调用 .<em>toString</em>()方法进行拆箱；</p>
<p>​     由于<em>Hero</em>类中覆写了 .<em>toString</em>()方法，此时返回的不是默认<u><em>Hero</em>@十六进制地址形式</u> 。</p>
<p>​     最后结合所有对象.toString() ,转换成<em>String</em>类型[…,…,…,…]打印出来。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.准备好一个集合类型 LinkList，插入十个Hero类型对象并设置不同随机hp</span></span><br><span class="line">LinkedList&lt;Hero&gt; heros = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">     String name = <span class="string">&quot;hero&quot;</span>+i;</span><br><span class="line">     <span class="keyword">int</span> hp = (<span class="keyword">int</span>)(Math.random()* <span class="number">1000</span>);</span><br><span class="line">     heros.add(<span class="keyword">new</span> Hero(name,hp)); <span class="comment">// 带int参数构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(heros);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.[匿名类]覆写比较器compare方法（比较规则）</span></span><br><span class="line">Comparator&lt;Hero&gt; comparable = <span class="keyword">new</span> Comparator&lt;Hero&gt;() </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(h1.HP &gt; h2.HP)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 注意，别写0</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.工具栏Collections进行排序</span></span><br><span class="line">Collections.sort(heros,comparable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.直接打印输出查看</span></span><br><span class="line">System.out.println(heros);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="9-x-迭代器初使用">9.x 迭代器初使用</h2>
<blockquote>
<p>根据学习C++经验，迭代器要和这些集合类型如  <em>ArrayList</em> 结合才能用。</p>
</blockquote>
<ul>
<li>
<p>声明一个集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 List接口多态实现 </span></span><br><span class="line">List array = <span class="keyword">new</span> ArrayList();</span><br><span class="line">array.add(<span class="number">12345</span>); array.add(<span class="string">&quot;上山打老虎&quot;</span>); array.add(<span class="keyword">new</span> Hero());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通for循环遍历集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.size();i++)</span><br><span class="line">    System.out.println(array.get(i));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代for循环遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hasNext - 判断当前是否有下一个元素，有返回true</span></span><br><span class="line"><span class="comment">// next - 返回当前元素类型。</span></span><br><span class="line"><span class="keyword">for</span> (Iterator it = array.iterator();it.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562208720076.png" alt="1562208720076"></p>
</li>
</ul>
<h1>第十章：泛型</h1>
<h2 id="10-1-泛型分类及作用">10.1 泛型分类及作用</h2>
<ul>
<li>
<p>泛型集合</p>
<blockquote>
<p>通过，泛型集合指定集合接受类型，如<Hero>只能接受 <u><em>Hero</em>对象及其子类</u></p>
</blockquote>
<p>如下，声明了一个非泛型对象数组集合，可添加不同对象，但也许我们只想添加<em>Hero</em>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList heros = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">heros.add(<span class="keyword">new</span> Hero());</span><br><span class="line">heros.add(<span class="keyword">new</span> Item());<span class="comment">// 此时泛型还可以添加无关的 Item对象</span></span><br></pre></td></tr></table></figure>
<p>通过泛型指定只能添加 <u><em>Hero</em>对象及其子类</u>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">heros.add(<span class="keyword">new</span> Hero());   </span><br><span class="line">heros.add(<span class="keyword">new</span> ADHero()); <span class="comment">// 子类也可以添加</span></span><br><span class="line">heros.add(<span class="keyword">new</span> Item());   <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>泛型方法 &amp; 泛型类 &amp; 泛型接口</p>
<blockquote>
<p>这些泛型，可以接受不同参数实现代码精简。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类，类中定义了非泛型方法&amp;泛型方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.[非泛型方法] 因为用的是类定义泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.[泛型方法] 这才是泛型方法，&lt;T&gt;声明在返回类型前</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.[静态方法 &amp; 编译错误]下面编译错误，静态类不能用类定义的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.[静态泛型方法] 用自己定义的泛型就不会出错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型接口类似泛型类声明</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterDemo</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>泛型转型</p>
<blockquote>
<p>暂时记住结论。</p>
</blockquote>
<p>我们知道，子类是可以转换成父类（多态），但是子类泛型和父类泛型不能互转！</p>
</li>
</ul>
<h2 id="10-2-泛型通配符">10.2 泛型通配符</h2>
<ul>
<li>
<p>通配符作用</p>
<ul>
<li><em>&lt; ? extends 类型名&gt;</em> ：只能取 <em>类型名、object</em>，不能插入；</li>
<li><em>&lt;?&gt;</em> : 只能取<em>object</em> ，不能插入；</li>
<li><em>&lt; ? super 类型名&gt;</em> ： 只能取<em>object</em> ，能插入满足通配符匹配所有类型的子类。</li>
</ul>
</li>
<li>
<p><em>&lt; ? extends 类型名&gt;</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 因为不能插入，所以先定义一个&lt;APHero&gt;泛型集合插入一些数据</span></span><br><span class="line">ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">apHeroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义&lt;? extends&gt;泛型集合：指向上面泛型集合</span></span><br><span class="line"> ArrayList&lt;? extends Hero&gt; heroList = apHeroList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.测试</span></span><br><span class="line"><span class="comment">// [取，可行] 因为&lt;? extends&gt;代表保存的都是 Hero及其子类，取出来都可以转换成Hero类型</span></span><br><span class="line">Hero h = herolist.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// [插，不可] 因为&lt;? extends&gt;可以是Hero及其子类，但只能确定为其中一个。</span></span><br><span class="line"><span class="comment">//  比如， &lt;? extends&gt;已经代表是&lt;Hero&gt;,根据泛型集合限定插入类型，此时插入APHero类型会失败。</span></span><br><span class="line">heroList.add(<span class="keyword">new</span> ADHero()); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>&lt;?&gt;</em></p>
<p>基本同*&lt; ? extends 类型名&gt;* ，由于少了 <em>extends</em> ，代表可以是指向任意泛型对象，而非某类及其子类。</p>
<p>但是，取数据也对应只能是 <em>Object</em> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...同前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.测试</span></span><br><span class="line"><span class="comment">// [取，可行]只能为object类型</span></span><br><span class="line">Object o = generalList.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// [插，不可]</span></span><br><span class="line">generalList.add(<span class="keyword">new</span> Item());  generalList.add(<span class="keyword">new</span> Hero()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>&lt; ? super 对象名&gt;</em></p>
<p>和*&lt; ? extends 对象名&gt;* 对象名不同，*&lt; ? super 对象名&gt;*代表可指向 对象名及父类。</p>
<p>如：<em>&lt; ? super Hero&gt;</em> ，代表可指向 <em>Hero</em>及其父类<em>Object</em> 。所以：</p>
<ul>
<li>可插入：<em>Hero</em> &amp; 子类<em>ADHero</em>等（父类泛型可以插入子类对象）</li>
<li>不可取：无法将父类泛型转换成子类（向下转换），<u>但是不可以像*&lt;?&gt;<em>取出来是</em>Object*类型吗？<strong>可行</strong></u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义&lt;? super&gt;泛型</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.测试</span></span><br><span class="line"><span class="comment">// [取，不可] 无法向下转换，父类转换成子类</span></span><br><span class="line">Hero h = heroList.get(<span class="number">0</span>);  <span class="comment">// 不可，编译错误</span></span><br><span class="line">Object O = heroList.get(<span class="number">0</span>); <span class="comment">// 可行</span></span><br><span class="line"><span class="comment">// [插，可行]</span></span><br><span class="line">heroList.add(<span class="keyword">new</span> Hero()); </span><br><span class="line">heroList.add(<span class="keyword">new</span> ADHero()); <span class="comment">// 子类可插入</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通配符取出、插入总结</p>
<ul>
<li>
<p>取出</p>
<blockquote>
<p>无论是何种通配符，取出是只要满足 <u>向上转换</u> 规则即可。</p>
</blockquote>
<p>如：<em>&lt;? extends Hero&gt;</em> ,是 <em>Hero</em>及子类，只要<u>转换的对象类型是<strong>通配符匹配所有类型的父类（或同级）</strong></u>，即可插入。</p>
<p>显然，<em>Hero</em> 是*&lt;? extends Hero&gt;<em>所有类型父类，所以可以取出转换成</em>Hero*：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">Hero h = heroList.get(<span class="number">0</span>); <span class="comment">// 可行</span></span><br></pre></td></tr></table></figure>
<p>但是， <? super Hero> & <?>  ，<em>Hero</em>不满足通配符所代表的所有类型类型父类，所以出错；</p>
<p>以此推论，向上转换成<em>Object</em>则行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">Hero h = heroList.get(<span class="number">0</span>);  <span class="comment">// 编译错误</span></span><br><span class="line">Object O = heroList.get(<span class="number">0</span>); <span class="comment">// 可行</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>插入</p>
<blockquote>
<p>插入即&quot;向下插入&quot;，插入对象是<strong>通配符匹配所有类型的子类（或同级）</strong>。</p>
</blockquote>
<p>如：<em><? extends Hero>* & *<?></em> ,它们的子类是不确定的，所以不能插入。</p>
<p>而：<em>&lt;? extends Hero&gt;</em> ，<em>ADHero、Hero</em> 显然满足符合<u>该通配符匹配的所有类型子类（同级）</u>，故可以插入。</p>
</li>
</ul>
</li>
</ul>
<h1>第十一章：<em>Lambda</em></h1>
<h2 id="11-1-匿名类">11.1 匿名类</h2>
<ul>
<li>
<p>使用时机</p>
<p>在<em>new</em>创建：一个类对象 、 一个接口子类对象、一个抽象类子类对象时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类|接口  名字 =  <span class="keyword">new</span> 类|接口()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    重写方法;</span><br><span class="line">&#125;；  </span><br></pre></td></tr></table></figure>
<p>如，下面 <em>new Runnable</em>接口实现了一个匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runnable是一个接口</span></span><br><span class="line">Runnable x = <span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>我们知道，接口是不能被实例化的，上述代码实际是这么一个实现过程：</p>
<ul>
<li>{}相当于一个继承了<em>Runnable</em>接口  <strong>BUT</strong>  匿名的类实现了<em>Runnable</em>接口方法；</li>
<li>该匿名类则可以通过<u>多态</u> 转换成父类接口<em>Runnable</em>类型。</li>
</ul>
</li>
<li>
<p>总结</p>
<p>在实际开发中，我们可以看到有方法，用<u>抽象类、接口作参数实现多态</u>。</p>
<p>而我们实际需要的是一个子类对象，如果该方法仅仅调用<strong>1</strong> 次，用匿名类简化格式，<u>不必特地实现一个类继承该接口、抽象类</u>。</p>
</li>
</ul>
<h2 id="11-2-Lambda-基本用法">11.2 <em>Lambda</em> 基本用法</h2>
<ul>
<li>
<p><em>Lambda</em> 语法</p>
<p>在 java中，其表达式格式语法一般是：<code>(parameters) -&gt; &#123; statements; &#125;</code> 。</p>
<p>在满足一定条件下，还可以进一步简写：</p>
<ul>
<li><em>参数类型可选</em> ：不需要声明参数类型，编译器可以统一识别参数值；</li>
<li><em>只有一个参数</em> ： 参数 ()可选</li>
<li><em>主体{}只有一条语句</em> ：此时 <em>return</em> 关键字 &amp; {} ，可不写。注意 ！
<ul>
<li>主体{} 不省略时，哪怕只有一条语句，函数有返回值<em>return</em>关键字不可省！</li>
<li>主体{} 省略时，<em>return</em> 也必须省略！</li>
</ul>
</li>
</ul>
<p><em>以下是一些简单示例：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>Lambda</em> 用于简化匿名类</p>
<p>在 <em>9.5 Collections类</em>  一节，我们用 <em>Collections.sort(heros，Comparator)</em> 静态方法去比较 <em>Hero</em> 的HP属性，进而按HP大小打印<em>heros</em>数组中各<em>Hero</em>对象信息。</p>
<p>我们用到匿名类覆写实现了 <em>Comparator</em> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.[匿名类]覆写比较器compare方法（比较规则）</span></span><br><span class="line">Comparator&lt;Hero&gt; comparable = <span class="keyword">new</span> Comparator&lt;Hero&gt;() </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(h1.HP &gt; h2.HP)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 注意，别写0</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Collections.sort(heros,comparable);</span><br><span class="line">System.out.println(heros);</span><br></pre></td></tr></table></figure>
<p>这里可以将匿名类简写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Hero&gt; comparable = (Hero h1,Hero h2) -&gt; &#123; <span class="keyword">return</span>  h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>;&#125;;</span><br></pre></td></tr></table></figure>
<p>还可以进一步简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.去掉参数类型 </span></span><br><span class="line"><span class="comment">// 2.去掉&#123;&#125;(只有一条语句) </span></span><br><span class="line"><span class="comment">// 3.去掉return（只有一条语句 + 没有&#123;&#125;）</span></span><br><span class="line"></span><br><span class="line">Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>Lambda</em> 用于把方法作参数</p>
<p>在上面我们通过匿名类 或者 <em>lambda</em>简化，最终创建了<em>Comparator</em>对象comparable，然后调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Hero&gt; comparable = (h1,h2) -&gt; h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">Collections.sort(heros,comparable);</span><br></pre></td></tr></table></figure>
<p>我们可以更进一步，直接传递 <em>lambda</em> 表达式作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(heros,(h1,h2) -&gt;  h1.HP &gt; h2.HP ? <span class="number">1</span>:<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>最终上面代码被成功简化成一行。</p>
<p>当然还有其它匿名方法例子，实现遍历输出：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(<span class="meta">@NotNull</span> java.util.function.Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">array.add(<span class="number">4</span>);array.add(<span class="number">5</span>);array.add(<span class="number">3</span>);array.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach方法参数有一个Cosumer接口，通过lambda表达式创建一个继承Cosumer接口匿名对象</span></span><br><span class="line">array.forEach(n -&gt; System.out.println(n));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-3-Lambda-聚合操作">11.3 <em>Lambda</em> 聚合操作</h2>
<p>在上面我们介绍了，如果方法参数是一个接口或者抽象类等，可利用<em>Lambda</em> 表达式作为方法参数。表达式创建一个继承该接口 |抽象类的匿名类，这种方法也叫做<strong>匿名方法</strong>。</p>
<p>我们可以用同时使用多个匿名方法，实现聚合操作。</p>
<ul>
<li>
<p>实例介绍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Hero类型集合，准备多个对象指定HP</span></span><br><span class="line">ArrayList&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String name = <span class="string">&quot;hero&quot;</span>+i;</span><br><span class="line">    <span class="keyword">int</span> hp = (<span class="keyword">int</span>)(Math.random()* <span class="number">1000</span>);</span><br><span class="line">    heros.add(<span class="keyword">new</span> Hero(name,hp)); <span class="comment">// 带int参数构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heros对象有多个方法，进行聚合操作</span></span><br><span class="line">heros</span><br><span class="line">      .stream()</span><br><span class="line">      .sorted((h1,h2) -&gt; h1.HP &gt; h2.HP ? <span class="number">1</span>:-<span class="number">1</span>) <span class="comment">// 比较器接口 </span></span><br><span class="line">      .forEach(n -&gt; System.out.println(n)); <span class="comment">// Cosumer接口</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更多操作</p>
<blockquote>
<p>实例参考，具体待用到补充：<a target="_blank" rel="noopener" href="http://how2j.cn/k/lambda/lambda-stream/700.html#nowhere">聚合操作</a></p>
</blockquote>
<p>以 <u>源为 <em>List</em></u> 为例：</p>
<ul>
<li>中间操作方法
<ul>
<li><em>filter</em> ：匹配</li>
<li><em>distinct</em>： 去除重复(根据equals判断)</li>
<li><em>sorted</em> ：自然排序</li>
<li><em>sorted(Comparator<T>)</em> ：指定排序</li>
<li><em>limit</em> ：保留</li>
<li><em>skip</em> ：忽略</li>
</ul>
</li>
<li>结束操作方法
<ul>
<li><em>forEach()</em>：遍历每个元素</li>
<li><em>toArray()</em> ：转换为数组</li>
<li><em>min(Comparator<T>)</em> ： 取最小的元素</li>
<li><em>max(Comparator<T>)</em>： 取最大的元素</li>
<li><em>count()</em>： 总数</li>
<li><em>findFirst()</em>：第一个元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>第十二章：多线程</h1>
<h2 id="12-0-基本知识">12.0 基本知识</h2>
<h4 id="线程与进程介绍">线程与进程介绍</h4>
<ul>
<li>
<p><strong>什么是进程</strong>？</p>
<blockquote>
<p>打开任务管理管理器，可以看到很多【正在运行】的应用程序，这就是对应进程。</p>
</blockquote>
<ul>
<li>正在运行的应用程序；</li>
<li>系统分配和调用资源的基本单位</li>
</ul>
</li>
<li>
<p><strong>线程？单线程与多线程</strong>？</p>
<ul>
<li>
<p><strong>线程</strong>：是进程的单个顺序控制流，是执行的最小单位（执行路径）</p>
</li>
<li>
<p><strong>单线程</strong>：<em>e.g. 记事本程序</em></p>
<p>一个进程如果只有一条执行路径，则为单线程</p>
</li>
<li>
<p><strong>多线程</strong>：<em>e.g. 扫雷程序：计时、玩家扫雷</em></p>
<p>一个进程如果有多条执行路径，则为多线程程序</p>
</li>
</ul>
</li>
<li>
<p><strong>子线程设置名字 &amp; 源码分析</strong></p>
<ul>
<li>
<p><code>MyThread.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须要定义这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 调用父类（Thread）构造函数（一个参数的方法）</span></span><br><span class="line">    <span class="comment">// 调用顺序看下截图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/27/maMfQbDJkK3LpnY.png" alt="image-20210427235215262"></p>
</li>
<li>
<p><code>MyThreadDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima_01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方式1：继承Thread类</span></span><br><span class="line"><span class="comment">        1:定义一个类MyThread继承Thread类</span></span><br><span class="line"><span class="comment">        2:在MyThread类中重写run()方法</span></span><br><span class="line"><span class="comment">        3:创建MyThread类的对象</span></span><br><span class="line"><span class="comment">        4:启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my1.setName(<span class="string">&quot;11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        my1.run();</span></span><br><span class="line"><span class="comment">//        my2.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void start​() 导致此线程开始执行; Java虚拟机调用此线程的run方法</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>获取Main方法进程名</strong></p>
<ul>
<li>
<p>不能使用<u>Thread对象方法</u>：getName()，因为没继承Thread</p>
</li>
<li>
<p>应该用<u>Thread静态方法</u>，<code>Thread.currentThread</code> 获取当前执行对象, 再调用<code>getName()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String mainTreadName = Thread.currentThread.getName()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="线程调度">线程调度</h4>
<p>线程主要有两种调度【模型】：</p>
<ul>
<li>
<p><strong>分时调度模型</strong>：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p>
</li>
<li>
<p><strong>抢占式调度模型</strong>：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，<u>优先级高的线程</u>获取的 CPU 时间片相对多一些</p>
</li>
</ul>
<p>Java使用的是<u>抢占式调度模型</u> ，具有<strong>随机性</strong>。</p>
<ul>
<li>
<p><strong>随机性</strong> ：因为CPU在某个时刻只能执行一条命令，线程只有得到CPU时间片（使用权），才可以执行。而抢占式调度模型多线程执行具有随机性，谁抢到CPU是不确定的。</p>
</li>
<li>
<p><strong>线程优先级：</strong> 通过设置线程优先级，可以让某个线程得到CPU的<strong>概率</strong>变大。（但不意味着是绝对优先，<u>只是概率增大</u>）</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>方法名</strong></th>
<th style="text-align:center"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">final int getPriority()</td>
<td style="text-align:center">返回此线程的优先级</td>
</tr>
<tr>
<td style="text-align:center">final void setPriority(int newPriority)</td>
<td style="text-align:center">更改此线程的优先级 线程默认优先级是5；线程优先级的范围1-10</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="线程生命周期">线程生命周期</h4>
<blockquote>
<p>📓 面试重点！</p>
</blockquote>
<p><img src="https://i.loli.net/2021/04/28/VCN8xckXHMdrl1R.png" alt="image-20210428164922743"></p>
<ul>
<li><strong>变为阻塞</strong> ：是由 <u>运行</u> 状态进入的， 且是被<code>sleep()</code> 一些阻塞式方法导致的</li>
<li><strong>变为就绪：</strong> 可能是 <u>新建</u> 状态获得资源，也可能是 <u>运行</u> 状态进入</li>
</ul>
<h2 id="12-1-多线程快速入门">12.1 多线程快速入门</h2>
<h3 id="不使用多线程">不使用多线程</h3>
<p>下面有一个 <em>Hero</em> 类，实现了<em>attack</em> 方法，用于模拟游戏人物进行攻击：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line"></span><br><span class="line">    Hero(String name ,<span class="keyword">int</span> hp) </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;  <span class="keyword">this</span>.HP = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数：攻击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">attack</span><span class="params">(Hero h,<span class="keyword">int</span> damage)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        h.HP -= damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;[%s]正在攻击[%s],[%s]血量为:[%d]..\n&quot;</span>, name,h.name,h.name,h.HP);</span><br><span class="line">        <span class="keyword">if</span> (h.isDead())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(h.name + <span class="string">&quot;--已经挂了！\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数：判断是否死亡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= HP ? <span class="keyword">true</span> :<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在主函数中，实例化游戏人物<em>VN，garren</em> 各自分别攻击 <em>teemo、bh</em> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 英雄开始攻击</span></span><br><span class="line">        <span class="keyword">while</span> (!teemo.isDead())</span><br><span class="line">            VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (!bh.isDead())</span><br><span class="line">            gareen.attack(bh,<span class="number">100</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为都在主函数中的主线程中，显然应该先是<em>VN</em> 攻击，然后<em>garren</em> 进行攻击，这样一种串行方式。</p>
<p>但是实际游戏中，<em>VN</em> 和 <em>garren</em> 是可以同时进行攻击的，如何实现呢？</p>
<h3 id="多线程实现并行攻击">多线程实现并行攻击</h3>
<p>根据上面思考，我们应该分别把 <em><u>VN攻击teemo</u></em> 和 <em><u>garren攻击bh</u></em> 放在不同线程中并行执行。</p>
<p>一般来说，实现多线程我们有三种方式：</p>
<ul>
<li>继承 <em>Thread</em> 类</li>
<li>实现 <em>Runnable</em> 接口</li>
<li>匿名类的方式</li>
</ul>
<h4 id="1-继承-Thread-类">1. 继承 <em>Thread</em> 类</h4>
<p>通过继承<em>Thread</em> 类，然后覆写<em>run()</em> 方法，<u>在<em>run()</em> 方法写上需要并发的操作</u> 。这样，在实例化对象后，执行对象方法 <em>start()</em> 启动后便会分配线程来执行 <em>run()</em> 中操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KillThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillThread</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h1 = h1;</span><br><span class="line">        <span class="keyword">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 覆写父类Thread中run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!h2.isDead()) <span class="comment">// 模拟不断攻击敌方英雄</span></span><br><span class="line">            h1.attack(h2,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主函数，实例化 <em>KillThread</em> 对象，执行<em>start()</em> 方法来创建线程，然后执行方法<em>run()</em> 中操作。</p>
<p>显然，下面<em>KillThread</em> 对象<em>kh1、kh2</em>，分别创建了两个线程执行 <u>VN攻击Teemo</u>，<u>garren攻击bh</u>。</p>
<blockquote>
<p>📓 创建两个线程，代码排版中是串行的，但是实际<strong>执行是并行</strong>的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果执行 kt1.run()、kt2.run() 不会创建新线程,相当于串行操作</span></span><br><span class="line">        KillThread kt1 = <span class="keyword">new</span> KillThread(VN, teemo);</span><br><span class="line">        kt1.start();  </span><br><span class="line">        KillThread kt2 = <span class="keyword">new</span> KillThread(gareen, bh);</span><br><span class="line">        kt2.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据下面部分输出截图，可以发现 <u>VN攻击Teemo</u>，<u>garren攻击bh</u> 可以并行执行：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563157470532.png" alt="1563157470532"></p>
<h4 id="2-实现-Runnable-接口">2. 实现 <em>Runnable</em> 接口</h4>
<p>通过 实现 <em>Runnable</em> 接口 和 继承 <em>Thread</em> 类来实现多线程，大同小异。</p>
<blockquote>
<p><strong>相比继承Thread类，实现Runnable接口的好处：</strong></p>
<ul>
<li>
<p>避免了Java<strong>单继承</strong>的局限性</p>
</li>
<li>
<p>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p>
</li>
</ul>
</blockquote>
<p>唯一需注意的是，<em>Runnable</em> 接口 虽然要求实现 <em>run()</em> 方法，但是：</p>
<blockquote>
<p>直接调用*run()*方法，并不会启动一个新的线程。[<strong>面试]需要借助线程对象 start()方法</strong>，才会启动一个新的线程。</p>
</blockquote>
<p>下面创建一个 <em>Battle</em> 类，实现<em>Runnable</em> 接口，可以看到：除了没有继承 <em>Thread</em> 类，<u>其余都一模一样</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> LOL.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> // 以下和继承<span class="title">Thread</span>方式代码一样</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillThread</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h1 = h1;</span><br><span class="line">        <span class="keyword">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 覆写父类Thread中run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!h2.isDead()) <span class="comment">// 模拟不断攻击敌方英雄</span></span><br><span class="line">            h1.attack(h2,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数需要借助 <em>Thread</em> 对象 *start()*方法，启动一个新线程，这也是和直接继承 <em>Thread</em> 类不同地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        Battle battle1 = <span class="keyword">new</span> Battle(gareen,teemo);</span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start(); <span class="comment">// 把Battle对象当做Thread构造函数参数传递进去</span></span><br><span class="line">        Battle battle2 = <span class="keyword">new</span> Battle(bh,leesin);</span><br><span class="line">        <span class="keyword">new</span> Thread(battle2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-匿名类">3. 匿名类</h4>
<p>在 <u>2.实现 <em>Runnable</em> 接口</u> 中，我们难免会想到通过匿名类方式来实现，因为它满足：</p>
<ol>
<li>通过继承接口/类方式实现一个类(<em>Battle</em>)</li>
<li><strong>该类对象仅被调用一次</strong></li>
</ol>
<p>当然，在 <u>3.继承 <em>Thread</em> 类</u> 中也满足上述条件，可以通过匿名类实例<em>KillThread</em> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          // 匿名类生成本来的KillThread对象</span></span><br><span class="line"><span class="comment">           Thread t1= new Thread()&#123;  </span></span><br><span class="line"><span class="comment">            public void run()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                while(!teemo.isDead())</span></span><br><span class="line"><span class="comment">                    gareen.attackHero(teemo);            </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 匿名类实现生成Battlel类对象</span></span><br><span class="line">        Runnable battle1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) </span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// 注意要有 ; 分号</span></span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();</span><br><span class="line"></span><br><span class="line">        Runnable battle2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!bh.isDead()) </span><br><span class="line">                    gareen.attack(bh,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(battle2).start();</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们还可以更进一步，使用 <em>lambada</em> 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更进一步：通过lambada表达式</span></span><br><span class="line">        Runnable battle1 = () -&gt; &#123;<span class="keyword">while</span> (!teemo.isDead()) VN.attack(teemo,<span class="number">100</span>);&#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();</span><br><span class="line">        Runnable battle2 = () -&gt; &#123;<span class="keyword">while</span> (!bh.isDead()) gareen.attack(bh,<span class="number">100</span>);&#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(battle2).start();        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>
<h2 id="12-2-多线程常用方法">12.2 多线程常用方法</h2>
<h3 id="sleep-方法"><em>sleep()</em> 方法</h3>
<p><em>sleep()</em> 是 <em>Thread</em> 类静态方法，可以使 <u>当前</u> 线程阻塞，并指定暂停时间，重点在于理解 <u>当前</u>：</p>
<blockquote>
<p>下面是<strong>14.1</strong>中 <u>3.匿名类</u> 在主函数实现多线程代码，删减了 <em>garren</em> 攻击 <em>bh</em> 创建线程部分。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [1]暂停1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// sleep要处理异常，为了方便直接在主函数throw</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名类实现</span></span><br><span class="line">        Runnable battle1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">// [2]暂停2s</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) </span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面有两个位置发生暂停：</p>
<ul>
<li>[1]暂停1s：显然当前线程是主线程，所以会使得主线程暂停1s；</li>
<li>[2]暂停2s：执行完   <code>new Thread(battle1).start();</code>   启动新线程1，新线程1会执行 <em>run()</em> 方法。那么当前线程就是线程1，线程1被暂停2s。</li>
</ul>
<h3 id="yield-方法"><em>yield()</em> 方法</h3>
<p><em>yield()</em> 也是 <em>Thread</em> 类静态方法，<strong>使当前线程变为<u>就绪状态</u></strong> （<em>sleep()</em> 是阻塞），使得其他线程更多机会获取CPU。</p>
<p>但不能指定暂停时间，因为线程重新到<em>就绪状态</em> 后，执行<em>yield()<em>的线程<u>有可能在进入</em>就绪状态</em> 马上又被执行</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [1]主线程从运行--&gt;就绪</span></span><br><span class="line">        Thread.yield(); <span class="comment">// 实际测试没有效果，后面代码还是执行主函数代码，主线程立马又被调度了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名类实现</span></span><br><span class="line">        Runnable battle1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead()) </span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// [2]VN攻击teemo线程从运行--&gt;就绪</span></span><br><span class="line">                Thread.yield(); <span class="comment">// 让出CPU调度 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        <span class="keyword">new</span> Thread(battle1).start();       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="join-方法"><em>join()</em> 方法</h3>
<blockquote>
<p>slepp()、yield()都是Thread类静态方法，但jion() 是Thread类实例对象方法。</p>
</blockquote>
<p>一种特殊的<em>wait</em>，<u>当前</u> 运行线程调用另一个线程的<em>join</em>方法。</p>
<p><u>当前线程进入阻塞状态直到<em>join</em>的线程运行结束</u> ，等待该线程终止。 注意该方法也需要捕捉异常。-</p>
<ul>
<li>⚠️ 此时有其它子线程，也必须等到调用jion() 的线程先执行完毕。 ​</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    void join()：等待这个线程死亡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">        ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">        ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">        tj1.setName(<span class="string">&quot;康熙&quot;</span>);</span><br><span class="line">        tj2.setName(<span class="string">&quot;四阿哥&quot;</span>);</span><br><span class="line">        tj3.setName(<span class="string">&quot;八阿哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.启动主线程后，三个线程抢占执行，谁都可能执行</span></span><br><span class="line">        tj1.start();</span><br><span class="line">        tj2.start();</span><br><span class="line">        tj3.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.主线程继续往下执行，</span></span><br><span class="line">        <span class="comment">//   遇到设置康熙线程jion后，主线程和另外两个阿哥线程         //   【都阻塞】，等待康熙线程执行完</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tj1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setPriority-方法"><em>setPriority()</em> 方法</h3>
<p><em>setPriority()</em> 用于设置优先级，优先级的高的线程更高几率获得 <em>CPU</em> 调度。有以下几个需要知道知识点：</p>
<ul>
<li>
<p>线程优先级表示</p>
<p>线程优先级表示用整数：1~10，也可以用<em>java</em> 内置的三种 <em>INT</em>  型常量表示：</p>
<ul>
<li>最低优先级 1：<em>Thread.MIN_PRIORITY</em></li>
<li>普通优先级 5：<em>Thread.MAX_PRIORITY</em></li>
<li>最高优先级10：<em>Thread.NORM_PRIORITY</em></li>
</ul>
</li>
<li>
<p>默认线程优先级</p>
<p><em>Java</em>默认的线程优先级是 <u>父线程的优先级</u>，而非普通优先级 <em>Thread.NORM_PRIORITY</em> 。</p>
</li>
</ul>
<p>详细参考 <u>操作系统</u> 一书，这里以一个简单实例说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Hero VN = <span class="keyword">new</span> Hero(<span class="string">&quot;VN&quot;</span>,<span class="number">2500</span>);</span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero(<span class="string">&quot;teemo&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero(<span class="string">&quot;gareen&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero(<span class="string">&quot;bh&quot;</span>,<span class="number">2800</span>);</span><br><span class="line">        </span><br><span class="line">        Thread  t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!teemo.isDead())</span><br><span class="line">                    VN.attack(teemo,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread  t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!bh.isDead())</span><br><span class="line">                    gareen.attack(bh,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程优先级</span></span><br><span class="line">        System.out.format(<span class="string">&quot;t1优先级%d，t2优先级%d\n&quot;</span> ,t1.getPriority(),t2.getPriority());</span><br><span class="line">        <span class="comment">// 重新设置线程优先级</span></span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        <span class="comment">// 获取优先级</span></span><br><span class="line">        System.out.format(<span class="string">&quot;t1优先级%d，t2优先级%d\n&quot;</span> ,t1.getPriority(),t2.getPriority());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1563179771296.png" alt="1563179771296"></p>
<h3 id="setDaemon-方法"><em>setDaemon()</em> 方法</h3>
<p><em>setDaemon()</em> 用于设置守护线程。什么是守护线程？</p>
<p>简单理解，一个 <u>进程</u> 中用于守护其它线程的线程，如果其它线程结束，只剩下守护线程，那么<u>进程</u> 结束。</p>
<p>守护线程通常会被用来做：日志、性能统计等工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t1线程被设为当前进程的守护线程</span></span><br><span class="line"> t1.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个破解线程用穷举法匹配指定的某密码；创建一个日志守护线程，打印用过哪些密码匹配。</p>
</blockquote>
<ul>
<li>🔑 由于日志线程是守护线程，那么破解线程匹配成功结束，守护线程日志也就结束了；</li>
<li>🔑 设置一个公共容器 <em>LinkList</em></li>
</ul>
<p>答案查看：<a target="_blank" rel="noopener" href="http://how2j.cn/k/thread/thread-methods/354.html#nowhere">多线程常用方法</a></p>
<blockquote>
<p>设置三个线程：“关羽”、“张飞”、“刘备” 。“刘备”为当前线程（也是主线程），“关羽”和“张飞”为守护线程。</p>
</blockquote>
<p>下面示例中，“刘备”线程挂了后，“关羽”、“张飞” 也马上停止了（但还是挣扎了会）。<img src="https://i.loli.net/2021/04/28/MlOCfaikYJmg2Uz.png" alt="image-20210428162833700"></p>
<h2 id="12-3-多线程同步">12.3 多线程同步</h2>
<p>多线程同步问题，指多线程同时修改一个数据时，导致数据不一致等。解决多线程问题，通常通过：</p>
<ol>
<li><em>volatile</em>关键字 ：可保证可见性；</li>
<li><em>synchronized</em>关键字 ：是一个同步锁，保证原子性和可见性；</li>
<li><em>Lock</em> 接口：保证原子性和可见性，详情暂略。</li>
</ol>
<p>在解释 <em>volatile</em> &amp; <em>synchronized</em> 同步锁前，先了解一些<strong>并发编程基本概念</strong>。</p>
<blockquote>
<p>思考下面售票案例：为什么控制台会：1. 输出相同票、2.出现负数票？</p>
</blockquote>
<ul>
<li>
<p>主函数类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建SellTicket类的对象</span></span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>SellTicket 线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在SellTicket类中重写run()方法实现卖票，代码步骤如下</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>解释</strong></p>
<ul>
<li><strong>相同票</strong>：打印出售票、 <code>tickets--</code> 两条语句共享tickets变量，导致没有及时更新<code>tickets</code>变量</li>
<li><strong>出现负数票：</strong> <code>if (tickets &gt; 0)</code> 语句判断和 <code>tickets--</code>共享tickets变量  ，没有及时更新tickets变量</li>
</ul>
</li>
</ul>
<h3 id="1-如何解决多线程">1.如何解决多线程</h3>
<ul>
<li>
<p><strong>安全问题出现的条件</strong></p>
<ul>
<li>是<u>多线程环境</u></li>
<li>有共享数据</li>
<li>有<u>多条语句操作（包含，读、写等）共享数据</u></li>
</ul>
<blockquote>
<p>为什么一定要求是<strong>一个线程有多条语句</strong>操作共享数据？</p>
</blockquote>
<p>如果两个线程，各只有一条语句操作数据，虽然线程执行具有随机性，但是无论哪个线程执行自己那条语句（是原子性语句）时，其它线程即使此刻抢占到CPU，修改了共享变量。但由于前一个线程不再会执行共享数据相关操作，因此实际是不影响的。</p>
<blockquote>
<p>⚠️ 区分多线程中线程来源同一个类和不同类情况。</p>
</blockquote>
<ul>
<li>
<p>两个线程来自<strong>同一个线程类两个对象</strong> ，该<strong>类有<u>多条</u>语句修改共享类变量的操作</strong> ；<strong>锁住类的共享操作数据语句</strong>保证同一时候只有一个线程对共享变量进行修改</p>
</li>
<li>
<p>【<strong>消费生产问题</strong>】两个线程<strong>来自不同线程类</strong>，但<strong>各<u>有一条或多条</u>语句对共享变量进行修改</strong> ；<strong>使用P、V操作</strong>保证同一时候只有一个线程对共享变量进行修改。参考 ：<u>7.生产者消费者</u> 小节实例</p>
<blockquote>
<p>JAVA中使用 wait()、notifyAll() 来实现，但是和PV操作逻辑是不一样的。</p>
<p><img src="https://i.loli.net/2021/04/28/YuCTpjbHaI1BPki.jpg" alt="这里写图片描述"></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>如何解决多线程安全</strong>？</p>
<ul>
<li>
<p>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</p>
</li>
<li>
<p>Java提供了同步代码块的方式来解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// 多条语句操作共享数据的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><u>synchronized同步方式优缺点？</u></p>
<ul>
<li>
<p>好处：解决了多线程的数据安全问题</p>
</li>
<li>
<p>弊端：当线程很多时，因为<strong>每个线程都会去判断同步上的锁</strong>，这是很耗费资源的，无形中会降低程序的运行效率</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>尝试synchronized解决售票问题</strong></p>
<blockquote>
<p>为什么下面这种方式，执行还是一样的问题？</p>
</blockquote>
<img src="https://i.loli.net/2021/04/28/RTd6tA1BcxoDGkQ.png" alt="image-20210428213154792" style="zoom:80%;" />
<ul>
<li>因为每次创建线程对象，锁对象<code>new Object</code> 也是重新创建的，三个线程对象三把锁，所以锁不住</li>
</ul>
<p>因此，我们要定义一个公共的锁对象：</p>
<p><img src="https://i.loli.net/2021/04/28/4aIhloMyBYN9ctZ.png" alt="image-20210428213403318"></p>
</li>
</ul>
<h3 id="2-原子性、可见性、有序性">2.原子性、可见性、有序性</h3>
<ul>
<li>
<p><strong>原子性</strong></p>
<p>即一个或多个操作，要么全部执行，要么全部不执行，类似于数据库事务概念。</p>
<p>在 <em>java</em> 中，基本数据类型的变量的读取和赋值操作是原子性操作，其余不是，例如：</p>
<blockquote>
<p>【<strong>面试高频</strong>】判断：下面语句1~4，都是原子性操作吗？（即是否每条语句包含的操作要么都完成/要么都不完成）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;        <span class="comment">// 语句1</span></span><br><span class="line">y = x;         <span class="comment">// 语句2</span></span><br><span class="line">x++;           <span class="comment">// 语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure>
<p>其实，除了第一条语句，其余都不是原子性操作。</p>
<ul>
<li>x = 10：线程执行该语句将10写入内存；</li>
<li>y = x：读取x值 --&gt; 然后将10写入内存，进行了两次操作；</li>
<li>x++ ：读取x值 --&gt; 进行+1操作 --&gt; 写入新值，进行了三次操作；</li>
<li>x = x + 1：同x++，三次操作。</li>
</ul>
<p>所以，只有x=10这种简单赋值操作是原子性语句。在 java中提供了 <em>synchronized</em> 关键字 和<em>Lock</em> 接口来实现。</p>
</li>
<li>
<p><strong>可见性</strong></p>
<p>对于可见性，<em>Java</em> 提供了<em>volatile</em> 关键字来保证可见性，当然<em>synchronized</em> 关键字 和<em>Lock</em> 接口也可以保证。</p>
<p>可见性，即指<strong>一个共享变量被<em>volatile</em> 修饰时，它会保证修改的值会立即被更新到主存</strong>。当有其他线程需要读取时，它会去内存中读取新值。</p>
</li>
<li>
<p><strong>有序性</strong></p>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序。但是<strong>重排序过程不会影响到 <u>单线程</u> 程序的执行，却会影响到 <u>多线程</u> 并发执行的正确性</strong>。</p>
<p>在<em>java</em> 中，也是通过 <em>volatile</em>关键字来保证一定的“有序性&quot;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1  context初始化操作</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )</span><br><span class="line">&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(context);</span><br></pre></td></tr></table></figure>
<p>由于指令重新排序，可能导致语句2先于语句1执行。即相当于<em>inited = ture</em>被执行 ， <em>context = loadContext()</em>  未被执行。然后线程2 <u>错误判读已经初始化完毕</u> ，执行<em>System.out.println(context);</em>  打印出<em>context</em> 。</p>
<p>通过加上<em>volatile</em> 关键字对 <em>inited</em> 变量进行修饰，可以避免这种情况。</p>
<p>因为，<strong>程序执行到<em>volatile</em>修饰变量读/写操作时，保证在<u>其前面的操作肯定已经完成，后面操作未执行</u></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> inited = <span class="keyword">true</span>;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-volatile-关键字">3.<em>volatile</em> 关键字</h3>
<p><em>volatile</em> 关键字主要有两个作用：<u>使被修饰变量具有可见性</u> &amp;  <u>禁止指令重排保证可见性</u>。</p>
<p>保证可见性，见前。这里结合实例保证被修饰变量具有可见性。</p>
<blockquote>
<p>设计一个线程1不断学狗叫，一个线程2过1秒结束这令人窒息的操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程类，有一个学狗叫操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 多线程.test_Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_Thread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学狗叫：汪汪汪~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        test_Thread t1 = <span class="keyword">new</span> test_Thread();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;  <span class="comment">// 匿名类方式生成一个线程1s后结束t1线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">               <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">                t1.flag =<span class="keyword">false</span>; <span class="comment">// 把flag设置为flase，由于可见性，将结束线程t1中while循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际输出：过了大概1s，线程1停止了学狗叫。</p>
<h3 id="4-synchronized关键字">4.<em>synchronized</em>关键字</h3>
<p><strong><em>volatile</em> 关键字可以保证可见性，但是不能保证原子性</strong>，会导致多线程出现脏数据等问题。例如下面例子：</p>
<h4 id="1-一个DEMO">1. 一个DEMO</h4>
<blockquote>
<p>⚠️ <em>java</em> 函数不能改变<em>int</em>类型实参，也不能加上<em>ref</em> 关键字改变！所以出此下策：把数组当做参数传递，组第一个元素是我们想通过函数改变的值。数组是引用类型，可以改变里面的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程类IncreaseThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncreaseThread</span><span class="params">(<span class="keyword">int</span>[] num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数使得num值被修改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line"><span class="keyword">import</span> 多线程.IncreaseThread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        Thread addThreads[] = <span class="keyword">new</span> Thread[<span class="number">100000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           IncreaseThread ih = <span class="keyword">new</span> IncreaseThread(num);</span><br><span class="line">           ih.start();</span><br><span class="line">           addThreads[i] = ih;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 所有增加子线程都加入主线程中，保证子线程都【先】执行完</span></span><br><span class="line">       <span class="comment">// *如果线程已经执行完，不会在执行吧？是</span></span><br><span class="line">       <span class="comment">// *如果没有这行代码，子线程也会在主线程执行完继续执行</span></span><br><span class="line">       <span class="keyword">for</span> (Thread t : addThreads)</span><br><span class="line">           t.join();</span><br><span class="line">       System.out.println(num[<span class="number">0</span>]); <span class="comment">// 输出有时候是：999995 / 99996 ..</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-分析结果">2. 分析结果</h4>
<blockquote>
<p>我们看到输出结果并非为100000，这是为什么？</p>
</blockquote>
<p>因为 <em>num[0]++;</em> 并非是原子性语句，它由三个操作：<strong>取num[0]值 --&gt; +1 操作 --&gt; 写入 num[0]</strong> 三个操作组成。</p>
<p>在多线程这将导致一个问题，例如恰好某时刻 num[0] = 100，存在线程A、B：</p>
<ol>
<li>线程A，取出*num[0]*值 = 100，准备进行+1操作</li>
<li>线程B，恰好也取出*num[0]*值 = 100</li>
<li>线程A，执行<em>num[0]++</em> 操作，<em>num[0] = 101</em></li>
<li>线程B，也执行 <em>num[0]++</em> 操作，所以 <em>num[0] = 101</em>没有被改变</li>
<li>所以线程A、B写入值都是101，没有正确顺序执行++操作。</li>
</ol>
<p>这就是为什么每次运行结果都是 &lt;100000。</p>
<h4 id="3-synchronized-同步锁"><em>3. synchronized</em> 同步锁</h4>
<p>我们可以用<em>synchronized</em>  关键字保证同一时刻只有一个线程获取锁，然后执行同步代码。</p>
<blockquote>
<p>【面试】synchronized只能修饰：类、方法或代码块，<u>不能修饰变量</u>。</p>
</blockquote>
<p>在 <em>IncreaseThread</em> 类中给 <em>run()</em> 函数加上同步锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证了  <em>num[0]++</em> 操作同一时刻只有一个线程可以执行。经过多次测试输出结果 == 100000。</p>
<p>⚠️ 直接给 <em>run()</em> 加锁也许并不是一个好做法，这会使得里面所有需要并行操作都加锁。因为这里只有  <em>num[0]++</em> 这一条语句故这样写。更好的做法是，<strong>单独设计一个函数包含++操作，然后给这个函数加锁，在run()中调用</strong>。</p>
<h4 id="4-匿名类使用同步锁">4. 匿名类使用同步锁</h4>
<p>匿名类下就没法用<em>synchronized</em>关键字限定一个函数，然后<em>run()</em> 执行这个函数（当然你可以限定 <em>run()</em> …）</p>
<p>我们可以首先定义一个<em>object</em> 常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object someObject = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>然后在匿名类中，<code>synchronized (someObject)&#123; // 包含要原子性执行的语句 &#125;</code>，下面是示例。</p>
<blockquote>
<p>暂时不明白<em>synchronized (someObject)</em> 设置不同参数有何作用？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        Thread addThreads[] = <span class="keyword">new</span> Thread[<span class="number">100000</span>];</span><br><span class="line">        <span class="keyword">final</span> Object someObject = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread ih = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  <span class="comment">// 不推荐：synchronized限定run()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="comment">// synchronized体&#123;&#125;代码被独占</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num[<span class="number">0</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ih.start();</span><br><span class="line">            addThreads[i] = ih;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有增加子线程都加入主线程中，保证子线程都执行完</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads)</span><br><span class="line">            t.join();</span><br><span class="line">        System.out.println(num[<span class="number">0</span>]);   <span class="comment">// 多次测试输出是：100000</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-synchronized-同步方法">5. <em>synchronized</em> 同步方法</h4>
<ul>
<li>
<p><strong>同步对象方法</strong></p>
<blockquote>
<p>给上述卖票代码加个else语句：偶数执行if，奇数执行else。esle语句存在一个方法，给它加上锁。</p>
</blockquote>
<p>但是synchronized 关键字直接加到方法上会出问题：</p>
<ul>
<li><strong>同步对象方法的默认锁是<code>this</code></strong> （默认且不能指认），而前述if语句的是的锁是<code>obj</code> ，两把锁是不一样的！</li>
<li>因此要把锁改为<code>this</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// synchronized (obj) &#123; // 应该改为this</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                        tickets--;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sellTicket();</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private synchronized void sellTicket() &#123;</span></span><br><span class="line"><span class="comment">//        if (tickets &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;        System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);</span></span><br><span class="line"><span class="comment">//            tickets--;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>同步静态方法</strong></p>
<ul>
<li>
<p><strong>同步静态方法默认锁是当前类</strong> ，因此不能用对象方法的锁<code>this</code></p>
</li>
<li>
<p>可以采用反射：<code>&lt;类名&gt;.class</code> 获取当前类的字节码</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/04/28/7ZiTS4De1289cpQ.png" alt="image-20210428220549403"></p>
</li>
</ul>
<h3 id="5-常见线程安全的类">5.常见线程安全的类</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">共同点</th>
<th style="text-align:center">不同点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>HashMap</em> &amp; <em>Hashtable</em>（安全）</td>
<td style="text-align:center">都实现了Map接口，按键值对保存数据。</td>
<td style="text-align:center">1.<em>HashMap</em>可以存null，<em>Hashtable</em>不可以。2. <em>Hashtable</em>是线程安全类，<strong><em>put()<em>方法用</em>synchronized</em> 关键字修饰</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><em>StringBuffer</em>（安全） &amp;<em>StringBuilder</em></td>
<td style="text-align:center">操作字符串，可以进行字符串拼接等操作。</td>
<td style="text-align:center">1.<em>StringBuilder</em> 是线程安全类，比如 <em>public synchronized StringBuilder append(int i)</em> 方法，<strong>用了<em>synchronized</em>关键字</strong></td>
</tr>
<tr>
<td style="text-align:center"><em>ArrayList</em> &amp; <em>Vector</em>（安全）</td>
<td style="text-align:center">都是可扩展动态数组</td>
<td style="text-align:center">1.同上查看源码得知，<strong><em>Vector</em> 是线程安全类</strong>。</td>
</tr>
</tbody>
</table>
<h4 id="把非线程安全集合转为线程安全">把非线程安全集合转为线程安全</h4>
<p>借助工具类 <em>Collections</em> 中静态方法 <em>Collections.synchronizedList()</em> 可以进行非安全集合到安全转换。</p>
<blockquote>
<p>注意：<em>StringBuffer</em>  不属于集合范畴，不能转换。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line"><span class="comment">// 错误写法：返回是list无法转换为 Arraylist</span></span><br><span class="line"><span class="comment">//ArrayList&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span></span><br><span class="line">List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer,String&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt; ();</span><br><span class="line">Map&lt;Integer,String&gt; map2 = Collections.synchronizedMap(map1);      </span><br></pre></td></tr></table></figure>
<h3 id="6-Lock锁">6.Lock锁</h3>
<p><img src="https://i.loli.net/2021/04/28/tSoiYbRl5kdA9my.png" alt="image-20210428222639476"></p>
<ul>
<li>
<p><strong>创建Lock锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();  <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// Lock要手动释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-生产者消费者">7.生产者消费者</h3>
<ul>
<li>
<p><strong>生产者消费者问题</strong></p>
<p>生产者和消费者在<strong>同一时间段内共用同一存储空间</strong>，生产者向空间里生产数据，而消费者取走数据。</p>
</li>
<li>
<p><strong>常用方法</strong></p>
<p><img src="https://i.loli.net/2021/04/28/adoxFtOm7LNeb2n.png" alt="image-20210428223250219"></p>
<p><img src="https://i.loli.net/2021/04/28/YuCTpjbHaI1BPki.jpg" alt="这里写图片描述"></p>
</li>
<li>
<p><strong>案例分析</strong></p>
<blockquote>
<p>生产者消费者案例中包含的类：</p>
<ul>
<li>
<p><strong>奶箱类(Box)</strong>：<strong>存储一个共享成员变量mike</strong>，表示第x瓶奶，提供存储牛奶<code>put()</code>和获取牛奶<code>get()</code>的操作</p>
</li>
<li>
<p><strong>生产者类(Producer)</strong>：实现Runnable接口，重写run()方法，调用存储牛奶<code>put()</code>的操作，<u>循环放30瓶</u></p>
</li>
<li>
<p><strong>消费者类(Customer)</strong>：实现Runnable接口，重写run()方法，调用获取牛奶<code>get()</code>的操作，<u>死循环不断获取</u></p>
</li>
<li>
<p><strong>测试类(BoxDemo)</strong>：里面有main方法，main方法中的代码步骤如下:</p>
<ol>
<li>创建奶箱对象，这是共享数据区域</li>
<li>创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作对象</li>
<li>把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</li>
<li>创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</li>
<li>启动线程</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jpf254/article/details/79459560">为什么Object.wait(),Object.notify(),Object.notifyAll()必须在同步块synchronized中执行呢?</a></p>
</blockquote>
<p>⚠️ <strong>重点看下面P、V逻辑和wait()、notify() 逻辑区分</strong>。</p>
<blockquote>
<ul>
<li>
<p>在Java中，我们使用<code>wait()</code>和<code>nofify()</code>或<code>notifyAll()</code>来实现线程间通信。一个线程在测试条件不满足后进入等待状态;</p>
</li>
<li>
<p>在经典的生产者-消费者问题中，生产者线程因缓存区满而等待，消费者线程在消费了缓存区的一个元素后通知生产者线程。</p>
</li>
</ul>
</blockquote>
<p>调用<code>notify()</code>和<code>notifyAll()</code>方法来通知一个或多个线程一个条件已经改变了。<strong>一旦通知线程退出同步方法或同步块，所有等待的线程会争抢它们等待对象上的对象锁</strong>。</p>
<p>获取锁的线程会从等待状态返回并继续执行。</p>
<blockquote>
<p>下面只用synchronized关键字锁住put和get操作，由于消费者<code>while(true)</code>一直消费会导致控制台最后一直输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br><span class="line">用户拿到第30瓶奶</span><br></pre></td></tr></table></figure>
<p>必须要<strong>设置进程间通信</strong>，只用生产者<code>put()</code> 了一瓶奶，才能允许消费者取<code>get()</code> 牛奶 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        Box b = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(b);</span><br><span class="line">      <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        */</span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第x瓶奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> milk;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示奶箱的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供存储牛奶和获取牛奶的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> milk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果有牛奶，等待消费</span></span><br><span class="line">        <span class="keyword">if</span>(state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.milk = milk;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工将第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有牛奶，等待生产</span></span><br><span class="line">        <span class="keyword">if</span>(!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有牛奶，就消费牛奶</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span> + <span class="keyword">this</span>.milk + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费完毕之后，修改奶箱状态</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒其他等待的线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            b.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-4-线程交互">12.4 线程交互</h2>
<blockquote>
<p>生成者、消费者问题：p = synchronized ，占有；v = this.wait 释放。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">Sleep()方法</th>
<th style="text-align:center">Wait()方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</td>
<td style="text-align:center">wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</td>
</tr>
<tr>
<td style="text-align:center">sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁</td>
<td style="text-align:center">wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</td>
</tr>
<tr>
<td style="text-align:center">在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。</td>
<td style="text-align:center">wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</td>
</tr>
</tbody>
</table>
<p>❔ 试着解释下面分别用 sleep(2000) 和 wait(2000)的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            number += <span class="number">100</span>;  <span class="comment">// 执行到这number=110</span></span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// synchronized 保证原子性，代码只能被全部执行或不执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * (休息2S,阻塞线程)</span></span><br><span class="line"><span class="comment">             * 以验证当前线程对象的机锁被占用时, 是否被可以访问其他同步代码块</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 输出 2100</span></span><br><span class="line">            <span class="comment">//this.wait(2000); // 输出 110</span></span><br><span class="line">            number *= <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            firstMethod();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(threadTest);</span><br><span class="line">        thread.start();  <span class="comment">// 执行firstMethod()</span></span><br><span class="line">        threadTest.secondMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-5-线程池快速入门">12.5 线程池快速入门</h2>
<h4 id="创建一个线程池">创建一个线程池</h4>
<p>下面表示创建一个：拥有线程个数为10、最多可增长至15，允许线程空闲60s后被回收，线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数中</span></span><br><span class="line">ThreadPoolExecutor threadPool= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>
<p><em>ThreadPoolExecutor</em> 类用于实现线程池，其创建多线程的构造函数原型如下：</p>
<blockquote>
<p><em>ThreadPoolExecutor(int <u>corePoolSize</u>, int <u>maximumPoolSize</u>, long <u>keepAliveTime</u>, TimeUnit <u>unit</u>, BlockingQueue<Runnable> <u>workQueue</u>, RejectedExecutionHandler <u>handler</u>)</em></p>
</blockquote>
<ul>
<li><em>corePoolSize</em> ：表示线程池最低拥有的线程数</li>
<li><em>maximumPoolSize</em> ：表示线程池最多可增长到线程数</li>
<li><em>keepAliveTime</em> &amp; <em>unit</em>：表示线程空闲后的存活时间，超过后会被回收，最终保持池中10个线程</li>
<li><em>workQueue</em> ：存放任务的阻塞队列</li>
<li><em>handler</em>：当队列和最大线程池都满了之后的饱和策略</li>
</ul>
<h4 id="执行任务">执行任务</h4>
<p>通过 <em>ThreadPoolExecutor</em> 对象 <em>execute()</em> 方法执行任务，接受的参数为 <em>Runnable</em> 类型。</p>
<blockquote>
<p><em>public void execute( Runnable command )</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DEMO-遍历搜寻文件夹">DEMO : 遍历搜寻文件夹</h4>
<blockquote>
<p>🎉 对指定文件夹进行遍历搜寻，如果找到文件含有“黄旺辉”字样，就分配一个线程对该文件进行处理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="comment">// 1.创建线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="comment">// 2.搜寻指定文件</span></span><br><span class="line">         t.searchFile(<span class="string">&quot;D:/hwh/uploadToGit/本科&quot;</span>,threadPool);       </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 函数：搜寻指定文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchFile</span><span class="params">(String root, ThreadPoolExecutor threadPool)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(root);</span><br><span class="line">        <span class="comment">// 每个文件/文件夹都一定会被遍历到：所以可以在这里判断是否是文件</span></span><br><span class="line">        <span class="keyword">if</span> (f.getName().contains(<span class="string">&quot;黄旺辉&quot;</span>)) <span class="comment">// 找到满足条件文件开始分配任务</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 设定任务</span></span><br><span class="line">           Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程在对指定文件执行任务：&quot;</span> +  f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">          <span class="comment">// 分配线程执行任务</span></span><br><span class="line">          threadPool.execute(task);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归搜寻</span></span><br><span class="line">        <span class="keyword">for</span>(File file : f.listFiles())</span><br><span class="line">                searchFile(file.getAbsolutePath(),threadPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>第十三章：网络编程</h1>
<h2 id="13-1-基本知识">13.1 基本知识</h2>
<h3 id="服务器和客户端通信">服务器和客户端通信</h3>
<p><img src="http://stepimagewm.how2j.cn/881.png" alt="ç«¯å£"></p>
<p>上图表示，服务器IP：192.168.1.100 ，客户端IP：192.168.1.189，它们分别通过各自的端口 8080、1087 和对方进行通信。</p>
<h3 id="如何获取本机IP地址？">如何获取本机IP地址？</h3>
<ul>
<li>
<p>通过<em>java</em>自带<em>API</em></p>
<p>获取本机IP可以通过java自带的API，引用类：<code>java.net.InetAddress</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用getLocalHost()，必须处理异常UnknownHostException</span></span><br><span class="line">     InetAddress host = InetAddress.getLocalHost(); </span><br><span class="line">     String ip = host.getHostAddress();</span><br><span class="line">     System.out.println(<span class="string">&quot;本机IP地址是：&quot;</span> + ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562380334548.png" alt="1562380334548"></p>
</li>
<li>
<p><em>cmd</em>命令：<em>ipconfig</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt; ipconfig </span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562380215050.png" alt="1562380215050"></p>
</li>
</ul>
<h3 id="ping-命令"><em>ping</em> 命令</h3>
<ul>
<li>
<p>通过<em>java</em>自带<em>API</em></p>
<blockquote>
<p>直接复制粘贴，需要时再看。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSocket</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + <span class="string">&quot;192.168.2.106&quot;</span>);</span><br><span class="line">        <span class="comment">// 缓存流，建立在字符流之上</span></span><br><span class="line">        <span class="comment">// InputStreamReader类继承字符流类Reader，可使得字节流向字符流转换</span></span><br><span class="line">        <span class="comment">// 注意加上 &quot;gbk&quot;，否则执行的命令乱码</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> InputStreamReader(p.getInputStream(),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.length() != <span class="number">0</span>)  sb.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;本次指令返回的消息是：&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过<em>cmd</em>命令<em>ping</em></p>
<p><em>ping</em>某个IP地址，这个IP是网关地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt; ping 192.168.0.1 </span><br></pre></td></tr></table></figure>
<p><em>ping</em>一个主机名，如果能返回说明：DNS解析正确，且本机或本网和外部连接正确</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\86151&gt; ping baidu.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="13-2-实战测试网络连通">13.2 实战测试网络连通</h2>
<ol>
<li>
<p>观察本地网络设置是否正确： <code>ipconfig /all</code></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383275004.png" alt="1562383275004"></p>
</li>
<li>
<p>检测本地TCP/IP 协议：<code>Ping 127.0.0.1</code></p>
<blockquote>
<p>IP地址由两个部分组成，即<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/9765459">网络地址</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/9765500">主机地址</a> ，（IPV4）长<strong>4</strong>个字节，32位。根据网络地址占的字节数不同，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p>
<ul>
<li><strong>A类</strong>：第1个字节为网络号，后3个字节为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>号。最前面为“0”，所以地址网络号取值于1~126之间 。而保留的<code>127（01111111）+ 0.0.1</code> 就是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80">本地回送地址</a> ，一般用于测试。</li>
<li>本机回送地址（Loopback Address），即<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>IP<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032">堆栈</a>内部的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859">IP地址</a>，主要用于（1）<u>网络软件测试</u> 以及（2）本地机<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1235923">进程间通信</a>，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。</li>
</ul>
</blockquote>
<p>有返回接收则配置正确。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383378227.png" alt="1562383378227"></p>
</li>
<li>
<p>检查本地IP地址是否有误：<code>ping 本机IP</code></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">好文：ping到底做了什么？</a></p>
</blockquote>
<p>有返回接收则配置正确，否则要重新配置下。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383507956.png" alt="1562383507956"></p>
</li>
<li>
<p>检查硬件问题 &amp; 本机与本地网络连接是否正常（非局域网可忽略）：<code>ping 本机网关IP</code></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21787311/answer/19316065">网关和路由器区别？</a></p>
<ul>
<li><strong>网关设备</strong>：一个大概念，不具体特指一类产品，只要 <u>连接两个不同的网络的设备</u>都可以叫网关；</li>
<li><strong>路由器</strong>：一般特指能够 <u>实现路由寻找和转发</u>的 特定类产品，路由器很显然能够实现网关的功能。</li>
<li><strong>默认网关</strong>：不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个 <u>默认的中转地址</u> 上面进行转发，也就是默认网关。 可以在<strong>路由器、三层交换机上，可以在防火墙上</strong>，可以在服务器上，所以和物理的设备无关。</li>
</ul>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562383725128.png" alt="1562383725128"></p>
</li>
<li>
<p>检查本网或本机与外部连接是否正常： <code>Ping  远程IP地址</code></p>
<blockquote>
<p>有些 IP是ping不通的，因为有防火墙或者其它设置，这里百度找了个能ping通的。</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562384976509.png" alt="1562384976509"></p>
</li>
<li>
<p>在<strong>5.</strong> 基础上检查DNS解析：<code>ping 域名</code></p>
<p>如果可以<em>ping</em>通，则说明域名解析可正常运行。</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562384636345.png" alt="1562384636345"></p>
</li>
</ol>
<h2 id="13-3-网络编程通信实战">13.3 网络编程通信实战</h2>
<p>​        在<strong>13.1</strong>中介绍了服务器和客户端通过各自端口进行简单通信。本节通过实战编程，实现服务端和客户端简单交流对话。</p>
<h3 id="如何编程实现通信？">如何编程实现通信？</h3>
<p>​         通过套接字：<em>{ IP地址，端口号 }</em> ，<em>Java</em> 有封装好类 <em>ServerSocket &amp; Socket</em> ，进而通过套接字输入、输出流 实现通信。</p>
<ul>
<li>服务端通过 <em>ServerSocket</em> 对象 <em>ss</em>打开端口；</li>
<li>客户端创建套接字 <em>Socket</em> 对象 <em>socket</em> 连接到服务端，并通过 套接字建立 <u>输出流</u>  进行数据传输；</li>
<li>服务端通过 <em>ServerSocket</em> 对象 <em>ss.accept()</em> 方法，返回 <em>Socket</em> 对象（客户端的？），通过 <u>输入流</u> 读数据；</li>
<li>服务端进行回应，并关闭服务。</li>
</ul>
<h3 id="编程实现">编程实现</h3>
<ul>
<li>
<p>客户端 - <em>Client</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> QQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数：套接字初始化连接的主机和端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host 指定连接的主机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> post 指定连接的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String host,<span class="keyword">int</span> post)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(host,post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端发送指定消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientMsg  要发送的消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msg</span><span class="params">(String clientMsg)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立[套接字字节输出流]对象发生消息</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.客户端发消息</span></span><br><span class="line">        <span class="comment">// 注意String类型 --&gt; byte[]</span></span><br><span class="line">        os.write(clientMsg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.注意：客户端套接字必须要关闭，才开始连接服务端</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Q1 : 为什么设计每个方法 t hrows IOException ？</em></p>
<p><em>A1:</em>  因为创建套接字对象<em>socket</em> | 调用对象方法 ，都要处理 <em>IOException</em> 异常，每个方法写 <em>try catch</em> 太麻   烦，不如先抛出异常，在主函数中统一处理。</p>
<p><em>Q2 : 为什么msg() 方法发送完消息立马关闭套接字 socket.close() ，而不是等服务器接收了再关闭 ？</em></p>
<p><em>A1:</em>  事实上，只有先关闭套接字<em>socket.close()</em> ，客户端才会开始连接服务端！</p>
</li>
<li>
<p>服务端 - <em>Server</em></p>
<blockquote>
<p>⚠️  <em>ServerSocket</em> 对象 <em>ss.accept()</em> 方法，必须客户端建立连接之后，否则会一直阻塞！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> QQ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ServerSocket ss;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开端口，建立套接字对象监听端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> post 要打开的服务端端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> post)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ss = <span class="keyword">new</span> ServerSocket(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭套接字连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ss.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端对客户发来的消息进行回应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1.注意：客户端必须已经连接，否则会一直阻塞</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.建立[套接字字节输入流]，读取客户端发过来的消息</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] all = is.readAllBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.类型转换: 将byte[] ---&gt; String</span></span><br><span class="line">        String clientMsg = <span class="keyword">new</span> String(all);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.回应客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端回复-小白兔回道：&quot;</span> + reMsg(clientMsg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reMsg</span><span class="params">(String clientMsg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(clientMsg.contains(<span class="string">&quot;你好&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好！我是小白兔。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clientMsg.contains(<span class="string">&quot;沙雕&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你才是沙雕！你全家都是沙雕！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clientMsg.contains(<span class="string">&quot;你叫什么&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;my name is dad&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clientMsg.contains(<span class="string">&quot;我好烦呀~&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;放下得自在。&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;风太大，没听清！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>主函数串联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 服务端打开端口</span></span><br><span class="line">     Server server = <span class="keyword">new</span> Server(<span class="number">8886</span>);</span><br><span class="line">     <span class="comment">// 客户端连接端口</span></span><br><span class="line">     Client client = <span class="keyword">new</span> Client(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8886</span>);</span><br><span class="line">    </span><br><span class="line">     Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">     System.out.print(<span class="string">&quot;客户端-大灰狼说道：&quot;</span>);</span><br><span class="line">     String clientMsg = s.nextLine();</span><br><span class="line">     <span class="comment">// 客户端通过套接字输出流发生消息</span></span><br><span class="line">     client.msg(clientMsg);</span><br><span class="line">     <span class="comment">// 服务端通过套接字输入流进行回应</span></span><br><span class="line">     server.response();</span><br><span class="line">      </span><br><span class="line">     server.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">     System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562470443412.png" alt="1562470443412"></p>
</li>
</ul>
<h1>第十四章：<em>JDBC</em></h1>
<h2 id="14-1-JDBC-快速入门">14.1  JDBC 快速入门</h2>
<h3 id="什么是-JDBC？">什么是 JDBC？</h3>
<p><em>JDBC</em> 即  <em><u>Java DataBase Connection</u></em>  ，是<em>JAVA</em> 的一个 <em>API</em> 通过 <em>JAVA</em> 访问数据库。</p>
<p>其一般执行流程如下：</p>
<ul>
<li>连接数据源，如数据库</li>
<li>进行增删查改指令</li>
<li>处理响应并返回结果</li>
</ul>
<h3 id="下载-JDBC">下载 JDBC</h3>
<ol>
<li>
<p>官网下载驱动包</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/connector/j/"><em>Download Connector/J</em></a></p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562987672708.png" alt="1562987672708"></p>
<p>选择：<em>Platform Independent</em> —&gt; <em>mysql-connector-java-8.0.16.zip</em> ，然后下载：</p>
<blockquote>
<p>坑：下面还有一个下载<em>MySQL Installer</em> ，是下载 <em>mysql</em> 全家桶 ！</p>
</blockquote>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562987944125.png" alt="1562987944125"></p>
</li>
<li>
<p>解压</p>
<p>解压之后会在下载目录出现：<em>mysql-connector-java-8.0.16</em> 文件夹，里面有我们要的 <em>jar</em> 包：</p>
<p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1562988107051.png" alt="1562988107051"></p>
</li>
<li>
<p>引用包</p>
<p>在工程目录下新建一个文件夹：<em>lib</em> ，然后将 <em>mysql-connector-java-8.0.16.jar</em> 包复制到该目录下。</p>
<p>在IDEA中，右键选择该<em>jar</em> 包 --&gt; <em>Add as Library</em> ，即可添加成功。</p>
<p>更好的添加包方法点击：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26525215/article/details/53239123">IDEA导入包两种方法</a></p>
</li>
</ol>
<h3 id="简单-DEMO">简单 DEMO</h3>
<h4 id="mysqlDB-类"><em>mysqlDB</em> 类</h4>
<p>在 <em>mysqlDB</em> 类中主要有三个函数，负责执行操作数据库对应三个流程：</p>
<ul>
<li>
<p><em>mysqlDB()</em> 连接数据库</p>
<p>🔈 最新 <em>SQL</em> 驱动： <u>1.加载驱动程序</u> 这步可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public mysqlDB(String url,String user,String passwd) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    this.URL = url;  this.USER = user; this.PASSWD = passwd;</span><br><span class="line">    // 1.加载驱动程序</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">    // 2.获取数据库连接</span><br><span class="line">    conn = DriverManager.getConnection(url,user,passwd);</span><br><span class="line">    System.out.println(&quot;成功连接数据库！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>crudDB()</em> <u>增删查改</u></p>
<p><em>crudBOY</em>  表演时刻：执行指定 <em>sql</em> 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ResultSet  crudDB(String sql) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    // 3.操作数据库</span><br><span class="line">    Statement s = conn.createStatement();</span><br><span class="line">    ResultSet rs = s.executeQuery(sql);</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em>exit()</em> 退出</p>
<blockquote>
<p><em>Statement</em> 对象应该也关闭，这里没。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void exit() throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="主函数中">主函数中</h4>
<p>在主函数中串接所有流程，和数据库进行 <em>Connection</em> 连接需提供 <em>url</em> ：</p>
<blockquote>
<p><em>url = “jdbc:mysql://&lt;地址&gt;:&lt;端口&gt;/&lt;数据库名&gt;?serverTimezone=UTC”</em></p>
</blockquote>
<ul>
<li>&lt;地址&gt;：这里选择本机地址，<em>127.0.0.1 / localhost</em></li>
<li>&lt;端口&gt;：<em>mysql</em> 专用端口，3360</li>
<li>&lt;数据库名&gt;：预先准备好的数据库，<em>test</em></li>
<li>⚠️<em>?serverTimezone=UTC</em> ：新版驱动器出现的问题，要指定 <em>time zone value</em> 。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">public class hello</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;;</span><br><span class="line">           final String user = &quot;root&quot;;</span><br><span class="line">           final String passwd = &quot;123456&quot;;</span><br><span class="line">           String sql = &quot;SELECT * FROM student WHERE gender = &#x27;F&#x27;;&quot;;</span><br><span class="line">           </span><br><span class="line">           // 连接数据库--执行sql语句</span><br><span class="line">           mysqlDB mdb = new mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.crudDB(sql);</span><br><span class="line">            </span><br><span class="line">           // 读取指定列名数据</span><br><span class="line">           while(rs.next())</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(rs.getString(&quot;name&quot;) + rs.getInt(&quot;score&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mysqlDB-类完整代码"><em>mysqlDB</em> 类完整代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package JDBC_demo;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class mysqlDB</span><br><span class="line">&#123;</span><br><span class="line">    final String URL ;</span><br><span class="line">    final String USER ;</span><br><span class="line">    final String PASSWD ;</span><br><span class="line">    Connection conn;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数：进行初始化和数据库连接</span><br><span class="line">     * @param url  jdbc:mysql://127.0.0.1:3306/&lt;数据库名&gt;</span><br><span class="line">     * @param user  mysql账号</span><br><span class="line">     * @param passwd   mysql密码</span><br><span class="line">     */</span><br><span class="line">    public mysqlDB(String url,String user,String passwd) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        this.URL = url;  this.USER = user; this.PASSWD = passwd;</span><br><span class="line">        // 1.加载驱动程序</span><br><span class="line">        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        // 2.获取数据库连接</span><br><span class="line">        conn = DriverManager.getConnection(url,user,passwd);</span><br><span class="line">        System.out.println(&quot;成功连接数据库！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行增删查改</span><br><span class="line">     * @param sql 要执行的sql语句</span><br><span class="line">     */</span><br><span class="line">    public ResultSet  crudDB(String sql) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        // 3.操作数据库</span><br><span class="line">        Statement s = conn.createStatement();</span><br><span class="line">        ResultSet rs = s.executeQuery(sql);</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void exit() throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-2-查询技巧">14.2 查询技巧</h2>
<p>​        因为，增、删、改并不需要处理返回的数据，比较简单就是执行<em>sql</em> 语句即可。但是查询较为复杂，这里来通过几个查询实例，来进一步熟悉 <em>JDBC API</em>。</p>
<h3 id="验证用户登陆">验证用户登陆</h3>
<blockquote>
<p><em>student</em> 表中没有设置密码字段，所以下面只验证了名字，简单表达意思。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">public class hello</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;;</span><br><span class="line">           final String user = &quot;root&quot;;</span><br><span class="line">           final String passwd = &quot;123456&quot;;</span><br><span class="line">           String sql = &quot;SELECT  * FROM student WHERE name = &#x27;&#x27;&quot; + &quot;刘婷&#x27;&quot;;</span><br><span class="line">           </span><br><span class="line">           // 连接数据库--执行sql语句</span><br><span class="line">           mysqlDB mdb = new mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.crudDB(sql);</span><br><span class="line">            </span><br><span class="line">           // 进行判断</span><br><span class="line">            if(rs.next()) // re.next() 返回的是bool类型，没有找到数据返回false</span><br><span class="line">                System.out.println(&quot;账号密码正确&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;账号密码错误&quot;);</span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>拼接字符串有个坑，要注意给字符串类型&quot;刘婷&quot;加上单/双引号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT  * FROM student WHERE name = &#x27;&#x27;&quot;</span> + <span class="string">&quot;刘婷&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="获取总数">获取总数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">public class hello</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       try</span><br><span class="line">       &#123;</span><br><span class="line">           final String url = &quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;;</span><br><span class="line">           final String user = &quot;root&quot;;</span><br><span class="line">           final String passwd = &quot;123456&quot;;</span><br><span class="line">           String sql = &quot;SELECT count(*) FROM student WHERE gender = &#x27;F&#x27;&quot;;</span><br><span class="line">           </span><br><span class="line">           // 连接数据库--执行sql语句</span><br><span class="line">           mysqlDB mdb = new mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.crudDB(sql);</span><br><span class="line">            </span><br><span class="line">           // 进行判断</span><br><span class="line">           rs.next(); // 读取下一行数据，这里是第一行</span><br><span class="line">           int girl_num = rs.getInt(1); // 获取第一列第一行数据</span><br><span class="line">           System.out.println(&quot;女生总数为：&quot; + girl_num );</span><br><span class="line">           </span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><em>rs.next()</em> : 读取下一行数据，如果下一行数据不存在返回 <em>false</em> ；</p>
</li>
<li>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功连接数据库！</span><br><span class="line">女生总数为：5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="14-3-再谈-Statement-eceute">14.3 再谈 Statement &amp; eceute()</h2>
<h3 id="预编译-Statement"><em>预编译 Statement</em></h3>
<h4 id="Statement-弊端"><em>Statement</em> 弊端</h4>
<p>在前面，我们知道 <em>Statement</em> 对象主要用于执行 <em>sql</em> 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ResultSet  crudDB(String sql) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    // 3.操作数据库</span><br><span class="line">    Statement s = conn.createStatement();</span><br><span class="line">    ResultSet rs = s.executeQuery(sql);</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，有以下几个弊端：</p>
<ol>
<li>
<p>只能执行完整<em>sql</em> 语句，不能对 <em>sql</em> 语句进行模板化修改；</p>
</li>
<li>
<p>易遭受 <em>sql</em> 注入攻击，比如在前面我们拼接查询，是否存在用户<em>sql</em> 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT  * FROM student WHERE name = &quot; + name; // name 由用户输入</span><br></pre></td></tr></table></figure>
<p>如果用户输入<u>‘刘婷’ OR 1=1</u> ,而非 <u>刘婷</u> ，那么拼接语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  * FROM student WHERE name = &#x27;刘婷&#x27; OR 1=1;</span><br></pre></td></tr></table></figure>
<p>如果用户表有100万条数据，那么显然会耗光内存，让数据库负载过高。</p>
</li>
</ol>
<h4 id="PreparedStatement"><em>PreparedStatement</em></h4>
<p><em>PreparedStatement</em> 和 <em>Statement</em> 都是用来执行 <em>sql</em> 语句。不同是<em>PreparedStatement</em> 可以通过 <code>？</code> 来预留<em>sql</em> 语句编辑位置，而非直接拼接。</p>
<p>下面展示重新封装<em>crubDB()</em> 方法为 *identityUser()*验证用户(同前只验证姓名)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;  <span class="comment">// 注意要引用PreparedStatement </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet  <span class="title">identityUser</span><span class="params">(String sql, String userName)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 3.操作数据库</span></span><br><span class="line">    PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setString(<span class="number">1</span>, userName);</span><br><span class="line">    ResultSet rs = ps.executeQuery();</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中，调用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;</span>;</span><br><span class="line">           <span class="keyword">final</span> String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           <span class="keyword">final</span> String passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">           String sql = <span class="string">&quot;SELECT * FROM student WHERE name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 连接数据库--执行sql语句</span></span><br><span class="line">           mysqlDB mdb = <span class="keyword">new</span> mysqlDB(url, user, passwd);</span><br><span class="line">           ResultSet rs = mdb.identityUser(sql,<span class="string">&quot;刘婷&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 进行判断</span></span><br><span class="line">           <span class="keyword">if</span>(rs.next()) <span class="comment">// re.next() 返回的是bool类型，没有找到数据返回false</span></span><br><span class="line">               System.out.println(<span class="string">&quot;正在登陆...&quot;</span>);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               System.out.println(<span class="string">&quot;用户不存在！&quot;</span>);</span><br><span class="line">           mdb.exit();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<em>sql语句</em> 不用给 <code>？</code> 代表的字符串类似加上单/双引号，会出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT * FROM student WHERE name = &#x27;?&#x27;&quot;</span>; <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure>
<p>因为，<code>ps.setString(1, userName);</code> 方法会自动设置好。</p>
<h3 id="三种不同eceute">三种不同<em>eceute</em></h3>
<p>执行 <em>sql</em> 语句，通常头三种方法：<em>eceute() &amp; executeUpdate() &amp; executeQuery()</em> ，它们都是 <em>Statement</em> 对象方法，主要有以下区别。</p>
<h4 id="返回值不同">返回值不同</h4>
<p><em>eceute()</em>  用来执行 <em>sql</em> 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement s = conn.createStatement();</span><br><span class="line">boolean rs = s.execute(sql); // 返回bool类型，判断执行是否成功</span><br></pre></td></tr></table></figure>
<p><em>executeUpdate() &amp; executeQuery()</em> 相似，但是三者返回值不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int number = s.executeUpdate(sql); // 返回int类型，有多少语句被影响</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = s.executeQuery(sql); // 返回ResultSet类型，可以查询返回数据</span><br></pre></td></tr></table></figure>
<h4 id="是否支持查询语句">是否支持查询语句</h4>
<p><em>executeUpdate()</em> 可以进行 <u>增、删、改</u>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.executeUpdate(sqlInsert); <span class="comment">// 执行INSERT插入数据</span></span><br><span class="line">s.executeUpdate(sqlDelete); <span class="comment">// 执行DELETE删除数据</span></span><br><span class="line">s.executeUpdate(sqlUpdate); <span class="comment">// 执行UPDATE更新数据</span></span><br></pre></td></tr></table></figure>
<p>但是不能查询表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.executeUpdate(sqlSelect); <span class="comment">// 出错：执行SELECT查询数据</span></span><br></pre></td></tr></table></figure>
<p><em>executeQuery()</em> 一般用于<u>查询语句</u> ，进行其它更新操作会报错：</p>
<blockquote>
<p><em>java.sql.SQLException: Can not issue data manipulation statements with executeQuery().</em></p>
</blockquote>
<p><em>execute()</em> 没有限制可以进行：<u>增、删、改、查</u> 。</p>
<h2 id="14-4-特殊操作-事务">14.4 特殊操作 &amp; 事务</h2>
<h3 id="特殊操作">特殊操作</h3>
<blockquote>
<p>未展开讲，用到可查询：<a target="_blank" rel="noopener" href="http://how2j.cn/k/jdbc/jdbc-id/398.html#nowhere">特殊操作</a></p>
</blockquote>
<p>这里的特殊操作包括两种：</p>
<ul>
<li>获取自增长id：如果表中id为<em>AUTO_INCREMENT</em>，无论是*execute()<em>还是</em>executeUpdate()*都不会返回自增长id。</li>
<li>获取表元数据：诸如，数据库服务器版本，驱动版本，都有哪些数据库等等</li>
</ul>
<h3 id="事务">事务</h3>
<blockquote>
<p>为什么要使用事务，不在赘述，同 <em>MySQL笔记</em>，这里主要展示 <em>JDBC</em> 如何使用事务。</p>
</blockquote>
<p>⚠️ 支持事务前提：当前<em>MySQL</em>服务器本身要支持<em>INNODB</em>, 同时表类型为 <em>INNODB</em> 。</p>
<h4 id="支持事务">支持事务</h4>
<p>在当发现无法执行事务时，再进行以下修改。</p>
<ul>
<li>
<p>设置表类型为 <em>INNODB</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE teble_name ENGINE  = innodb;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置服务器支持 <em>INNODB</em></p>
<blockquote>
<p><em>mysql</em> 从 <u>5.5</u> 版本已将 <em>innoDB</em> 作为默认存储引擎。</p>
</blockquote>
<p>点击查看： <a target="_blank" rel="noopener" href="http://how2j.cn/k/mysql/mysql-innodb/1064.html">开启<em>MYSQL INNODB</em>的办法</a></p>
</li>
</ul>
<h4 id="事务实例">事务实例</h4>
<p>在事务中的多个操作，要么都成功，要么都失败。</p>
<p>在 <em>JDBC</em> 中，主要是取消<em>excute()</em> 等之后 <u>自动</u> 提交，改为 <u>手动</u> 提交所有操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JDBC_demo.mysqlDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String passwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE student SET score = score + ? WHERE name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        mysqlDB mdb = <span class="keyword">new</span> mysqlDB(url, user, passwd);</span><br><span class="line">        PreparedStatement ps = mdb.conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 事务：刘婷+10分，小白-10分</span></span><br><span class="line">        mdb.conn.setAutoCommit(<span class="keyword">false</span>);   <span class="comment">// 取消自动提交</span></span><br><span class="line">        </span><br><span class="line">        ps.setInt(<span class="number">1</span>, <span class="number">10</span>);ps.setString(<span class="number">2</span>, <span class="string">&quot;刘婷&quot;</span>);</span><br><span class="line">        ps.executeUpdate(); <span class="comment">// 看下面错误解析</span></span><br><span class="line">        </span><br><span class="line">        ps.setInt(<span class="number">1</span>, -<span class="number">10</span>);ps.setString(<span class="number">2</span>, <span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">        </span><br><span class="line">        mdb.conn.commit(); <span class="comment">// 手动提交        </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ 调试半小时犯的2个错误，有关： <code>ps.executeUpdate();</code></p>
<ol>
<li>
<p>用<em>ps.executeQuery()</em> ，提示 ：<u><em>Cannot issue data manipulation statements with executeQuery()</em></u></p>
<p>原因：<em>executeQuery()</em> 适用于 <em>SELECT</em> ，用户更新等操作会报错。</p>
</li>
<li>
<p>添加参数<em>sql</em>：<em>ps.executeQuery(sql)</em> ，在前面创建 <em>PreparedStatement</em> 对象已给参数 <em>sql</em> ，再添参数会出现解析错误。</p>
</li>
</ol>
<h2 id="14-5-数据库线程池-待">14.5 数据库线程池(待)</h2>
</div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wanghui Huang</div><div class="author-info__description">tech & life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wanghui-Huang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wanghui-Huang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:hwh199601@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">royhuang's studio</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/37224/" title="C++从零开始（开源）：一文读懂muduo">C++从零开始（开源）：一文读懂muduo</a><time datetime="2023-03-11T05:48:01.602Z" title="发表于 2023-03-11 13:48:01">2023-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/45495/" title="C++从零开始（十二）：Linux系统编程入门">C++从零开始（十二）：Linux系统编程入门</a><time datetime="2022-04-03T05:45:34.660Z" title="发表于 2022-04-03 13:45:34">2022-04-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/17467/" title="C++从零开始（十一）：C++进阶（下）STL">C++从零开始（十一）：C++进阶（下）STL</a><time datetime="2022-02-14T09:55:49.585Z" title="发表于 2022-02-14 17:55:49">2022-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/51012/" title="C++从零开始（十）：C++进阶（上）模板">C++从零开始（十）：C++进阶（上）模板</a><time datetime="2022-02-11T08:17:22.936Z" title="发表于 2022-02-11 16:17:22">2022-02-11</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">14</span><i class="fas fa-caret-left "></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"><span class="card-category-list-name">从零开始</span><span class="card-category-list-count">14</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">C++基础</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="card-category-list-name">C++环境搭建</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/"><span class="card-category-list-name">C++进阶</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"><span class="card-category-list-name">C++面对对象</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"><span class="card-category-list-name">Linux系统编程</span><span class="card-category-list-count">1</span></a></li></ul></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Git/"><span class="card-category-list-name">Git</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%BB%BA%E7%AB%99/"><span class="card-category-list-name">建站</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">校招笔记</span><span class="card-category-list-count">15</span><i class="fas fa-caret-left "></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/"><span class="card-category-list-name">JAVA</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">计算机基础</span><span class="card-category-list-count">8</span></a></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.38em; color: rgb(172, 154, 106)">C++</a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.45em; color: rgb(161, 151, 102)">教程</a><a href="/tags/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 1.22em; color: rgb(71, 156, 61)">C++环境搭建</a><a href="/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 1.15em; color: rgb(159, 148, 84)">远程开发</a><a href="/tags/CMake/" style="font-size: 1.15em; color: rgb(156, 184, 187)">CMake</a><a href="/tags/Makefile/" style="font-size: 1.15em; color: rgb(160, 157, 140)">Makefile</a><a href="/tags/g/" style="font-size: 1.15em; color: rgb(108, 69, 89)">g++</a><a href="/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" style="font-size: 1.22em; color: rgb(175, 61, 76)">快速入门</a><a href="/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/" style="font-size: 1.15em; color: rgb(53, 114, 77)">面对对象</a><a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 1.15em; color: rgb(184, 62, 192)">继承</a><a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0/" style="font-size: 1.15em; color: rgb(11, 14, 5)">虚函数</a><a href="/tags/C-%E5%9F%BA%E7%A1%80/" style="font-size: 1.3em; color: rgb(43, 50, 160)">C++基础</a><a href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" style="font-size: 1.15em; color: rgb(114, 113, 154)">运算符重载</a><a href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/" style="font-size: 1.15em; color: rgb(31, 29, 12)">结构体</a><a href="/tags/%E6%9E%9A%E4%B8%BE/" style="font-size: 1.15em; color: rgb(180, 5, 26)">枚举</a><a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 1.15em; color: rgb(65, 82, 111)">类型转换</a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 1.15em; color: rgb(54, 73, 72)">函数</a><a href="/tags/%E6%8C%87%E9%92%88/" style="font-size: 1.15em; color: rgb(111, 172, 181)">指针</a><a href="/tags/muduo/" style="font-size: 1.15em; color: rgb(115, 97, 73)">muduo</a><a href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" style="font-size: 1.15em; color: rgb(128, 143, 115)">系统编程</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">四月 2022</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/12/"><span class="card-archive-list-date">十二月 2021</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><span class="card-archive-list-count">17</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-11-23T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">340.2k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-03-14T16:36:19.363Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Wanghui Huang</div><div class="footer_custom_text">Support By <a target="_blank" rel="noopener" href="https://cloud.tencent.com/" style="text-decoration:underline; color:#476679;"> Tencent Cloud </a> |  <a target="_blank" rel="noopener" href="https://hexo.io/" style="text-decoration:underline; color:#476679;">Hexo</a> | <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="text-decoration:underline; color:#476679;">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-comments-5g2cfsved8c0de34',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <h1 id="tree-toc-title" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/categories/">目 录 </a> </h1>
      <h5 id="tree-toc-subtitle" style="text-align:center;margin:0;line-hight:1.5"> <a href="https://hwh.zone/">royhuang's blog</a> </h5>
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/">
          C++
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/">
          从零开始
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/">
          C++面对对象
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17506/" title="C++从零开始（七）：面对对象（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（七）：面对对象（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/60158/" title="C++从零开始（九）：面对对象（下）继承和虚函数"><i class="post-icon gg-file-document"></i>C++从零开始（九）：面对对象（下）继承和虚函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43924/" title="C++从零开始（八）：面对对象（中）运算符重载"><i class="post-icon gg-file-document"></i>C++从零开始（八）：面对对象（中）运算符重载</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">
          Linux系统编程
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45495/" title="C++从零开始（十二）：Linux系统编程入门"><i class="post-icon gg-file-document"></i>C++从零开始（十二）：Linux系统编程入门</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E8%BF%9B%E9%98%B6/">
          C++进阶
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51012/" title="C++从零开始（十）：C++进阶（上）模板"><i class="post-icon gg-file-document"></i>C++从零开始（十）：C++进阶（上）模板</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/17467/" title="C++从零开始（十一）：C++进阶（下）STL"><i class="post-icon gg-file-document"></i>C++从零开始（十一）：C++进阶（下）STL</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
          C++环境搭建
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/18652/" title="C++从零开始（一）：环境搭建（上）VSCode远程开发"><i class="post-icon gg-file-document"></i>C++从零开始（一）：环境搭建（上）VSCode远程开发</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/2834/" title="C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（二）：环境搭建（下）g++/Makefile/CMake快速入门</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/C/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/C-%E5%9F%BA%E7%A1%80/">
          C++基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/26224/" title="C++从零开始（三）：务实基础（上）快速入门"><i class="post-icon gg-file-document"></i>C++从零开始（三）：务实基础（上）快速入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/6587/" title="C++从零开始（六）：务实基础（下）复合类型及转换"><i class="post-icon gg-file-document"></i>C++从零开始（六）：务实基础（下）复合类型及转换</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51595/" title="C++从零开始（五）：务实基础（下）函数"><i class="post-icon gg-file-document"></i>C++从零开始（五）：务实基础（下）函数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/24237/" title="C++从零开始（四）：务实基础（中）指针和引用"><i class="post-icon gg-file-document"></i>C++从零开始（四）：务实基础（中）指针和引用</a></li></ul></li></ul></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/Git/">
          Git
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/43848/" title="Git基础笔记（初步整理）"><i class="post-icon gg-file-document"></i>Git基础笔记（初步整理）</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">
          建站
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56326/" title="Hexo+Github Pages快速打造属于自己的网站"><i class="post-icon gg-file-document"></i>Hexo+Github Pages快速打造属于自己的网站</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/">
          校招笔记
        </a>
      <ul class="tree-list-children">
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/JAVA/">
          JAVA
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/42516/" title="校招笔记（一）_Java_JVM"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_JVM</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/51787/" title="校招笔记（一）_Java_Java入门"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_Java入门</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/45493/" title="校招笔记（一）_Java_锁"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_锁</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/8959/" title="校招笔记（一）_Java_多线程"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_多线程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/21069/" title="校招笔记（一）_Java_集合"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_集合</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/7257/" title="校招笔记（一）_Java_面对对象"><i class="post-icon gg-file-document"></i>校招笔记（一）_Java_面对对象</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
          计算机基础
        </a>
      <ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/p/61434/" title="校招笔记（七）_计算机基础_数据结构"><i class="post-icon gg-file-document"></i>校招笔记（七）_计算机基础_数据结构</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/5582/" title="校招笔记（九）_计算机基础_相关补充"><i class="post-icon gg-file-document"></i>校招笔记（九）_计算机基础_相关补充</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/46361/" title="校招笔记（三）_计算机基础_计算机网络"><i class="post-icon gg-file-document"></i>校招笔记（三）_计算机基础_计算机网络</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/56848/" title="校招笔记（五）_计算机基础_MySQL"><i class="post-icon gg-file-document"></i>校招笔记（五）_计算机基础_MySQL</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/44980/" title="校招笔记（二）_计算机基础_Linux&Git"><i class="post-icon gg-file-document"></i>校招笔记（二）_计算机基础_Linux&Git</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31667/" title="校招笔记（八）_计算机基础_场景&智力题"><i class="post-icon gg-file-document"></i>校招笔记（八）_计算机基础_场景&智力题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/15646/" title="校招笔记（四）_计算机基础_操作系统"><i class="post-icon gg-file-document"></i>校招笔记（四）_计算机基础_操作系统</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/p/31215/" title="校招笔记（六）_计算机基础_Redis"><i class="post-icon gg-file-document"></i>校招笔记（六）_计算机基础_Redis</a></li></ul></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>